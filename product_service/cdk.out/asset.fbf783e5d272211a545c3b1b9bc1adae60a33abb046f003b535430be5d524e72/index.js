"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// asset-input/node_modules/mongoose/lib/driver.js
var require_driver = __commonJS({
  "asset-input/node_modules/mongoose/lib/driver.js"(exports2, module2) {
    "use strict";
    var driver = null;
    module2.exports.get = function() {
      return driver;
    };
    module2.exports.set = function(v) {
      driver = v;
    };
  }
});

// asset-input/node_modules/mongodb/lib/error.js
var require_error = __commonJS({
  "asset-input/node_modules/mongodb/lib/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isResumableError = exports2.isNetworkTimeoutError = exports2.isSDAMUnrecoverableError = exports2.isNodeShuttingDownError = exports2.isRetryableReadError = exports2.isRetryableWriteError = exports2.needsRetryableWriteLabel = exports2.MongoWriteConcernError = exports2.MongoServerSelectionError = exports2.MongoSystemError = exports2.MongoMissingDependencyError = exports2.MongoMissingCredentialsError = exports2.MongoCompatibilityError = exports2.MongoInvalidArgumentError = exports2.MongoParseError = exports2.MongoNetworkTimeoutError = exports2.MongoNetworkError = exports2.isNetworkErrorBeforeHandshake = exports2.MongoTopologyClosedError = exports2.MongoCursorExhaustedError = exports2.MongoServerClosedError = exports2.MongoCursorInUseError = exports2.MongoUnexpectedServerResponseError = exports2.MongoGridFSChunkError = exports2.MongoGridFSStreamError = exports2.MongoTailableCursorError = exports2.MongoChangeStreamError = exports2.MongoAWSError = exports2.MongoKerberosError = exports2.MongoExpiredSessionError = exports2.MongoTransactionError = exports2.MongoNotConnectedError = exports2.MongoDecompressionError = exports2.MongoBatchReExecutionError = exports2.MongoRuntimeError = exports2.MongoAPIError = exports2.MongoDriverError = exports2.MongoServerError = exports2.MongoError = exports2.MongoErrorLabel = exports2.GET_MORE_RESUMABLE_CODES = exports2.MONGODB_ERROR_CODES = exports2.NODE_IS_RECOVERING_ERROR_MESSAGE = exports2.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = void 0;
    var kErrorLabels = Symbol("errorLabels");
    exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp("not master", "i");
    exports2.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp("not master or secondary", "i");
    exports2.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp("node is recovering", "i");
    exports2.MONGODB_ERROR_CODES = Object.freeze({
      HostUnreachable: 6,
      HostNotFound: 7,
      NetworkTimeout: 89,
      ShutdownInProgress: 91,
      PrimarySteppedDown: 189,
      ExceededTimeLimit: 262,
      SocketException: 9001,
      NotWritablePrimary: 10107,
      InterruptedAtShutdown: 11600,
      InterruptedDueToReplStateChange: 11602,
      NotPrimaryNoSecondaryOk: 13435,
      NotPrimaryOrSecondary: 13436,
      StaleShardVersion: 63,
      StaleEpoch: 150,
      StaleConfig: 13388,
      RetryChangeStream: 234,
      FailedToSatisfyReadPreference: 133,
      CursorNotFound: 43,
      LegacyNotPrimary: 10058,
      WriteConcernFailed: 64,
      NamespaceNotFound: 26,
      IllegalOperation: 20,
      MaxTimeMSExpired: 50,
      UnknownReplWriteConcern: 79,
      UnsatisfiableWriteConcern: 100
    });
    exports2.GET_MORE_RESUMABLE_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.HostUnreachable,
      exports2.MONGODB_ERROR_CODES.HostNotFound,
      exports2.MONGODB_ERROR_CODES.NetworkTimeout,
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports2.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports2.MONGODB_ERROR_CODES.ExceededTimeLimit,
      exports2.MONGODB_ERROR_CODES.SocketException,
      exports2.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports2.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports2.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
      exports2.MONGODB_ERROR_CODES.StaleShardVersion,
      exports2.MONGODB_ERROR_CODES.StaleEpoch,
      exports2.MONGODB_ERROR_CODES.StaleConfig,
      exports2.MONGODB_ERROR_CODES.RetryChangeStream,
      exports2.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
      exports2.MONGODB_ERROR_CODES.CursorNotFound
    ]);
    exports2.MongoErrorLabel = Object.freeze({
      RetryableWriteError: "RetryableWriteError",
      TransientTransactionError: "TransientTransactionError",
      UnknownTransactionCommitResult: "UnknownTransactionCommitResult",
      ResumableChangeStreamError: "ResumableChangeStreamError",
      HandshakeError: "HandshakeError",
      ResetPool: "ResetPool",
      InterruptInUseConnections: "InterruptInUseConnections",
      NoWritesPerformed: "NoWritesPerformed"
    });
    function isAggregateError(e) {
      return "errors" in e && Array.isArray(e.errors);
    }
    var MongoError = class _MongoError extends Error {
      constructor(message) {
        super(_MongoError.buildErrorMessage(message));
        if (message instanceof Error) {
          this.cause = message;
        }
        this[kErrorLabels] = /* @__PURE__ */ new Set();
      }
      /** @internal */
      static buildErrorMessage(e) {
        if (typeof e === "string") {
          return e;
        }
        if (isAggregateError(e) && e.message.length === 0) {
          return e.errors.length === 0 ? "AggregateError has an empty errors array. Please check the `cause` property for more information." : e.errors.map(({ message }) => message).join(", ");
        }
        return e.message;
      }
      get name() {
        return "MongoError";
      }
      /** Legacy name for server error responses */
      get errmsg() {
        return this.message;
      }
      /**
       * Checks the error to see if it has an error label
       *
       * @param label - The error label to check for
       * @returns returns true if the error has the provided error label
       */
      hasErrorLabel(label) {
        return this[kErrorLabels].has(label);
      }
      addErrorLabel(label) {
        this[kErrorLabels].add(label);
      }
      get errorLabels() {
        return Array.from(this[kErrorLabels]);
      }
    };
    exports2.MongoError = MongoError;
    var MongoServerError = class extends MongoError {
      constructor(message) {
        super(message.message || message.errmsg || message.$err || "n/a");
        if (message.errorLabels) {
          this[kErrorLabels] = new Set(message.errorLabels);
        }
        for (const name in message) {
          if (name !== "errorLabels" && name !== "errmsg" && name !== "message")
            this[name] = message[name];
        }
      }
      get name() {
        return "MongoServerError";
      }
    };
    exports2.MongoServerError = MongoServerError;
    var MongoDriverError = class extends MongoError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoDriverError";
      }
    };
    exports2.MongoDriverError = MongoDriverError;
    var MongoAPIError = class extends MongoDriverError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoAPIError";
      }
    };
    exports2.MongoAPIError = MongoAPIError;
    var MongoRuntimeError = class extends MongoDriverError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoRuntimeError";
      }
    };
    exports2.MongoRuntimeError = MongoRuntimeError;
    var MongoBatchReExecutionError = class extends MongoAPIError {
      constructor(message = "This batch has already been executed, create new batch to execute") {
        super(message);
      }
      get name() {
        return "MongoBatchReExecutionError";
      }
    };
    exports2.MongoBatchReExecutionError = MongoBatchReExecutionError;
    var MongoDecompressionError = class extends MongoRuntimeError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoDecompressionError";
      }
    };
    exports2.MongoDecompressionError = MongoDecompressionError;
    var MongoNotConnectedError = class extends MongoAPIError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoNotConnectedError";
      }
    };
    exports2.MongoNotConnectedError = MongoNotConnectedError;
    var MongoTransactionError = class extends MongoAPIError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoTransactionError";
      }
    };
    exports2.MongoTransactionError = MongoTransactionError;
    var MongoExpiredSessionError = class extends MongoAPIError {
      constructor(message = "Cannot use a session that has ended") {
        super(message);
      }
      get name() {
        return "MongoExpiredSessionError";
      }
    };
    exports2.MongoExpiredSessionError = MongoExpiredSessionError;
    var MongoKerberosError = class extends MongoRuntimeError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoKerberosError";
      }
    };
    exports2.MongoKerberosError = MongoKerberosError;
    var MongoAWSError = class extends MongoRuntimeError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoAWSError";
      }
    };
    exports2.MongoAWSError = MongoAWSError;
    var MongoChangeStreamError = class extends MongoRuntimeError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoChangeStreamError";
      }
    };
    exports2.MongoChangeStreamError = MongoChangeStreamError;
    var MongoTailableCursorError = class extends MongoAPIError {
      constructor(message = "Tailable cursor does not support this operation") {
        super(message);
      }
      get name() {
        return "MongoTailableCursorError";
      }
    };
    exports2.MongoTailableCursorError = MongoTailableCursorError;
    var MongoGridFSStreamError = class extends MongoRuntimeError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGridFSStreamError";
      }
    };
    exports2.MongoGridFSStreamError = MongoGridFSStreamError;
    var MongoGridFSChunkError = class extends MongoRuntimeError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGridFSChunkError";
      }
    };
    exports2.MongoGridFSChunkError = MongoGridFSChunkError;
    var MongoUnexpectedServerResponseError = class extends MongoRuntimeError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoUnexpectedServerResponseError";
      }
    };
    exports2.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;
    var MongoCursorInUseError = class extends MongoAPIError {
      constructor(message = "Cursor is already initialized") {
        super(message);
      }
      get name() {
        return "MongoCursorInUseError";
      }
    };
    exports2.MongoCursorInUseError = MongoCursorInUseError;
    var MongoServerClosedError = class extends MongoAPIError {
      constructor(message = "Server is closed") {
        super(message);
      }
      get name() {
        return "MongoServerClosedError";
      }
    };
    exports2.MongoServerClosedError = MongoServerClosedError;
    var MongoCursorExhaustedError = class extends MongoAPIError {
      constructor(message) {
        super(message || "Cursor is exhausted");
      }
      get name() {
        return "MongoCursorExhaustedError";
      }
    };
    exports2.MongoCursorExhaustedError = MongoCursorExhaustedError;
    var MongoTopologyClosedError = class extends MongoAPIError {
      constructor(message = "Topology is closed") {
        super(message);
      }
      get name() {
        return "MongoTopologyClosedError";
      }
    };
    exports2.MongoTopologyClosedError = MongoTopologyClosedError;
    var kBeforeHandshake = Symbol("beforeHandshake");
    function isNetworkErrorBeforeHandshake(err) {
      return err[kBeforeHandshake] === true;
    }
    exports2.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;
    var MongoNetworkError = class extends MongoError {
      constructor(message, options) {
        super(message);
        if (options && typeof options.beforeHandshake === "boolean") {
          this[kBeforeHandshake] = options.beforeHandshake;
        }
      }
      get name() {
        return "MongoNetworkError";
      }
    };
    exports2.MongoNetworkError = MongoNetworkError;
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoNetworkTimeoutError";
      }
    };
    exports2.MongoNetworkTimeoutError = MongoNetworkTimeoutError;
    var MongoParseError = class extends MongoDriverError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoParseError";
      }
    };
    exports2.MongoParseError = MongoParseError;
    var MongoInvalidArgumentError = class extends MongoAPIError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoInvalidArgumentError";
      }
    };
    exports2.MongoInvalidArgumentError = MongoInvalidArgumentError;
    var MongoCompatibilityError = class extends MongoAPIError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoCompatibilityError";
      }
    };
    exports2.MongoCompatibilityError = MongoCompatibilityError;
    var MongoMissingCredentialsError = class extends MongoAPIError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoMissingCredentialsError";
      }
    };
    exports2.MongoMissingCredentialsError = MongoMissingCredentialsError;
    var MongoMissingDependencyError = class extends MongoAPIError {
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoMissingDependencyError";
      }
    };
    exports2.MongoMissingDependencyError = MongoMissingDependencyError;
    var MongoSystemError = class extends MongoError {
      constructor(message, reason) {
        var _a;
        if (reason && reason.error) {
          super(reason.error.message || reason.error);
        } else {
          super(message);
        }
        if (reason) {
          this.reason = reason;
        }
        this.code = (_a = reason.error) === null || _a === void 0 ? void 0 : _a.code;
      }
      get name() {
        return "MongoSystemError";
      }
    };
    exports2.MongoSystemError = MongoSystemError;
    var MongoServerSelectionError = class extends MongoSystemError {
      constructor(message, reason) {
        super(message, reason);
      }
      get name() {
        return "MongoServerSelectionError";
      }
    };
    exports2.MongoServerSelectionError = MongoServerSelectionError;
    function makeWriteConcernResultObject(input) {
      const output = Object.assign({}, input);
      if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
      }
      return output;
    }
    var MongoWriteConcernError = class extends MongoServerError {
      constructor(message, result) {
        if (result && Array.isArray(result.errorLabels)) {
          message.errorLabels = result.errorLabels;
        }
        super(message);
        this.errInfo = message.errInfo;
        if (result != null) {
          this.result = makeWriteConcernResultObject(result);
        }
      }
      get name() {
        return "MongoWriteConcernError";
      }
    };
    exports2.MongoWriteConcernError = MongoWriteConcernError;
    var RETRYABLE_READ_ERROR_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.HostUnreachable,
      exports2.MONGODB_ERROR_CODES.HostNotFound,
      exports2.MONGODB_ERROR_CODES.NetworkTimeout,
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports2.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports2.MONGODB_ERROR_CODES.SocketException,
      exports2.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports2.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports2.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = /* @__PURE__ */ new Set([
      ...RETRYABLE_READ_ERROR_CODES,
      exports2.MONGODB_ERROR_CODES.ExceededTimeLimit
    ]);
    function needsRetryableWriteLabel(error, maxWireVersion) {
      var _a, _b, _c;
      if (error instanceof MongoNetworkError) {
        return true;
      }
      if (error instanceof MongoError) {
        if ((maxWireVersion >= 9 || error.hasErrorLabel(exports2.MongoErrorLabel.RetryableWriteError)) && !error.hasErrorLabel(exports2.MongoErrorLabel.HandshakeError)) {
          return false;
        }
      }
      if (error instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has((_c = (_b = (_a = error.result) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : error.code) !== null && _c !== void 0 ? _c : 0);
      }
      if (error instanceof MongoError && typeof error.code === "number") {
        return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
      }
      const isNotWritablePrimaryError2 = exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
      if (isNotWritablePrimaryError2) {
        return true;
      }
      const isNodeIsRecoveringError = exports2.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
      if (isNodeIsRecoveringError) {
        return true;
      }
      return false;
    }
    exports2.needsRetryableWriteLabel = needsRetryableWriteLabel;
    function isRetryableWriteError(error) {
      return error.hasErrorLabel(exports2.MongoErrorLabel.RetryableWriteError);
    }
    exports2.isRetryableWriteError = isRetryableWriteError;
    function isRetryableReadError(error) {
      const hasRetryableErrorCode = typeof error.code === "number" ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;
      if (hasRetryableErrorCode) {
        return true;
      }
      if (error instanceof MongoNetworkError) {
        return true;
      }
      const isNotWritablePrimaryError2 = exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
      if (isNotWritablePrimaryError2) {
        return true;
      }
      const isNodeIsRecoveringError = exports2.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
      if (isNodeIsRecoveringError) {
        return true;
      }
      return false;
    }
    exports2.isRetryableReadError = isRetryableReadError;
    var SDAM_RECOVERING_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports2.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports2.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
    ]);
    var SDAM_NOT_PRIMARY_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports2.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports2.MONGODB_ERROR_CODES.LegacyNotPrimary
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress
    ]);
    function isRecoveringError(err) {
      if (typeof err.code === "number") {
        return SDAM_RECOVERING_CODES.has(err.code);
      }
      return exports2.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports2.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
    }
    function isNotWritablePrimaryError(err) {
      if (typeof err.code === "number") {
        return SDAM_NOT_PRIMARY_CODES.has(err.code);
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
    }
    function isNodeShuttingDownError(err) {
      return !!(typeof err.code === "number" && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
    }
    exports2.isNodeShuttingDownError = isNodeShuttingDownError;
    function isSDAMUnrecoverableError(error) {
      if (error instanceof MongoParseError || error == null) {
        return true;
      }
      return isRecoveringError(error) || isNotWritablePrimaryError(error);
    }
    exports2.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
    function isNetworkTimeoutError(err) {
      return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
    }
    exports2.isNetworkTimeoutError = isNetworkTimeoutError;
    function isResumableError(error, wireVersion) {
      if (error == null || !(error instanceof MongoError)) {
        return false;
      }
      if (error instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion != null && wireVersion >= 9) {
        if (error.code === exports2.MONGODB_ERROR_CODES.CursorNotFound) {
          return true;
        }
        return error.hasErrorLabel(exports2.MongoErrorLabel.ResumableChangeStreamError);
      }
      if (typeof error.code === "number") {
        return exports2.GET_MORE_RESUMABLE_CODES.has(error.code);
      }
      return false;
    }
    exports2.isResumableError = isResumableError;
  }
});

// asset-input/node_modules/bson/lib/error.js
var require_error2 = __commonJS({
  "asset-input/node_modules/bson/lib/error.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BSONTypeError = exports2.BSONError = void 0;
    var BSONError = (
      /** @class */
      function(_super) {
        __extends(BSONError2, _super);
        function BSONError2(message) {
          var _this = _super.call(this, message) || this;
          Object.setPrototypeOf(_this, BSONError2.prototype);
          return _this;
        }
        Object.defineProperty(BSONError2.prototype, "name", {
          get: function() {
            return "BSONError";
          },
          enumerable: false,
          configurable: true
        });
        return BSONError2;
      }(Error)
    );
    exports2.BSONError = BSONError;
    var BSONTypeError = (
      /** @class */
      function(_super) {
        __extends(BSONTypeError2, _super);
        function BSONTypeError2(message) {
          var _this = _super.call(this, message) || this;
          Object.setPrototypeOf(_this, BSONTypeError2.prototype);
          return _this;
        }
        Object.defineProperty(BSONTypeError2.prototype, "name", {
          get: function() {
            return "BSONTypeError";
          },
          enumerable: false,
          configurable: true
        });
        return BSONTypeError2;
      }(TypeError)
    );
    exports2.BSONTypeError = BSONTypeError;
  }
});

// asset-input/node_modules/bson/lib/utils/global.js
var require_global = __commonJS({
  "asset-input/node_modules/bson/lib/utils/global.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGlobal = void 0;
    function checkForMath(potentialGlobal) {
      return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal;
    }
    function getGlobal() {
      return checkForMath(typeof globalThis === "object" && globalThis) || checkForMath(typeof window === "object" && window) || checkForMath(typeof self === "object" && self) || checkForMath(typeof global === "object" && global) || // eslint-disable-next-line @typescript-eslint/no-implied-eval
      Function("return this")();
    }
    exports2.getGlobal = getGlobal;
  }
});

// asset-input/node_modules/bson/lib/parser/utils.js
var require_utils = __commonJS({
  "asset-input/node_modules/bson/lib/parser/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deprecate = exports2.isObjectLike = exports2.isDate = exports2.haveBuffer = exports2.isMap = exports2.isRegExp = exports2.isBigUInt64Array = exports2.isBigInt64Array = exports2.isUint8Array = exports2.isAnyArrayBuffer = exports2.randomBytes = exports2.normalizedFunctionString = void 0;
    var buffer_1 = require("buffer");
    var global_1 = require_global();
    function normalizedFunctionString(fn) {
      return fn.toString().replace("function(", "function (");
    }
    exports2.normalizedFunctionString = normalizedFunctionString;
    function isReactNative() {
      var g = (0, global_1.getGlobal)();
      return typeof g.navigator === "object" && g.navigator.product === "ReactNative";
    }
    var insecureRandomBytes = function insecureRandomBytes2(size) {
      var insecureWarning = isReactNative() ? "BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values." : "BSON: No cryptographic implementation for random bytes present, falling back to a less secure implementation.";
      console.warn(insecureWarning);
      var result = buffer_1.Buffer.alloc(size);
      for (var i = 0; i < size; ++i)
        result[i] = Math.floor(Math.random() * 256);
      return result;
    };
    var detectRandomBytes = function() {
      if (process.browser) {
        if (typeof window !== "undefined") {
          var target_1 = window.crypto || window.msCrypto;
          if (target_1 && target_1.getRandomValues) {
            return function(size) {
              return target_1.getRandomValues(buffer_1.Buffer.alloc(size));
            };
          }
        }
        if (typeof global !== "undefined" && global.crypto && global.crypto.getRandomValues) {
          return function(size) {
            return global.crypto.getRandomValues(buffer_1.Buffer.alloc(size));
          };
        }
        return insecureRandomBytes;
      } else {
        var requiredRandomBytes = void 0;
        try {
          requiredRandomBytes = require("crypto").randomBytes;
        } catch (e) {
        }
        return requiredRandomBytes || insecureRandomBytes;
      }
    };
    exports2.randomBytes = detectRandomBytes();
    function isAnyArrayBuffer(value) {
      return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    function isUint8Array(value) {
      return Object.prototype.toString.call(value) === "[object Uint8Array]";
    }
    exports2.isUint8Array = isUint8Array;
    function isBigInt64Array(value) {
      return Object.prototype.toString.call(value) === "[object BigInt64Array]";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUInt64Array(value) {
      return Object.prototype.toString.call(value) === "[object BigUint64Array]";
    }
    exports2.isBigUInt64Array = isBigUInt64Array;
    function isRegExp(d) {
      return Object.prototype.toString.call(d) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isMap(d) {
      return Object.prototype.toString.call(d) === "[object Map]";
    }
    exports2.isMap = isMap;
    function haveBuffer() {
      return typeof global !== "undefined" && typeof global.Buffer !== "undefined";
    }
    exports2.haveBuffer = haveBuffer;
    function isDate(d) {
      return isObjectLike(d) && Object.prototype.toString.call(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isObjectLike(candidate) {
      return typeof candidate === "object" && candidate !== null;
    }
    exports2.isObjectLike = isObjectLike;
    function deprecate(fn, message) {
      var warned = false;
      function deprecated() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!warned) {
          console.warn(message);
          warned = true;
        }
        return fn.apply(this, args);
      }
      return deprecated;
    }
    exports2.deprecate = deprecate;
  }
});

// asset-input/node_modules/bson/lib/ensure_buffer.js
var require_ensure_buffer = __commonJS({
  "asset-input/node_modules/bson/lib/ensure_buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureBuffer = void 0;
    var buffer_1 = require("buffer");
    var error_1 = require_error2();
    var utils_1 = require_utils();
    function ensureBuffer(potentialBuffer) {
      if (ArrayBuffer.isView(potentialBuffer)) {
        return buffer_1.Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
      }
      if ((0, utils_1.isAnyArrayBuffer)(potentialBuffer)) {
        return buffer_1.Buffer.from(potentialBuffer);
      }
      throw new error_1.BSONTypeError("Must use either Buffer or TypedArray");
    }
    exports2.ensureBuffer = ensureBuffer;
  }
});

// asset-input/node_modules/bson/lib/uuid_utils.js
var require_uuid_utils = __commonJS({
  "asset-input/node_modules/bson/lib/uuid_utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferToUuidHexString = exports2.uuidHexStringToBuffer = exports2.uuidValidateString = void 0;
    var buffer_1 = require("buffer");
    var error_1 = require_error2();
    var VALIDATION_REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;
    var uuidValidateString = function(str) {
      return typeof str === "string" && VALIDATION_REGEX.test(str);
    };
    exports2.uuidValidateString = uuidValidateString;
    var uuidHexStringToBuffer = function(hexString) {
      if (!(0, exports2.uuidValidateString)(hexString)) {
        throw new error_1.BSONTypeError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".');
      }
      var sanitizedHexString = hexString.replace(/-/g, "");
      return buffer_1.Buffer.from(sanitizedHexString, "hex");
    };
    exports2.uuidHexStringToBuffer = uuidHexStringToBuffer;
    var bufferToUuidHexString = function(buffer, includeDashes) {
      if (includeDashes === void 0) {
        includeDashes = true;
      }
      return includeDashes ? buffer.toString("hex", 0, 4) + "-" + buffer.toString("hex", 4, 6) + "-" + buffer.toString("hex", 6, 8) + "-" + buffer.toString("hex", 8, 10) + "-" + buffer.toString("hex", 10, 16) : buffer.toString("hex");
    };
    exports2.bufferToUuidHexString = bufferToUuidHexString;
  }
});

// asset-input/node_modules/bson/lib/constants.js
var require_constants = __commonJS({
  "asset-input/node_modules/bson/lib/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BSON_BINARY_SUBTYPE_USER_DEFINED = exports2.BSON_BINARY_SUBTYPE_COLUMN = exports2.BSON_BINARY_SUBTYPE_ENCRYPTED = exports2.BSON_BINARY_SUBTYPE_MD5 = exports2.BSON_BINARY_SUBTYPE_UUID_NEW = exports2.BSON_BINARY_SUBTYPE_UUID = exports2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = exports2.BSON_BINARY_SUBTYPE_FUNCTION = exports2.BSON_BINARY_SUBTYPE_DEFAULT = exports2.BSON_DATA_MAX_KEY = exports2.BSON_DATA_MIN_KEY = exports2.BSON_DATA_DECIMAL128 = exports2.BSON_DATA_LONG = exports2.BSON_DATA_TIMESTAMP = exports2.BSON_DATA_INT = exports2.BSON_DATA_CODE_W_SCOPE = exports2.BSON_DATA_SYMBOL = exports2.BSON_DATA_CODE = exports2.BSON_DATA_DBPOINTER = exports2.BSON_DATA_REGEXP = exports2.BSON_DATA_NULL = exports2.BSON_DATA_DATE = exports2.BSON_DATA_BOOLEAN = exports2.BSON_DATA_OID = exports2.BSON_DATA_UNDEFINED = exports2.BSON_DATA_BINARY = exports2.BSON_DATA_ARRAY = exports2.BSON_DATA_OBJECT = exports2.BSON_DATA_STRING = exports2.BSON_DATA_NUMBER = exports2.JS_INT_MIN = exports2.JS_INT_MAX = exports2.BSON_INT64_MIN = exports2.BSON_INT64_MAX = exports2.BSON_INT32_MIN = exports2.BSON_INT32_MAX = void 0;
    exports2.BSON_INT32_MAX = 2147483647;
    exports2.BSON_INT32_MIN = -2147483648;
    exports2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    exports2.BSON_INT64_MIN = -Math.pow(2, 63);
    exports2.JS_INT_MAX = Math.pow(2, 53);
    exports2.JS_INT_MIN = -Math.pow(2, 53);
    exports2.BSON_DATA_NUMBER = 1;
    exports2.BSON_DATA_STRING = 2;
    exports2.BSON_DATA_OBJECT = 3;
    exports2.BSON_DATA_ARRAY = 4;
    exports2.BSON_DATA_BINARY = 5;
    exports2.BSON_DATA_UNDEFINED = 6;
    exports2.BSON_DATA_OID = 7;
    exports2.BSON_DATA_BOOLEAN = 8;
    exports2.BSON_DATA_DATE = 9;
    exports2.BSON_DATA_NULL = 10;
    exports2.BSON_DATA_REGEXP = 11;
    exports2.BSON_DATA_DBPOINTER = 12;
    exports2.BSON_DATA_CODE = 13;
    exports2.BSON_DATA_SYMBOL = 14;
    exports2.BSON_DATA_CODE_W_SCOPE = 15;
    exports2.BSON_DATA_INT = 16;
    exports2.BSON_DATA_TIMESTAMP = 17;
    exports2.BSON_DATA_LONG = 18;
    exports2.BSON_DATA_DECIMAL128 = 19;
    exports2.BSON_DATA_MIN_KEY = 255;
    exports2.BSON_DATA_MAX_KEY = 127;
    exports2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    exports2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    exports2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    exports2.BSON_BINARY_SUBTYPE_UUID = 3;
    exports2.BSON_BINARY_SUBTYPE_UUID_NEW = 4;
    exports2.BSON_BINARY_SUBTYPE_MD5 = 5;
    exports2.BSON_BINARY_SUBTYPE_ENCRYPTED = 6;
    exports2.BSON_BINARY_SUBTYPE_COLUMN = 7;
    exports2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
  }
});

// asset-input/node_modules/bson/lib/binary.js
var require_binary = __commonJS({
  "asset-input/node_modules/bson/lib/binary.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UUID = exports2.Binary = void 0;
    var buffer_1 = require("buffer");
    var ensure_buffer_1 = require_ensure_buffer();
    var uuid_utils_1 = require_uuid_utils();
    var utils_1 = require_utils();
    var error_1 = require_error2();
    var constants_1 = require_constants();
    var Binary = (
      /** @class */
      function() {
        function Binary2(buffer, subType) {
          if (!(this instanceof Binary2))
            return new Binary2(buffer, subType);
          if (!(buffer == null) && !(typeof buffer === "string") && !ArrayBuffer.isView(buffer) && !(buffer instanceof ArrayBuffer) && !Array.isArray(buffer)) {
            throw new error_1.BSONTypeError("Binary can only be constructed from string, Buffer, TypedArray, or Array<number>");
          }
          this.sub_type = subType !== null && subType !== void 0 ? subType : Binary2.BSON_BINARY_SUBTYPE_DEFAULT;
          if (buffer == null) {
            this.buffer = buffer_1.Buffer.alloc(Binary2.BUFFER_SIZE);
            this.position = 0;
          } else {
            if (typeof buffer === "string") {
              this.buffer = buffer_1.Buffer.from(buffer, "binary");
            } else if (Array.isArray(buffer)) {
              this.buffer = buffer_1.Buffer.from(buffer);
            } else {
              this.buffer = (0, ensure_buffer_1.ensureBuffer)(buffer);
            }
            this.position = this.buffer.byteLength;
          }
        }
        Binary2.prototype.put = function(byteValue) {
          if (typeof byteValue === "string" && byteValue.length !== 1) {
            throw new error_1.BSONTypeError("only accepts single character String");
          } else if (typeof byteValue !== "number" && byteValue.length !== 1)
            throw new error_1.BSONTypeError("only accepts single character Uint8Array or Array");
          var decodedByte;
          if (typeof byteValue === "string") {
            decodedByte = byteValue.charCodeAt(0);
          } else if (typeof byteValue === "number") {
            decodedByte = byteValue;
          } else {
            decodedByte = byteValue[0];
          }
          if (decodedByte < 0 || decodedByte > 255) {
            throw new error_1.BSONTypeError("only accepts number in a valid unsigned byte range 0-255");
          }
          if (this.buffer.length > this.position) {
            this.buffer[this.position++] = decodedByte;
          } else {
            var buffer = buffer_1.Buffer.alloc(Binary2.BUFFER_SIZE + this.buffer.length);
            this.buffer.copy(buffer, 0, 0, this.buffer.length);
            this.buffer = buffer;
            this.buffer[this.position++] = decodedByte;
          }
        };
        Binary2.prototype.write = function(sequence, offset) {
          offset = typeof offset === "number" ? offset : this.position;
          if (this.buffer.length < offset + sequence.length) {
            var buffer = buffer_1.Buffer.alloc(this.buffer.length + sequence.length);
            this.buffer.copy(buffer, 0, 0, this.buffer.length);
            this.buffer = buffer;
          }
          if (ArrayBuffer.isView(sequence)) {
            this.buffer.set((0, ensure_buffer_1.ensureBuffer)(sequence), offset);
            this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
          } else if (typeof sequence === "string") {
            this.buffer.write(sequence, offset, sequence.length, "binary");
            this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;
          }
        };
        Binary2.prototype.read = function(position, length) {
          length = length && length > 0 ? length : this.position;
          return this.buffer.slice(position, position + length);
        };
        Binary2.prototype.value = function(asRaw) {
          asRaw = !!asRaw;
          if (asRaw && this.buffer.length === this.position) {
            return this.buffer;
          }
          if (asRaw) {
            return this.buffer.slice(0, this.position);
          }
          return this.buffer.toString("binary", 0, this.position);
        };
        Binary2.prototype.length = function() {
          return this.position;
        };
        Binary2.prototype.toJSON = function() {
          return this.buffer.toString("base64");
        };
        Binary2.prototype.toString = function(format) {
          return this.buffer.toString(format);
        };
        Binary2.prototype.toExtendedJSON = function(options) {
          options = options || {};
          var base64String = this.buffer.toString("base64");
          var subType = Number(this.sub_type).toString(16);
          if (options.legacy) {
            return {
              $binary: base64String,
              $type: subType.length === 1 ? "0" + subType : subType
            };
          }
          return {
            $binary: {
              base64: base64String,
              subType: subType.length === 1 ? "0" + subType : subType
            }
          };
        };
        Binary2.prototype.toUUID = function() {
          if (this.sub_type === Binary2.SUBTYPE_UUID) {
            return new UUID(this.buffer.slice(0, this.position));
          }
          throw new error_1.BSONError('Binary sub_type "'.concat(this.sub_type, '" is not supported for converting to UUID. Only "').concat(Binary2.SUBTYPE_UUID, '" is currently supported.'));
        };
        Binary2.fromExtendedJSON = function(doc, options) {
          options = options || {};
          var data;
          var type;
          if ("$binary" in doc) {
            if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
              type = doc.$type ? parseInt(doc.$type, 16) : 0;
              data = buffer_1.Buffer.from(doc.$binary, "base64");
            } else {
              if (typeof doc.$binary !== "string") {
                type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
                data = buffer_1.Buffer.from(doc.$binary.base64, "base64");
              }
            }
          } else if ("$uuid" in doc) {
            type = 4;
            data = (0, uuid_utils_1.uuidHexStringToBuffer)(doc.$uuid);
          }
          if (!data) {
            throw new error_1.BSONTypeError("Unexpected Binary Extended JSON format ".concat(JSON.stringify(doc)));
          }
          return type === constants_1.BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary2(data, type);
        };
        Binary2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        Binary2.prototype.inspect = function() {
          var asBuffer = this.value(true);
          return 'new Binary(Buffer.from("'.concat(asBuffer.toString("hex"), '", "hex"), ').concat(this.sub_type, ")");
        };
        Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
        Binary2.BUFFER_SIZE = 256;
        Binary2.SUBTYPE_DEFAULT = 0;
        Binary2.SUBTYPE_FUNCTION = 1;
        Binary2.SUBTYPE_BYTE_ARRAY = 2;
        Binary2.SUBTYPE_UUID_OLD = 3;
        Binary2.SUBTYPE_UUID = 4;
        Binary2.SUBTYPE_MD5 = 5;
        Binary2.SUBTYPE_ENCRYPTED = 6;
        Binary2.SUBTYPE_COLUMN = 7;
        Binary2.SUBTYPE_USER_DEFINED = 128;
        return Binary2;
      }()
    );
    exports2.Binary = Binary;
    Object.defineProperty(Binary.prototype, "_bsontype", { value: "Binary" });
    var UUID_BYTE_LENGTH = 16;
    var UUID = (
      /** @class */
      function(_super) {
        __extends(UUID2, _super);
        function UUID2(input) {
          var _this = this;
          var bytes;
          var hexStr;
          if (input == null) {
            bytes = UUID2.generate();
          } else if (input instanceof UUID2) {
            bytes = buffer_1.Buffer.from(input.buffer);
            hexStr = input.__id;
          } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
            bytes = (0, ensure_buffer_1.ensureBuffer)(input);
          } else if (typeof input === "string") {
            bytes = (0, uuid_utils_1.uuidHexStringToBuffer)(input);
          } else {
            throw new error_1.BSONTypeError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
          }
          _this = _super.call(this, bytes, constants_1.BSON_BINARY_SUBTYPE_UUID_NEW) || this;
          _this.__id = hexStr;
          return _this;
        }
        Object.defineProperty(UUID2.prototype, "id", {
          /**
           * The UUID bytes
           * @readonly
           */
          get: function() {
            return this.buffer;
          },
          set: function(value) {
            this.buffer = value;
            if (UUID2.cacheHexString) {
              this.__id = (0, uuid_utils_1.bufferToUuidHexString)(value);
            }
          },
          enumerable: false,
          configurable: true
        });
        UUID2.prototype.toHexString = function(includeDashes) {
          if (includeDashes === void 0) {
            includeDashes = true;
          }
          if (UUID2.cacheHexString && this.__id) {
            return this.__id;
          }
          var uuidHexString = (0, uuid_utils_1.bufferToUuidHexString)(this.id, includeDashes);
          if (UUID2.cacheHexString) {
            this.__id = uuidHexString;
          }
          return uuidHexString;
        };
        UUID2.prototype.toString = function(encoding) {
          return encoding ? this.id.toString(encoding) : this.toHexString();
        };
        UUID2.prototype.toJSON = function() {
          return this.toHexString();
        };
        UUID2.prototype.equals = function(otherId) {
          if (!otherId) {
            return false;
          }
          if (otherId instanceof UUID2) {
            return otherId.id.equals(this.id);
          }
          try {
            return new UUID2(otherId).id.equals(this.id);
          } catch (_a) {
            return false;
          }
        };
        UUID2.prototype.toBinary = function() {
          return new Binary(this.id, Binary.SUBTYPE_UUID);
        };
        UUID2.generate = function() {
          var bytes = (0, utils_1.randomBytes)(UUID_BYTE_LENGTH);
          bytes[6] = bytes[6] & 15 | 64;
          bytes[8] = bytes[8] & 63 | 128;
          return buffer_1.Buffer.from(bytes);
        };
        UUID2.isValid = function(input) {
          if (!input) {
            return false;
          }
          if (input instanceof UUID2) {
            return true;
          }
          if (typeof input === "string") {
            return (0, uuid_utils_1.uuidValidateString)(input);
          }
          if ((0, utils_1.isUint8Array)(input)) {
            if (input.length !== UUID_BYTE_LENGTH) {
              return false;
            }
            return (input[6] & 240) === 64 && (input[8] & 128) === 128;
          }
          return false;
        };
        UUID2.createFromHexString = function(hexString) {
          var buffer = (0, uuid_utils_1.uuidHexStringToBuffer)(hexString);
          return new UUID2(buffer);
        };
        UUID2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        UUID2.prototype.inspect = function() {
          return 'new UUID("'.concat(this.toHexString(), '")');
        };
        return UUID2;
      }(Binary)
    );
    exports2.UUID = UUID;
  }
});

// asset-input/node_modules/bson/lib/code.js
var require_code = __commonJS({
  "asset-input/node_modules/bson/lib/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Code = void 0;
    var Code = (
      /** @class */
      function() {
        function Code2(code, scope) {
          if (!(this instanceof Code2))
            return new Code2(code, scope);
          this.code = code;
          this.scope = scope;
        }
        Code2.prototype.toJSON = function() {
          return { code: this.code, scope: this.scope };
        };
        Code2.prototype.toExtendedJSON = function() {
          if (this.scope) {
            return { $code: this.code, $scope: this.scope };
          }
          return { $code: this.code };
        };
        Code2.fromExtendedJSON = function(doc) {
          return new Code2(doc.$code, doc.$scope);
        };
        Code2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        Code2.prototype.inspect = function() {
          var codeJson = this.toJSON();
          return 'new Code("'.concat(String(codeJson.code), '"').concat(codeJson.scope ? ", ".concat(JSON.stringify(codeJson.scope)) : "", ")");
        };
        return Code2;
      }()
    );
    exports2.Code = Code;
    Object.defineProperty(Code.prototype, "_bsontype", { value: "Code" });
  }
});

// asset-input/node_modules/bson/lib/db_ref.js
var require_db_ref = __commonJS({
  "asset-input/node_modules/bson/lib/db_ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DBRef = exports2.isDBRefLike = void 0;
    var utils_1 = require_utils();
    function isDBRefLike(value) {
      return (0, utils_1.isObjectLike)(value) && value.$id != null && typeof value.$ref === "string" && (value.$db == null || typeof value.$db === "string");
    }
    exports2.isDBRefLike = isDBRefLike;
    var DBRef = (
      /** @class */
      function() {
        function DBRef2(collection, oid, db, fields) {
          if (!(this instanceof DBRef2))
            return new DBRef2(collection, oid, db, fields);
          var parts = collection.split(".");
          if (parts.length === 2) {
            db = parts.shift();
            collection = parts.shift();
          }
          this.collection = collection;
          this.oid = oid;
          this.db = db;
          this.fields = fields || {};
        }
        Object.defineProperty(DBRef2.prototype, "namespace", {
          // Property provided for compatibility with the 1.x parser
          // the 1.x parser used a "namespace" property, while 4.x uses "collection"
          /** @internal */
          get: function() {
            return this.collection;
          },
          set: function(value) {
            this.collection = value;
          },
          enumerable: false,
          configurable: true
        });
        DBRef2.prototype.toJSON = function() {
          var o = Object.assign({
            $ref: this.collection,
            $id: this.oid
          }, this.fields);
          if (this.db != null)
            o.$db = this.db;
          return o;
        };
        DBRef2.prototype.toExtendedJSON = function(options) {
          options = options || {};
          var o = {
            $ref: this.collection,
            $id: this.oid
          };
          if (options.legacy) {
            return o;
          }
          if (this.db)
            o.$db = this.db;
          o = Object.assign(o, this.fields);
          return o;
        };
        DBRef2.fromExtendedJSON = function(doc) {
          var copy = Object.assign({}, doc);
          delete copy.$ref;
          delete copy.$id;
          delete copy.$db;
          return new DBRef2(doc.$ref, doc.$id, doc.$db, copy);
        };
        DBRef2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        DBRef2.prototype.inspect = function() {
          var oid = this.oid === void 0 || this.oid.toString === void 0 ? this.oid : this.oid.toString();
          return 'new DBRef("'.concat(this.namespace, '", new ObjectId("').concat(String(oid), '")').concat(this.db ? ', "'.concat(this.db, '"') : "", ")");
        };
        return DBRef2;
      }()
    );
    exports2.DBRef = DBRef;
    Object.defineProperty(DBRef.prototype, "_bsontype", { value: "DBRef" });
  }
});

// asset-input/node_modules/bson/lib/long.js
var require_long = __commonJS({
  "asset-input/node_modules/bson/lib/long.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Long = void 0;
    var utils_1 = require_utils();
    var wasm = void 0;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(
        // prettier-ignore
        new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])
      ), {}).exports;
    } catch (_a) {
    }
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    var Long = (
      /** @class */
      function() {
        function Long2(low, high, unsigned) {
          if (low === void 0) {
            low = 0;
          }
          if (!(this instanceof Long2))
            return new Long2(low, high, unsigned);
          if (typeof low === "bigint") {
            Object.assign(this, Long2.fromBigInt(low, !!high));
          } else if (typeof low === "string") {
            Object.assign(this, Long2.fromString(low, !!high));
          } else {
            this.low = low | 0;
            this.high = high | 0;
            this.unsigned = !!unsigned;
          }
          Object.defineProperty(this, "__isLong__", {
            value: true,
            configurable: false,
            writable: false,
            enumerable: false
          });
        }
        Long2.fromBits = function(lowBits, highBits, unsigned) {
          return new Long2(lowBits, highBits, unsigned);
        };
        Long2.fromInt = function(value, unsigned) {
          var obj, cachedObj, cache;
          if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = Long2.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
              UINT_CACHE[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
              cachedObj = INT_CACHE[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = Long2.fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
              INT_CACHE[value] = obj;
            return obj;
          }
        };
        Long2.fromNumber = function(value, unsigned) {
          if (isNaN(value))
            return unsigned ? Long2.UZERO : Long2.ZERO;
          if (unsigned) {
            if (value < 0)
              return Long2.UZERO;
            if (value >= TWO_PWR_64_DBL)
              return Long2.MAX_UNSIGNED_VALUE;
          } else {
            if (value <= -TWO_PWR_63_DBL)
              return Long2.MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
              return Long2.MAX_VALUE;
          }
          if (value < 0)
            return Long2.fromNumber(-value, unsigned).neg();
          return Long2.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
        };
        Long2.fromBigInt = function(value, unsigned) {
          return Long2.fromString(value.toString(), unsigned);
        };
        Long2.fromString = function(str, unsigned, radix) {
          if (str.length === 0)
            throw Error("empty string");
          if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return Long2.ZERO;
          if (typeof unsigned === "number") {
            radix = unsigned, unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          var p;
          if ((p = str.indexOf("-")) > 0)
            throw Error("interior hyphen");
          else if (p === 0) {
            return Long2.fromString(str.substring(1), unsigned, radix).neg();
          }
          var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
          var result = Long2.ZERO;
          for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
              var power = Long2.fromNumber(Math.pow(radix, size));
              result = result.mul(power).add(Long2.fromNumber(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(Long2.fromNumber(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        };
        Long2.fromBytes = function(bytes, unsigned, le) {
          return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
        };
        Long2.fromBytesLE = function(bytes, unsigned) {
          return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
        };
        Long2.fromBytesBE = function(bytes, unsigned) {
          return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
        };
        Long2.isLong = function(value) {
          return (0, utils_1.isObjectLike)(value) && value["__isLong__"] === true;
        };
        Long2.fromValue = function(val, unsigned) {
          if (typeof val === "number")
            return Long2.fromNumber(val, unsigned);
          if (typeof val === "string")
            return Long2.fromString(val, unsigned);
          return Long2.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
        };
        Long2.prototype.add = function(addend) {
          if (!Long2.isLong(addend))
            addend = Long2.fromValue(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        Long2.prototype.and = function(other) {
          if (!Long2.isLong(other))
            other = Long2.fromValue(other);
          return Long2.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
        };
        Long2.prototype.compare = function(other) {
          if (!Long2.isLong(other))
            other = Long2.fromValue(other);
          if (this.eq(other))
            return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg)
            return -1;
          if (!thisNeg && otherNeg)
            return 1;
          if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        Long2.prototype.comp = function(other) {
          return this.compare(other);
        };
        Long2.prototype.divide = function(divisor) {
          if (!Long2.isLong(divisor))
            divisor = Long2.fromValue(divisor);
          if (divisor.isZero())
            throw Error("division by zero");
          if (wasm) {
            if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
              return this;
            }
            var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
            return Long2.fromBits(low, wasm.get_high(), this.unsigned);
          }
          if (this.isZero())
            return this.unsigned ? Long2.UZERO : Long2.ZERO;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(Long2.MIN_VALUE)) {
              if (divisor.eq(Long2.ONE) || divisor.eq(Long2.NEG_ONE))
                return Long2.MIN_VALUE;
              else if (divisor.eq(Long2.MIN_VALUE))
                return Long2.ONE;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(Long2.ZERO)) {
                  return divisor.isNegative() ? Long2.ONE : Long2.NEG_ONE;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(Long2.MIN_VALUE))
              return this.unsigned ? Long2.UZERO : Long2.ZERO;
            if (this.isNegative()) {
              if (divisor.isNegative())
                return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
            res = Long2.ZERO;
          } else {
            if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
            if (divisor.gt(this))
              return Long2.UZERO;
            if (divisor.gt(this.shru(1)))
              return Long2.UONE;
            res = Long2.UZERO;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log2 = Math.ceil(Math.log(approx) / Math.LN2);
            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
            var approxRes = Long2.fromNumber(approx);
            var approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = Long2.fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
              approxRes = Long2.ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        Long2.prototype.div = function(divisor) {
          return this.divide(divisor);
        };
        Long2.prototype.equals = function(other) {
          if (!Long2.isLong(other))
            other = Long2.fromValue(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        Long2.prototype.eq = function(other) {
          return this.equals(other);
        };
        Long2.prototype.getHighBits = function() {
          return this.high;
        };
        Long2.prototype.getHighBitsUnsigned = function() {
          return this.high >>> 0;
        };
        Long2.prototype.getLowBits = function() {
          return this.low;
        };
        Long2.prototype.getLowBitsUnsigned = function() {
          return this.low >>> 0;
        };
        Long2.prototype.getNumBitsAbs = function() {
          if (this.isNegative()) {
            return this.eq(Long2.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          }
          var val = this.high !== 0 ? this.high : this.low;
          var bit;
          for (bit = 31; bit > 0; bit--)
            if ((val & 1 << bit) !== 0)
              break;
          return this.high !== 0 ? bit + 33 : bit + 1;
        };
        Long2.prototype.greaterThan = function(other) {
          return this.comp(other) > 0;
        };
        Long2.prototype.gt = function(other) {
          return this.greaterThan(other);
        };
        Long2.prototype.greaterThanOrEqual = function(other) {
          return this.comp(other) >= 0;
        };
        Long2.prototype.gte = function(other) {
          return this.greaterThanOrEqual(other);
        };
        Long2.prototype.ge = function(other) {
          return this.greaterThanOrEqual(other);
        };
        Long2.prototype.isEven = function() {
          return (this.low & 1) === 0;
        };
        Long2.prototype.isNegative = function() {
          return !this.unsigned && this.high < 0;
        };
        Long2.prototype.isOdd = function() {
          return (this.low & 1) === 1;
        };
        Long2.prototype.isPositive = function() {
          return this.unsigned || this.high >= 0;
        };
        Long2.prototype.isZero = function() {
          return this.high === 0 && this.low === 0;
        };
        Long2.prototype.lessThan = function(other) {
          return this.comp(other) < 0;
        };
        Long2.prototype.lt = function(other) {
          return this.lessThan(other);
        };
        Long2.prototype.lessThanOrEqual = function(other) {
          return this.comp(other) <= 0;
        };
        Long2.prototype.lte = function(other) {
          return this.lessThanOrEqual(other);
        };
        Long2.prototype.modulo = function(divisor) {
          if (!Long2.isLong(divisor))
            divisor = Long2.fromValue(divisor);
          if (wasm) {
            var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
            return Long2.fromBits(low, wasm.get_high(), this.unsigned);
          }
          return this.sub(this.div(divisor).mul(divisor));
        };
        Long2.prototype.mod = function(divisor) {
          return this.modulo(divisor);
        };
        Long2.prototype.rem = function(divisor) {
          return this.modulo(divisor);
        };
        Long2.prototype.multiply = function(multiplier) {
          if (this.isZero())
            return Long2.ZERO;
          if (!Long2.isLong(multiplier))
            multiplier = Long2.fromValue(multiplier);
          if (wasm) {
            var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
            return Long2.fromBits(low, wasm.get_high(), this.unsigned);
          }
          if (multiplier.isZero())
            return Long2.ZERO;
          if (this.eq(Long2.MIN_VALUE))
            return multiplier.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
          if (multiplier.eq(Long2.MIN_VALUE))
            return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
          if (this.isNegative()) {
            if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
            else
              return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(Long2.TWO_PWR_24) && multiplier.lt(Long2.TWO_PWR_24))
            return Long2.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        Long2.prototype.mul = function(multiplier) {
          return this.multiply(multiplier);
        };
        Long2.prototype.negate = function() {
          if (!this.unsigned && this.eq(Long2.MIN_VALUE))
            return Long2.MIN_VALUE;
          return this.not().add(Long2.ONE);
        };
        Long2.prototype.neg = function() {
          return this.negate();
        };
        Long2.prototype.not = function() {
          return Long2.fromBits(~this.low, ~this.high, this.unsigned);
        };
        Long2.prototype.notEquals = function(other) {
          return !this.equals(other);
        };
        Long2.prototype.neq = function(other) {
          return this.notEquals(other);
        };
        Long2.prototype.ne = function(other) {
          return this.notEquals(other);
        };
        Long2.prototype.or = function(other) {
          if (!Long2.isLong(other))
            other = Long2.fromValue(other);
          return Long2.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
        };
        Long2.prototype.shiftLeft = function(numBits) {
          if (Long2.isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return Long2.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
          else
            return Long2.fromBits(0, this.low << numBits - 32, this.unsigned);
        };
        Long2.prototype.shl = function(numBits) {
          return this.shiftLeft(numBits);
        };
        Long2.prototype.shiftRight = function(numBits) {
          if (Long2.isLong(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return Long2.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
          else
            return Long2.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        Long2.prototype.shr = function(numBits) {
          return this.shiftRight(numBits);
        };
        Long2.prototype.shiftRightUnsigned = function(numBits) {
          if (Long2.isLong(numBits))
            numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0)
            return this;
          else {
            var high = this.high;
            if (numBits < 32) {
              var low = this.low;
              return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32)
              return Long2.fromBits(high, 0, this.unsigned);
            else
              return Long2.fromBits(high >>> numBits - 32, 0, this.unsigned);
          }
        };
        Long2.prototype.shr_u = function(numBits) {
          return this.shiftRightUnsigned(numBits);
        };
        Long2.prototype.shru = function(numBits) {
          return this.shiftRightUnsigned(numBits);
        };
        Long2.prototype.subtract = function(subtrahend) {
          if (!Long2.isLong(subtrahend))
            subtrahend = Long2.fromValue(subtrahend);
          return this.add(subtrahend.neg());
        };
        Long2.prototype.sub = function(subtrahend) {
          return this.subtract(subtrahend);
        };
        Long2.prototype.toInt = function() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        Long2.prototype.toNumber = function() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
        };
        Long2.prototype.toBigInt = function() {
          return BigInt(this.toString());
        };
        Long2.prototype.toBytes = function(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        Long2.prototype.toBytesLE = function() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24
          ];
        };
        Long2.prototype.toBytesBE = function() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        Long2.prototype.toSigned = function() {
          if (!this.unsigned)
            return this;
          return Long2.fromBits(this.low, this.high, false);
        };
        Long2.prototype.toString = function(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq(Long2.MIN_VALUE)) {
              var radixLong = Long2.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
            } else
              return "-" + this.neg().toString(radix);
          }
          var radixToPower = Long2.fromNumber(Math.pow(radix, 6), this.unsigned);
          var rem = this;
          var result = "";
          while (true) {
            var remDiv = rem.div(radixToPower);
            var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
            var digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) {
              return digits + result;
            } else {
              while (digits.length < 6)
                digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        };
        Long2.prototype.toUnsigned = function() {
          if (this.unsigned)
            return this;
          return Long2.fromBits(this.low, this.high, true);
        };
        Long2.prototype.xor = function(other) {
          if (!Long2.isLong(other))
            other = Long2.fromValue(other);
          return Long2.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };
        Long2.prototype.eqz = function() {
          return this.isZero();
        };
        Long2.prototype.le = function(other) {
          return this.lessThanOrEqual(other);
        };
        Long2.prototype.toExtendedJSON = function(options) {
          if (options && options.relaxed)
            return this.toNumber();
          return { $numberLong: this.toString() };
        };
        Long2.fromExtendedJSON = function(doc, options) {
          var result = Long2.fromString(doc.$numberLong);
          return options && options.relaxed ? result.toNumber() : result;
        };
        Long2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        Long2.prototype.inspect = function() {
          return 'new Long("'.concat(this.toString(), '"').concat(this.unsigned ? ", true" : "", ")");
        };
        Long2.TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL);
        Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(4294967295 | 0, 4294967295 | 0, true);
        Long2.ZERO = Long2.fromInt(0);
        Long2.UZERO = Long2.fromInt(0, true);
        Long2.ONE = Long2.fromInt(1);
        Long2.UONE = Long2.fromInt(1, true);
        Long2.NEG_ONE = Long2.fromInt(-1);
        Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);
        Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);
        return Long2;
      }()
    );
    exports2.Long = Long;
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    Object.defineProperty(Long.prototype, "_bsontype", { value: "Long" });
  }
});

// asset-input/node_modules/bson/lib/decimal128.js
var require_decimal128 = __commonJS({
  "asset-input/node_modules/bson/lib/decimal128.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Decimal128 = void 0;
    var buffer_1 = require("buffer");
    var error_1 = require_error2();
    var long_1 = require_long();
    var utils_1 = require_utils();
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    function isDigit(value) {
      return !isNaN(parseInt(value, 10));
    }
    function divideu128(value) {
      var DIVISOR = long_1.Long.fromNumber(1e3 * 1e3 * 1e3);
      var _rem = long_1.Long.fromNumber(0);
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return { quotient: value, rem: _rem };
      }
      for (var i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new long_1.Long(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value, rem: _rem };
    }
    function multiply64x2(left, right) {
      if (!left && !right) {
        return { high: long_1.Long.fromNumber(0), low: long_1.Long.fromNumber(0) };
      }
      var leftHigh = left.shiftRightUnsigned(32);
      var leftLow = new long_1.Long(left.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new long_1.Long(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new long_1.Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new long_1.Long(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    }
    function lessThan(left, right) {
      var uhleft = left.high >>> 0;
      var uhright = right.high >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        var ulleft = left.low >>> 0;
        var ulright = right.low >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    }
    function invalidErr(string, message) {
      throw new error_1.BSONTypeError('"'.concat(string, '" is not a valid Decimal128 string - ').concat(message));
    }
    var Decimal128 = (
      /** @class */
      function() {
        function Decimal1282(bytes) {
          if (!(this instanceof Decimal1282))
            return new Decimal1282(bytes);
          if (typeof bytes === "string") {
            this.bytes = Decimal1282.fromString(bytes).bytes;
          } else if ((0, utils_1.isUint8Array)(bytes)) {
            if (bytes.byteLength !== 16) {
              throw new error_1.BSONTypeError("Decimal128 must take a Buffer of 16 bytes");
            }
            this.bytes = bytes;
          } else {
            throw new error_1.BSONTypeError("Decimal128 must take a Buffer or string");
          }
        }
        Decimal1282.fromString = function(representation) {
          var isNegative = false;
          var sawRadix = false;
          var foundNonZero = false;
          var significantDigits = 0;
          var nDigitsRead = 0;
          var nDigits = 0;
          var radixPosition = 0;
          var firstNonZero = 0;
          var digits = [0];
          var nDigitsStored = 0;
          var digitsInsert = 0;
          var firstDigit = 0;
          var lastDigit = 0;
          var exponent = 0;
          var i = 0;
          var significandHigh = new long_1.Long(0, 0);
          var significandLow = new long_1.Long(0, 0);
          var biasedExponent = 0;
          var index = 0;
          if (representation.length >= 7e3) {
            throw new error_1.BSONTypeError("" + representation + " not a valid Decimal128 string");
          }
          var stringMatch = representation.match(PARSE_STRING_REGEXP);
          var infMatch = representation.match(PARSE_INF_REGEXP);
          var nanMatch = representation.match(PARSE_NAN_REGEXP);
          if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
            throw new error_1.BSONTypeError("" + representation + " not a valid Decimal128 string");
          }
          if (stringMatch) {
            var unsignedNumber = stringMatch[2];
            var e = stringMatch[4];
            var expSign = stringMatch[5];
            var expNumber = stringMatch[6];
            if (e && expNumber === void 0)
              invalidErr(representation, "missing exponent power");
            if (e && unsignedNumber === void 0)
              invalidErr(representation, "missing exponent base");
            if (e === void 0 && (expSign || expNumber)) {
              invalidErr(representation, "missing e before exponent");
            }
          }
          if (representation[index] === "+" || representation[index] === "-") {
            isNegative = representation[index++] === "-";
          }
          if (!isDigit(representation[index]) && representation[index] !== ".") {
            if (representation[index] === "i" || representation[index] === "I") {
              return new Decimal1282(buffer_1.Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
            } else if (representation[index] === "N") {
              return new Decimal1282(buffer_1.Buffer.from(NAN_BUFFER));
            }
          }
          while (isDigit(representation[index]) || representation[index] === ".") {
            if (representation[index] === ".") {
              if (sawRadix)
                invalidErr(representation, "contains multiple periods");
              sawRadix = true;
              index = index + 1;
              continue;
            }
            if (nDigitsStored < 34) {
              if (representation[index] !== "0" || foundNonZero) {
                if (!foundNonZero) {
                  firstNonZero = nDigitsRead;
                }
                foundNonZero = true;
                digits[digitsInsert++] = parseInt(representation[index], 10);
                nDigitsStored = nDigitsStored + 1;
              }
            }
            if (foundNonZero)
              nDigits = nDigits + 1;
            if (sawRadix)
              radixPosition = radixPosition + 1;
            nDigitsRead = nDigitsRead + 1;
            index = index + 1;
          }
          if (sawRadix && !nDigitsRead)
            throw new error_1.BSONTypeError("" + representation + " not a valid Decimal128 string");
          if (representation[index] === "e" || representation[index] === "E") {
            var match = representation.substr(++index).match(EXPONENT_REGEX);
            if (!match || !match[2])
              return new Decimal1282(buffer_1.Buffer.from(NAN_BUFFER));
            exponent = parseInt(match[0], 10);
            index = index + match[0].length;
          }
          if (representation[index])
            return new Decimal1282(buffer_1.Buffer.from(NAN_BUFFER));
          firstDigit = 0;
          if (!nDigitsStored) {
            firstDigit = 0;
            lastDigit = 0;
            digits[0] = 0;
            nDigits = 1;
            nDigitsStored = 1;
            significantDigits = 0;
          } else {
            lastDigit = nDigitsStored - 1;
            significantDigits = nDigits;
            if (significantDigits !== 1) {
              while (digits[firstNonZero + significantDigits - 1] === 0) {
                significantDigits = significantDigits - 1;
              }
            }
          }
          if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
            exponent = EXPONENT_MIN;
          } else {
            exponent = exponent - radixPosition;
          }
          while (exponent > EXPONENT_MAX) {
            lastDigit = lastDigit + 1;
            if (lastDigit - firstDigit > MAX_DIGITS) {
              var digitsString = digits.join("");
              if (digitsString.match(/^0+$/)) {
                exponent = EXPONENT_MAX;
                break;
              }
              invalidErr(representation, "overflow");
            }
            exponent = exponent - 1;
          }
          while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
            if (lastDigit === 0 && significantDigits < nDigitsStored) {
              exponent = EXPONENT_MIN;
              significantDigits = 0;
              break;
            }
            if (nDigitsStored < nDigits) {
              nDigits = nDigits - 1;
            } else {
              lastDigit = lastDigit - 1;
            }
            if (exponent < EXPONENT_MAX) {
              exponent = exponent + 1;
            } else {
              var digitsString = digits.join("");
              if (digitsString.match(/^0+$/)) {
                exponent = EXPONENT_MAX;
                break;
              }
              invalidErr(representation, "overflow");
            }
          }
          if (lastDigit - firstDigit + 1 < significantDigits) {
            var endOfString = nDigitsRead;
            if (sawRadix) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            if (isNegative) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            var roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
            var roundBit = 0;
            if (roundDigit >= 5) {
              roundBit = 1;
              if (roundDigit === 5) {
                roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
                for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
                  if (parseInt(representation[i], 10)) {
                    roundBit = 1;
                    break;
                  }
                }
              }
            }
            if (roundBit) {
              var dIdx = lastDigit;
              for (; dIdx >= 0; dIdx--) {
                if (++digits[dIdx] > 9) {
                  digits[dIdx] = 0;
                  if (dIdx === 0) {
                    if (exponent < EXPONENT_MAX) {
                      exponent = exponent + 1;
                      digits[dIdx] = 1;
                    } else {
                      return new Decimal1282(buffer_1.Buffer.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                    }
                  }
                }
              }
            }
          }
          significandHigh = long_1.Long.fromNumber(0);
          significandLow = long_1.Long.fromNumber(0);
          if (significantDigits === 0) {
            significandHigh = long_1.Long.fromNumber(0);
            significandLow = long_1.Long.fromNumber(0);
          } else if (lastDigit - firstDigit < 17) {
            var dIdx = firstDigit;
            significandLow = long_1.Long.fromNumber(digits[dIdx++]);
            significandHigh = new long_1.Long(0, 0);
            for (; dIdx <= lastDigit; dIdx++) {
              significandLow = significandLow.multiply(long_1.Long.fromNumber(10));
              significandLow = significandLow.add(long_1.Long.fromNumber(digits[dIdx]));
            }
          } else {
            var dIdx = firstDigit;
            significandHigh = long_1.Long.fromNumber(digits[dIdx++]);
            for (; dIdx <= lastDigit - 17; dIdx++) {
              significandHigh = significandHigh.multiply(long_1.Long.fromNumber(10));
              significandHigh = significandHigh.add(long_1.Long.fromNumber(digits[dIdx]));
            }
            significandLow = long_1.Long.fromNumber(digits[dIdx++]);
            for (; dIdx <= lastDigit; dIdx++) {
              significandLow = significandLow.multiply(long_1.Long.fromNumber(10));
              significandLow = significandLow.add(long_1.Long.fromNumber(digits[dIdx]));
            }
          }
          var significand = multiply64x2(significandHigh, long_1.Long.fromString("100000000000000000"));
          significand.low = significand.low.add(significandLow);
          if (lessThan(significand.low, significandLow)) {
            significand.high = significand.high.add(long_1.Long.fromNumber(1));
          }
          biasedExponent = exponent + EXPONENT_BIAS;
          var dec = { low: long_1.Long.fromNumber(0), high: long_1.Long.fromNumber(0) };
          if (significand.high.shiftRightUnsigned(49).and(long_1.Long.fromNumber(1)).equals(long_1.Long.fromNumber(1))) {
            dec.high = dec.high.or(long_1.Long.fromNumber(3).shiftLeft(61));
            dec.high = dec.high.or(long_1.Long.fromNumber(biasedExponent).and(long_1.Long.fromNumber(16383).shiftLeft(47)));
            dec.high = dec.high.or(significand.high.and(long_1.Long.fromNumber(140737488355327)));
          } else {
            dec.high = dec.high.or(long_1.Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
            dec.high = dec.high.or(significand.high.and(long_1.Long.fromNumber(562949953421311)));
          }
          dec.low = significand.low;
          if (isNegative) {
            dec.high = dec.high.or(long_1.Long.fromString("9223372036854775808"));
          }
          var buffer = buffer_1.Buffer.alloc(16);
          index = 0;
          buffer[index++] = dec.low.low & 255;
          buffer[index++] = dec.low.low >> 8 & 255;
          buffer[index++] = dec.low.low >> 16 & 255;
          buffer[index++] = dec.low.low >> 24 & 255;
          buffer[index++] = dec.low.high & 255;
          buffer[index++] = dec.low.high >> 8 & 255;
          buffer[index++] = dec.low.high >> 16 & 255;
          buffer[index++] = dec.low.high >> 24 & 255;
          buffer[index++] = dec.high.low & 255;
          buffer[index++] = dec.high.low >> 8 & 255;
          buffer[index++] = dec.high.low >> 16 & 255;
          buffer[index++] = dec.high.low >> 24 & 255;
          buffer[index++] = dec.high.high & 255;
          buffer[index++] = dec.high.high >> 8 & 255;
          buffer[index++] = dec.high.high >> 16 & 255;
          buffer[index++] = dec.high.high >> 24 & 255;
          return new Decimal1282(buffer);
        };
        Decimal1282.prototype.toString = function() {
          var biased_exponent;
          var significand_digits = 0;
          var significand = new Array(36);
          for (var i = 0; i < significand.length; i++)
            significand[i] = 0;
          var index = 0;
          var is_zero = false;
          var significand_msb;
          var significand128 = { parts: [0, 0, 0, 0] };
          var j, k;
          var string = [];
          index = 0;
          var buffer = this.bytes;
          var low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          index = 0;
          var dec = {
            low: new long_1.Long(low, midl),
            high: new long_1.Long(midh, high)
          };
          if (dec.high.lessThan(long_1.Long.ZERO)) {
            string.push("-");
          }
          var combination = high >> 26 & COMBINATION_MASK;
          if (combination >> 3 === 3) {
            if (combination === COMBINATION_INFINITY) {
              return string.join("") + "Infinity";
            } else if (combination === COMBINATION_NAN) {
              return "NaN";
            } else {
              biased_exponent = high >> 15 & EXPONENT_MASK;
              significand_msb = 8 + (high >> 14 & 1);
            }
          } else {
            significand_msb = high >> 14 & 7;
            biased_exponent = high >> 17 & EXPONENT_MASK;
          }
          var exponent = biased_exponent - EXPONENT_BIAS;
          significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
          significand128.parts[1] = midh;
          significand128.parts[2] = midl;
          significand128.parts[3] = low;
          if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
            is_zero = true;
          } else {
            for (k = 3; k >= 0; k--) {
              var least_digits = 0;
              var result = divideu128(significand128);
              significand128 = result.quotient;
              least_digits = result.rem.low;
              if (!least_digits)
                continue;
              for (j = 8; j >= 0; j--) {
                significand[k * 9 + j] = least_digits % 10;
                least_digits = Math.floor(least_digits / 10);
              }
            }
          }
          if (is_zero) {
            significand_digits = 1;
            significand[index] = 0;
          } else {
            significand_digits = 36;
            while (!significand[index]) {
              significand_digits = significand_digits - 1;
              index = index + 1;
            }
          }
          var scientific_exponent = significand_digits - 1 + exponent;
          if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
            if (significand_digits > 34) {
              string.push("".concat(0));
              if (exponent > 0)
                string.push("E+".concat(exponent));
              else if (exponent < 0)
                string.push("E".concat(exponent));
              return string.join("");
            }
            string.push("".concat(significand[index++]));
            significand_digits = significand_digits - 1;
            if (significand_digits) {
              string.push(".");
            }
            for (var i = 0; i < significand_digits; i++) {
              string.push("".concat(significand[index++]));
            }
            string.push("E");
            if (scientific_exponent > 0) {
              string.push("+".concat(scientific_exponent));
            } else {
              string.push("".concat(scientific_exponent));
            }
          } else {
            if (exponent >= 0) {
              for (var i = 0; i < significand_digits; i++) {
                string.push("".concat(significand[index++]));
              }
            } else {
              var radix_position = significand_digits + exponent;
              if (radix_position > 0) {
                for (var i = 0; i < radix_position; i++) {
                  string.push("".concat(significand[index++]));
                }
              } else {
                string.push("0");
              }
              string.push(".");
              while (radix_position++ < 0) {
                string.push("0");
              }
              for (var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
                string.push("".concat(significand[index++]));
              }
            }
          }
          return string.join("");
        };
        Decimal1282.prototype.toJSON = function() {
          return { $numberDecimal: this.toString() };
        };
        Decimal1282.prototype.toExtendedJSON = function() {
          return { $numberDecimal: this.toString() };
        };
        Decimal1282.fromExtendedJSON = function(doc) {
          return Decimal1282.fromString(doc.$numberDecimal);
        };
        Decimal1282.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        Decimal1282.prototype.inspect = function() {
          return 'new Decimal128("'.concat(this.toString(), '")');
        };
        return Decimal1282;
      }()
    );
    exports2.Decimal128 = Decimal128;
    Object.defineProperty(Decimal128.prototype, "_bsontype", { value: "Decimal128" });
  }
});

// asset-input/node_modules/bson/lib/double.js
var require_double = __commonJS({
  "asset-input/node_modules/bson/lib/double.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Double = void 0;
    var Double = (
      /** @class */
      function() {
        function Double2(value) {
          if (!(this instanceof Double2))
            return new Double2(value);
          if (value instanceof Number) {
            value = value.valueOf();
          }
          this.value = +value;
        }
        Double2.prototype.valueOf = function() {
          return this.value;
        };
        Double2.prototype.toJSON = function() {
          return this.value;
        };
        Double2.prototype.toString = function(radix) {
          return this.value.toString(radix);
        };
        Double2.prototype.toExtendedJSON = function(options) {
          if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
            return this.value;
          }
          if (Object.is(Math.sign(this.value), -0)) {
            return { $numberDouble: "-".concat(this.value.toFixed(1)) };
          }
          return {
            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
          };
        };
        Double2.fromExtendedJSON = function(doc, options) {
          var doubleValue = parseFloat(doc.$numberDouble);
          return options && options.relaxed ? doubleValue : new Double2(doubleValue);
        };
        Double2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        Double2.prototype.inspect = function() {
          var eJSON = this.toExtendedJSON();
          return "new Double(".concat(eJSON.$numberDouble, ")");
        };
        return Double2;
      }()
    );
    exports2.Double = Double;
    Object.defineProperty(Double.prototype, "_bsontype", { value: "Double" });
  }
});

// asset-input/node_modules/bson/lib/int_32.js
var require_int_32 = __commonJS({
  "asset-input/node_modules/bson/lib/int_32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Int32 = void 0;
    var Int32 = (
      /** @class */
      function() {
        function Int322(value) {
          if (!(this instanceof Int322))
            return new Int322(value);
          if (value instanceof Number) {
            value = value.valueOf();
          }
          this.value = +value | 0;
        }
        Int322.prototype.valueOf = function() {
          return this.value;
        };
        Int322.prototype.toString = function(radix) {
          return this.value.toString(radix);
        };
        Int322.prototype.toJSON = function() {
          return this.value;
        };
        Int322.prototype.toExtendedJSON = function(options) {
          if (options && (options.relaxed || options.legacy))
            return this.value;
          return { $numberInt: this.value.toString() };
        };
        Int322.fromExtendedJSON = function(doc, options) {
          return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int322(doc.$numberInt);
        };
        Int322.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        Int322.prototype.inspect = function() {
          return "new Int32(".concat(this.valueOf(), ")");
        };
        return Int322;
      }()
    );
    exports2.Int32 = Int32;
    Object.defineProperty(Int32.prototype, "_bsontype", { value: "Int32" });
  }
});

// asset-input/node_modules/bson/lib/max_key.js
var require_max_key = __commonJS({
  "asset-input/node_modules/bson/lib/max_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxKey = void 0;
    var MaxKey = (
      /** @class */
      function() {
        function MaxKey2() {
          if (!(this instanceof MaxKey2))
            return new MaxKey2();
        }
        MaxKey2.prototype.toExtendedJSON = function() {
          return { $maxKey: 1 };
        };
        MaxKey2.fromExtendedJSON = function() {
          return new MaxKey2();
        };
        MaxKey2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        MaxKey2.prototype.inspect = function() {
          return "new MaxKey()";
        };
        return MaxKey2;
      }()
    );
    exports2.MaxKey = MaxKey;
    Object.defineProperty(MaxKey.prototype, "_bsontype", { value: "MaxKey" });
  }
});

// asset-input/node_modules/bson/lib/min_key.js
var require_min_key = __commonJS({
  "asset-input/node_modules/bson/lib/min_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MinKey = void 0;
    var MinKey = (
      /** @class */
      function() {
        function MinKey2() {
          if (!(this instanceof MinKey2))
            return new MinKey2();
        }
        MinKey2.prototype.toExtendedJSON = function() {
          return { $minKey: 1 };
        };
        MinKey2.fromExtendedJSON = function() {
          return new MinKey2();
        };
        MinKey2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        MinKey2.prototype.inspect = function() {
          return "new MinKey()";
        };
        return MinKey2;
      }()
    );
    exports2.MinKey = MinKey;
    Object.defineProperty(MinKey.prototype, "_bsontype", { value: "MinKey" });
  }
});

// asset-input/node_modules/bson/lib/objectid.js
var require_objectid = __commonJS({
  "asset-input/node_modules/bson/lib/objectid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectId = void 0;
    var buffer_1 = require("buffer");
    var ensure_buffer_1 = require_ensure_buffer();
    var error_1 = require_error2();
    var utils_1 = require_utils();
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    var PROCESS_UNIQUE = null;
    var kId = Symbol("id");
    var ObjectId2 = (
      /** @class */
      function() {
        function ObjectId3(inputId) {
          if (!(this instanceof ObjectId3))
            return new ObjectId3(inputId);
          var workingId;
          if (typeof inputId === "object" && inputId && "id" in inputId) {
            if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
              throw new error_1.BSONTypeError("Argument passed in must have an id that is of type string or Buffer");
            }
            if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
              workingId = buffer_1.Buffer.from(inputId.toHexString(), "hex");
            } else {
              workingId = inputId.id;
            }
          } else {
            workingId = inputId;
          }
          if (workingId == null || typeof workingId === "number") {
            this[kId] = ObjectId3.generate(typeof workingId === "number" ? workingId : void 0);
          } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
            this[kId] = workingId instanceof buffer_1.Buffer ? workingId : (0, ensure_buffer_1.ensureBuffer)(workingId);
          } else if (typeof workingId === "string") {
            if (workingId.length === 12) {
              var bytes = buffer_1.Buffer.from(workingId);
              if (bytes.byteLength === 12) {
                this[kId] = bytes;
              } else {
                throw new error_1.BSONTypeError("Argument passed in must be a string of 12 bytes");
              }
            } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
              this[kId] = buffer_1.Buffer.from(workingId, "hex");
            } else {
              throw new error_1.BSONTypeError("Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer");
            }
          } else {
            throw new error_1.BSONTypeError("Argument passed in does not match the accepted types");
          }
          if (ObjectId3.cacheHexString) {
            this.__id = this.id.toString("hex");
          }
        }
        Object.defineProperty(ObjectId3.prototype, "id", {
          /**
           * The ObjectId bytes
           * @readonly
           */
          get: function() {
            return this[kId];
          },
          set: function(value) {
            this[kId] = value;
            if (ObjectId3.cacheHexString) {
              this.__id = value.toString("hex");
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ObjectId3.prototype, "generationTime", {
          /**
           * The generation time of this ObjectId instance
           * @deprecated Please use getTimestamp / createFromTime which returns an int32 epoch
           */
          get: function() {
            return this.id.readInt32BE(0);
          },
          set: function(value) {
            this.id.writeUInt32BE(value, 0);
          },
          enumerable: false,
          configurable: true
        });
        ObjectId3.prototype.toHexString = function() {
          if (ObjectId3.cacheHexString && this.__id) {
            return this.__id;
          }
          var hexString = this.id.toString("hex");
          if (ObjectId3.cacheHexString && !this.__id) {
            this.__id = hexString;
          }
          return hexString;
        };
        ObjectId3.getInc = function() {
          return ObjectId3.index = (ObjectId3.index + 1) % 16777215;
        };
        ObjectId3.generate = function(time) {
          if ("number" !== typeof time) {
            time = Math.floor(Date.now() / 1e3);
          }
          var inc = ObjectId3.getInc();
          var buffer = buffer_1.Buffer.alloc(12);
          buffer.writeUInt32BE(time, 0);
          if (PROCESS_UNIQUE === null) {
            PROCESS_UNIQUE = (0, utils_1.randomBytes)(5);
          }
          buffer[4] = PROCESS_UNIQUE[0];
          buffer[5] = PROCESS_UNIQUE[1];
          buffer[6] = PROCESS_UNIQUE[2];
          buffer[7] = PROCESS_UNIQUE[3];
          buffer[8] = PROCESS_UNIQUE[4];
          buffer[11] = inc & 255;
          buffer[10] = inc >> 8 & 255;
          buffer[9] = inc >> 16 & 255;
          return buffer;
        };
        ObjectId3.prototype.toString = function(format) {
          if (format)
            return this.id.toString(format);
          return this.toHexString();
        };
        ObjectId3.prototype.toJSON = function() {
          return this.toHexString();
        };
        ObjectId3.prototype.equals = function(otherId) {
          if (otherId === void 0 || otherId === null) {
            return false;
          }
          if (otherId instanceof ObjectId3) {
            return this[kId][11] === otherId[kId][11] && this[kId].equals(otherId[kId]);
          }
          if (typeof otherId === "string" && ObjectId3.isValid(otherId) && otherId.length === 12 && (0, utils_1.isUint8Array)(this.id)) {
            return otherId === buffer_1.Buffer.prototype.toString.call(this.id, "latin1");
          }
          if (typeof otherId === "string" && ObjectId3.isValid(otherId) && otherId.length === 24) {
            return otherId.toLowerCase() === this.toHexString();
          }
          if (typeof otherId === "string" && ObjectId3.isValid(otherId) && otherId.length === 12) {
            return buffer_1.Buffer.from(otherId).equals(this.id);
          }
          if (typeof otherId === "object" && "toHexString" in otherId && typeof otherId.toHexString === "function") {
            var otherIdString = otherId.toHexString();
            var thisIdString = this.toHexString().toLowerCase();
            return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
          }
          return false;
        };
        ObjectId3.prototype.getTimestamp = function() {
          var timestamp = /* @__PURE__ */ new Date();
          var time = this.id.readUInt32BE(0);
          timestamp.setTime(Math.floor(time) * 1e3);
          return timestamp;
        };
        ObjectId3.createPk = function() {
          return new ObjectId3();
        };
        ObjectId3.createFromTime = function(time) {
          var buffer = buffer_1.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
          buffer.writeUInt32BE(time, 0);
          return new ObjectId3(buffer);
        };
        ObjectId3.createFromHexString = function(hexString) {
          if (typeof hexString === "undefined" || hexString != null && hexString.length !== 24) {
            throw new error_1.BSONTypeError("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
          }
          return new ObjectId3(buffer_1.Buffer.from(hexString, "hex"));
        };
        ObjectId3.isValid = function(id) {
          if (id == null)
            return false;
          try {
            new ObjectId3(id);
            return true;
          } catch (_a) {
            return false;
          }
        };
        ObjectId3.prototype.toExtendedJSON = function() {
          if (this.toHexString)
            return { $oid: this.toHexString() };
          return { $oid: this.toString("hex") };
        };
        ObjectId3.fromExtendedJSON = function(doc) {
          return new ObjectId3(doc.$oid);
        };
        ObjectId3.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        ObjectId3.prototype.inspect = function() {
          return 'new ObjectId("'.concat(this.toHexString(), '")');
        };
        ObjectId3.index = Math.floor(Math.random() * 16777215);
        return ObjectId3;
      }()
    );
    exports2.ObjectId = ObjectId2;
    Object.defineProperty(ObjectId2.prototype, "generate", {
      value: (0, utils_1.deprecate)(function(time) {
        return ObjectId2.generate(time);
      }, "Please use the static `ObjectId.generate(time)` instead")
    });
    Object.defineProperty(ObjectId2.prototype, "getInc", {
      value: (0, utils_1.deprecate)(function() {
        return ObjectId2.getInc();
      }, "Please use the static `ObjectId.getInc()` instead")
    });
    Object.defineProperty(ObjectId2.prototype, "get_inc", {
      value: (0, utils_1.deprecate)(function() {
        return ObjectId2.getInc();
      }, "Please use the static `ObjectId.getInc()` instead")
    });
    Object.defineProperty(ObjectId2, "get_inc", {
      value: (0, utils_1.deprecate)(function() {
        return ObjectId2.getInc();
      }, "Please use the static `ObjectId.getInc()` instead")
    });
    Object.defineProperty(ObjectId2.prototype, "_bsontype", { value: "ObjectID" });
  }
});

// asset-input/node_modules/bson/lib/regexp.js
var require_regexp = __commonJS({
  "asset-input/node_modules/bson/lib/regexp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BSONRegExp = void 0;
    var error_1 = require_error2();
    function alphabetize(str) {
      return str.split("").sort().join("");
    }
    var BSONRegExp = (
      /** @class */
      function() {
        function BSONRegExp2(pattern, options) {
          if (!(this instanceof BSONRegExp2))
            return new BSONRegExp2(pattern, options);
          this.pattern = pattern;
          this.options = alphabetize(options !== null && options !== void 0 ? options : "");
          if (this.pattern.indexOf("\0") !== -1) {
            throw new error_1.BSONError("BSON Regex patterns cannot contain null bytes, found: ".concat(JSON.stringify(this.pattern)));
          }
          if (this.options.indexOf("\0") !== -1) {
            throw new error_1.BSONError("BSON Regex options cannot contain null bytes, found: ".concat(JSON.stringify(this.options)));
          }
          for (var i = 0; i < this.options.length; i++) {
            if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
              throw new error_1.BSONError("The regular expression option [".concat(this.options[i], "] is not supported"));
            }
          }
        }
        BSONRegExp2.parseOptions = function(options) {
          return options ? options.split("").sort().join("") : "";
        };
        BSONRegExp2.prototype.toExtendedJSON = function(options) {
          options = options || {};
          if (options.legacy) {
            return { $regex: this.pattern, $options: this.options };
          }
          return { $regularExpression: { pattern: this.pattern, options: this.options } };
        };
        BSONRegExp2.fromExtendedJSON = function(doc) {
          if ("$regex" in doc) {
            if (typeof doc.$regex !== "string") {
              if (doc.$regex._bsontype === "BSONRegExp") {
                return doc;
              }
            } else {
              return new BSONRegExp2(doc.$regex, BSONRegExp2.parseOptions(doc.$options));
            }
          }
          if ("$regularExpression" in doc) {
            return new BSONRegExp2(doc.$regularExpression.pattern, BSONRegExp2.parseOptions(doc.$regularExpression.options));
          }
          throw new error_1.BSONTypeError("Unexpected BSONRegExp EJSON object form: ".concat(JSON.stringify(doc)));
        };
        return BSONRegExp2;
      }()
    );
    exports2.BSONRegExp = BSONRegExp;
    Object.defineProperty(BSONRegExp.prototype, "_bsontype", { value: "BSONRegExp" });
  }
});

// asset-input/node_modules/bson/lib/symbol.js
var require_symbol = __commonJS({
  "asset-input/node_modules/bson/lib/symbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BSONSymbol = void 0;
    var BSONSymbol = (
      /** @class */
      function() {
        function BSONSymbol2(value) {
          if (!(this instanceof BSONSymbol2))
            return new BSONSymbol2(value);
          this.value = value;
        }
        BSONSymbol2.prototype.valueOf = function() {
          return this.value;
        };
        BSONSymbol2.prototype.toString = function() {
          return this.value;
        };
        BSONSymbol2.prototype.inspect = function() {
          return 'new BSONSymbol("'.concat(this.value, '")');
        };
        BSONSymbol2.prototype.toJSON = function() {
          return this.value;
        };
        BSONSymbol2.prototype.toExtendedJSON = function() {
          return { $symbol: this.value };
        };
        BSONSymbol2.fromExtendedJSON = function(doc) {
          return new BSONSymbol2(doc.$symbol);
        };
        BSONSymbol2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        return BSONSymbol2;
      }()
    );
    exports2.BSONSymbol = BSONSymbol;
    Object.defineProperty(BSONSymbol.prototype, "_bsontype", { value: "Symbol" });
  }
});

// asset-input/node_modules/bson/lib/timestamp.js
var require_timestamp = __commonJS({
  "asset-input/node_modules/bson/lib/timestamp.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = exports2.LongWithoutOverridesClass = void 0;
    var long_1 = require_long();
    var utils_1 = require_utils();
    exports2.LongWithoutOverridesClass = long_1.Long;
    var Timestamp = (
      /** @class */
      function(_super) {
        __extends(Timestamp2, _super);
        function Timestamp2(low, high) {
          var _this = this;
          if (!(_this instanceof Timestamp2))
            return new Timestamp2(low, high);
          if (long_1.Long.isLong(low)) {
            _this = _super.call(this, low.low, low.high, true) || this;
          } else if ((0, utils_1.isObjectLike)(low) && typeof low.t !== "undefined" && typeof low.i !== "undefined") {
            _this = _super.call(this, low.i, low.t, true) || this;
          } else {
            _this = _super.call(this, low, high, true) || this;
          }
          Object.defineProperty(_this, "_bsontype", {
            value: "Timestamp",
            writable: false,
            configurable: false,
            enumerable: false
          });
          return _this;
        }
        Timestamp2.prototype.toJSON = function() {
          return {
            $timestamp: this.toString()
          };
        };
        Timestamp2.fromInt = function(value) {
          return new Timestamp2(long_1.Long.fromInt(value, true));
        };
        Timestamp2.fromNumber = function(value) {
          return new Timestamp2(long_1.Long.fromNumber(value, true));
        };
        Timestamp2.fromBits = function(lowBits, highBits) {
          return new Timestamp2(lowBits, highBits);
        };
        Timestamp2.fromString = function(str, optRadix) {
          return new Timestamp2(long_1.Long.fromString(str, true, optRadix));
        };
        Timestamp2.prototype.toExtendedJSON = function() {
          return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
        };
        Timestamp2.fromExtendedJSON = function(doc) {
          return new Timestamp2(doc.$timestamp);
        };
        Timestamp2.prototype[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return this.inspect();
        };
        Timestamp2.prototype.inspect = function() {
          return "new Timestamp({ t: ".concat(this.getHighBits(), ", i: ").concat(this.getLowBits(), " })");
        };
        Timestamp2.MAX_VALUE = long_1.Long.MAX_UNSIGNED_VALUE;
        return Timestamp2;
      }(exports2.LongWithoutOverridesClass)
    );
    exports2.Timestamp = Timestamp;
  }
});

// asset-input/node_modules/bson/lib/extended_json.js
var require_extended_json = __commonJS({
  "asset-input/node_modules/bson/lib/extended_json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EJSON = exports2.isBSONType = void 0;
    var binary_1 = require_binary();
    var code_1 = require_code();
    var db_ref_1 = require_db_ref();
    var decimal128_1 = require_decimal128();
    var double_1 = require_double();
    var error_1 = require_error2();
    var int_32_1 = require_int_32();
    var long_1 = require_long();
    var max_key_1 = require_max_key();
    var min_key_1 = require_min_key();
    var objectid_1 = require_objectid();
    var utils_1 = require_utils();
    var regexp_1 = require_regexp();
    var symbol_1 = require_symbol();
    var timestamp_1 = require_timestamp();
    function isBSONType(value) {
      return (0, utils_1.isObjectLike)(value) && Reflect.has(value, "_bsontype") && typeof value._bsontype === "string";
    }
    exports2.isBSONType = isBSONType;
    var BSON_INT32_MAX = 2147483647;
    var BSON_INT32_MIN = -2147483648;
    var BSON_INT64_MAX = 9223372036854776e3;
    var BSON_INT64_MIN = -9223372036854776e3;
    var keysToCodecs = {
      $oid: objectid_1.ObjectId,
      $binary: binary_1.Binary,
      $uuid: binary_1.Binary,
      $symbol: symbol_1.BSONSymbol,
      $numberInt: int_32_1.Int32,
      $numberDecimal: decimal128_1.Decimal128,
      $numberDouble: double_1.Double,
      $numberLong: long_1.Long,
      $minKey: min_key_1.MinKey,
      $maxKey: max_key_1.MaxKey,
      $regex: regexp_1.BSONRegExp,
      $regularExpression: regexp_1.BSONRegExp,
      $timestamp: timestamp_1.Timestamp
    };
    function deserializeValue(value, options) {
      if (options === void 0) {
        options = {};
      }
      if (typeof value === "number") {
        if (options.relaxed || options.legacy) {
          return value;
        }
        if (Math.floor(value) === value) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX)
            return new int_32_1.Int32(value);
          if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX)
            return long_1.Long.fromNumber(value);
        }
        return new double_1.Double(value);
      }
      if (value == null || typeof value !== "object")
        return value;
      if (value.$undefined)
        return null;
      var keys = Object.keys(value).filter(function(k) {
        return k.startsWith("$") && value[k] != null;
      });
      for (var i = 0; i < keys.length; i++) {
        var c = keysToCodecs[keys[i]];
        if (c)
          return c.fromExtendedJSON(value, options);
      }
      if (value.$date != null) {
        var d = value.$date;
        var date = /* @__PURE__ */ new Date();
        if (options.legacy) {
          if (typeof d === "number")
            date.setTime(d);
          else if (typeof d === "string")
            date.setTime(Date.parse(d));
        } else {
          if (typeof d === "string")
            date.setTime(Date.parse(d));
          else if (long_1.Long.isLong(d))
            date.setTime(d.toNumber());
          else if (typeof d === "number" && options.relaxed)
            date.setTime(d);
        }
        return date;
      }
      if (value.$code != null) {
        var copy = Object.assign({}, value);
        if (value.$scope) {
          copy.$scope = deserializeValue(value.$scope);
        }
        return code_1.Code.fromExtendedJSON(value);
      }
      if ((0, db_ref_1.isDBRefLike)(value) || value.$dbPointer) {
        var v = value.$ref ? value : value.$dbPointer;
        if (v instanceof db_ref_1.DBRef)
          return v;
        var dollarKeys = Object.keys(v).filter(function(k) {
          return k.startsWith("$");
        });
        var valid_1 = true;
        dollarKeys.forEach(function(k) {
          if (["$ref", "$id", "$db"].indexOf(k) === -1)
            valid_1 = false;
        });
        if (valid_1)
          return db_ref_1.DBRef.fromExtendedJSON(v);
      }
      return value;
    }
    function serializeArray(array, options) {
      return array.map(function(v, index) {
        options.seenObjects.push({ propertyName: "index ".concat(index), obj: null });
        try {
          return serializeValue(v, options);
        } finally {
          options.seenObjects.pop();
        }
      });
    }
    function getISOString(date) {
      var isoStr = date.toISOString();
      return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
    }
    function serializeValue(value, options) {
      if ((typeof value === "object" || typeof value === "function") && value !== null) {
        var index = options.seenObjects.findIndex(function(entry) {
          return entry.obj === value;
        });
        if (index !== -1) {
          var props = options.seenObjects.map(function(entry) {
            return entry.propertyName;
          });
          var leadingPart = props.slice(0, index).map(function(prop) {
            return "".concat(prop, " -> ");
          }).join("");
          var alreadySeen = props[index];
          var circularPart = " -> " + props.slice(index + 1, props.length - 1).map(function(prop) {
            return "".concat(prop, " -> ");
          }).join("");
          var current = props[props.length - 1];
          var leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
          var dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
          throw new error_1.BSONTypeError("Converting circular structure to EJSON:\n" + "    ".concat(leadingPart).concat(alreadySeen).concat(circularPart).concat(current, "\n") + "    ".concat(leadingSpace, "\\").concat(dashes, "/"));
        }
        options.seenObjects[options.seenObjects.length - 1].obj = value;
      }
      if (Array.isArray(value))
        return serializeArray(value, options);
      if (value === void 0)
        return null;
      if (value instanceof Date || (0, utils_1.isDate)(value)) {
        var dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
        if (options.legacy) {
          return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
        }
        return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
      }
      if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
        if (Math.floor(value) === value) {
          var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX, int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;
          if (int32Range)
            return { $numberInt: value.toString() };
          if (int64Range)
            return { $numberLong: value.toString() };
        }
        return { $numberDouble: value.toString() };
      }
      if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {
        var flags = value.flags;
        if (flags === void 0) {
          var match = value.toString().match(/[gimuy]*$/);
          if (match) {
            flags = match[0];
          }
        }
        var rx = new regexp_1.BSONRegExp(value.source, flags);
        return rx.toExtendedJSON(options);
      }
      if (value != null && typeof value === "object")
        return serializeDocument(value, options);
      return value;
    }
    var BSON_TYPE_MAPPINGS = {
      Binary: function(o) {
        return new binary_1.Binary(o.value(), o.sub_type);
      },
      Code: function(o) {
        return new code_1.Code(o.code, o.scope);
      },
      DBRef: function(o) {
        return new db_ref_1.DBRef(o.collection || o.namespace, o.oid, o.db, o.fields);
      },
      Decimal128: function(o) {
        return new decimal128_1.Decimal128(o.bytes);
      },
      Double: function(o) {
        return new double_1.Double(o.value);
      },
      Int32: function(o) {
        return new int_32_1.Int32(o.value);
      },
      Long: function(o) {
        return long_1.Long.fromBits(
          // underscore variants for 1.x backwards compatibility
          o.low != null ? o.low : o.low_,
          o.low != null ? o.high : o.high_,
          o.low != null ? o.unsigned : o.unsigned_
        );
      },
      MaxKey: function() {
        return new max_key_1.MaxKey();
      },
      MinKey: function() {
        return new min_key_1.MinKey();
      },
      ObjectID: function(o) {
        return new objectid_1.ObjectId(o);
      },
      ObjectId: function(o) {
        return new objectid_1.ObjectId(o);
      },
      BSONRegExp: function(o) {
        return new regexp_1.BSONRegExp(o.pattern, o.options);
      },
      Symbol: function(o) {
        return new symbol_1.BSONSymbol(o.value);
      },
      Timestamp: function(o) {
        return timestamp_1.Timestamp.fromBits(o.low, o.high);
      }
    };
    function serializeDocument(doc, options) {
      if (doc == null || typeof doc !== "object")
        throw new error_1.BSONError("not an object instance");
      var bsontype = doc._bsontype;
      if (typeof bsontype === "undefined") {
        var _doc = {};
        for (var name in doc) {
          options.seenObjects.push({ propertyName: name, obj: null });
          try {
            var value = serializeValue(doc[name], options);
            if (name === "__proto__") {
              Object.defineProperty(_doc, name, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            } else {
              _doc[name] = value;
            }
          } finally {
            options.seenObjects.pop();
          }
        }
        return _doc;
      } else if (isBSONType(doc)) {
        var outDoc = doc;
        if (typeof outDoc.toExtendedJSON !== "function") {
          var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
          if (!mapper) {
            throw new error_1.BSONTypeError("Unrecognized or invalid _bsontype: " + doc._bsontype);
          }
          outDoc = mapper(outDoc);
        }
        if (bsontype === "Code" && outDoc.scope) {
          outDoc = new code_1.Code(outDoc.code, serializeValue(outDoc.scope, options));
        } else if (bsontype === "DBRef" && outDoc.oid) {
          outDoc = new db_ref_1.DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
        }
        return outDoc.toExtendedJSON(options);
      } else {
        throw new error_1.BSONError("_bsontype must be a string, but was: " + typeof bsontype);
      }
    }
    var EJSON;
    (function(EJSON2) {
      function parse(text, options) {
        var finalOptions = Object.assign({}, { relaxed: true, legacy: false }, options);
        if (typeof finalOptions.relaxed === "boolean")
          finalOptions.strict = !finalOptions.relaxed;
        if (typeof finalOptions.strict === "boolean")
          finalOptions.relaxed = !finalOptions.strict;
        return JSON.parse(text, function(key, value) {
          if (key.indexOf("\0") !== -1) {
            throw new error_1.BSONError("BSON Document field names cannot contain null bytes, found: ".concat(JSON.stringify(key)));
          }
          return deserializeValue(value, finalOptions);
        });
      }
      EJSON2.parse = parse;
      function stringify(value, replacer, space, options) {
        if (space != null && typeof space === "object") {
          options = space;
          space = 0;
        }
        if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
          options = replacer;
          replacer = void 0;
          space = 0;
        }
        var serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
          seenObjects: [{ propertyName: "(root)", obj: null }]
        });
        var doc = serializeValue(value, serializeOptions);
        return JSON.stringify(doc, replacer, space);
      }
      EJSON2.stringify = stringify;
      function serialize(value, options) {
        options = options || {};
        return JSON.parse(stringify(value, options));
      }
      EJSON2.serialize = serialize;
      function deserialize(ejson, options) {
        options = options || {};
        return parse(JSON.stringify(ejson), options);
      }
      EJSON2.deserialize = deserialize;
    })(EJSON = exports2.EJSON || (exports2.EJSON = {}));
  }
});

// asset-input/node_modules/bson/lib/map.js
var require_map = __commonJS({
  "asset-input/node_modules/bson/lib/map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Map = void 0;
    var global_1 = require_global();
    var bsonMap;
    exports2.Map = bsonMap;
    var bsonGlobal = (0, global_1.getGlobal)();
    if (bsonGlobal.Map) {
      exports2.Map = bsonMap = bsonGlobal.Map;
    } else {
      exports2.Map = bsonMap = /** @class */
      function() {
        function Map2(array) {
          if (array === void 0) {
            array = [];
          }
          this._keys = [];
          this._values = {};
          for (var i = 0; i < array.length; i++) {
            if (array[i] == null)
              continue;
            var entry = array[i];
            var key = entry[0];
            var value = entry[1];
            this._keys.push(key);
            this._values[key] = { v: value, i: this._keys.length - 1 };
          }
        }
        Map2.prototype.clear = function() {
          this._keys = [];
          this._values = {};
        };
        Map2.prototype.delete = function(key) {
          var value = this._values[key];
          if (value == null)
            return false;
          delete this._values[key];
          this._keys.splice(value.i, 1);
          return true;
        };
        Map2.prototype.entries = function() {
          var _this = this;
          var index = 0;
          return {
            next: function() {
              var key = _this._keys[index++];
              return {
                value: key !== void 0 ? [key, _this._values[key].v] : void 0,
                done: key !== void 0 ? false : true
              };
            }
          };
        };
        Map2.prototype.forEach = function(callback, self2) {
          self2 = self2 || this;
          for (var i = 0; i < this._keys.length; i++) {
            var key = this._keys[i];
            callback.call(self2, this._values[key].v, key, self2);
          }
        };
        Map2.prototype.get = function(key) {
          return this._values[key] ? this._values[key].v : void 0;
        };
        Map2.prototype.has = function(key) {
          return this._values[key] != null;
        };
        Map2.prototype.keys = function() {
          var _this = this;
          var index = 0;
          return {
            next: function() {
              var key = _this._keys[index++];
              return {
                value: key !== void 0 ? key : void 0,
                done: key !== void 0 ? false : true
              };
            }
          };
        };
        Map2.prototype.set = function(key, value) {
          if (this._values[key]) {
            this._values[key].v = value;
            return this;
          }
          this._keys.push(key);
          this._values[key] = { v: value, i: this._keys.length - 1 };
          return this;
        };
        Map2.prototype.values = function() {
          var _this = this;
          var index = 0;
          return {
            next: function() {
              var key = _this._keys[index++];
              return {
                value: key !== void 0 ? _this._values[key].v : void 0,
                done: key !== void 0 ? false : true
              };
            }
          };
        };
        Object.defineProperty(Map2.prototype, "size", {
          get: function() {
            return this._keys.length;
          },
          enumerable: false,
          configurable: true
        });
        return Map2;
      }();
    }
  }
});

// asset-input/node_modules/bson/lib/parser/calculate_size.js
var require_calculate_size = __commonJS({
  "asset-input/node_modules/bson/lib/parser/calculate_size.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateObjectSize = void 0;
    var buffer_1 = require("buffer");
    var binary_1 = require_binary();
    var constants = require_constants();
    var utils_1 = require_utils();
    function calculateObjectSize(object, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === "function") {
          object = object.toBSON();
        }
        for (var key in object) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    }
    exports2.calculateObjectSize = calculateObjectSize;
    function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
      if (serializeFunctions === void 0) {
        serializeFunctions = false;
      }
      if (isArray === void 0) {
        isArray = false;
      }
      if (ignoreUndefined === void 0) {
        ignoreUndefined = false;
      }
      if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === "function") {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + buffer_1.Buffer.byteLength(name, "utf8") + 1 + 4 + buffer_1.Buffer.byteLength(value, "utf8") + 1;
        case "number":
          if (Math.floor(value) === value && value >= constants.JS_INT_MIN && value <= constants.JS_INT_MAX) {
            if (value >= constants.BSON_INT32_MIN && value <= constants.BSON_INT32_MAX) {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
        case "object":
          if (value == null || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || (0, utils_1.isDate)(value)) {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || (0, utils_1.isAnyArrayBuffer)(value)) {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.byteLength;
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (value["_bsontype"] === "Decimal128") {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
          } else if (value["_bsontype"] === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + buffer_1.Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + buffer_1.Buffer.byteLength(value.code.toString(), "utf8") + 1;
            }
          } else if (value["_bsontype"] === "Binary") {
            var binary = value;
            if (binary.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + (binary.position + 1 + 4 + 1);
            }
          } else if (value["_bsontype"] === "Symbol") {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + buffer_1.Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
          } else if (value["_bsontype"] === "DBRef") {
            var ordered_values = Object.assign({
              $ref: value.collection,
              $id: value.oid
            }, value.fields);
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value["_bsontype"] === "BSONRegExp") {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.Buffer.byteLength(value.pattern, "utf8") + 1 + buffer_1.Buffer.byteLength(value.options, "utf8") + 1;
          } else {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (value instanceof RegExp || (0, utils_1.isRegExp)(value) || String.call(value) === "[object RegExp]") {
            return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + buffer_1.Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + buffer_1.Buffer.byteLength((0, utils_1.normalizedFunctionString)(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name != null ? buffer_1.Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + buffer_1.Buffer.byteLength((0, utils_1.normalizedFunctionString)(value), "utf8") + 1;
            }
          }
      }
      return 0;
    }
  }
});

// asset-input/node_modules/bson/lib/validate_utf8.js
var require_validate_utf8 = __commonJS({
  "asset-input/node_modules/bson/lib/validate_utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUtf8 = void 0;
    var FIRST_BIT = 128;
    var FIRST_TWO_BITS = 192;
    var FIRST_THREE_BITS = 224;
    var FIRST_FOUR_BITS = 240;
    var FIRST_FIVE_BITS = 248;
    var TWO_BIT_CHAR = 192;
    var THREE_BIT_CHAR = 224;
    var FOUR_BIT_CHAR = 240;
    var CONTINUING_CHAR = 128;
    function validateUtf8(bytes, start, end) {
      var continuation = 0;
      for (var i = start; i < end; i += 1) {
        var byte = bytes[i];
        if (continuation) {
          if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {
            return false;
          }
          continuation -= 1;
        } else if (byte & FIRST_BIT) {
          if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {
            continuation = 1;
          } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {
            continuation = 2;
          } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {
            continuation = 3;
          } else {
            return false;
          }
        }
      }
      return !continuation;
    }
    exports2.validateUtf8 = validateUtf8;
  }
});

// asset-input/node_modules/bson/lib/parser/deserializer.js
var require_deserializer = __commonJS({
  "asset-input/node_modules/bson/lib/parser/deserializer.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = void 0;
    var buffer_1 = require("buffer");
    var binary_1 = require_binary();
    var code_1 = require_code();
    var constants = require_constants();
    var db_ref_1 = require_db_ref();
    var decimal128_1 = require_decimal128();
    var double_1 = require_double();
    var error_1 = require_error2();
    var int_32_1 = require_int_32();
    var long_1 = require_long();
    var max_key_1 = require_max_key();
    var min_key_1 = require_min_key();
    var objectid_1 = require_objectid();
    var regexp_1 = require_regexp();
    var symbol_1 = require_symbol();
    var timestamp_1 = require_timestamp();
    var validate_utf8_1 = require_validate_utf8();
    var JS_INT_MAX_LONG = long_1.Long.fromNumber(constants.JS_INT_MAX);
    var JS_INT_MIN_LONG = long_1.Long.fromNumber(constants.JS_INT_MIN);
    var functionCache = {};
    function deserialize(buffer, options, isArray) {
      options = options == null ? {} : options;
      var index = options && options.index ? options.index : 0;
      var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
      if (size < 5) {
        throw new error_1.BSONError("bson size must be >= 5, is ".concat(size));
      }
      if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {
        throw new error_1.BSONError("buffer length ".concat(buffer.length, " must be >= bson size ").concat(size));
      }
      if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {
        throw new error_1.BSONError("buffer length ".concat(buffer.length, " must === bson size ").concat(size));
      }
      if (size + index > buffer.byteLength) {
        throw new error_1.BSONError("(bson size ".concat(size, " + options.index ").concat(index, " must be <= buffer length ").concat(buffer.byteLength, ")"));
      }
      if (buffer[index + size - 1] !== 0) {
        throw new error_1.BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer, index, options, isArray);
    }
    exports2.deserialize = deserialize;
    var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
    function deserializeObject(buffer, index, options, isArray) {
      if (isArray === void 0) {
        isArray = false;
      }
      var evalFunctions = options["evalFunctions"] == null ? false : options["evalFunctions"];
      var cacheFunctions = options["cacheFunctions"] == null ? false : options["cacheFunctions"];
      var fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
      var raw = options["raw"] == null ? false : options["raw"];
      var bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
      var promoteBuffers = options["promoteBuffers"] == null ? false : options["promoteBuffers"];
      var promoteLongs = options["promoteLongs"] == null ? true : options["promoteLongs"];
      var promoteValues = options["promoteValues"] == null ? true : options["promoteValues"];
      var validation = options.validation == null ? { utf8: true } : options.validation;
      var globalUTFValidation = true;
      var validationSetting;
      var utf8KeysSet = /* @__PURE__ */ new Set();
      var utf8ValidatedKeys = validation.utf8;
      if (typeof utf8ValidatedKeys === "boolean") {
        validationSetting = utf8ValidatedKeys;
      } else {
        globalUTFValidation = false;
        var utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key2) {
          return utf8ValidatedKeys[key2];
        });
        if (utf8ValidationValues.length === 0) {
          throw new error_1.BSONError("UTF-8 validation setting cannot be empty");
        }
        if (typeof utf8ValidationValues[0] !== "boolean") {
          throw new error_1.BSONError("Invalid UTF-8 validation option, must specify boolean values");
        }
        validationSetting = utf8ValidationValues[0];
        if (!utf8ValidationValues.every(function(item) {
          return item === validationSetting;
        })) {
          throw new error_1.BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
        }
      }
      if (!globalUTFValidation) {
        for (var _i = 0, _a = Object.keys(utf8ValidatedKeys); _i < _a.length; _i++) {
          var key = _a[_i];
          utf8KeysSet.add(key);
        }
      }
      var startIndex = index;
      if (buffer.length < 5)
        throw new error_1.BSONError("corrupt bson message < 5 bytes long");
      var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (size < 5 || size > buffer.length)
        throw new error_1.BSONError("corrupt bson message");
      var object = isArray ? [] : {};
      var arrayIndex = 0;
      var done = false;
      var isPossibleDBRef = isArray ? false : null;
      var dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      while (!done) {
        var elementType = buffer[index++];
        if (elementType === 0)
          break;
        var i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.byteLength)
          throw new error_1.BSONError("Bad BSON Document: illegal CString");
        var name = isArray ? arrayIndex++ : buffer.toString("utf8", index, i);
        var shouldValidateKey = true;
        if (globalUTFValidation || utf8KeysSet.has(name)) {
          shouldValidateKey = validationSetting;
        } else {
          shouldValidateKey = !validationSetting;
        }
        if (isPossibleDBRef !== false && name[0] === "$") {
          isPossibleDBRef = allowedDBRefKeys.test(name);
        }
        var value = void 0;
        index = i + 1;
        if (elementType === constants.BSON_DATA_STRING) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {
            throw new error_1.BSONError("bad string length in bson");
          }
          value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
        } else if (elementType === constants.BSON_DATA_OID) {
          var oid = buffer_1.Buffer.alloc(12);
          buffer.copy(oid, 0, index, index + 12);
          value = new objectid_1.ObjectId(oid);
          index = index + 12;
        } else if (elementType === constants.BSON_DATA_INT && promoteValues === false) {
          value = new int_32_1.Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);
        } else if (elementType === constants.BSON_DATA_INT) {
          value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        } else if (elementType === constants.BSON_DATA_NUMBER && promoteValues === false) {
          value = new double_1.Double(dataview.getFloat64(index, true));
          index = index + 8;
        } else if (elementType === constants.BSON_DATA_NUMBER) {
          value = dataview.getFloat64(index, true);
          index = index + 8;
        } else if (elementType === constants.BSON_DATA_DATE) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          value = new Date(new long_1.Long(lowBits, highBits).toNumber());
        } else if (elementType === constants.BSON_DATA_BOOLEAN) {
          if (buffer[index] !== 0 && buffer[index] !== 1)
            throw new error_1.BSONError("illegal boolean type value");
          value = buffer[index++] === 1;
        } else if (elementType === constants.BSON_DATA_OBJECT) {
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer.length - index)
            throw new error_1.BSONError("bad embedded document length in bson");
          if (raw) {
            value = buffer.slice(index, index + objectSize);
          } else {
            var objectOptions = options;
            if (!globalUTFValidation) {
              objectOptions = __assign(__assign({}, options), { validation: { utf8: shouldValidateKey } });
            }
            value = deserializeObject(buffer, _index, objectOptions, false);
          }
          index = index + objectSize;
        } else if (elementType === constants.BSON_DATA_ARRAY) {
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var arrayOptions = options;
          var stopIndex = index + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = {};
            for (var n in options) {
              arrayOptions[n] = options[n];
            }
            arrayOptions["raw"] = true;
          }
          if (!globalUTFValidation) {
            arrayOptions = __assign(__assign({}, arrayOptions), { validation: { utf8: shouldValidateKey } });
          }
          value = deserializeObject(buffer, _index, arrayOptions, true);
          index = index + objectSize;
          if (buffer[index - 1] !== 0)
            throw new error_1.BSONError("invalid array terminator byte");
          if (index !== stopIndex)
            throw new error_1.BSONError("corrupted array bson");
        } else if (elementType === constants.BSON_DATA_UNDEFINED) {
          value = void 0;
        } else if (elementType === constants.BSON_DATA_NULL) {
          value = null;
        } else if (elementType === constants.BSON_DATA_LONG) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var long = new long_1.Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            value = long;
          }
        } else if (elementType === constants.BSON_DATA_DECIMAL128) {
          var bytes = buffer_1.Buffer.alloc(16);
          buffer.copy(bytes, 0, index, index + 16);
          index = index + 16;
          var decimal128 = new decimal128_1.Decimal128(bytes);
          if ("toObject" in decimal128 && typeof decimal128.toObject === "function") {
            value = decimal128.toObject();
          } else {
            value = decimal128;
          }
        } else if (elementType === constants.BSON_DATA_BINARY) {
          var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer[index++];
          if (binarySize < 0)
            throw new error_1.BSONError("Negative binary type element size found");
          if (binarySize > buffer.byteLength)
            throw new error_1.BSONError("Binary type size larger than document size");
          if (buffer["slice"] != null) {
            if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0)
                throw new error_1.BSONError("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new error_1.BSONError("Binary type with subtype 0x02 contains too long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new error_1.BSONError("Binary type with subtype 0x02 contains too short binary size");
            }
            if (promoteBuffers && promoteValues) {
              value = buffer.slice(index, index + binarySize);
            } else {
              value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType);
              if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW) {
                value = value.toUUID();
              }
            }
          } else {
            var _buffer = buffer_1.Buffer.alloc(binarySize);
            if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0)
                throw new error_1.BSONError("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new error_1.BSONError("Binary type with subtype 0x02 contains too long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new error_1.BSONError("Binary type with subtype 0x02 contains too short binary size");
            }
            for (i = 0; i < binarySize; i++) {
              _buffer[i] = buffer[index + i];
            }
            if (promoteBuffers && promoteValues) {
              value = _buffer;
            } else if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW) {
              value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType).toUUID();
            } else {
              value = new binary_1.Binary(buffer.slice(index, index + binarySize), subType);
            }
          }
          index = index + binarySize;
        } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new error_1.BSONError("Bad BSON Document: illegal CString");
          var source = buffer.toString("utf8", index, i);
          index = i + 1;
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new error_1.BSONError("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString("utf8", index, i);
          index = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          value = new RegExp(source, optionsArray.join(""));
        } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new error_1.BSONError("Bad BSON Document: illegal CString");
          var source = buffer.toString("utf8", index, i);
          index = i + 1;
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new error_1.BSONError("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString("utf8", index, i);
          index = i + 1;
          value = new regexp_1.BSONRegExp(source, regExpOptions);
        } else if (elementType === constants.BSON_DATA_SYMBOL) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {
            throw new error_1.BSONError("bad string length in bson");
          }
          var symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);
          value = promoteValues ? symbol : new symbol_1.BSONSymbol(symbol);
          index = index + stringSize;
        } else if (elementType === constants.BSON_DATA_TIMESTAMP) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          value = new timestamp_1.Timestamp(lowBits, highBits);
        } else if (elementType === constants.BSON_DATA_MIN_KEY) {
          value = new min_key_1.MinKey();
        } else if (elementType === constants.BSON_DATA_MAX_KEY) {
          value = new max_key_1.MaxKey();
        } else if (elementType === constants.BSON_DATA_CODE) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {
            throw new error_1.BSONError("bad string length in bson");
          }
          var functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);
          if (evalFunctions) {
            if (cacheFunctions) {
              value = isolateEval(functionString, functionCache, object);
            } else {
              value = isolateEval(functionString);
            }
          } else {
            value = new code_1.Code(functionString);
          }
          index = index + stringSize;
        } else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new error_1.BSONError("code_w_scope total size shorter minimum expected length");
          }
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {
            throw new error_1.BSONError("bad string length in bson");
          }
          var functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var scopeObject = deserializeObject(buffer, _index, options, false);
          index = index + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new error_1.BSONError("code_w_scope total size is too short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new error_1.BSONError("code_w_scope total size is too long, clips outer document");
          }
          if (evalFunctions) {
            if (cacheFunctions) {
              value = isolateEval(functionString, functionCache, object);
            } else {
              value = isolateEval(functionString);
            }
            value.scope = scopeObject;
          } else {
            value = new code_1.Code(functionString, scopeObject);
          }
        } else if (elementType === constants.BSON_DATA_DBPOINTER) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new error_1.BSONError("bad string length in bson");
          if (validation != null && validation.utf8) {
            if (!(0, validate_utf8_1.validateUtf8)(buffer, index, index + stringSize - 1)) {
              throw new error_1.BSONError("Invalid UTF-8 string in BSON document");
            }
          }
          var namespace = buffer.toString("utf8", index, index + stringSize - 1);
          index = index + stringSize;
          var oidBuffer = buffer_1.Buffer.alloc(12);
          buffer.copy(oidBuffer, 0, index, index + 12);
          var oid = new objectid_1.ObjectId(oidBuffer);
          index = index + 12;
          value = new db_ref_1.DBRef(namespace, oid);
        } else {
          throw new error_1.BSONError("Detected unknown BSON type ".concat(elementType.toString(16), ' for fieldname "').concat(name, '"'));
        }
        if (name === "__proto__") {
          Object.defineProperty(object, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          object[name] = value;
        }
      }
      if (size !== index - startIndex) {
        if (isArray)
          throw new error_1.BSONError("corrupt array bson");
        throw new error_1.BSONError("corrupt object bson");
      }
      if (!isPossibleDBRef)
        return object;
      if ((0, db_ref_1.isDBRefLike)(object)) {
        var copy = Object.assign({}, object);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new db_ref_1.DBRef(object.$ref, object.$id, object.$db, copy);
      }
      return object;
    }
    function isolateEval(functionString, functionCache2, object) {
      if (!functionCache2)
        return new Function(functionString);
      if (functionCache2[functionString] == null) {
        functionCache2[functionString] = new Function(functionString);
      }
      return functionCache2[functionString].bind(object);
    }
    function getValidatedString(buffer, start, end, shouldValidateUtf8) {
      var value = buffer.toString("utf8", start, end);
      if (shouldValidateUtf8) {
        for (var i = 0; i < value.length; i++) {
          if (value.charCodeAt(i) === 65533) {
            if (!(0, validate_utf8_1.validateUtf8)(buffer, start, end)) {
              throw new error_1.BSONError("Invalid UTF-8 string in BSON document");
            }
            break;
          }
        }
      }
      return value;
    }
  }
});

// asset-input/node_modules/bson/lib/parser/serializer.js
var require_serializer = __commonJS({
  "asset-input/node_modules/bson/lib/parser/serializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeInto = void 0;
    var binary_1 = require_binary();
    var constants = require_constants();
    var ensure_buffer_1 = require_ensure_buffer();
    var error_1 = require_error2();
    var extended_json_1 = require_extended_json();
    var long_1 = require_long();
    var map_1 = require_map();
    var utils_1 = require_utils();
    var regexp = /\x00/;
    var ignoreKeys = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
    function serializeString(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      var size = buffer.write(value, index + 4, void 0, "utf8");
      buffer[index + 3] = size + 1 >> 24 & 255;
      buffer[index + 2] = size + 1 >> 16 & 255;
      buffer[index + 1] = size + 1 >> 8 & 255;
      buffer[index] = size + 1 & 255;
      index = index + 4 + size;
      buffer[index++] = 0;
      return index;
    }
    var SPACE_FOR_FLOAT64 = new Uint8Array(8);
    var DV_FOR_FLOAT64 = new DataView(SPACE_FOR_FLOAT64.buffer, SPACE_FOR_FLOAT64.byteOffset, SPACE_FOR_FLOAT64.byteLength);
    function serializeNumber(buffer, key, value, index, isArray) {
      if (Number.isInteger(value) && value >= constants.BSON_INT32_MIN && value <= constants.BSON_INT32_MAX) {
        buffer[index++] = constants.BSON_DATA_INT;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        buffer[index++] = value & 255;
        buffer[index++] = value >> 8 & 255;
        buffer[index++] = value >> 16 & 255;
        buffer[index++] = value >> 24 & 255;
      } else {
        buffer[index++] = constants.BSON_DATA_NUMBER;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        DV_FOR_FLOAT64.setFloat64(0, value, true);
        buffer.set(SPACE_FOR_FLOAT64, index);
        index = index + 8;
      }
      return index;
    }
    function serializeNull(buffer, key, _, index, isArray) {
      buffer[index++] = constants.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    }
    function serializeBoolean(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value ? 1 : 0;
      return index;
    }
    function serializeDate(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var dateInMilis = long_1.Long.fromNumber(value.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer[index++] = lowBits & 255;
      buffer[index++] = lowBits >> 8 & 255;
      buffer[index++] = lowBits >> 16 & 255;
      buffer[index++] = lowBits >> 24 & 255;
      buffer[index++] = highBits & 255;
      buffer[index++] = highBits >> 8 & 255;
      buffer[index++] = highBits >> 16 & 255;
      buffer[index++] = highBits >> 24 & 255;
      return index;
    }
    function serializeRegExp(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw Error("value " + value.source + " must not contain null bytes");
      }
      index = index + buffer.write(value.source, index, void 0, "utf8");
      buffer[index++] = 0;
      if (value.ignoreCase)
        buffer[index++] = 105;
      if (value.global)
        buffer[index++] = 115;
      if (value.multiline)
        buffer[index++] = 109;
      buffer[index++] = 0;
      return index;
    }
    function serializeBSONRegExp(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw Error("pattern " + value.pattern + " must not contain null bytes");
      }
      index = index + buffer.write(value.pattern, index, void 0, "utf8");
      buffer[index++] = 0;
      index = index + buffer.write(value.options.split("").sort().join(""), index, void 0, "utf8");
      buffer[index++] = 0;
      return index;
    }
    function serializeMinMax(buffer, key, value, index, isArray) {
      if (value === null) {
        buffer[index++] = constants.BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer[index++] = constants.BSON_DATA_MIN_KEY;
      } else {
        buffer[index++] = constants.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    }
    function serializeObjectId(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (typeof value.id === "string") {
        buffer.write(value.id, index, void 0, "binary");
      } else if ((0, utils_1.isUint8Array)(value.id)) {
        buffer.set(value.id.subarray(0, 12), index);
      } else {
        throw new error_1.BSONTypeError("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
      }
      return index + 12;
    }
    function serializeBuffer(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = value.length;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
      buffer[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT;
      buffer.set((0, ensure_buffer_1.ensureBuffer)(value), index);
      index = index + size;
      return index;
    }
    function serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
      if (checkKeys === void 0) {
        checkKeys = false;
      }
      if (depth === void 0) {
        depth = 0;
      }
      if (serializeFunctions === void 0) {
        serializeFunctions = false;
      }
      if (ignoreUndefined === void 0) {
        ignoreUndefined = true;
      }
      if (isArray === void 0) {
        isArray = false;
      }
      if (path === void 0) {
        path = [];
      }
      for (var i = 0; i < path.length; i++) {
        if (path[i] === value)
          throw new error_1.BSONError("cyclic dependency detected");
      }
      path.push(value);
      buffer[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      path.pop();
      return endIndex;
    }
    function serializeDecimal128(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer.set(value.bytes.subarray(0, 16), index);
      return index + 16;
    }
    function serializeLong(buffer, key, value, index, isArray) {
      buffer[index++] = value._bsontype === "Long" ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var lowBits = value.getLowBits();
      var highBits = value.getHighBits();
      buffer[index++] = lowBits & 255;
      buffer[index++] = lowBits >> 8 & 255;
      buffer[index++] = lowBits >> 16 & 255;
      buffer[index++] = lowBits >> 24 & 255;
      buffer[index++] = highBits & 255;
      buffer[index++] = highBits >> 8 & 255;
      buffer[index++] = highBits >> 16 & 255;
      buffer[index++] = highBits >> 24 & 255;
      return index;
    }
    function serializeInt32(buffer, key, value, index, isArray) {
      value = value.valueOf();
      buffer[index++] = constants.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value & 255;
      buffer[index++] = value >> 8 & 255;
      buffer[index++] = value >> 16 & 255;
      buffer[index++] = value >> 24 & 255;
      return index;
    }
    function serializeDouble(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      DV_FOR_FLOAT64.setFloat64(0, value.value, true);
      buffer.set(SPACE_FOR_FLOAT64, index);
      index = index + 8;
      return index;
    }
    function serializeFunction(buffer, key, value, index, _checkKeys, _depth, isArray) {
      if (_checkKeys === void 0) {
        _checkKeys = false;
      }
      if (_depth === void 0) {
        _depth = 0;
      }
      buffer[index++] = constants.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var functionString = (0, utils_1.normalizedFunctionString)(value);
      var size = buffer.write(functionString, index + 4, void 0, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
      return index;
    }
    function serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
      if (checkKeys === void 0) {
        checkKeys = false;
      }
      if (depth === void 0) {
        depth = 0;
      }
      if (serializeFunctions === void 0) {
        serializeFunctions = false;
      }
      if (ignoreUndefined === void 0) {
        ignoreUndefined = true;
      }
      if (isArray === void 0) {
        isArray = false;
      }
      if (value.scope && typeof value.scope === "object") {
        buffer[index++] = constants.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var startIndex = index;
        var functionString = typeof value.code === "string" ? value.code : value.code.toString();
        index = index + 4;
        var codeSize = buffer.write(functionString, index + 4, void 0, "utf8") + 1;
        buffer[index] = codeSize & 255;
        buffer[index + 1] = codeSize >> 8 & 255;
        buffer[index + 2] = codeSize >> 16 & 255;
        buffer[index + 3] = codeSize >> 24 & 255;
        buffer[index + 4 + codeSize - 1] = 0;
        index = index + codeSize + 4;
        var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
        index = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer[startIndex++] = totalSize & 255;
        buffer[startIndex++] = totalSize >> 8 & 255;
        buffer[startIndex++] = totalSize >> 16 & 255;
        buffer[startIndex++] = totalSize >> 24 & 255;
        buffer[index++] = 0;
      } else {
        buffer[index++] = constants.BSON_DATA_CODE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var functionString = value.code.toString();
        var size = buffer.write(functionString, index + 4, void 0, "utf8") + 1;
        buffer[index] = size & 255;
        buffer[index + 1] = size >> 8 & 255;
        buffer[index + 2] = size >> 16 & 255;
        buffer[index + 3] = size >> 24 & 255;
        index = index + 4 + size - 1;
        buffer[index++] = 0;
      }
      return index;
    }
    function serializeBinary(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var data = value.value(true);
      var size = value.position;
      if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
      buffer[index++] = value.sub_type;
      if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer[index++] = size & 255;
        buffer[index++] = size >> 8 & 255;
        buffer[index++] = size >> 16 & 255;
        buffer[index++] = size >> 24 & 255;
      }
      buffer.set(data, index);
      index = index + value.position;
      return index;
    }
    function serializeSymbol(buffer, key, value, index, isArray) {
      buffer[index++] = constants.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = buffer.write(value.value, index + 4, void 0, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
      return index;
    }
    function serializeDBRef(buffer, key, value, index, depth, serializeFunctions, isArray) {
      buffer[index++] = constants.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, void 0, "utf8") : buffer.write(key, index, void 0, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var startIndex = index;
      var output = {
        $ref: value.collection || value.namespace,
        $id: value.oid
      };
      if (value.db != null) {
        output.$db = value.db;
      }
      output = Object.assign(output, value.fields);
      var endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions);
      var size = endIndex - startIndex;
      buffer[startIndex++] = size & 255;
      buffer[startIndex++] = size >> 8 & 255;
      buffer[startIndex++] = size >> 16 & 255;
      buffer[startIndex++] = size >> 24 & 255;
      return endIndex;
    }
    function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
      if (checkKeys === void 0) {
        checkKeys = false;
      }
      if (startingIndex === void 0) {
        startingIndex = 0;
      }
      if (depth === void 0) {
        depth = 0;
      }
      if (serializeFunctions === void 0) {
        serializeFunctions = false;
      }
      if (ignoreUndefined === void 0) {
        ignoreUndefined = true;
      }
      if (path === void 0) {
        path = [];
      }
      startingIndex = startingIndex || 0;
      path = path || [];
      path.push(object);
      var index = startingIndex + 4;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          var key = "".concat(i);
          var value = object[i];
          if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === "function") {
            value = value.toBSON();
          }
          if (typeof value === "string") {
            index = serializeString(buffer, key, value, index, true);
          } else if (typeof value === "number") {
            index = serializeNumber(buffer, key, value, index, true);
          } else if (typeof value === "bigint") {
            throw new error_1.BSONTypeError("Unsupported type BigInt, please use Decimal128");
          } else if (typeof value === "boolean") {
            index = serializeBoolean(buffer, key, value, index, true);
          } else if (value instanceof Date || (0, utils_1.isDate)(value)) {
            index = serializeDate(buffer, key, value, index, true);
          } else if (value === void 0) {
            index = serializeNull(buffer, key, value, index, true);
          } else if (value === null) {
            index = serializeNull(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
            index = serializeObjectId(buffer, key, value, index, true);
          } else if ((0, utils_1.isUint8Array)(value)) {
            index = serializeBuffer(buffer, key, value, index, true);
          } else if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {
            index = serializeRegExp(buffer, key, value, index, true);
          } else if (typeof value === "object" && value["_bsontype"] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
          } else if (typeof value === "object" && (0, extended_json_1.isBSONType)(value) && value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value, index, true);
          } else if (typeof value === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, true);
          } else if (value["_bsontype"] === "Code") {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
          } else if (value["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value, index, true);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new error_1.BSONTypeError("Unrecognized or invalid _bsontype: ".concat(String(value["_bsontype"])));
          }
        }
      } else if (object instanceof map_1.Map || (0, utils_1.isMap)(object)) {
        var iterator = object.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = !!entry.done;
          if (done)
            continue;
          var key = entry.value[0];
          var value = entry.value[1];
          var type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index = serializeString(buffer, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value, index);
          } else if (type === "bigint" || (0, utils_1.isBigInt64Array)(value) || (0, utils_1.isBigUInt64Array)(value)) {
            throw new error_1.BSONTypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value, index);
          } else if (value instanceof Date || (0, utils_1.isDate)(value)) {
            index = serializeDate(buffer, key, value, index);
          } else if (value === null || value === void 0 && ignoreUndefined === false) {
            index = serializeNull(buffer, key, value, index);
          } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
            index = serializeObjectId(buffer, key, value, index);
          } else if ((0, utils_1.isUint8Array)(value)) {
            index = serializeBuffer(buffer, key, value, index);
          } else if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {
            index = serializeRegExp(buffer, key, value, index);
          } else if (type === "object" && value["_bsontype"] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value, index);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value, index);
          } else if (value["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value, index);
          } else if (value["_bsontype"] === "Code") {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value, index);
          } else if (value["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value, index);
          } else if (value["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value, index);
          } else if (value["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value, index);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value, index);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new error_1.BSONTypeError("Unrecognized or invalid _bsontype: ".concat(String(value["_bsontype"])));
          }
        }
      } else {
        if (typeof (object === null || object === void 0 ? void 0 : object.toBSON) === "function") {
          object = object.toBSON();
          if (object != null && typeof object !== "object") {
            throw new error_1.BSONTypeError("toBSON function did not return an object");
          }
        }
        for (var key in object) {
          var value = object[key];
          if (typeof (value === null || value === void 0 ? void 0 : value.toBSON) === "function") {
            value = value.toBSON();
          }
          var type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index = serializeString(buffer, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value, index);
          } else if (type === "bigint") {
            throw new error_1.BSONTypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value, index);
          } else if (value instanceof Date || (0, utils_1.isDate)(value)) {
            index = serializeDate(buffer, key, value, index);
          } else if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer, key, value, index);
          } else if (value["_bsontype"] === "ObjectId" || value["_bsontype"] === "ObjectID") {
            index = serializeObjectId(buffer, key, value, index);
          } else if ((0, utils_1.isUint8Array)(value)) {
            index = serializeBuffer(buffer, key, value, index);
          } else if (value instanceof RegExp || (0, utils_1.isRegExp)(value)) {
            index = serializeRegExp(buffer, key, value, index);
          } else if (type === "object" && value["_bsontype"] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value, index);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value, index);
          } else if (value["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value, index);
          } else if (value["_bsontype"] === "Code") {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value, index);
          } else if (value["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value, index);
          } else if (value["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value, index);
          } else if (value["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value, index);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value, index);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new error_1.BSONTypeError("Unrecognized or invalid _bsontype: ".concat(String(value["_bsontype"])));
          }
        }
      }
      path.pop();
      buffer[index++] = 0;
      var size = index - startingIndex;
      buffer[startingIndex++] = size & 255;
      buffer[startingIndex++] = size >> 8 & 255;
      buffer[startingIndex++] = size >> 16 & 255;
      buffer[startingIndex++] = size >> 24 & 255;
      return index;
    }
    exports2.serializeInto = serializeInto;
  }
});

// asset-input/node_modules/bson/lib/bson.js
var require_bson = __commonJS({
  "asset-input/node_modules/bson/lib/bson.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BSONRegExp = exports2.MaxKey = exports2.MinKey = exports2.Int32 = exports2.Double = exports2.Timestamp = exports2.Long = exports2.UUID = exports2.ObjectId = exports2.Binary = exports2.DBRef = exports2.BSONSymbol = exports2.Map = exports2.Code = exports2.LongWithoutOverridesClass = exports2.EJSON = exports2.BSON_INT64_MIN = exports2.BSON_INT64_MAX = exports2.BSON_INT32_MIN = exports2.BSON_INT32_MAX = exports2.BSON_DATA_UNDEFINED = exports2.BSON_DATA_TIMESTAMP = exports2.BSON_DATA_SYMBOL = exports2.BSON_DATA_STRING = exports2.BSON_DATA_REGEXP = exports2.BSON_DATA_OID = exports2.BSON_DATA_OBJECT = exports2.BSON_DATA_NUMBER = exports2.BSON_DATA_NULL = exports2.BSON_DATA_MIN_KEY = exports2.BSON_DATA_MAX_KEY = exports2.BSON_DATA_LONG = exports2.BSON_DATA_INT = exports2.BSON_DATA_DECIMAL128 = exports2.BSON_DATA_DBPOINTER = exports2.BSON_DATA_DATE = exports2.BSON_DATA_CODE_W_SCOPE = exports2.BSON_DATA_CODE = exports2.BSON_DATA_BOOLEAN = exports2.BSON_DATA_BINARY = exports2.BSON_DATA_ARRAY = exports2.BSON_BINARY_SUBTYPE_COLUMN = exports2.BSON_BINARY_SUBTYPE_ENCRYPTED = exports2.BSON_BINARY_SUBTYPE_UUID_NEW = exports2.BSON_BINARY_SUBTYPE_UUID = exports2.BSON_BINARY_SUBTYPE_USER_DEFINED = exports2.BSON_BINARY_SUBTYPE_MD5 = exports2.BSON_BINARY_SUBTYPE_FUNCTION = exports2.BSON_BINARY_SUBTYPE_DEFAULT = exports2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = void 0;
    exports2.deserializeStream = exports2.calculateObjectSize = exports2.deserialize = exports2.serializeWithBufferAndIndex = exports2.serialize = exports2.setInternalBufferSize = exports2.BSONTypeError = exports2.BSONError = exports2.ObjectID = exports2.Decimal128 = void 0;
    var buffer_1 = require("buffer");
    var binary_1 = require_binary();
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return binary_1.Binary;
    } });
    Object.defineProperty(exports2, "UUID", { enumerable: true, get: function() {
      return binary_1.UUID;
    } });
    var code_1 = require_code();
    Object.defineProperty(exports2, "Code", { enumerable: true, get: function() {
      return code_1.Code;
    } });
    var db_ref_1 = require_db_ref();
    Object.defineProperty(exports2, "DBRef", { enumerable: true, get: function() {
      return db_ref_1.DBRef;
    } });
    var decimal128_1 = require_decimal128();
    Object.defineProperty(exports2, "Decimal128", { enumerable: true, get: function() {
      return decimal128_1.Decimal128;
    } });
    var double_1 = require_double();
    Object.defineProperty(exports2, "Double", { enumerable: true, get: function() {
      return double_1.Double;
    } });
    var ensure_buffer_1 = require_ensure_buffer();
    var extended_json_1 = require_extended_json();
    var int_32_1 = require_int_32();
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return int_32_1.Int32;
    } });
    var long_1 = require_long();
    Object.defineProperty(exports2, "Long", { enumerable: true, get: function() {
      return long_1.Long;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports2, "Map", { enumerable: true, get: function() {
      return map_1.Map;
    } });
    var max_key_1 = require_max_key();
    Object.defineProperty(exports2, "MaxKey", { enumerable: true, get: function() {
      return max_key_1.MaxKey;
    } });
    var min_key_1 = require_min_key();
    Object.defineProperty(exports2, "MinKey", { enumerable: true, get: function() {
      return min_key_1.MinKey;
    } });
    var objectid_1 = require_objectid();
    Object.defineProperty(exports2, "ObjectId", { enumerable: true, get: function() {
      return objectid_1.ObjectId;
    } });
    Object.defineProperty(exports2, "ObjectID", { enumerable: true, get: function() {
      return objectid_1.ObjectId;
    } });
    var error_1 = require_error2();
    var calculate_size_1 = require_calculate_size();
    var deserializer_1 = require_deserializer();
    var serializer_1 = require_serializer();
    var regexp_1 = require_regexp();
    Object.defineProperty(exports2, "BSONRegExp", { enumerable: true, get: function() {
      return regexp_1.BSONRegExp;
    } });
    var symbol_1 = require_symbol();
    Object.defineProperty(exports2, "BSONSymbol", { enumerable: true, get: function() {
      return symbol_1.BSONSymbol;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return timestamp_1.Timestamp;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_BYTE_ARRAY", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_BYTE_ARRAY;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_DEFAULT", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_DEFAULT;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_FUNCTION", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_FUNCTION;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_MD5", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_MD5;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_USER_DEFINED", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_USER_DEFINED;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_UUID", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_UUID;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_UUID_NEW", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_UUID_NEW;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_ENCRYPTED", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_ENCRYPTED;
    } });
    Object.defineProperty(exports2, "BSON_BINARY_SUBTYPE_COLUMN", { enumerable: true, get: function() {
      return constants_1.BSON_BINARY_SUBTYPE_COLUMN;
    } });
    Object.defineProperty(exports2, "BSON_DATA_ARRAY", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_ARRAY;
    } });
    Object.defineProperty(exports2, "BSON_DATA_BINARY", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_BINARY;
    } });
    Object.defineProperty(exports2, "BSON_DATA_BOOLEAN", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_BOOLEAN;
    } });
    Object.defineProperty(exports2, "BSON_DATA_CODE", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_CODE;
    } });
    Object.defineProperty(exports2, "BSON_DATA_CODE_W_SCOPE", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_CODE_W_SCOPE;
    } });
    Object.defineProperty(exports2, "BSON_DATA_DATE", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_DATE;
    } });
    Object.defineProperty(exports2, "BSON_DATA_DBPOINTER", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_DBPOINTER;
    } });
    Object.defineProperty(exports2, "BSON_DATA_DECIMAL128", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_DECIMAL128;
    } });
    Object.defineProperty(exports2, "BSON_DATA_INT", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_INT;
    } });
    Object.defineProperty(exports2, "BSON_DATA_LONG", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_LONG;
    } });
    Object.defineProperty(exports2, "BSON_DATA_MAX_KEY", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_MAX_KEY;
    } });
    Object.defineProperty(exports2, "BSON_DATA_MIN_KEY", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_MIN_KEY;
    } });
    Object.defineProperty(exports2, "BSON_DATA_NULL", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_NULL;
    } });
    Object.defineProperty(exports2, "BSON_DATA_NUMBER", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_NUMBER;
    } });
    Object.defineProperty(exports2, "BSON_DATA_OBJECT", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_OBJECT;
    } });
    Object.defineProperty(exports2, "BSON_DATA_OID", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_OID;
    } });
    Object.defineProperty(exports2, "BSON_DATA_REGEXP", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_REGEXP;
    } });
    Object.defineProperty(exports2, "BSON_DATA_STRING", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_STRING;
    } });
    Object.defineProperty(exports2, "BSON_DATA_SYMBOL", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_SYMBOL;
    } });
    Object.defineProperty(exports2, "BSON_DATA_TIMESTAMP", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_TIMESTAMP;
    } });
    Object.defineProperty(exports2, "BSON_DATA_UNDEFINED", { enumerable: true, get: function() {
      return constants_1.BSON_DATA_UNDEFINED;
    } });
    Object.defineProperty(exports2, "BSON_INT32_MAX", { enumerable: true, get: function() {
      return constants_1.BSON_INT32_MAX;
    } });
    Object.defineProperty(exports2, "BSON_INT32_MIN", { enumerable: true, get: function() {
      return constants_1.BSON_INT32_MIN;
    } });
    Object.defineProperty(exports2, "BSON_INT64_MAX", { enumerable: true, get: function() {
      return constants_1.BSON_INT64_MAX;
    } });
    Object.defineProperty(exports2, "BSON_INT64_MIN", { enumerable: true, get: function() {
      return constants_1.BSON_INT64_MIN;
    } });
    var extended_json_2 = require_extended_json();
    Object.defineProperty(exports2, "EJSON", { enumerable: true, get: function() {
      return extended_json_2.EJSON;
    } });
    var timestamp_2 = require_timestamp();
    Object.defineProperty(exports2, "LongWithoutOverridesClass", { enumerable: true, get: function() {
      return timestamp_2.LongWithoutOverridesClass;
    } });
    var error_2 = require_error2();
    Object.defineProperty(exports2, "BSONError", { enumerable: true, get: function() {
      return error_2.BSONError;
    } });
    Object.defineProperty(exports2, "BSONTypeError", { enumerable: true, get: function() {
      return error_2.BSONTypeError;
    } });
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = buffer_1.Buffer.alloc(MAXSIZE);
    function setInternalBufferSize(size) {
      if (buffer.length < size) {
        buffer = buffer_1.Buffer.alloc(size);
      }
    }
    exports2.setInternalBufferSize = setInternalBufferSize;
    function serialize(object, options) {
      if (options === void 0) {
        options = {};
      }
      var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      var minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = buffer_1.Buffer.alloc(minInternalBufferSize);
      }
      var serializationIndex = (0, serializer_1.serializeInto)(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
      var finishedBuffer = buffer_1.Buffer.alloc(serializationIndex);
      buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    }
    exports2.serialize = serialize;
    function serializeWithBufferAndIndex(object, finalBuffer, options) {
      if (options === void 0) {
        options = {};
      }
      var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      var startIndex = typeof options.index === "number" ? options.index : 0;
      var serializationIndex = (0, serializer_1.serializeInto)(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined);
      buffer.copy(finalBuffer, startIndex, 0, serializationIndex);
      return startIndex + serializationIndex - 1;
    }
    exports2.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
    function deserialize(buffer2, options) {
      if (options === void 0) {
        options = {};
      }
      return (0, deserializer_1.deserialize)(buffer2 instanceof buffer_1.Buffer ? buffer2 : (0, ensure_buffer_1.ensureBuffer)(buffer2), options);
    }
    exports2.deserialize = deserialize;
    function calculateObjectSize(object, options) {
      if (options === void 0) {
        options = {};
      }
      options = options || {};
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      return (0, calculate_size_1.calculateObjectSize)(object, serializeFunctions, ignoreUndefined);
    }
    exports2.calculateObjectSize = calculateObjectSize;
    function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
      var internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
      var bufferData = (0, ensure_buffer_1.ensureBuffer)(data);
      var index = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;
        internalOptions.index = index;
        documents[docStartIndex + i] = (0, deserializer_1.deserialize)(bufferData, internalOptions);
        index = index + size;
      }
      return index;
    }
    exports2.deserializeStream = deserializeStream;
    var BSON = {
      Binary: binary_1.Binary,
      Code: code_1.Code,
      DBRef: db_ref_1.DBRef,
      Decimal128: decimal128_1.Decimal128,
      Double: double_1.Double,
      Int32: int_32_1.Int32,
      Long: long_1.Long,
      UUID: binary_1.UUID,
      Map: map_1.Map,
      MaxKey: max_key_1.MaxKey,
      MinKey: min_key_1.MinKey,
      ObjectId: objectid_1.ObjectId,
      ObjectID: objectid_1.ObjectId,
      BSONRegExp: regexp_1.BSONRegExp,
      BSONSymbol: symbol_1.BSONSymbol,
      Timestamp: timestamp_1.Timestamp,
      EJSON: extended_json_1.EJSON,
      setInternalBufferSize,
      serialize,
      serializeWithBufferAndIndex,
      deserialize,
      calculateObjectSize,
      deserializeStream,
      BSONError: error_1.BSONError,
      BSONTypeError: error_1.BSONTypeError
    };
    exports2.default = BSON;
  }
});

// asset-input/node_modules/mongodb/lib/bson.js
var require_bson2 = __commonJS({
  "asset-input/node_modules/mongodb/lib/bson.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveBSONOptions = exports2.pluckBSONSerializeOptions = exports2.BSON = exports2.Timestamp = exports2.ObjectId = exports2.MinKey = exports2.MaxKey = exports2.Map = exports2.Long = exports2.Int32 = exports2.Double = exports2.Decimal128 = exports2.DBRef = exports2.Code = exports2.BSONSymbol = exports2.BSONRegExp = exports2.Binary = exports2.calculateObjectSize = exports2.serialize = exports2.deserialize = void 0;
    var BSON = require_bson();
    exports2.BSON = BSON;
    try {
      exports2.BSON = BSON = require("bson-ext");
    } catch {
    }
    exports2.deserialize = BSON.deserialize;
    exports2.serialize = BSON.serialize;
    exports2.calculateObjectSize = BSON.calculateObjectSize;
    var bson_1 = require_bson();
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return bson_1.Binary;
    } });
    Object.defineProperty(exports2, "BSONRegExp", { enumerable: true, get: function() {
      return bson_1.BSONRegExp;
    } });
    Object.defineProperty(exports2, "BSONSymbol", { enumerable: true, get: function() {
      return bson_1.BSONSymbol;
    } });
    Object.defineProperty(exports2, "Code", { enumerable: true, get: function() {
      return bson_1.Code;
    } });
    Object.defineProperty(exports2, "DBRef", { enumerable: true, get: function() {
      return bson_1.DBRef;
    } });
    Object.defineProperty(exports2, "Decimal128", { enumerable: true, get: function() {
      return bson_1.Decimal128;
    } });
    Object.defineProperty(exports2, "Double", { enumerable: true, get: function() {
      return bson_1.Double;
    } });
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return bson_1.Int32;
    } });
    Object.defineProperty(exports2, "Long", { enumerable: true, get: function() {
      return bson_1.Long;
    } });
    Object.defineProperty(exports2, "Map", { enumerable: true, get: function() {
      return bson_1.Map;
    } });
    Object.defineProperty(exports2, "MaxKey", { enumerable: true, get: function() {
      return bson_1.MaxKey;
    } });
    Object.defineProperty(exports2, "MinKey", { enumerable: true, get: function() {
      return bson_1.MinKey;
    } });
    Object.defineProperty(exports2, "ObjectId", { enumerable: true, get: function() {
      return bson_1.ObjectId;
    } });
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return bson_1.Timestamp;
    } });
    function pluckBSONSerializeOptions(options) {
      const { fieldsAsRaw, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw, enableUtf8Validation } = options;
      return {
        fieldsAsRaw,
        promoteValues,
        promoteBuffers,
        promoteLongs,
        serializeFunctions,
        ignoreUndefined,
        bsonRegExp,
        raw,
        enableUtf8Validation
      };
    }
    exports2.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
    function resolveBSONOptions(options, parent) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
      const parentOptions = parent === null || parent === void 0 ? void 0 : parent.bsonOptions;
      return {
        raw: (_b = (_a = options === null || options === void 0 ? void 0 : options.raw) !== null && _a !== void 0 ? _a : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.raw) !== null && _b !== void 0 ? _b : false,
        promoteLongs: (_d = (_c = options === null || options === void 0 ? void 0 : options.promoteLongs) !== null && _c !== void 0 ? _c : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteLongs) !== null && _d !== void 0 ? _d : true,
        promoteValues: (_f = (_e = options === null || options === void 0 ? void 0 : options.promoteValues) !== null && _e !== void 0 ? _e : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteValues) !== null && _f !== void 0 ? _f : true,
        promoteBuffers: (_h = (_g = options === null || options === void 0 ? void 0 : options.promoteBuffers) !== null && _g !== void 0 ? _g : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.promoteBuffers) !== null && _h !== void 0 ? _h : false,
        ignoreUndefined: (_k = (_j = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _j !== void 0 ? _j : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.ignoreUndefined) !== null && _k !== void 0 ? _k : false,
        bsonRegExp: (_m = (_l = options === null || options === void 0 ? void 0 : options.bsonRegExp) !== null && _l !== void 0 ? _l : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.bsonRegExp) !== null && _m !== void 0 ? _m : false,
        serializeFunctions: (_p = (_o = options === null || options === void 0 ? void 0 : options.serializeFunctions) !== null && _o !== void 0 ? _o : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.serializeFunctions) !== null && _p !== void 0 ? _p : false,
        fieldsAsRaw: (_r = (_q = options === null || options === void 0 ? void 0 : options.fieldsAsRaw) !== null && _q !== void 0 ? _q : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.fieldsAsRaw) !== null && _r !== void 0 ? _r : {},
        enableUtf8Validation: (_t = (_s = options === null || options === void 0 ? void 0 : options.enableUtf8Validation) !== null && _s !== void 0 ? _s : parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.enableUtf8Validation) !== null && _t !== void 0 ? _t : true
      };
    }
    exports2.resolveBSONOptions = resolveBSONOptions;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/wire_protocol/constants.js
var require_constants2 = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/wire_protocol/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OP_MSG = exports2.OP_COMPRESSED = exports2.OP_DELETE = exports2.OP_QUERY = exports2.OP_INSERT = exports2.OP_UPDATE = exports2.OP_REPLY = exports2.MIN_SUPPORTED_QE_SERVER_VERSION = exports2.MIN_SUPPORTED_QE_WIRE_VERSION = exports2.MAX_SUPPORTED_WIRE_VERSION = exports2.MIN_SUPPORTED_WIRE_VERSION = exports2.MAX_SUPPORTED_SERVER_VERSION = exports2.MIN_SUPPORTED_SERVER_VERSION = void 0;
    exports2.MIN_SUPPORTED_SERVER_VERSION = "3.6";
    exports2.MAX_SUPPORTED_SERVER_VERSION = "6.0";
    exports2.MIN_SUPPORTED_WIRE_VERSION = 6;
    exports2.MAX_SUPPORTED_WIRE_VERSION = 17;
    exports2.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
    exports2.MIN_SUPPORTED_QE_SERVER_VERSION = "7.0";
    exports2.OP_REPLY = 1;
    exports2.OP_UPDATE = 2001;
    exports2.OP_INSERT = 2002;
    exports2.OP_QUERY = 2004;
    exports2.OP_DELETE = 2006;
    exports2.OP_COMPRESSED = 2012;
    exports2.OP_MSG = 2013;
  }
});

// asset-input/node_modules/mongodb/lib/constants.js
var require_constants3 = __commonJS({
  "asset-input/node_modules/mongodb/lib/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TOPOLOGY_EVENTS = exports2.CMAP_EVENTS = exports2.HEARTBEAT_EVENTS = exports2.RESUME_TOKEN_CHANGED = exports2.END = exports2.CHANGE = exports2.INIT = exports2.MORE = exports2.RESPONSE = exports2.SERVER_HEARTBEAT_FAILED = exports2.SERVER_HEARTBEAT_SUCCEEDED = exports2.SERVER_HEARTBEAT_STARTED = exports2.COMMAND_FAILED = exports2.COMMAND_SUCCEEDED = exports2.COMMAND_STARTED = exports2.CLUSTER_TIME_RECEIVED = exports2.CONNECTION_CHECKED_IN = exports2.CONNECTION_CHECKED_OUT = exports2.CONNECTION_CHECK_OUT_FAILED = exports2.CONNECTION_CHECK_OUT_STARTED = exports2.CONNECTION_CLOSED = exports2.CONNECTION_READY = exports2.CONNECTION_CREATED = exports2.CONNECTION_POOL_READY = exports2.CONNECTION_POOL_CLEARED = exports2.CONNECTION_POOL_CLOSED = exports2.CONNECTION_POOL_CREATED = exports2.TOPOLOGY_DESCRIPTION_CHANGED = exports2.TOPOLOGY_CLOSED = exports2.TOPOLOGY_OPENING = exports2.SERVER_DESCRIPTION_CHANGED = exports2.SERVER_CLOSED = exports2.SERVER_OPENING = exports2.DESCRIPTION_RECEIVED = exports2.UNPINNED = exports2.PINNED = exports2.MESSAGE = exports2.ENDED = exports2.CLOSED = exports2.CONNECT = exports2.OPEN = exports2.CLOSE = exports2.TIMEOUT = exports2.ERROR = exports2.SYSTEM_JS_COLLECTION = exports2.SYSTEM_COMMAND_COLLECTION = exports2.SYSTEM_USER_COLLECTION = exports2.SYSTEM_PROFILE_COLLECTION = exports2.SYSTEM_INDEX_COLLECTION = exports2.SYSTEM_NAMESPACE_COLLECTION = void 0;
    exports2.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports2.LEGACY_HELLO_COMMAND = exports2.MONGO_CLIENT_EVENTS = exports2.LOCAL_SERVER_EVENTS = exports2.SERVER_RELAY_EVENTS = exports2.APM_EVENTS = void 0;
    exports2.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
    exports2.SYSTEM_INDEX_COLLECTION = "system.indexes";
    exports2.SYSTEM_PROFILE_COLLECTION = "system.profile";
    exports2.SYSTEM_USER_COLLECTION = "system.users";
    exports2.SYSTEM_COMMAND_COLLECTION = "$cmd";
    exports2.SYSTEM_JS_COLLECTION = "system.js";
    exports2.ERROR = "error";
    exports2.TIMEOUT = "timeout";
    exports2.CLOSE = "close";
    exports2.OPEN = "open";
    exports2.CONNECT = "connect";
    exports2.CLOSED = "closed";
    exports2.ENDED = "ended";
    exports2.MESSAGE = "message";
    exports2.PINNED = "pinned";
    exports2.UNPINNED = "unpinned";
    exports2.DESCRIPTION_RECEIVED = "descriptionReceived";
    exports2.SERVER_OPENING = "serverOpening";
    exports2.SERVER_CLOSED = "serverClosed";
    exports2.SERVER_DESCRIPTION_CHANGED = "serverDescriptionChanged";
    exports2.TOPOLOGY_OPENING = "topologyOpening";
    exports2.TOPOLOGY_CLOSED = "topologyClosed";
    exports2.TOPOLOGY_DESCRIPTION_CHANGED = "topologyDescriptionChanged";
    exports2.CONNECTION_POOL_CREATED = "connectionPoolCreated";
    exports2.CONNECTION_POOL_CLOSED = "connectionPoolClosed";
    exports2.CONNECTION_POOL_CLEARED = "connectionPoolCleared";
    exports2.CONNECTION_POOL_READY = "connectionPoolReady";
    exports2.CONNECTION_CREATED = "connectionCreated";
    exports2.CONNECTION_READY = "connectionReady";
    exports2.CONNECTION_CLOSED = "connectionClosed";
    exports2.CONNECTION_CHECK_OUT_STARTED = "connectionCheckOutStarted";
    exports2.CONNECTION_CHECK_OUT_FAILED = "connectionCheckOutFailed";
    exports2.CONNECTION_CHECKED_OUT = "connectionCheckedOut";
    exports2.CONNECTION_CHECKED_IN = "connectionCheckedIn";
    exports2.CLUSTER_TIME_RECEIVED = "clusterTimeReceived";
    exports2.COMMAND_STARTED = "commandStarted";
    exports2.COMMAND_SUCCEEDED = "commandSucceeded";
    exports2.COMMAND_FAILED = "commandFailed";
    exports2.SERVER_HEARTBEAT_STARTED = "serverHeartbeatStarted";
    exports2.SERVER_HEARTBEAT_SUCCEEDED = "serverHeartbeatSucceeded";
    exports2.SERVER_HEARTBEAT_FAILED = "serverHeartbeatFailed";
    exports2.RESPONSE = "response";
    exports2.MORE = "more";
    exports2.INIT = "init";
    exports2.CHANGE = "change";
    exports2.END = "end";
    exports2.RESUME_TOKEN_CHANGED = "resumeTokenChanged";
    exports2.HEARTBEAT_EVENTS = Object.freeze([
      exports2.SERVER_HEARTBEAT_STARTED,
      exports2.SERVER_HEARTBEAT_SUCCEEDED,
      exports2.SERVER_HEARTBEAT_FAILED
    ]);
    exports2.CMAP_EVENTS = Object.freeze([
      exports2.CONNECTION_POOL_CREATED,
      exports2.CONNECTION_POOL_READY,
      exports2.CONNECTION_POOL_CLEARED,
      exports2.CONNECTION_POOL_CLOSED,
      exports2.CONNECTION_CREATED,
      exports2.CONNECTION_READY,
      exports2.CONNECTION_CLOSED,
      exports2.CONNECTION_CHECK_OUT_STARTED,
      exports2.CONNECTION_CHECK_OUT_FAILED,
      exports2.CONNECTION_CHECKED_OUT,
      exports2.CONNECTION_CHECKED_IN
    ]);
    exports2.TOPOLOGY_EVENTS = Object.freeze([
      exports2.SERVER_OPENING,
      exports2.SERVER_CLOSED,
      exports2.SERVER_DESCRIPTION_CHANGED,
      exports2.TOPOLOGY_OPENING,
      exports2.TOPOLOGY_CLOSED,
      exports2.TOPOLOGY_DESCRIPTION_CHANGED,
      exports2.ERROR,
      exports2.TIMEOUT,
      exports2.CLOSE
    ]);
    exports2.APM_EVENTS = Object.freeze([
      exports2.COMMAND_STARTED,
      exports2.COMMAND_SUCCEEDED,
      exports2.COMMAND_FAILED
    ]);
    exports2.SERVER_RELAY_EVENTS = Object.freeze([
      exports2.SERVER_HEARTBEAT_STARTED,
      exports2.SERVER_HEARTBEAT_SUCCEEDED,
      exports2.SERVER_HEARTBEAT_FAILED,
      exports2.COMMAND_STARTED,
      exports2.COMMAND_SUCCEEDED,
      exports2.COMMAND_FAILED,
      ...exports2.CMAP_EVENTS
    ]);
    exports2.LOCAL_SERVER_EVENTS = Object.freeze([
      exports2.CONNECT,
      exports2.DESCRIPTION_RECEIVED,
      exports2.CLOSED,
      exports2.ENDED
    ]);
    exports2.MONGO_CLIENT_EVENTS = Object.freeze([
      ...exports2.CMAP_EVENTS,
      ...exports2.APM_EVENTS,
      ...exports2.TOPOLOGY_EVENTS,
      ...exports2.HEARTBEAT_EVENTS
    ]);
    exports2.LEGACY_HELLO_COMMAND = "ismaster";
    exports2.LEGACY_HELLO_COMMAND_CAMEL_CASE = "isMaster";
  }
});

// asset-input/node_modules/mongodb/lib/promise_provider.js
var require_promise_provider = __commonJS({
  "asset-input/node_modules/mongodb/lib/promise_provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PromiseProvider = void 0;
    var error_1 = require_error();
    var kPromise = Symbol("promise");
    var store = {
      [kPromise]: null
    };
    var PromiseProvider = class _PromiseProvider {
      /**
       * Validates the passed in promise library
       * @deprecated Setting a custom promise library is deprecated the next major version will use the global Promise constructor only.
       */
      static validate(lib) {
        if (typeof lib !== "function")
          throw new error_1.MongoInvalidArgumentError(`Promise must be a function, got ${lib}`);
        return !!lib;
      }
      /**
       * Sets the promise library
       * @deprecated Setting a custom promise library is deprecated the next major version will use the global Promise constructor only.
       */
      static set(lib) {
        if (lib === null) {
          store[kPromise] = null;
          return;
        }
        if (!_PromiseProvider.validate(lib)) {
          return;
        }
        store[kPromise] = lib;
      }
      /**
       * Get the stored promise library, or resolves passed in
       * @deprecated Setting a custom promise library is deprecated the next major version will use the global Promise constructor only.
       */
      static get() {
        return store[kPromise];
      }
    };
    exports2.PromiseProvider = PromiseProvider;
  }
});

// asset-input/node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "asset-input/node_modules/mongodb/lib/read_concern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadConcern = exports2.ReadConcernLevel = void 0;
    exports2.ReadConcernLevel = Object.freeze({
      local: "local",
      majority: "majority",
      linearizable: "linearizable",
      available: "available",
      snapshot: "snapshot"
    });
    var ReadConcern = class _ReadConcern {
      /** Constructs a ReadConcern from the read concern level.*/
      constructor(level) {
        var _a;
        this.level = (_a = exports2.ReadConcernLevel[level]) !== null && _a !== void 0 ? _a : level;
      }
      /**
       * Construct a ReadConcern given an options object.
       *
       * @param options - The options object from which to extract the write concern.
       */
      static fromOptions(options) {
        if (options == null) {
          return;
        }
        if (options.readConcern) {
          const { readConcern } = options;
          if (readConcern instanceof _ReadConcern) {
            return readConcern;
          } else if (typeof readConcern === "string") {
            return new _ReadConcern(readConcern);
          } else if ("level" in readConcern && readConcern.level) {
            return new _ReadConcern(readConcern.level);
          }
        }
        if (options.level) {
          return new _ReadConcern(options.level);
        }
        return;
      }
      static get MAJORITY() {
        return exports2.ReadConcernLevel.majority;
      }
      static get AVAILABLE() {
        return exports2.ReadConcernLevel.available;
      }
      static get LINEARIZABLE() {
        return exports2.ReadConcernLevel.linearizable;
      }
      static get SNAPSHOT() {
        return exports2.ReadConcernLevel.snapshot;
      }
      toJSON() {
        return { level: this.level };
      }
    };
    exports2.ReadConcern = ReadConcern;
  }
});

// asset-input/node_modules/mongodb/lib/read_preference.js
var require_read_preference = __commonJS({
  "asset-input/node_modules/mongodb/lib/read_preference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadPreference = exports2.ReadPreferenceMode = void 0;
    var error_1 = require_error();
    exports2.ReadPreferenceMode = Object.freeze({
      primary: "primary",
      primaryPreferred: "primaryPreferred",
      secondary: "secondary",
      secondaryPreferred: "secondaryPreferred",
      nearest: "nearest"
    });
    var ReadPreference = class _ReadPreference {
      /**
       * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
       * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.
       * @param options - Additional read preference options
       */
      constructor(mode, tags, options) {
        if (!_ReadPreference.isValid(mode)) {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
        }
        if (options == null && typeof tags === "object" && !Array.isArray(tags)) {
          options = tags;
          tags = void 0;
        } else if (tags && !Array.isArray(tags)) {
          throw new error_1.MongoInvalidArgumentError("ReadPreference tags must be an array");
        }
        this.mode = mode;
        this.tags = tags;
        this.hedge = options === null || options === void 0 ? void 0 : options.hedge;
        this.maxStalenessSeconds = void 0;
        this.minWireVersion = void 0;
        options = options !== null && options !== void 0 ? options : {};
        if (options.maxStalenessSeconds != null) {
          if (options.maxStalenessSeconds <= 0) {
            throw new error_1.MongoInvalidArgumentError("maxStalenessSeconds must be a positive integer");
          }
          this.maxStalenessSeconds = options.maxStalenessSeconds;
          this.minWireVersion = 5;
        }
        if (this.mode === _ReadPreference.PRIMARY) {
          if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with tags");
          }
          if (this.maxStalenessSeconds) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with maxStalenessSeconds");
          }
          if (this.hedge) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with hedge");
          }
        }
      }
      // Support the deprecated `preference` property introduced in the porcelain layer
      get preference() {
        return this.mode;
      }
      static fromString(mode) {
        return new _ReadPreference(mode);
      }
      /**
       * Construct a ReadPreference given an options object.
       *
       * @param options - The options object from which to extract the read preference.
       */
      static fromOptions(options) {
        var _a, _b, _c;
        if (!options)
          return;
        const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : (_b = options.session) === null || _b === void 0 ? void 0 : _b.transaction.options.readPreference;
        const readPreferenceTags = options.readPreferenceTags;
        if (readPreference == null) {
          return;
        }
        if (typeof readPreference === "string") {
          return new _ReadPreference(readPreference, readPreferenceTags, {
            maxStalenessSeconds: options.maxStalenessSeconds,
            hedge: options.hedge
          });
        } else if (!(readPreference instanceof _ReadPreference) && typeof readPreference === "object") {
          const mode = readPreference.mode || readPreference.preference;
          if (mode && typeof mode === "string") {
            return new _ReadPreference(mode, (_c = readPreference.tags) !== null && _c !== void 0 ? _c : readPreferenceTags, {
              maxStalenessSeconds: readPreference.maxStalenessSeconds,
              hedge: options.hedge
            });
          }
        }
        if (readPreferenceTags) {
          readPreference.tags = readPreferenceTags;
        }
        return readPreference;
      }
      /**
       * Replaces options.readPreference with a ReadPreference instance
       */
      static translate(options) {
        if (options.readPreference == null)
          return options;
        const r = options.readPreference;
        if (typeof r === "string") {
          options.readPreference = new _ReadPreference(r);
        } else if (r && !(r instanceof _ReadPreference) && typeof r === "object") {
          const mode = r.mode || r.preference;
          if (mode && typeof mode === "string") {
            options.readPreference = new _ReadPreference(mode, r.tags, {
              maxStalenessSeconds: r.maxStalenessSeconds
            });
          }
        } else if (!(r instanceof _ReadPreference)) {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);
        }
        return options;
      }
      /**
       * Validate if a mode is legal
       *
       * @param mode - The string representing the read preference mode.
       */
      static isValid(mode) {
        const VALID_MODES = /* @__PURE__ */ new Set([
          _ReadPreference.PRIMARY,
          _ReadPreference.PRIMARY_PREFERRED,
          _ReadPreference.SECONDARY,
          _ReadPreference.SECONDARY_PREFERRED,
          _ReadPreference.NEAREST,
          null
        ]);
        return VALID_MODES.has(mode);
      }
      /**
       * Validate if a mode is legal
       *
       * @param mode - The string representing the read preference mode.
       */
      isValid(mode) {
        return _ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
      }
      /**
       * Indicates that this readPreference needs the "secondaryOk" bit when sent over the wire
       * @deprecated Use secondaryOk instead
       * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query
       */
      slaveOk() {
        return this.secondaryOk();
      }
      /**
       * Indicates that this readPreference needs the "SecondaryOk" bit when sent over the wire
       * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query
       */
      secondaryOk() {
        const NEEDS_SECONDARYOK = /* @__PURE__ */ new Set([
          _ReadPreference.PRIMARY_PREFERRED,
          _ReadPreference.SECONDARY,
          _ReadPreference.SECONDARY_PREFERRED,
          _ReadPreference.NEAREST
        ]);
        return NEEDS_SECONDARYOK.has(this.mode);
      }
      /**
       * Check if the two ReadPreferences are equivalent
       *
       * @param readPreference - The read preference with which to check equality
       */
      equals(readPreference) {
        return readPreference.mode === this.mode;
      }
      /** Return JSON representation */
      toJSON() {
        const readPreference = { mode: this.mode };
        if (Array.isArray(this.tags))
          readPreference.tags = this.tags;
        if (this.maxStalenessSeconds)
          readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
        if (this.hedge)
          readPreference.hedge = this.hedge;
        return readPreference;
      }
    };
    exports2.ReadPreference = ReadPreference;
    ReadPreference.PRIMARY = exports2.ReadPreferenceMode.primary;
    ReadPreference.PRIMARY_PREFERRED = exports2.ReadPreferenceMode.primaryPreferred;
    ReadPreference.SECONDARY = exports2.ReadPreferenceMode.secondary;
    ReadPreference.SECONDARY_PREFERRED = exports2.ReadPreferenceMode.secondaryPreferred;
    ReadPreference.NEAREST = exports2.ReadPreferenceMode.nearest;
    ReadPreference.primary = new ReadPreference(exports2.ReadPreferenceMode.primary);
    ReadPreference.primaryPreferred = new ReadPreference(exports2.ReadPreferenceMode.primaryPreferred);
    ReadPreference.secondary = new ReadPreference(exports2.ReadPreferenceMode.secondary);
    ReadPreference.secondaryPreferred = new ReadPreference(exports2.ReadPreferenceMode.secondaryPreferred);
    ReadPreference.nearest = new ReadPreference(exports2.ReadPreferenceMode.nearest);
  }
});

// asset-input/node_modules/mongodb/lib/sdam/common.js
var require_common = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._advanceClusterTime = exports2.drainTimerQueue = exports2.ServerType = exports2.TopologyType = exports2.STATE_CONNECTED = exports2.STATE_CONNECTING = exports2.STATE_CLOSED = exports2.STATE_CLOSING = void 0;
    var timers_1 = require("timers");
    exports2.STATE_CLOSING = "closing";
    exports2.STATE_CLOSED = "closed";
    exports2.STATE_CONNECTING = "connecting";
    exports2.STATE_CONNECTED = "connected";
    exports2.TopologyType = Object.freeze({
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown",
      LoadBalanced: "LoadBalanced"
    });
    exports2.ServerType = Object.freeze({
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown",
      LoadBalancer: "LoadBalancer"
    });
    function drainTimerQueue(queue) {
      queue.forEach(timers_1.clearTimeout);
      queue.clear();
    }
    exports2.drainTimerQueue = drainTimerQueue;
    function _advanceClusterTime(entity, $clusterTime) {
      if (entity.clusterTime == null) {
        entity.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
          entity.clusterTime = $clusterTime;
        }
      }
    }
    exports2._advanceClusterTime = _advanceClusterTime;
  }
});

// asset-input/node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "asset-input/node_modules/mongodb/lib/write_concern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteConcern = exports2.WRITE_CONCERN_KEYS = void 0;
    exports2.WRITE_CONCERN_KEYS = ["w", "wtimeout", "j", "journal", "fsync"];
    var WriteConcern = class _WriteConcern {
      /**
       * Constructs a WriteConcern from the write concern properties.
       * @param w - request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.
       * @param wtimeout - specify a time limit to prevent write operations from blocking indefinitely
       * @param j - request acknowledgment that the write operation has been written to the on-disk journal
       * @param fsync - equivalent to the j option
       */
      constructor(w, wtimeout, j, fsync) {
        if (w != null) {
          if (!Number.isNaN(Number(w))) {
            this.w = Number(w);
          } else {
            this.w = w;
          }
        }
        if (wtimeout != null) {
          this.wtimeout = wtimeout;
        }
        if (j != null) {
          this.j = j;
        }
        if (fsync != null) {
          this.fsync = fsync;
        }
      }
      /** Construct a WriteConcern given an options object. */
      static fromOptions(options, inherit) {
        if (options == null)
          return void 0;
        inherit = inherit !== null && inherit !== void 0 ? inherit : {};
        let opts;
        if (typeof options === "string" || typeof options === "number") {
          opts = { w: options };
        } else if (options instanceof _WriteConcern) {
          opts = options;
        } else {
          opts = options.writeConcern;
        }
        const parentOpts = inherit instanceof _WriteConcern ? inherit : inherit.writeConcern;
        const { w = void 0, wtimeout = void 0, j = void 0, fsync = void 0, journal = void 0, wtimeoutMS = void 0 } = {
          ...parentOpts,
          ...opts
        };
        if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
          return new _WriteConcern(w, wtimeout !== null && wtimeout !== void 0 ? wtimeout : wtimeoutMS, j !== null && j !== void 0 ? j : journal, fsync);
        }
        return void 0;
      }
    };
    exports2.WriteConcern = WriteConcern;
  }
});

// asset-input/node_modules/mongodb/lib/utils.js
var require_utils2 = __commonJS({
  "asset-input/node_modules/mongodb/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compareObjectId = exports2.getMongoDBClientEncryption = exports2.commandSupportsReadConcern = exports2.shuffle = exports2.parsePackageVersion = exports2.supportsRetryableWrites = exports2.enumToString = exports2.emitWarningOnce = exports2.emitWarning = exports2.MONGODB_WARNING_CODE = exports2.DEFAULT_PK_FACTORY = exports2.HostAddress = exports2.BufferPool = exports2.List = exports2.deepCopy = exports2.isRecord = exports2.setDifference = exports2.isHello = exports2.isSuperset = exports2.resolveOptions = exports2.hasAtomicOperators = exports2.calculateDurationInMs = exports2.now = exports2.makeStateMachine = exports2.errorStrictEqual = exports2.arrayStrictEqual = exports2.eachAsyncSeries = exports2.eachAsync = exports2.maxWireVersion = exports2.uuidV4 = exports2.databaseNamespace = exports2.maybeCallback = exports2.makeCounter = exports2.MongoDBNamespace = exports2.ns = exports2.deprecateOptions = exports2.defaultMsgHandler = exports2.getTopology = exports2.decorateWithExplain = exports2.decorateWithReadConcern = exports2.decorateWithCollation = exports2.isPromiseLike = exports2.applyWriteConcern = exports2.applyRetryableWrites = exports2.filterOptions = exports2.mergeOptions = exports2.isObject = exports2.normalizeHintField = exports2.checkCollectionName = exports2.MAX_JS_INT = void 0;
    exports2.matchesParentDomain = exports2.parseUnsignedInteger = exports2.parseInteger = void 0;
    var crypto = require("crypto");
    var url_1 = require("url");
    var bson_1 = require_bson2();
    var constants_1 = require_constants2();
    var constants_2 = require_constants3();
    var error_1 = require_error();
    var promise_provider_1 = require_promise_provider();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var write_concern_1 = require_write_concern();
    exports2.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;
    function checkCollectionName(collectionName) {
      if ("string" !== typeof collectionName) {
        throw new error_1.MongoInvalidArgumentError("Collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf("..") !== -1) {
        throw new error_1.MongoInvalidArgumentError("Collection names cannot be empty");
      }
      if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw new error_1.MongoInvalidArgumentError("Collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw new error_1.MongoInvalidArgumentError("Collection names must not start or end with '.'");
      }
      if (collectionName.indexOf("\0") !== -1) {
        throw new error_1.MongoInvalidArgumentError("Collection names cannot contain a null character");
      }
    }
    exports2.checkCollectionName = checkCollectionName;
    function normalizeHintField(hint) {
      let finalHint = void 0;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach((param) => {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (const name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    }
    exports2.normalizeHintField = normalizeHintField;
    var TO_STRING = (object) => Object.prototype.toString.call(object);
    function isObject(arg) {
      return "[object Object]" === TO_STRING(arg);
    }
    exports2.isObject = isObject;
    function mergeOptions(target, source) {
      return { ...target, ...source };
    }
    exports2.mergeOptions = mergeOptions;
    function filterOptions(options, names) {
      const filterOptions2 = {};
      for (const name in options) {
        if (names.includes(name)) {
          filterOptions2[name] = options[name];
        }
      }
      return filterOptions2;
    }
    exports2.filterOptions = filterOptions;
    function applyRetryableWrites(target, db) {
      var _a;
      if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {
        target.retryWrites = true;
      }
      return target;
    }
    exports2.applyRetryableWrites = applyRetryableWrites;
    function applyWriteConcern(target, sources, options) {
      options = options !== null && options !== void 0 ? options : {};
      const db = sources.db;
      const coll = sources.collection;
      if (options.session && options.session.inTransaction()) {
        if (target.writeConcern) {
          delete target.writeConcern;
        }
        return target;
      }
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        return Object.assign(target, { writeConcern });
      }
      if (coll && coll.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });
      }
      if (db && db.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });
      }
      return target;
    }
    exports2.applyWriteConcern = applyWriteConcern;
    function isPromiseLike(value) {
      return !!value && typeof value.then === "function";
    }
    exports2.isPromiseLike = isPromiseLike;
    function decorateWithCollation(command, target, options) {
      const capabilities = getTopology(target).capabilities;
      if (options.collation && typeof options.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options.collation;
        } else {
          throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
        }
      }
    }
    exports2.decorateWithCollation = decorateWithCollation;
    function decorateWithReadConcern(command, coll, options) {
      if (options && options.session && options.session.inTransaction()) {
        return;
      }
      const readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern });
      }
    }
    exports2.decorateWithReadConcern = decorateWithReadConcern;
    function decorateWithExplain(command, explain) {
      if (command.explain) {
        return command;
      }
      return { explain: command, verbosity: explain.verbosity };
    }
    exports2.decorateWithExplain = decorateWithExplain;
    function getTopology(provider) {
      if ("topology" in provider && provider.topology) {
        return provider.topology;
      } else if ("s" in provider && "client" in provider.s && provider.s.client.topology) {
        return provider.s.client.topology;
      } else if ("s" in provider && "db" in provider.s && provider.s.db.s.client.topology) {
        return provider.s.db.s.client.topology;
      }
      throw new error_1.MongoNotConnectedError("MongoClient must be connected to perform this operation");
    }
    exports2.getTopology = getTopology;
    function defaultMsgHandler(name, option) {
      return `${name} option [${option}] is deprecated and will be removed in a later version.`;
    }
    exports2.defaultMsgHandler = defaultMsgHandler;
    function deprecateOptions(config, fn) {
      if (process.noDeprecation === true) {
        return fn;
      }
      const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
      const optionsWarned = /* @__PURE__ */ new Set();
      function deprecated(...args) {
        const options = args[config.optionsIndex];
        if (!isObject(options) || Object.keys(options).length === 0) {
          return fn.bind(this)(...args);
        }
        for (const deprecatedOption of config.deprecatedOptions) {
          if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {
            optionsWarned.add(deprecatedOption);
            const msg = msgHandler(config.name, deprecatedOption);
            emitWarning(msg);
            if (this && "getLogger" in this) {
              const logger = this.getLogger();
              if (logger) {
                logger.warn(msg);
              }
            }
          }
        }
        return fn.bind(this)(...args);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    exports2.deprecateOptions = deprecateOptions;
    function ns(ns2) {
      return MongoDBNamespace.fromString(ns2);
    }
    exports2.ns = ns;
    var MongoDBNamespace = class _MongoDBNamespace {
      /**
       * Create a namespace object
       *
       * @param db - database name
       * @param collection - collection name
       */
      constructor(db, collection) {
        this.db = db;
        this.collection = collection === "" ? void 0 : collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new _MongoDBNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (typeof namespace !== "string" || namespace === "") {
          throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
        }
        const [db, ...collectionParts] = namespace.split(".");
        const collection = collectionParts.join(".");
        return new _MongoDBNamespace(db, collection === "" ? void 0 : collection);
      }
    };
    exports2.MongoDBNamespace = MongoDBNamespace;
    function* makeCounter(seed = 0) {
      let count = seed;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    exports2.makeCounter = makeCounter;
    function maybeCallback(promiseFn, callback) {
      const PromiseConstructor = promise_provider_1.PromiseProvider.get();
      const promise = promiseFn();
      if (callback == null) {
        if (PromiseConstructor == null) {
          return promise;
        } else {
          return new PromiseConstructor((resolve, reject) => {
            promise.then(resolve, reject);
          });
        }
      }
      promise.then((result) => callback(void 0, result), (error) => callback(error));
      return;
    }
    exports2.maybeCallback = maybeCallback;
    function databaseNamespace(ns2) {
      return ns2.split(".")[0];
    }
    exports2.databaseNamespace = databaseNamespace;
    function uuidV4() {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    }
    exports2.uuidV4 = uuidV4;
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.loadBalanced) {
          return constants_1.MAX_SUPPORTED_WIRE_VERSION;
        }
        if (topologyOrServer.hello) {
          return topologyOrServer.hello.maxWireVersion;
        }
        if ("lastHello" in topologyOrServer && typeof topologyOrServer.lastHello === "function") {
          const lastHello = topologyOrServer.lastHello();
          if (lastHello) {
            return lastHello.maxWireVersion;
          }
        }
        if (topologyOrServer.description && "maxWireVersion" in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    exports2.maxWireVersion = maxWireVersion;
    function eachAsync(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = 0;
      for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
      }
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
        }
      }
    }
    exports2.eachAsync = eachAsync;
    function eachAsyncSeries(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = arr.length;
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        idx++;
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
          return;
        }
        eachFn(arr[idx], eachCallback);
      }
      eachFn(arr[idx], eachCallback);
    }
    exports2.eachAsyncSeries = eachAsyncSeries;
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    exports2.arrayStrictEqual = arrayStrictEqual;
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (!lhs || !rhs) {
        return lhs === rhs;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    exports2.errorStrictEqual = errorStrictEqual;
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    exports2.makeStateMachine = makeStateMachine;
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    exports2.now = now;
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        throw new error_1.MongoInvalidArgumentError("Numeric value required to calculate duration");
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    exports2.calculateDurationInMs = calculateDurationInMs;
    function hasAtomicOperators(doc) {
      if (Array.isArray(doc)) {
        for (const document2 of doc) {
          if (hasAtomicOperators(document2)) {
            return true;
          }
        }
        return false;
      }
      const keys = Object.keys(doc);
      return keys.length > 0 && keys[0][0] === "$";
    }
    exports2.hasAtomicOperators = hasAtomicOperators;
    function resolveOptions(parent, options) {
      var _a, _b, _c;
      const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));
      const session = options === null || options === void 0 ? void 0 : options.session;
      if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {
        const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;
        if (readConcern) {
          result.readConcern = readConcern;
        }
        const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;
        if (writeConcern) {
          result.writeConcern = writeConcern;
        }
      }
      const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;
      if (readPreference) {
        result.readPreference = readPreference;
      }
      return result;
    }
    exports2.resolveOptions = resolveOptions;
    function isSuperset(set, subset) {
      set = Array.isArray(set) ? new Set(set) : set;
      subset = Array.isArray(subset) ? new Set(subset) : subset;
      for (const elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }
    exports2.isSuperset = isSuperset;
    function isHello(doc) {
      return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
    }
    exports2.isHello = isHello;
    function setDifference(setA, setB) {
      const difference = new Set(setA);
      for (const elem of setB) {
        difference.delete(elem);
      }
      return difference;
    }
    exports2.setDifference = setDifference;
    var HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
    function isRecord(value, requiredKeys = void 0) {
      if (!isObject(value)) {
        return false;
      }
      const ctor = value.constructor;
      if (ctor && ctor.prototype) {
        if (!isObject(ctor.prototype)) {
          return false;
        }
        if (!HAS_OWN(ctor.prototype, "isPrototypeOf")) {
          return false;
        }
      }
      if (requiredKeys) {
        const keys = Object.keys(value);
        return isSuperset(keys, requiredKeys);
      }
      return true;
    }
    exports2.isRecord = isRecord;
    function deepCopy(value) {
      if (value == null) {
        return value;
      } else if (Array.isArray(value)) {
        return value.map((item) => deepCopy(item));
      } else if (isRecord(value)) {
        const res = {};
        for (const key in value) {
          res[key] = deepCopy(value[key]);
        }
        return res;
      }
      const ctor = value.constructor;
      if (ctor) {
        switch (ctor.name.toLowerCase()) {
          case "date":
            return new ctor(Number(value));
          case "map":
            return new Map(value);
          case "set":
            return new Set(value);
          case "buffer":
            return Buffer.from(value);
        }
      }
      return value;
    }
    exports2.deepCopy = deepCopy;
    var List = class {
      get length() {
        return this.count;
      }
      get [Symbol.toStringTag]() {
        return "List";
      }
      constructor() {
        this.count = 0;
        this.head = {
          next: null,
          prev: null,
          value: null
        };
        this.head.next = this.head;
        this.head.prev = this.head;
      }
      toArray() {
        return Array.from(this);
      }
      toString() {
        return `head <=> ${this.toArray().join(" <=> ")} <=> head`;
      }
      *[Symbol.iterator]() {
        for (const node of this.nodes()) {
          yield node.value;
        }
      }
      *nodes() {
        let ptr = this.head.next;
        while (ptr !== this.head) {
          const { next } = ptr;
          yield ptr;
          ptr = next;
        }
      }
      /** Insert at end of list */
      push(value) {
        this.count += 1;
        const newNode = {
          next: this.head,
          prev: this.head.prev,
          value
        };
        this.head.prev.next = newNode;
        this.head.prev = newNode;
      }
      /** Inserts every item inside an iterable instead of the iterable itself */
      pushMany(iterable) {
        for (const value of iterable) {
          this.push(value);
        }
      }
      /** Insert at front of list */
      unshift(value) {
        this.count += 1;
        const newNode = {
          next: this.head.next,
          prev: this.head,
          value
        };
        this.head.next.prev = newNode;
        this.head.next = newNode;
      }
      remove(node) {
        if (node === this.head || this.length === 0) {
          return null;
        }
        this.count -= 1;
        const prevNode = node.prev;
        const nextNode = node.next;
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        return node.value;
      }
      /** Removes the first node at the front of the list */
      shift() {
        return this.remove(this.head.next);
      }
      /** Removes the last node at the end of the list */
      pop() {
        return this.remove(this.head.prev);
      }
      /** Iterates through the list and removes nodes where filter returns true */
      prune(filter) {
        for (const node of this.nodes()) {
          if (filter(node.value)) {
            this.remove(node);
          }
        }
      }
      clear() {
        this.count = 0;
        this.head.next = this.head;
        this.head.prev = this.head;
      }
      /** Returns the first item in the list, does not remove */
      first() {
        return this.head.next.value;
      }
      /** Returns the last item in the list, does not remove */
      last() {
        return this.head.prev.value;
      }
    };
    exports2.List = List;
    var BufferPool = class {
      constructor() {
        this.buffers = new List();
        this.totalByteLength = 0;
      }
      get length() {
        return this.totalByteLength;
      }
      /** Adds a buffer to the internal buffer pool list */
      append(buffer) {
        this.buffers.push(buffer);
        this.totalByteLength += buffer.length;
      }
      /**
       * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,
       * otherwise return null. Size can be negative, caller should error check.
       */
      getInt32() {
        if (this.totalByteLength < 4) {
          return null;
        }
        const firstBuffer = this.buffers.first();
        if (firstBuffer != null && firstBuffer.byteLength >= 4) {
          return firstBuffer.readInt32LE(0);
        }
        const top4Bytes = this.read(4);
        const value = top4Bytes.readInt32LE(0);
        this.totalByteLength += 4;
        this.buffers.unshift(top4Bytes);
        return value;
      }
      /** Reads the requested number of bytes, optionally consuming them */
      read(size) {
        if (typeof size !== "number" || size < 0) {
          throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
        }
        if (size > this.totalByteLength) {
          return Buffer.alloc(0);
        }
        const result = Buffer.allocUnsafe(size);
        for (let bytesRead = 0; bytesRead < size; ) {
          const buffer = this.buffers.shift();
          if (buffer == null) {
            break;
          }
          const bytesRemaining = size - bytesRead;
          const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
          const bytes = buffer.subarray(0, bytesReadable);
          result.set(bytes, bytesRead);
          bytesRead += bytesReadable;
          this.totalByteLength -= bytesReadable;
          if (bytesReadable < buffer.byteLength) {
            this.buffers.unshift(buffer.subarray(bytesReadable));
          }
        }
        return result;
      }
    };
    exports2.BufferPool = BufferPool;
    var HostAddress = class _HostAddress {
      constructor(hostString) {
        this.host = void 0;
        this.port = void 0;
        this.socketPath = void 0;
        this.isIPv6 = false;
        const escapedHost = hostString.split(" ").join("%20");
        if (escapedHost.endsWith(".sock")) {
          this.socketPath = decodeURIComponent(escapedHost);
          return;
        }
        const urlString = `iLoveJS://${escapedHost}`;
        let url;
        try {
          url = new url_1.URL(urlString);
        } catch (urlError) {
          const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
          runtimeError.cause = urlError;
          throw runtimeError;
        }
        const hostname = url.hostname;
        const port = url.port;
        let normalized = decodeURIComponent(hostname).toLowerCase();
        if (normalized.startsWith("[") && normalized.endsWith("]")) {
          this.isIPv6 = true;
          normalized = normalized.substring(1, hostname.length - 1);
        }
        this.host = normalized.toLowerCase();
        if (typeof port === "number") {
          this.port = port;
        } else if (typeof port === "string" && port !== "") {
          this.port = Number.parseInt(port, 10);
        } else {
          this.port = 27017;
        }
        if (this.port === 0) {
          throw new error_1.MongoParseError("Invalid port (zero) with hostname");
        }
        Object.freeze(this);
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.inspect();
      }
      inspect() {
        return `new HostAddress('${this.toString()}')`;
      }
      toString() {
        if (typeof this.host === "string") {
          if (this.isIPv6) {
            return `[${this.host}]:${this.port}`;
          }
          return `${this.host}:${this.port}`;
        }
        return `${this.socketPath}`;
      }
      static fromString(s) {
        return new _HostAddress(s);
      }
      static fromHostPort(host, port) {
        if (host.includes(":")) {
          host = `[${host}]`;
        }
        return _HostAddress.fromString(`${host}:${port}`);
      }
      static fromSrvRecord({ name, port }) {
        return _HostAddress.fromHostPort(name, port);
      }
    };
    exports2.HostAddress = HostAddress;
    exports2.DEFAULT_PK_FACTORY = {
      // We prefer not to rely on ObjectId having a createPk method
      createPk() {
        return new bson_1.ObjectId();
      }
    };
    exports2.MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      return process.emitWarning(message, { code: exports2.MONGODB_WARNING_CODE });
    }
    exports2.emitWarning = emitWarning;
    var emittedWarnings = /* @__PURE__ */ new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    exports2.emitWarningOnce = emitWarningOnce;
    function enumToString(en) {
      return Object.values(en).join(", ");
    }
    exports2.enumToString = enumToString;
    function supportsRetryableWrites(server) {
      if (!server) {
        return false;
      }
      if (server.loadBalanced) {
        return true;
      }
      if (server.description.logicalSessionTimeoutMinutes != null) {
        if (server.description.type !== common_1.ServerType.Standalone) {
          return true;
        }
      }
      return false;
    }
    exports2.supportsRetryableWrites = supportsRetryableWrites;
    function parsePackageVersion({ version }) {
      const [major, minor, patch] = version.split(".").map((n) => Number.parseInt(n, 10));
      return { major, minor, patch };
    }
    exports2.parsePackageVersion = parsePackageVersion;
    function shuffle(sequence, limit = 0) {
      const items = Array.from(sequence);
      if (limit > items.length) {
        throw new error_1.MongoRuntimeError("Limit must be less than the number of items");
      }
      let remainingItemsToShuffle = items.length;
      const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
      while (remainingItemsToShuffle > lowerBound) {
        const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
        remainingItemsToShuffle -= 1;
        const swapHold = items[remainingItemsToShuffle];
        items[remainingItemsToShuffle] = items[randomIndex];
        items[randomIndex] = swapHold;
      }
      return limit % items.length === 0 ? items : items.slice(lowerBound);
    }
    exports2.shuffle = shuffle;
    function commandSupportsReadConcern(command, options) {
      if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
        return true;
      }
      if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === "inline")) {
        return true;
      }
      return false;
    }
    exports2.commandSupportsReadConcern = commandSupportsReadConcern;
    function getMongoDBClientEncryption() {
      let mongodbClientEncryption = null;
      if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === "string" && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {
        try {
          mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);
        } catch {
        }
      } else {
        try {
          mongodbClientEncryption = require("mongodb-client-encryption");
        } catch {
        }
      }
      return mongodbClientEncryption;
    }
    exports2.getMongoDBClientEncryption = getMongoDBClientEncryption;
    function compareObjectId(oid1, oid2) {
      if (oid1 == null && oid2 == null) {
        return 0;
      }
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      return oid1.id.compare(oid2.id);
    }
    exports2.compareObjectId = compareObjectId;
    function parseInteger(value) {
      if (typeof value === "number")
        return Math.trunc(value);
      const parsedValue = Number.parseInt(String(value), 10);
      return Number.isNaN(parsedValue) ? null : parsedValue;
    }
    exports2.parseInteger = parseInteger;
    function parseUnsignedInteger(value) {
      const parsedInt = parseInteger(value);
      return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
    }
    exports2.parseUnsignedInteger = parseUnsignedInteger;
    function matchesParentDomain(address, srvHost) {
      const normalizedAddress = address.endsWith(".") ? address.slice(0, address.length - 1) : address;
      const normalizedSrvHost = srvHost.endsWith(".") ? srvHost.slice(0, srvHost.length - 1) : srvHost;
      const allCharacterBeforeFirstDot = /^.*?\./;
      const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, "")}`;
      const srvHostDomain = `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, "")}`;
      return addressDomain.endsWith(srvHostDomain);
    }
    exports2.matchesParentDomain = matchesParentDomain;
  }
});

// asset-input/node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "asset-input/node_modules/mongodb/lib/explain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Explain = exports2.ExplainVerbosity = void 0;
    var error_1 = require_error();
    exports2.ExplainVerbosity = Object.freeze({
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    });
    var Explain = class _Explain {
      constructor(verbosity) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? exports2.ExplainVerbosity.allPlansExecution : exports2.ExplainVerbosity.queryPlanner;
        } else {
          this.verbosity = verbosity;
        }
      }
      static fromOptions(options) {
        if ((options === null || options === void 0 ? void 0 : options.explain) == null)
          return;
        const explain = options.explain;
        if (typeof explain === "boolean" || typeof explain === "string") {
          return new _Explain(explain);
        }
        throw new error_1.MongoInvalidArgumentError('Field "explain" must be a string or a boolean');
      }
    };
    exports2.Explain = Explain;
  }
});

// asset-input/node_modules/mongodb/lib/sdam/server_selection.js
var require_server_selection = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/server_selection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readPreferenceServerSelector = exports2.secondaryWritableServerSelector = exports2.sameServerSelector = exports2.writableServerSelector = exports2.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    exports2.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
    function writableServerSelector() {
      return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
    }
    exports2.writableServerSelector = writableServerSelector;
    function sameServerSelector(description) {
      return (topologyDescription, servers) => {
        if (!description)
          return [];
        return servers.filter((sd) => {
          return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
        });
      };
    }
    exports2.sameServerSelector = sameServerSelector;
    function secondaryWritableServerSelector(wireVersion, readPreference) {
      if (!readPreference || !wireVersion || wireVersion && wireVersion < exports2.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
      }
      return readPreferenceServerSelector(readPreference);
    }
    exports2.secondaryWritableServerSelector = secondaryWritableServerSelector;
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          var _a;
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;
          if (staleness <= maxStalenessSeconds) {
            result.push(server);
          }
          return result;
        }, []);
      }
      if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
        return servers.reduce((result, server) => {
          var _a;
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;
          if (staleness <= maxStalenessSeconds) {
            result.push(server);
          }
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === common_1.ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === common_1.ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== common_1.ServerType.Unknown;
    }
    function loadBalancerFilter(server) {
      return server.type === common_1.ServerType.LoadBalancer;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new error_1.MongoInvalidArgumentError("Invalid read preference specified");
      }
      return (topologyDescription, servers) => {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
          return servers.filter(loadBalancerFilter);
        }
        if (topologyDescription.type === common_1.TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === read_preference_1.ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
        if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
    exports2.readPreferenceServerSelector = readPreferenceServerSelector;
  }
});

// asset-input/node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/operation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineAspects = exports2.AbstractOperation = exports2.Aspect = void 0;
    var util_1 = require("util");
    var bson_1 = require_bson2();
    var read_preference_1 = require_read_preference();
    exports2.Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXPLAINABLE: Symbol("EXPLAINABLE"),
      SKIP_COLLATION: Symbol("SKIP_COLLATION"),
      CURSOR_CREATING: Symbol("CURSOR_CREATING"),
      MUST_SELECT_SAME_SERVER: Symbol("MUST_SELECT_SAME_SERVER")
    };
    var kSession = Symbol("session");
    var AbstractOperation = class {
      constructor(options = {}) {
        var _a;
        this.executeAsync = (0, util_1.promisify)((server, session, callback) => {
          this.execute(server, session, callback);
        });
        this.readPreference = this.hasAspect(exports2.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : (_a = read_preference_1.ReadPreference.fromOptions(options)) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
        this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
        this[kSession] = options.session != null ? options.session : void 0;
        this.options = options;
        this.bypassPinningCheck = !!options.bypassPinningCheck;
        this.trySecondaryWrite = false;
      }
      hasAspect(aspect) {
        const ctor = this.constructor;
        if (ctor.aspects == null) {
          return false;
        }
        return ctor.aspects.has(aspect);
      }
      get session() {
        return this[kSession];
      }
      clearSession() {
        this[kSession] = void 0;
      }
      get canRetryRead() {
        return true;
      }
      get canRetryWrite() {
        return true;
      }
    };
    exports2.AbstractOperation = AbstractOperation;
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
    exports2.defineAspects = defineAspects;
  }
});

// asset-input/node_modules/mongodb/lib/operations/command.js
var require_command = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/command.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommandOperation = void 0;
    var error_1 = require_error();
    var explain_1 = require_explain();
    var read_concern_1 = require_read_concern();
    var server_selection_1 = require_server_selection();
    var utils_1 = require_utils2();
    var write_concern_1 = require_write_concern();
    var operation_1 = require_operation();
    var CommandOperation = class extends operation_1.AbstractOperation {
      constructor(parent, options) {
        super(options);
        this.options = options !== null && options !== void 0 ? options : {};
        const dbNameOverride = (options === null || options === void 0 ? void 0 : options.dbName) || (options === null || options === void 0 ? void 0 : options.authdb);
        if (dbNameOverride) {
          this.ns = new utils_1.MongoDBNamespace(dbNameOverride, "$cmd");
        } else {
          this.ns = parent ? parent.s.namespace.withCollection("$cmd") : new utils_1.MongoDBNamespace("admin", "$cmd");
        }
        this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (parent && parent.logger) {
          this.logger = parent.logger;
        }
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
          this.explain = explain_1.Explain.fromOptions(options);
        } else if ((options === null || options === void 0 ? void 0 : options.explain) != null) {
          throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
        }
      }
      get canRetryWrite() {
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
          return this.explain == null;
        }
        return true;
      }
      executeCommand(server, session, cmd, callback) {
        this.server = server;
        const options = {
          ...this.options,
          ...this.bsonOptions,
          readPreference: this.readPreference,
          session
        };
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
          Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
          options.omitReadPreference = true;
        }
        if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
          Object.assign(cmd, { writeConcern: this.writeConcern });
        }
        if (options.collation && typeof options.collation === "object" && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
          Object.assign(cmd, { collation: options.collation });
        }
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
          cmd = (0, utils_1.decorateWithExplain)(cmd, this.explain);
        }
        server.command(this.ns, cmd, options, callback);
      }
    };
    exports2.CommandOperation = CommandOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/add_user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddUserOperation = void 0;
    var crypto = require("crypto");
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var AddUserOperation = class extends command_1.CommandOperation {
      constructor(db, username, password, options) {
        super(db, options);
        this.db = db;
        this.username = username;
        this.password = password;
        this.options = options !== null && options !== void 0 ? options : {};
      }
      execute(server, session, callback) {
        const db = this.db;
        const username = this.username;
        const password = this.password;
        const options = this.options;
        if (options.digestPassword != null) {
          return callback(new error_1.MongoInvalidArgumentError('Option "digestPassword" not supported via addUser, use db.command(...) instead'));
        }
        let roles;
        if (!options.roles || Array.isArray(options.roles) && options.roles.length === 0) {
          (0, utils_1.emitWarningOnce)('Creating a user without roles is deprecated. Defaults to "root" if db is "admin" or "dbOwner" otherwise');
          if (db.databaseName.toLowerCase() === "admin") {
            roles = ["root"];
          } else {
            roles = ["dbOwner"];
          }
        } else {
          roles = Array.isArray(options.roles) ? options.roles : [options.roles];
        }
        let topology;
        try {
          topology = (0, utils_1.getTopology)(db);
        } catch (error) {
          return callback(error);
        }
        const digestPassword = topology.lastHello().maxWireVersion >= 7;
        let userPassword = password;
        if (!digestPassword) {
          const md5 = crypto.createHash("md5");
          md5.update(`${username}:mongo:${password}`);
          userPassword = md5.digest("hex");
        }
        const command = {
          createUser: username,
          customData: options.customData || {},
          roles,
          digestPassword
        };
        if (typeof password === "string") {
          command.pwd = userPassword;
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.AddUserOperation = AddUserOperation;
    (0, operation_1.defineAspects)(AddUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/execute_operation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeOperation = void 0;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var server_selection_1 = require_server_selection();
    var utils_1 = require_utils2();
    var operation_1 = require_operation();
    var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    function executeOperation(client, operation, callback) {
      return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);
    }
    exports2.executeOperation = executeOperation;
    async function executeOperationAsync(client, operation) {
      var _a, _b;
      if (!(operation instanceof operation_1.AbstractOperation)) {
        throw new error_1.MongoRuntimeError("This method requires a valid operation instance");
      }
      if (client.topology == null) {
        if (client.s.hasBeenClosed) {
          throw new error_1.MongoNotConnectedError("Client must be connected before running operations");
        }
        client.s.options[Symbol.for("@@mdb.skipPingOnConnect")] = true;
        try {
          await client.connect();
        } finally {
          delete client.s.options[Symbol.for("@@mdb.skipPingOnConnect")];
        }
      }
      const { topology } = client;
      if (topology == null) {
        throw new error_1.MongoRuntimeError("client.connect did not create a topology but also did not throw");
      }
      if (topology.shouldCheckForSessionSupport()) {
        await topology.selectServerAsync(read_preference_1.ReadPreference.primaryPreferred, {});
      }
      let session = operation.session;
      let owner;
      if (topology.hasSessionSupport()) {
        if (session == null) {
          owner = Symbol();
          session = client.startSession({ owner, explicit: false });
        } else if (session.hasEnded) {
          throw new error_1.MongoExpiredSessionError("Use of expired sessions is not permitted");
        } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
          throw new error_1.MongoCompatibilityError("Snapshot reads require MongoDB 5.0 or later");
        }
      } else {
        if (session && session.explicit) {
          throw new error_1.MongoCompatibilityError("Current topology does not support sessions");
        } else if (session && !session.explicit) {
          delete operation.options.session;
          operation.clearSession();
          session = void 0;
        }
      }
      const readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
      const inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());
      if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {
        throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
      }
      if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {
        session.unpin();
      }
      let selector;
      if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
        selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);
      } else if (operation.trySecondaryWrite) {
        selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
      } else {
        selector = readPreference;
      }
      const server = await topology.selectServerAsync(selector, { session });
      if (session == null) {
        return operation.executeAsync(server, void 0);
      }
      if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {
        try {
          return await operation.executeAsync(server, session);
        } finally {
          if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {
            await session.endSession().catch(() => null);
          }
        }
      }
      const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
      const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
      const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;
      if (hasWriteAspect && willRetryWrite) {
        operation.options.willRetryWrite = true;
        session.incrementTransactionNumber();
      }
      try {
        return await operation.executeAsync(server, session);
      } catch (operationError) {
        if (willRetry && operationError instanceof error_1.MongoError) {
          return await retryOperation(operation, operationError, {
            session,
            topology,
            selector
          });
        }
        throw operationError;
      } finally {
        if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {
          await session.endSession().catch(() => null);
        }
      }
    }
    async function retryOperation(operation, originalError, { session, topology, selector }) {
      const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
      const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
      if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
        throw new error_1.MongoServerError({
          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
          originalError
        });
      }
      if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {
        throw originalError;
      }
      if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {
        throw originalError;
      }
      if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {
        session.unpin({ force: true, forceClear: true });
      }
      const server = await topology.selectServerAsync(selector, { session });
      if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {
        throw new error_1.MongoUnexpectedServerResponseError("Selected server does not support retryable writes");
      }
      try {
        return await operation.executeAsync(server, session);
      } catch (retryError) {
        if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
          throw originalError;
        }
        throw retryError;
      }
    }
  }
});

// asset-input/node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/list_databases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListDatabasesOperation = void 0;
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ListDatabasesOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      execute(server, session, callback) {
        const cmd = { listDatabases: 1 };
        if (this.options.nameOnly) {
          cmd.nameOnly = Number(cmd.nameOnly);
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== void 0) {
          cmd.comment = this.options.comment;
        }
        super.executeCommand(server, session, cmd, callback);
      }
    };
    exports2.ListDatabasesOperation = ListDatabasesOperation;
    (0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/remove_user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemoveUserOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var RemoveUserOperation = class extends command_1.CommandOperation {
      constructor(db, username, options) {
        super(db, options);
        this.options = options;
        this.username = username;
      }
      execute(server, session, callback) {
        super.executeCommand(server, session, { dropUser: this.username }, (err) => {
          callback(err, err ? false : true);
        });
      }
    };
    exports2.RemoveUserOperation = RemoveUserOperation;
    (0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/run_command.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RunAdminCommandOperation = exports2.RunCommandOperation = void 0;
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var RunCommandOperation = class extends command_1.CommandOperation {
      constructor(parent, command, options) {
        super(parent, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.command = command;
      }
      execute(server, session, callback) {
        const command = this.command;
        this.executeCommand(server, session, command, callback);
      }
    };
    exports2.RunCommandOperation = RunCommandOperation;
    var RunAdminCommandOperation = class extends RunCommandOperation {
      constructor(parent, command, options) {
        super(parent, command, options);
        this.ns = new utils_1.MongoDBNamespace("admin");
      }
    };
    exports2.RunAdminCommandOperation = RunAdminCommandOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/validate_collection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidateCollectionOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var ValidateCollectionOperation = class extends command_1.CommandOperation {
      constructor(admin, collectionName, options) {
        const command = { validate: collectionName };
        const keys = Object.keys(options);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options[keys[i]];
          }
        }
        super(admin.s.db, options);
        this.options = options;
        this.command = command;
        this.collectionName = collectionName;
      }
      execute(server, session, callback) {
        const collectionName = this.collectionName;
        super.executeCommand(server, session, this.command, (err, doc) => {
          if (err != null)
            return callback(err);
          if (doc.ok === 0)
            return callback(new error_1.MongoRuntimeError("Error with validate command"));
          if (doc.result != null && typeof doc.result !== "string")
            return callback(new error_1.MongoRuntimeError("Error with validation data"));
          if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
            return callback(new error_1.MongoRuntimeError(`Invalid collection ${collectionName}`));
          if (doc.valid != null && !doc.valid)
            return callback(new error_1.MongoRuntimeError(`Invalid collection ${collectionName}`));
          return callback(void 0, doc);
        });
      }
    };
    exports2.ValidateCollectionOperation = ValidateCollectionOperation;
  }
});

// asset-input/node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "asset-input/node_modules/mongodb/lib/admin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Admin = void 0;
    var add_user_1 = require_add_user();
    var execute_operation_1 = require_execute_operation();
    var list_databases_1 = require_list_databases();
    var remove_user_1 = require_remove_user();
    var run_command_1 = require_run_command();
    var validate_collection_1 = require_validate_collection();
    var Admin = class {
      /**
       * Create a new Admin instance
       * @internal
       */
      constructor(db) {
        this.s = { db };
      }
      command(command, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = Object.assign({ dbName: "admin" }, options);
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new run_command_1.RunCommandOperation(this.s.db, command, options), callback);
      }
      buildInfo(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.command({ buildinfo: 1 }, options, callback);
      }
      serverInfo(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.command({ buildinfo: 1 }, options, callback);
      }
      serverStatus(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.command({ serverStatus: 1 }, options, callback);
      }
      ping(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.command({ ping: 1 }, options, callback);
      }
      addUser(username, password, options, callback) {
        if (typeof password === "function") {
          callback = password, password = void 0, options = {};
        } else if (typeof password !== "string") {
          if (typeof options === "function") {
            callback = options, options = password, password = void 0;
          } else {
            options = password, callback = void 0, password = void 0;
          }
        } else {
          if (typeof options === "function")
            callback = options, options = {};
        }
        options = Object.assign({ dbName: "admin" }, options);
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new add_user_1.AddUserOperation(this.s.db, username, password, options), callback);
      }
      removeUser(username, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = Object.assign({ dbName: "admin" }, options);
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new remove_user_1.RemoveUserOperation(this.s.db, username, options), callback);
      }
      validateCollection(collectionName, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options), callback);
      }
      listDatabases(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new list_databases_1.ListDatabasesOperation(this.s.db, options), callback);
      }
      replSetGetStatus(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.command({ replSetGetStatus: 1 }, options, callback);
      }
    };
    exports2.Admin = Admin;
  }
});

// asset-input/node_modules/mongodb/lib/operations/delete.js
var require_delete = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/delete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDeleteStatement = exports2.DeleteManyOperation = exports2.DeleteOneOperation = exports2.DeleteOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DeleteOperation = class extends command_1.CommandOperation {
      constructor(ns, statements, options) {
        super(void 0, options);
        this.options = options;
        this.ns = ns;
        this.statements = statements;
      }
      get canRetryWrite() {
        if (super.canRetryWrite === false) {
          return false;
        }
        return this.statements.every((op) => op.limit != null ? op.limit > 0 : true);
      }
      execute(server, session, callback) {
        var _a;
        const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
        const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
        const command = {
          delete: this.ns.collection,
          deletes: this.statements,
          ordered
        };
        if (options.let) {
          command.let = options.let;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
        if (unacknowledgedWrite) {
          if (this.statements.find((o) => o.hint)) {
            callback(new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`));
            return;
          }
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.DeleteOperation = DeleteOperation;
    var DeleteOneOperation = class extends DeleteOperation {
      constructor(collection, filter, options) {
        super(collection.s.namespace, [makeDeleteStatement(filter, { ...options, limit: 1 })], options);
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, res) => {
          var _a, _b;
          if (err || res == null)
            return callback(err);
          if (res.code)
            return callback(new error_1.MongoServerError(res));
          if (res.writeErrors)
            return callback(new error_1.MongoServerError(res.writeErrors[0]));
          if (this.explain)
            return callback(void 0, res);
          callback(void 0, {
            acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
            deletedCount: res.n
          });
        });
      }
    };
    exports2.DeleteOneOperation = DeleteOneOperation;
    var DeleteManyOperation = class extends DeleteOperation {
      constructor(collection, filter, options) {
        super(collection.s.namespace, [makeDeleteStatement(filter, options)], options);
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, res) => {
          var _a, _b;
          if (err || res == null)
            return callback(err);
          if (res.code)
            return callback(new error_1.MongoServerError(res));
          if (res.writeErrors)
            return callback(new error_1.MongoServerError(res.writeErrors[0]));
          if (this.explain)
            return callback(void 0, res);
          callback(void 0, {
            acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
            deletedCount: res.n
          });
        });
      }
    };
    exports2.DeleteManyOperation = DeleteManyOperation;
    function makeDeleteStatement(filter, options) {
      const op = {
        q: filter,
        limit: typeof options.limit === "number" ? options.limit : 0
      };
      if (options.single === true) {
        op.limit = 1;
      }
      if (options.collation) {
        op.collation = options.collation;
      }
      if (options.hint) {
        op.hint = options.hint;
      }
      return op;
    }
    exports2.makeDeleteStatement = makeDeleteStatement;
    (0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DeleteOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(DeleteManyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/bulk_write.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BulkWriteOperation = void 0;
    var operation_1 = require_operation();
    var BulkWriteOperation = class extends operation_1.AbstractOperation {
      constructor(collection, operations, options) {
        super(options);
        this.options = options;
        this.collection = collection;
        this.operations = operations;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        const operations = this.operations;
        const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
        const bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options);
        try {
          for (let i = 0; i < operations.length; i++) {
            bulk.raw(operations[i]);
          }
        } catch (err) {
          return callback(err);
        }
        bulk.execute({ ...options, session }, (err, r) => {
          if (!r && err) {
            return callback(err);
          }
          callback(void 0, r);
        });
      }
    };
    exports2.BulkWriteOperation = BulkWriteOperation;
    (0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/common_functions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareDocs = exports2.indexInformation = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    function indexInformation(db, name, _optionsOrCallback, _callback) {
      let options = _optionsOrCallback;
      let callback = _callback;
      if ("function" === typeof _optionsOrCallback) {
        callback = _optionsOrCallback;
        options = {};
      }
      const full = options.full == null ? false : options.full;
      let topology;
      try {
        topology = (0, utils_1.getTopology)(db);
      } catch (error) {
        return callback(error);
      }
      if (topology.isDestroyed())
        return callback(new error_1.MongoTopologyClosedError());
      function processResults(indexes) {
        const info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index = indexes[i];
          info[index.name] = [];
          for (const name2 in index.key) {
            info[index.name].push([name2, index.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options).toArray((err, indexes) => {
        if (err)
          return callback(err);
        if (!Array.isArray(indexes))
          return callback(void 0, []);
        if (full)
          return callback(void 0, indexes);
        callback(void 0, processResults(indexes));
      });
    }
    exports2.indexInformation = indexInformation;
    function prepareDocs(coll, docs, options) {
      var _a;
      const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : (_a = coll.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docs;
      }
      return docs.map((doc) => {
        if (doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      });
    }
    exports2.prepareDocs = prepareDocs;
  }
});

// asset-input/node_modules/mongodb/lib/operations/insert.js
var require_insert = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/insert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InsertManyOperation = exports2.InsertOneOperation = exports2.InsertOperation = void 0;
    var error_1 = require_error();
    var write_concern_1 = require_write_concern();
    var bulk_write_1 = require_bulk_write();
    var command_1 = require_command();
    var common_functions_1 = require_common_functions();
    var operation_1 = require_operation();
    var InsertOperation = class extends command_1.CommandOperation {
      constructor(ns, documents, options) {
        var _a;
        super(void 0, options);
        this.options = { ...options, checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false };
        this.ns = ns;
        this.documents = documents;
      }
      execute(server, session, callback) {
        var _a;
        const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
        const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
        const command = {
          insert: this.ns.collection,
          documents: this.documents,
          ordered
        };
        if (typeof options.bypassDocumentValidation === "boolean") {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.InsertOperation = InsertOperation;
    var InsertOneOperation = class extends InsertOperation {
      constructor(collection, doc, options) {
        super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, res) => {
          var _a, _b;
          if (err || res == null)
            return callback(err);
          if (res.code)
            return callback(new error_1.MongoServerError(res));
          if (res.writeErrors) {
            return callback(new error_1.MongoServerError(res.writeErrors[0]));
          }
          callback(void 0, {
            acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
            insertedId: this.documents[0]._id
          });
        });
      }
    };
    exports2.InsertOneOperation = InsertOneOperation;
    var InsertManyOperation = class extends operation_1.AbstractOperation {
      constructor(collection, docs, options) {
        super(options);
        if (!Array.isArray(docs)) {
          throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
        }
        this.options = options;
        this.collection = collection;
        this.docs = docs;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map((document2) => ({ insertOne: { document: document2 } })), options);
        bulkWriteOperation.execute(server, session, (err, res) => {
          var _a;
          if (err || res == null) {
            if (err && err.message === "Operation must be an object with an operation key") {
              err = new error_1.MongoInvalidArgumentError("Collection.insertMany() cannot be called with an array that has null/undefined values");
            }
            return callback(err);
          }
          callback(void 0, {
            acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,
            insertedCount: res.insertedCount,
            insertedIds: res.insertedIds
          });
        });
      }
    };
    exports2.InsertManyOperation = InsertManyOperation;
    (0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/update.js
var require_update = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/update.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeUpdateStatement = exports2.ReplaceOneOperation = exports2.UpdateManyOperation = exports2.UpdateOneOperation = exports2.UpdateOperation = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var UpdateOperation = class extends command_1.CommandOperation {
      constructor(ns, statements, options) {
        super(void 0, options);
        this.options = options;
        this.ns = ns;
        this.statements = statements;
      }
      get canRetryWrite() {
        if (super.canRetryWrite === false) {
          return false;
        }
        return this.statements.every((op) => op.multi == null || op.multi === false);
      }
      execute(server, session, callback) {
        var _a;
        const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
        const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
        const command = {
          update: this.ns.collection,
          updates: this.statements,
          ordered
        };
        if (typeof options.bypassDocumentValidation === "boolean") {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (options.let) {
          command.let = options.let;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
        if (unacknowledgedWrite) {
          if (this.statements.find((o) => o.hint)) {
            callback(new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`));
            return;
          }
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.UpdateOperation = UpdateOperation;
    var UpdateOneOperation = class extends UpdateOperation {
      constructor(collection, filter, update, options) {
        super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: false })], options);
        if (!(0, utils_1.hasAtomicOperators)(update)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, res) => {
          var _a, _b;
          if (err || !res)
            return callback(err);
          if (this.explain != null)
            return callback(void 0, res);
          if (res.code)
            return callback(new error_1.MongoServerError(res));
          if (res.writeErrors)
            return callback(new error_1.MongoServerError(res.writeErrors[0]));
          callback(void 0, {
            acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
            modifiedCount: res.nModified != null ? res.nModified : res.n,
            upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
            upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
            matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
          });
        });
      }
    };
    exports2.UpdateOneOperation = UpdateOneOperation;
    var UpdateManyOperation = class extends UpdateOperation {
      constructor(collection, filter, update, options) {
        super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: true })], options);
        if (!(0, utils_1.hasAtomicOperators)(update)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, res) => {
          var _a, _b;
          if (err || !res)
            return callback(err);
          if (this.explain != null)
            return callback(void 0, res);
          if (res.code)
            return callback(new error_1.MongoServerError(res));
          if (res.writeErrors)
            return callback(new error_1.MongoServerError(res.writeErrors[0]));
          callback(void 0, {
            acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
            modifiedCount: res.nModified != null ? res.nModified : res.n,
            upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
            upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
            matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
          });
        });
      }
    };
    exports2.UpdateManyOperation = UpdateManyOperation;
    var ReplaceOneOperation = class extends UpdateOperation {
      constructor(collection, filter, replacement, options) {
        super(collection.s.namespace, [makeUpdateStatement(filter, replacement, { ...options, multi: false })], options);
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
        }
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, res) => {
          var _a, _b;
          if (err || !res)
            return callback(err);
          if (this.explain != null)
            return callback(void 0, res);
          if (res.code)
            return callback(new error_1.MongoServerError(res));
          if (res.writeErrors)
            return callback(new error_1.MongoServerError(res.writeErrors[0]));
          callback(void 0, {
            acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,
            modifiedCount: res.nModified != null ? res.nModified : res.n,
            upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
            upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
            matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
          });
        });
      }
    };
    exports2.ReplaceOneOperation = ReplaceOneOperation;
    function makeUpdateStatement(filter, update, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError("Selector must be a valid JavaScript object");
      }
      if (update == null || typeof update !== "object") {
        throw new error_1.MongoInvalidArgumentError("Document must be a valid JavaScript object");
      }
      const op = { q: filter, u: update };
      if (typeof options.upsert === "boolean") {
        op.upsert = options.upsert;
      }
      if (options.multi) {
        op.multi = options.multi;
      }
      if (options.hint) {
        op.hint = options.hint;
      }
      if (options.arrayFilters) {
        op.arrayFilters = options.arrayFilters;
      }
      if (options.collation) {
        op.collation = options.collation;
      }
      return op;
    }
    exports2.makeUpdateStatement = makeUpdateStatement;
    (0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
    (0, operation_1.defineAspects)(UpdateOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(UpdateManyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(ReplaceOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.SKIP_COLLATION
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "asset-input/node_modules/mongodb/lib/bulk/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BulkOperationBase = exports2.FindOperators = exports2.MongoBulkWriteError = exports2.mergeBatchResults = exports2.WriteError = exports2.WriteConcernError = exports2.BulkWriteResult = exports2.Batch = exports2.BatchType = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var delete_1 = require_delete();
    var execute_operation_1 = require_execute_operation();
    var insert_1 = require_insert();
    var operation_1 = require_operation();
    var update_1 = require_update();
    var utils_1 = require_utils2();
    var write_concern_1 = require_write_concern();
    var kServerError = Symbol("serverError");
    exports2.BatchType = Object.freeze({
      INSERT: 1,
      UPDATE: 2,
      DELETE: 3
    });
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    exports2.Batch = Batch;
    var BulkWriteResult = class {
      /**
       * Create a new BulkWriteResult instance
       * @internal
       */
      constructor(bulkResult) {
        this.result = bulkResult;
      }
      /** Number of documents inserted. */
      get insertedCount() {
        var _a;
        return (_a = this.result.nInserted) !== null && _a !== void 0 ? _a : 0;
      }
      /** Number of documents matched for update. */
      get matchedCount() {
        var _a;
        return (_a = this.result.nMatched) !== null && _a !== void 0 ? _a : 0;
      }
      /** Number of documents modified. */
      get modifiedCount() {
        var _a;
        return (_a = this.result.nModified) !== null && _a !== void 0 ? _a : 0;
      }
      /** Number of documents deleted. */
      get deletedCount() {
        var _a;
        return (_a = this.result.nRemoved) !== null && _a !== void 0 ? _a : 0;
      }
      /** Number of documents upserted. */
      get upsertedCount() {
        var _a;
        return (_a = this.result.upserted.length) !== null && _a !== void 0 ? _a : 0;
      }
      /** Upserted document generated Id's, hash key is the index of the originating operation */
      get upsertedIds() {
        var _a;
        const upserted = {};
        for (const doc of (_a = this.result.upserted) !== null && _a !== void 0 ? _a : []) {
          upserted[doc.index] = doc._id;
        }
        return upserted;
      }
      /** Inserted document generated Id's, hash key is the index of the originating operation */
      get insertedIds() {
        var _a;
        const inserted = {};
        for (const doc of (_a = this.result.insertedIds) !== null && _a !== void 0 ? _a : []) {
          inserted[doc.index] = doc._id;
        }
        return inserted;
      }
      /** Evaluates to true if the bulk operation correctly executes */
      get ok() {
        return this.result.ok;
      }
      /** The number of inserted documents */
      get nInserted() {
        return this.result.nInserted;
      }
      /** Number of upserted documents */
      get nUpserted() {
        return this.result.nUpserted;
      }
      /** Number of matched documents */
      get nMatched() {
        return this.result.nMatched;
      }
      /** Number of documents updated physically on disk */
      get nModified() {
        return this.result.nModified;
      }
      /** Number of removed documents */
      get nRemoved() {
        return this.result.nRemoved;
      }
      /** Returns an array of all inserted ids */
      getInsertedIds() {
        return this.result.insertedIds;
      }
      /** Returns an array of all upserted ids */
      getUpsertedIds() {
        return this.result.upserted;
      }
      /** Returns the upserted id at the given index */
      getUpsertedIdAt(index) {
        return this.result.upserted[index];
      }
      /** Returns raw internal result */
      getRawResponse() {
        return this.result;
      }
      /** Returns true if the bulk operation contains a write error */
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      /** Returns the number of write errors off the bulk operation */
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      /** Returns a specific write error object */
      getWriteErrorAt(index) {
        return index < this.result.writeErrors.length ? this.result.writeErrors[index] : void 0;
      }
      /** Retrieve all write errors */
      getWriteErrors() {
        return this.result.writeErrors;
      }
      /**
       * Retrieve lastOp if available
       *
       * @deprecated Will be removed in 5.0
       */
      getLastOp() {
        return this.result.opTime;
      }
      /** Retrieve the write concern error if one exists */
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed });
        }
      }
      /* @deprecated Will be removed in 5.0 release */
      toJSON() {
        return this.result;
      }
      toString() {
        return `BulkWriteResult(${this.toJSON()})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    exports2.BulkWriteResult = BulkWriteResult;
    var WriteConcernError = class {
      constructor(error) {
        this[kServerError] = error;
      }
      /** Write concern error code. */
      get code() {
        return this[kServerError].code;
      }
      /** Write concern error message. */
      get errmsg() {
        return this[kServerError].errmsg;
      }
      /** Write concern error info. */
      get errInfo() {
        return this[kServerError].errInfo;
      }
      /** @deprecated The `err` prop that contained a MongoServerError has been deprecated. */
      get err() {
        return this[kServerError];
      }
      toJSON() {
        return this[kServerError];
      }
      toString() {
        return `WriteConcernError(${this.errmsg})`;
      }
    };
    exports2.WriteConcernError = WriteConcernError;
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      /** WriteError code. */
      get code() {
        return this.err.code;
      }
      /** WriteError original bulk operation index. */
      get index() {
        return this.err.index;
      }
      /** WriteError message. */
      get errmsg() {
        return this.err.errmsg;
      }
      /** WriteError details. */
      get errInfo() {
        return this.err.errInfo;
      }
      /** Returns the underlying operation that caused the error */
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    exports2.WriteError = WriteError;
    function longOrConvert(value) {
      return typeof value === "number" ? bson_1.Long.fromNumber(value) : value;
    }
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      }
      if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          errInfo: result.errInfo,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        let opTime = result.lastOp || result.opTime;
        if (opTime._bsontype === "Timestamp") {
          opTime = { ts: opTime, t: bson_1.Long.ZERO };
        }
        if (!bulkResult.opTime) {
          bulkResult.opTime = opTime;
        } else {
          const lastOpTS = longOrConvert(bulkResult.opTime.ts);
          const opTimeTS = longOrConvert(opTime.ts);
          if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.opTime = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            const lastOpT = longOrConvert(bulkResult.opTime.t);
            const opTimeT = longOrConvert(opTime.t);
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.opTime = opTime;
            }
          }
        }
      }
      if (isInsertBatch(batch) && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (isDeleteBatch(batch) && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (isUpdateBatch(batch) && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = 0;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            errInfo: result.writeErrors[i].errInfo,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    exports2.mergeBatchResults = mergeBatchResults;
    function executeCommands(bulkOperation, options, callback) {
      if (bulkOperation.s.batches.length === 0) {
        return callback(void 0, new BulkWriteResult(bulkOperation.s.bulkResult));
      }
      const batch = bulkOperation.s.batches.shift();
      function resultHandler(err, result) {
        if (err && "message" in err && !(err instanceof error_1.MongoWriteConcernError)) {
          return callback(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult)));
        }
        if (err instanceof error_1.MongoWriteConcernError) {
          return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
        }
        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
        if (mergeResult != null) {
          return callback(void 0, writeResult);
        }
        if (bulkOperation.handleWriteError(callback, writeResult))
          return;
        executeCommands(bulkOperation, options, callback);
      }
      const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
        ...options,
        ordered: bulkOperation.isOrdered
      });
      if (finalOptions.bypassDocumentValidation !== true) {
        delete finalOptions.bypassDocumentValidation;
      }
      if (bulkOperation.operationId) {
        resultHandler.operationId = bulkOperation.operationId;
      }
      if (bulkOperation.s.bypassDocumentValidation === true) {
        finalOptions.bypassDocumentValidation = true;
      }
      if (bulkOperation.s.checkKeys === false) {
        finalOptions.checkKeys = false;
      }
      if (finalOptions.retryWrites) {
        if (isUpdateBatch(batch)) {
          finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.multi);
        }
        if (isDeleteBatch(batch)) {
          finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.limit === 0);
        }
      }
      try {
        if (isInsertBatch(batch)) {
          (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.s.db.s.client, new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
        } else if (isUpdateBatch(batch)) {
          (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.s.db.s.client, new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
        } else if (isDeleteBatch(batch)) {
          (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.s.db.s.client, new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
        }
      } catch (err) {
        err.ok = 0;
        mergeBatchResults(batch, bulkOperation.s.bulkResult, err, void 0);
        callback();
      }
    }
    function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
      var _a, _b;
      mergeBatchResults(batch, bulkResult, void 0, err.result);
      callback(new MongoBulkWriteError({
        message: (_a = err.result) === null || _a === void 0 ? void 0 : _a.writeConcernError.errmsg,
        code: (_b = err.result) === null || _b === void 0 ? void 0 : _b.writeConcernError.result
      }, new BulkWriteResult(bulkResult)));
    }
    var MongoBulkWriteError = class extends error_1.MongoServerError {
      /** Creates a new MongoBulkWriteError */
      constructor(error, result) {
        var _a;
        super(error);
        this.writeErrors = [];
        if (error instanceof WriteConcernError)
          this.err = error;
        else if (!(error instanceof Error)) {
          this.message = error.message;
          this.code = error.code;
          this.writeErrors = (_a = error.writeErrors) !== null && _a !== void 0 ? _a : [];
        }
        this.result = result;
        Object.assign(this, error);
      }
      get name() {
        return "MongoBulkWriteError";
      }
      /** Number of documents inserted. */
      get insertedCount() {
        return this.result.insertedCount;
      }
      /** Number of documents matched for update. */
      get matchedCount() {
        return this.result.matchedCount;
      }
      /** Number of documents modified. */
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      /** Number of documents deleted. */
      get deletedCount() {
        return this.result.deletedCount;
      }
      /** Number of documents upserted. */
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      /** Inserted document generated Id's, hash key is the index of the originating operation */
      get insertedIds() {
        return this.result.insertedIds;
      }
      /** Upserted document generated Id's, hash key is the index of the originating operation */
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    exports2.MongoBulkWriteError = MongoBulkWriteError;
    var FindOperators = class {
      /**
       * Creates a new FindOperators object.
       * @internal
       */
      constructor(bulkOperation) {
        this.bulkOperation = bulkOperation;
      }
      /** Add a multiple update operation to the bulk operation */
      update(updateDocument) {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
          ...currentOp,
          multi: true
        }));
      }
      /** Add a single update operation to the bulk operation */
      updateOne(updateDocument) {
        if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
      }
      /** Add a replace one operation to the bulk operation */
      replaceOne(replacement) {
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
        }
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
      }
      /** Add a delete one operation to the bulk operation */
      deleteOne() {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
      }
      /** Add a delete many operation to the bulk operation */
      delete() {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
      }
      /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */
      upsert() {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.upsert = true;
        return this;
      }
      /** Specifies the collation for the query condition. */
      collation(collation) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.collation = collation;
        return this;
      }
      /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */
      arrayFilters(arrayFilters) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
        return this;
      }
      /** Specifies hint for the bulk operation. */
      hint(hint) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.hint = hint;
        return this;
      }
    };
    exports2.FindOperators = FindOperators;
    var BulkWriteShimOperation = class extends operation_1.AbstractOperation {
      constructor(bulkOperation, options) {
        super(options);
        this.bulkOperation = bulkOperation;
      }
      execute(server, session, callback) {
        if (this.options.session == null) {
          this.options.session = session;
        }
        return executeCommands(this.bulkOperation, this.options, callback);
      }
    };
    var BulkOperationBase = class {
      /**
       * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
       * @internal
       */
      constructor(collection, options, isOrdered) {
        this.isOrdered = isOrdered;
        const topology = (0, utils_1.getTopology)(collection);
        options = options == null ? {} : options;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = void 0;
        const hello = topology.lastHello();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options);
        finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          // Final result
          bulkResult,
          // Current batch state
          currentBatch: void 0,
          currentIndex: 0,
          // ordered specific
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          // unordered specific
          currentInsertBatch: void 0,
          currentUpdateBatch: void 0,
          currentRemoveBatch: void 0,
          batches: [],
          // Write concern
          writeConcern: write_concern_1.WriteConcern.fromOptions(options),
          // Max batch size options
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          // Namespace
          namespace,
          // Topology
          topology,
          // Options
          options: finalOptions,
          // BSON options
          bsonOptions: (0, bson_1.resolveBSONOptions)(options),
          // Current operation
          currentOp,
          // Executed
          executed,
          // Collection
          collection,
          // Fundamental error
          err: void 0,
          // check keys
          checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : false
        };
        if (options.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      /**
       * Add a single insert document to the bulk operation
       *
       * @example
       * ```ts
       * const bulkOp = collection.initializeOrderedBulkOp();
       *
       * // Adds three inserts to the bulkOp.
       * bulkOp
       *   .insert({ a: 1 })
       *   .insert({ b: 2 })
       *   .insert({ c: 3 });
       * await bulkOp.execute();
       * ```
       */
      insert(document2) {
        if (document2._id == null && !shouldForceServerObjectId(this)) {
          document2._id = new bson_1.ObjectId();
        }
        return this.addToOperationsList(exports2.BatchType.INSERT, document2);
      }
      /**
       * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
       * Returns a builder object used to complete the definition of the operation.
       *
       * @example
       * ```ts
       * const bulkOp = collection.initializeOrderedBulkOp();
       *
       * // Add an updateOne to the bulkOp
       * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
       *
       * // Add an updateMany to the bulkOp
       * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
       *
       * // Add an upsert
       * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
       *
       * // Add a deletion
       * bulkOp.find({ g: 7 }).deleteOne();
       *
       * // Add a multi deletion
       * bulkOp.find({ h: 8 }).delete();
       *
       * // Add a replaceOne
       * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});
       *
       * // Update using a pipeline (requires Mongodb 4.2 or higher)
       * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
       *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
       * ]);
       *
       * // All of the ops will now be executed
       * await bulkOp.execute();
       * ```
       */
      find(selector) {
        if (!selector) {
          throw new error_1.MongoInvalidArgumentError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      /** Specifies a raw operation to perform in the bulk write. */
      raw(op) {
        if (op == null || typeof op !== "object") {
          throw new error_1.MongoInvalidArgumentError("Operation must be an object with an operation key");
        }
        if ("insertOne" in op) {
          const forceServerObjectId = shouldForceServerObjectId(this);
          if (op.insertOne && op.insertOne.document == null) {
            if (forceServerObjectId !== true && op.insertOne._id == null) {
              op.insertOne._id = new bson_1.ObjectId();
            }
            return this.addToOperationsList(exports2.BatchType.INSERT, op.insertOne);
          }
          if (forceServerObjectId !== true && op.insertOne.document._id == null) {
            op.insertOne.document._id = new bson_1.ObjectId();
          }
          return this.addToOperationsList(exports2.BatchType.INSERT, op.insertOne.document);
        }
        if ("replaceOne" in op || "updateOne" in op || "updateMany" in op) {
          if ("replaceOne" in op) {
            if ("q" in op.replaceOne) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
            if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
              throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
            }
            return this.addToOperationsList(exports2.BatchType.UPDATE, updateStatement);
          }
          if ("updateOne" in op) {
            if ("q" in op.updateOne) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
              ...op.updateOne,
              multi: false
            });
            if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
              throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
            }
            return this.addToOperationsList(exports2.BatchType.UPDATE, updateStatement);
          }
          if ("updateMany" in op) {
            if ("q" in op.updateMany) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
              ...op.updateMany,
              multi: true
            });
            if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
              throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
            }
            return this.addToOperationsList(exports2.BatchType.UPDATE, updateStatement);
          }
        }
        if ("deleteOne" in op) {
          if ("q" in op.deleteOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          return this.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
        }
        if ("deleteMany" in op) {
          if ("q" in op.deleteMany) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          return this.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
        }
        throw new error_1.MongoInvalidArgumentError("bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany");
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      get writeConcern() {
        return this.s.writeConcern;
      }
      get batches() {
        const batches = [...this.s.batches];
        if (this.isOrdered) {
          if (this.s.currentBatch)
            batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            batches.push(this.s.currentRemoveBatch);
        }
        return batches;
      }
      execute(options, callback) {
        callback = typeof callback === "function" ? callback : typeof options === "function" ? options : void 0;
        return (0, utils_1.maybeCallback)(async () => {
          options = options != null && typeof options !== "function" ? options : {};
          if (this.s.executed) {
            throw new error_1.MongoBatchReExecutionError();
          }
          const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
          if (writeConcern) {
            this.s.writeConcern = writeConcern;
          }
          if (this.isOrdered) {
            if (this.s.currentBatch)
              this.s.batches.push(this.s.currentBatch);
          } else {
            if (this.s.currentInsertBatch)
              this.s.batches.push(this.s.currentInsertBatch);
            if (this.s.currentUpdateBatch)
              this.s.batches.push(this.s.currentUpdateBatch);
            if (this.s.currentRemoveBatch)
              this.s.batches.push(this.s.currentRemoveBatch);
          }
          if (this.s.batches.length === 0) {
            throw new error_1.MongoInvalidArgumentError("Invalid BulkOperation, Batch cannot be empty");
          }
          this.s.executed = true;
          const finalOptions = { ...this.s.options, ...options };
          const operation = new BulkWriteShimOperation(this, finalOptions);
          return (0, execute_operation_1.executeOperation)(this.s.collection.s.db.s.client, operation);
        }, callback);
      }
      /**
       * Handles the write error before executing commands
       * @internal
       */
      handleWriteError(callback, writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          callback(new MongoBulkWriteError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }, writeResult));
          return true;
        }
        const writeConcernError = writeResult.getWriteConcernError();
        if (writeConcernError) {
          callback(new MongoBulkWriteError(writeConcernError, writeResult));
          return true;
        }
        return false;
      }
    };
    exports2.BulkOperationBase = BulkOperationBase;
    Object.defineProperty(BulkOperationBase.prototype, "length", {
      enumerable: true,
      get() {
        return this.s.currentIndex;
      }
    });
    function shouldForceServerObjectId(bulkOperation) {
      var _a, _b;
      if (typeof bulkOperation.s.options.forceServerObjectId === "boolean") {
        return bulkOperation.s.options.forceServerObjectId;
      }
      if (typeof ((_a = bulkOperation.s.collection.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId) === "boolean") {
        return (_b = bulkOperation.s.collection.s.db.options) === null || _b === void 0 ? void 0 : _b.forceServerObjectId;
      }
      return false;
    }
    function isInsertBatch(batch) {
      return batch.batchType === exports2.BatchType.INSERT;
    }
    function isUpdateBatch(batch) {
      return batch.batchType === exports2.BatchType.UPDATE;
    }
    function isDeleteBatch(batch) {
      return batch.batchType === exports2.BatchType.DELETE;
    }
    function buildCurrentOp(bulkOp) {
      let { currentOp } = bulkOp.s;
      bulkOp.s.currentOp = void 0;
      if (!currentOp)
        currentOp = {};
      return currentOp;
    }
  }
});

// asset-input/node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "asset-input/node_modules/mongodb/lib/bulk/ordered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OrderedBulkOperation = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var common_1 = require_common2();
    var OrderedBulkOperation = class extends common_1.BulkOperationBase {
      /** @internal */
      constructor(collection, options) {
        super(collection, options, true);
      }
      addToOperationsList(batchType, document2) {
        const bsonSize = BSON.calculateObjectSize(document2, {
          checkKeys: false,
          // Since we don't know what the user selected for BSON options here,
          // err on the safe side, and check the size with ignoreUndefined: false.
          ignoreUndefined: false
        });
        if (bsonSize >= this.s.maxBsonObjectSize)
          throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
        if (this.s.currentBatch == null) {
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        const maxKeySize = this.s.maxKeySize;
        if (
          // New batch if we exceed the max batch op size
          this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
          // since we can't sent an empty batch
          this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
          this.s.currentBatch.batchType !== batchType
        ) {
          this.s.batches.push(this.s.currentBatch);
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
          this.s.currentBatchSize = 0;
          this.s.currentBatchSizeBytes = 0;
        }
        if (batchType === common_1.BatchType.INSERT) {
          this.s.bulkResult.insertedIds.push({
            index: this.s.currentIndex,
            _id: document2._id
          });
        }
        if (Array.isArray(document2)) {
          throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
        }
        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
        this.s.currentBatch.operations.push(document2);
        this.s.currentBatchSize += 1;
        this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
        this.s.currentIndex += 1;
        return this;
      }
    };
    exports2.OrderedBulkOperation = OrderedBulkOperation;
  }
});

// asset-input/node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "asset-input/node_modules/mongodb/lib/bulk/unordered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnorderedBulkOperation = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var common_1 = require_common2();
    var UnorderedBulkOperation = class extends common_1.BulkOperationBase {
      /** @internal */
      constructor(collection, options) {
        super(collection, options, false);
      }
      handleWriteError(callback, writeResult) {
        if (this.s.batches.length) {
          return false;
        }
        return super.handleWriteError(callback, writeResult);
      }
      addToOperationsList(batchType, document2) {
        const bsonSize = BSON.calculateObjectSize(document2, {
          checkKeys: false,
          // Since we don't know what the user selected for BSON options here,
          // err on the safe side, and check the size with ignoreUndefined: false.
          ignoreUndefined: false
        });
        if (bsonSize >= this.s.maxBsonObjectSize) {
          throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
        }
        this.s.currentBatch = void 0;
        if (batchType === common_1.BatchType.INSERT) {
          this.s.currentBatch = this.s.currentInsertBatch;
        } else if (batchType === common_1.BatchType.UPDATE) {
          this.s.currentBatch = this.s.currentUpdateBatch;
        } else if (batchType === common_1.BatchType.DELETE) {
          this.s.currentBatch = this.s.currentRemoveBatch;
        }
        const maxKeySize = this.s.maxKeySize;
        if (this.s.currentBatch == null) {
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        if (
          // New batch if we exceed the max batch op size
          this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
          // since we can't sent an empty batch
          this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
          this.s.currentBatch.batchType !== batchType
        ) {
          this.s.batches.push(this.s.currentBatch);
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        if (Array.isArray(document2)) {
          throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
        }
        this.s.currentBatch.operations.push(document2);
        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
        this.s.currentIndex = this.s.currentIndex + 1;
        if (batchType === common_1.BatchType.INSERT) {
          this.s.currentInsertBatch = this.s.currentBatch;
          this.s.bulkResult.insertedIds.push({
            index: this.s.bulkResult.insertedIds.length,
            _id: document2._id
          });
        } else if (batchType === common_1.BatchType.UPDATE) {
          this.s.currentUpdateBatch = this.s.currentBatch;
        } else if (batchType === common_1.BatchType.DELETE) {
          this.s.currentRemoveBatch = this.s.currentBatch;
        }
        this.s.currentBatch.size += 1;
        this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
        return this;
      }
    };
    exports2.UnorderedBulkOperation = UnorderedBulkOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/aggregate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AggregateOperation = exports2.DB_AGGREGATE_COLLECTION = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    exports2.DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends command_1.CommandOperation {
      constructor(ns, pipeline2, options) {
        super(void 0, { ...options, dbName: ns.db });
        this.options = { ...options };
        this.target = ns.collection || exports2.DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline2;
        this.hasWriteStage = false;
        if (typeof (options === null || options === void 0 ? void 0 : options.out) === "string") {
          this.pipeline = this.pipeline.concat({ $out: options.out });
          this.hasWriteStage = true;
        } else if (pipeline2.length > 0) {
          const finalStage = pipeline2[pipeline2.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.trySecondaryWrite = true;
        } else {
          delete this.options.writeConcern;
        }
        if (this.explain && this.writeConcern) {
          throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
        }
        if ((options === null || options === void 0 ? void 0 : options.cursor) != null && typeof options.cursor !== "object") {
          throw new error_1.MongoInvalidArgumentError("Cursor options must be an object");
        }
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      execute(server, session, callback) {
        const options = this.options;
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const command = { aggregate: this.target, pipeline: this.pipeline };
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = void 0;
        }
        if (this.hasWriteStage && this.writeConcern) {
          Object.assign(command, { writeConcern: this.writeConcern });
        }
        if (options.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (typeof options.allowDiskUse === "boolean") {
          command.allowDiskUse = options.allowDiskUse;
        }
        if (options.hint) {
          command.hint = options.hint;
        }
        if (options.let) {
          command.let = options.let;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        command.cursor = options.cursor || {};
        if (options.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options.batchSize;
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.AggregateOperation = AggregateOperation;
    (0, operation_1.defineAspects)(AggregateOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/mongo_types.js
var require_mongo_types = __commonJS({
  "asset-input/node_modules/mongodb/lib/mongo_types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationToken = exports2.TypedEventEmitter = exports2.BSONType = void 0;
    var events_1 = require("events");
    exports2.BSONType = Object.freeze({
      double: 1,
      string: 2,
      object: 3,
      array: 4,
      binData: 5,
      undefined: 6,
      objectId: 7,
      bool: 8,
      date: 9,
      null: 10,
      regex: 11,
      dbPointer: 12,
      javascript: 13,
      symbol: 14,
      javascriptWithScope: 15,
      int: 16,
      timestamp: 17,
      long: 18,
      decimal: 19,
      minKey: -1,
      maxKey: 127
    });
    var TypedEventEmitter = class extends events_1.EventEmitter {
    };
    exports2.TypedEventEmitter = TypedEventEmitter;
    var CancellationToken = class extends TypedEventEmitter {
    };
    exports2.CancellationToken = CancellationToken;
  }
});

// asset-input/node_modules/mongodb/lib/operations/get_more.js
var require_get_more = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/get_more.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GetMoreOperation = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var operation_1 = require_operation();
    var GetMoreOperation = class extends operation_1.AbstractOperation {
      constructor(ns, cursorId, server, options) {
        super(options);
        this.options = options;
        this.ns = ns;
        this.cursorId = cursorId;
        this.server = server;
      }
      /**
       * Although there is a server already associated with the get more operation, the signature
       * for execute passes a server so we will just use that one.
       */
      execute(server, session, callback) {
        if (server !== this.server) {
          return callback(new error_1.MongoRuntimeError("Getmore must run on the same server operation began on"));
        }
        if (this.cursorId == null || this.cursorId.isZero()) {
          return callback(new error_1.MongoRuntimeError("Unable to iterate cursor with no id"));
        }
        const collection = this.ns.collection;
        if (collection == null) {
          return callback(new error_1.MongoRuntimeError("A collection name must be determined before getMore"));
        }
        const getMoreCmd = {
          getMore: this.cursorId,
          collection
        };
        if (typeof this.options.batchSize === "number") {
          getMoreCmd.batchSize = Math.abs(this.options.batchSize);
        }
        if (typeof this.options.maxAwaitTimeMS === "number") {
          getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
        }
        if (this.options.comment !== void 0 && (0, utils_1.maxWireVersion)(server) >= 9) {
          getMoreCmd.comment = this.options.comment;
        }
        const commandOptions = {
          returnFieldSelector: null,
          documentsReturnedIn: "nextBatch",
          ...this.options
        };
        server.command(this.ns, getMoreCmd, commandOptions, callback);
      }
    };
    exports2.GetMoreOperation = GetMoreOperation;
    (0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/kill_cursors.js
var require_kill_cursors = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/kill_cursors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KillCursorsOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var KillCursorsOperation = class extends operation_1.AbstractOperation {
      constructor(cursorId, ns, server, options) {
        super(options);
        this.ns = ns;
        this.cursorId = cursorId;
        this.server = server;
      }
      execute(server, session, callback) {
        if (server !== this.server) {
          return callback(new error_1.MongoRuntimeError("Killcursor must run on the same server operation began on"));
        }
        const killCursors = this.ns.collection;
        if (killCursors == null) {
          return callback(new error_1.MongoRuntimeError("A collection name must be determined before killCursors"));
        }
        const killCursorsCommand = {
          killCursors,
          cursors: [this.cursorId]
        };
        server.command(this.ns, killCursorsCommand, { session }, () => callback());
      }
    };
    exports2.KillCursorsOperation = KillCursorsOperation;
    (0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
  }
});

// asset-input/node_modules/mongodb/lib/cmap/metrics.js
var require_metrics = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/metrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionPoolMetrics = void 0;
    var ConnectionPoolMetrics = class _ConnectionPoolMetrics {
      constructor() {
        this.txnConnections = 0;
        this.cursorConnections = 0;
        this.otherConnections = 0;
      }
      /**
       * Mark a connection as pinned for a specific operation.
       */
      markPinned(pinType) {
        if (pinType === _ConnectionPoolMetrics.TXN) {
          this.txnConnections += 1;
        } else if (pinType === _ConnectionPoolMetrics.CURSOR) {
          this.cursorConnections += 1;
        } else {
          this.otherConnections += 1;
        }
      }
      /**
       * Unmark a connection as pinned for an operation.
       */
      markUnpinned(pinType) {
        if (pinType === _ConnectionPoolMetrics.TXN) {
          this.txnConnections -= 1;
        } else if (pinType === _ConnectionPoolMetrics.CURSOR) {
          this.cursorConnections -= 1;
        } else {
          this.otherConnections -= 1;
        }
      }
      /**
       * Return information about the cmap metrics as a string.
       */
      info(maxPoolSize) {
        return `Timed out while checking out a connection from connection pool: maxPoolSize: ${maxPoolSize}, connections in use by cursors: ${this.cursorConnections}, connections in use by transactions: ${this.txnConnections}, connections in use by other operations: ${this.otherConnections}`;
      }
      /**
       * Reset the metrics to the initial values.
       */
      reset() {
        this.txnConnections = 0;
        this.cursorConnections = 0;
        this.otherConnections = 0;
      }
    };
    exports2.ConnectionPoolMetrics = ConnectionPoolMetrics;
    ConnectionPoolMetrics.TXN = "txn";
    ConnectionPoolMetrics.CURSOR = "cursor";
    ConnectionPoolMetrics.OTHER = "other";
  }
});

// asset-input/node_modules/mongodb/lib/sdam/server_description.js
var require_server_description = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/server_description.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compareTopologyVersion = exports2.parseServerType = exports2.ServerDescription = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var common_1 = require_common();
    var WRITABLE_SERVER_TYPES = /* @__PURE__ */ new Set([
      common_1.ServerType.RSPrimary,
      common_1.ServerType.Standalone,
      common_1.ServerType.Mongos,
      common_1.ServerType.LoadBalancer
    ]);
    var DATA_BEARING_SERVER_TYPES = /* @__PURE__ */ new Set([
      common_1.ServerType.RSPrimary,
      common_1.ServerType.RSSecondary,
      common_1.ServerType.Mongos,
      common_1.ServerType.Standalone,
      common_1.ServerType.LoadBalancer
    ]);
    var ServerDescription = class {
      /**
       * Create a ServerDescription
       * @internal
       *
       * @param address - The address of the server
       * @param hello - An optional hello response for this server
       */
      constructor(address, hello, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        if (address == null || address === "") {
          throw new error_1.MongoRuntimeError("ServerDescription must be provided with a non-empty address");
        }
        this.address = typeof address === "string" ? utils_1.HostAddress.fromString(address).toString() : address.toString();
        this.type = parseServerType(hello, options);
        this.hosts = (_b = (_a = hello === null || hello === void 0 ? void 0 : hello.hosts) === null || _a === void 0 ? void 0 : _a.map((host) => host.toLowerCase())) !== null && _b !== void 0 ? _b : [];
        this.passives = (_d = (_c = hello === null || hello === void 0 ? void 0 : hello.passives) === null || _c === void 0 ? void 0 : _c.map((host) => host.toLowerCase())) !== null && _d !== void 0 ? _d : [];
        this.arbiters = (_f = (_e = hello === null || hello === void 0 ? void 0 : hello.arbiters) === null || _e === void 0 ? void 0 : _e.map((host) => host.toLowerCase())) !== null && _f !== void 0 ? _f : [];
        this.tags = (_g = hello === null || hello === void 0 ? void 0 : hello.tags) !== null && _g !== void 0 ? _g : {};
        this.minWireVersion = (_h = hello === null || hello === void 0 ? void 0 : hello.minWireVersion) !== null && _h !== void 0 ? _h : 0;
        this.maxWireVersion = (_j = hello === null || hello === void 0 ? void 0 : hello.maxWireVersion) !== null && _j !== void 0 ? _j : 0;
        this.roundTripTime = (_k = options === null || options === void 0 ? void 0 : options.roundTripTime) !== null && _k !== void 0 ? _k : -1;
        this.lastUpdateTime = (0, utils_1.now)();
        this.lastWriteDate = (_m = (_l = hello === null || hello === void 0 ? void 0 : hello.lastWrite) === null || _l === void 0 ? void 0 : _l.lastWriteDate) !== null && _m !== void 0 ? _m : 0;
        this.error = (_o = options.error) !== null && _o !== void 0 ? _o : null;
        this.topologyVersion = (_r = (_q = (_p = this.error) === null || _p === void 0 ? void 0 : _p.topologyVersion) !== null && _q !== void 0 ? _q : hello === null || hello === void 0 ? void 0 : hello.topologyVersion) !== null && _r !== void 0 ? _r : null;
        this.setName = (_s = hello === null || hello === void 0 ? void 0 : hello.setName) !== null && _s !== void 0 ? _s : null;
        this.setVersion = (_t = hello === null || hello === void 0 ? void 0 : hello.setVersion) !== null && _t !== void 0 ? _t : null;
        this.electionId = (_u = hello === null || hello === void 0 ? void 0 : hello.electionId) !== null && _u !== void 0 ? _u : null;
        this.logicalSessionTimeoutMinutes = (_v = hello === null || hello === void 0 ? void 0 : hello.logicalSessionTimeoutMinutes) !== null && _v !== void 0 ? _v : null;
        this.primary = (_w = hello === null || hello === void 0 ? void 0 : hello.primary) !== null && _w !== void 0 ? _w : null;
        this.me = (_y = (_x = hello === null || hello === void 0 ? void 0 : hello.me) === null || _x === void 0 ? void 0 : _x.toLowerCase()) !== null && _y !== void 0 ? _y : null;
        this.$clusterTime = (_z = hello === null || hello === void 0 ? void 0 : hello.$clusterTime) !== null && _z !== void 0 ? _z : null;
      }
      get hostAddress() {
        return utils_1.HostAddress.fromString(this.address);
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      /** Is this server available for reads*/
      get isReadable() {
        return this.type === common_1.ServerType.RSSecondary || this.isWritable;
      }
      /** Is this server data bearing */
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      /** Is this server available for writes */
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : 27017;
      }
      /**
       * Determines if another `ServerDescription` is equal to this one per the rules defined
       * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}
       */
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === (other === null || other === void 0 ? void 0 : other.topologyVersion) || compareTopologyVersion(this.topologyVersion, other === null || other === void 0 ? void 0 : other.topologyVersion) === 0;
        const electionIdsEqual = this.electionId != null && (other === null || other === void 0 ? void 0 : other.electionId) != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === (other === null || other === void 0 ? void 0 : other.electionId);
        return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    exports2.ServerDescription = ServerDescription;
    function parseServerType(hello, options) {
      if (options === null || options === void 0 ? void 0 : options.loadBalanced) {
        return common_1.ServerType.LoadBalancer;
      }
      if (!hello || !hello.ok) {
        return common_1.ServerType.Unknown;
      }
      if (hello.isreplicaset) {
        return common_1.ServerType.RSGhost;
      }
      if (hello.msg && hello.msg === "isdbgrid") {
        return common_1.ServerType.Mongos;
      }
      if (hello.setName) {
        if (hello.hidden) {
          return common_1.ServerType.RSOther;
        } else if (hello.isWritablePrimary) {
          return common_1.ServerType.RSPrimary;
        } else if (hello.secondary) {
          return common_1.ServerType.RSSecondary;
        } else if (hello.arbiterOnly) {
          return common_1.ServerType.RSArbiter;
        } else {
          return common_1.ServerType.RSOther;
        }
      }
      return common_1.ServerType.Standalone;
    }
    exports2.parseServerType = parseServerType;
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function compareTopologyVersion(currentTv, newTv) {
      if (currentTv == null || newTv == null) {
        return -1;
      }
      if (!currentTv.processId.equals(newTv.processId)) {
        return -1;
      }
      const currentCounter = bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
      const newCounter = bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
      return currentCounter.compare(newCounter);
    }
    exports2.compareTopologyVersion = compareTopologyVersion;
  }
});

// asset-input/node_modules/mongodb/lib/sdam/topology_description.js
var require_topology_description = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/topology_description.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TopologyDescription = void 0;
    var WIRE_CONSTANTS = require_constants2();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var common_1 = require_common();
    var server_description_1 = require_server_description();
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MONGOS_OR_UNKNOWN = /* @__PURE__ */ new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
    var MONGOS_OR_STANDALONE = /* @__PURE__ */ new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
    var NON_PRIMARY_RS_MEMBERS = /* @__PURE__ */ new Set([
      common_1.ServerType.RSSecondary,
      common_1.ServerType.RSArbiter,
      common_1.ServerType.RSOther
    ]);
    var TopologyDescription = class _TopologyDescription {
      /**
       * Create a TopologyDescription
       */
      constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options = null) {
        var _a, _b;
        options = options !== null && options !== void 0 ? options : {};
        this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;
        this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : /* @__PURE__ */ new Map();
        this.stale = false;
        this.compatible = true;
        this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;
        this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 15;
        this.setName = setName !== null && setName !== void 0 ? setName : null;
        this.maxElectionId = maxElectionId !== null && maxElectionId !== void 0 ? maxElectionId : null;
        this.maxSetVersion = maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : null;
        this.commonWireVersion = commonWireVersion !== null && commonWireVersion !== void 0 ? commonWireVersion : 0;
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
            continue;
          }
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const [, server] of this.servers) {
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
          }
        }
      }
      /**
       * Returns a new TopologyDescription based on the SrvPollingEvent
       * @internal
       */
      updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
        const incomingHostnames = ev.hostnames();
        const currentHostnames = new Set(this.servers.keys());
        const hostnamesToAdd = new Set(incomingHostnames);
        const hostnamesToRemove = /* @__PURE__ */ new Set();
        for (const hostname of currentHostnames) {
          hostnamesToAdd.delete(hostname);
          if (!incomingHostnames.has(hostname)) {
            hostnamesToRemove.add(hostname);
          }
        }
        if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
          return this;
        }
        const serverDescriptions = new Map(this.servers);
        for (const removedHost of hostnamesToRemove) {
          serverDescriptions.delete(removedHost);
        }
        if (hostnamesToAdd.size > 0) {
          if (srvMaxHosts === 0) {
            for (const hostToAdd of hostnamesToAdd) {
              serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
            }
          } else if (serverDescriptions.size < srvMaxHosts) {
            const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
            for (const selectedHostToAdd of selectedHosts) {
              serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
            }
          }
        }
        return new _TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      /**
       * Returns a copy of this description updated with a given ServerDescription
       * @internal
       */
      update(serverDescription) {
        const address = serverDescription.address;
        let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
        const serverType = serverDescription.type;
        const serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        if (typeof serverDescription.setName === "string" && typeof setName === "string" && serverDescription.setName !== setName) {
          if (topologyType === common_1.TopologyType.Single) {
            serverDescription = new server_description_1.ServerDescription(address);
          } else {
            serverDescriptions.delete(address);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === common_1.TopologyType.Single) {
          return new _TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
        }
        if (topologyType === common_1.TopologyType.Unknown) {
          if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === common_1.TopologyType.Sharded) {
          if (!MONGOS_OR_UNKNOWN.has(serverType)) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
          if (MONGOS_OR_STANDALONE.has(serverType)) {
            serverDescriptions.delete(address);
          }
          if (serverType === common_1.ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
            topologyType = result[0];
            setName = result[1];
            maxSetVersion = result[2];
            maxElectionId = result[3];
          } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
            topologyType = result[0];
            setName = result[1];
          }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
          if (MONGOS_OR_STANDALONE.has(serverType)) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === common_1.ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
            topologyType = result[0];
            setName = result[1];
            maxSetVersion = result[2];
            maxElectionId = result[3];
          } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new _TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return null;
      }
      /**
       * Determines if the topology description has any known servers
       */
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
      }
      /**
       * Determines if this topology description has a data-bearing server available.
       */
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      /**
       * Determines if the topology has a definition for the provided address
       * @internal
       */
      hasServer(address) {
        return this.servers.has(address);
      }
    };
    exports2.TopologyDescription = TopologyDescription;
    function topologyTypeForServerType(serverType) {
      switch (serverType) {
        case common_1.ServerType.Standalone:
          return common_1.TopologyType.Single;
        case common_1.ServerType.Mongos:
          return common_1.TopologyType.Sharded;
        case common_1.ServerType.RSPrimary:
          return common_1.TopologyType.ReplicaSetWithPrimary;
        case common_1.ServerType.RSOther:
        case common_1.ServerType.RSSecondary:
          return common_1.TopologyType.ReplicaSetNoPrimary;
        default:
          return common_1.TopologyType.Unknown;
      }
    }
    function updateRsFromPrimary(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
      var _a;
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      if (serverDescription.maxWireVersion >= 17) {
        const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
        const maxElectionIdIsEqual = electionIdComparison === 0;
        const maxElectionIdIsLess = electionIdComparison === -1;
        const maxSetVersionIsLessOrEqual = (maxSetVersion !== null && maxSetVersion !== void 0 ? maxSetVersion : -1) <= ((_a = serverDescription.setVersion) !== null && _a !== void 0 ? _a : -1);
        if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
          maxElectionId = serverDescription.electionId;
          maxSetVersion = serverDescription.setVersion;
        } else {
          serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
        }
      } else {
        const electionId = serverDescription.electionId ? serverDescription.electionId : null;
        if (serverDescription.setVersion && electionId) {
          if (maxSetVersion && maxElectionId) {
            if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
              serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
              return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
            }
          }
          maxElectionId = serverDescription.electionId;
        }
        if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
          maxSetVersion = serverDescription.setVersion;
        }
      }
      for (const [address, server] of serverDescriptions) {
        if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
      if (setName == null) {
        throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
      const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
      setName = setName !== null && setName !== void 0 ? setName : serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const serverDescription of serverDescriptions.values()) {
        if (serverDescription.type === common_1.ServerType.RSPrimary) {
          return common_1.TopologyType.ReplicaSetWithPrimary;
        }
      }
      return common_1.TopologyType.ReplicaSetNoPrimary;
    }
  }
});

// asset-input/node_modules/mongodb/lib/cmap/wire_protocol/shared.js
var require_shared = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/wire_protocol/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSharded = exports2.applyCommonQueryOptions = exports2.getReadPreference = void 0;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var topology_description_1 = require_topology_description();
    function getReadPreference(cmd, options) {
      let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary;
      if (options === null || options === void 0 ? void 0 : options.readPreference) {
        readPreference = options.readPreference;
      }
      if (typeof readPreference === "string") {
        readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      }
      if (!(readPreference instanceof read_preference_1.ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
      }
      return readPreference;
    }
    exports2.getReadPreference = getReadPreference;
    function applyCommonQueryOptions(queryOptions, options) {
      Object.assign(queryOptions, {
        raw: typeof options.raw === "boolean" ? options.raw : false,
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
        bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
        enableUtf8Validation: typeof options.enableUtf8Validation === "boolean" ? options.enableUtf8Validation : true
      });
      if (options.session) {
        queryOptions.session = options.session;
      }
      return queryOptions;
    }
    exports2.applyCommonQueryOptions = applyCommonQueryOptions;
    function isSharded(topologyOrServer) {
      if (topologyOrServer == null) {
        return false;
      }
      if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === common_1.ServerType.Mongos);
      }
      return false;
    }
    exports2.isSharded = isSharded;
  }
});

// asset-input/node_modules/mongodb/lib/transactions.js
var require_transactions = __commonJS({
  "asset-input/node_modules/mongodb/lib/transactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTransactionCommand = exports2.Transaction = exports2.TxnState = void 0;
    var error_1 = require_error();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var write_concern_1 = require_write_concern();
    exports2.TxnState = Object.freeze({
      NO_TRANSACTION: "NO_TRANSACTION",
      STARTING_TRANSACTION: "STARTING_TRANSACTION",
      TRANSACTION_IN_PROGRESS: "TRANSACTION_IN_PROGRESS",
      TRANSACTION_COMMITTED: "TRANSACTION_COMMITTED",
      TRANSACTION_COMMITTED_EMPTY: "TRANSACTION_COMMITTED_EMPTY",
      TRANSACTION_ABORTED: "TRANSACTION_ABORTED"
    });
    var stateMachine = {
      [exports2.TxnState.NO_TRANSACTION]: [exports2.TxnState.NO_TRANSACTION, exports2.TxnState.STARTING_TRANSACTION],
      [exports2.TxnState.STARTING_TRANSACTION]: [
        exports2.TxnState.TRANSACTION_IN_PROGRESS,
        exports2.TxnState.TRANSACTION_COMMITTED,
        exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports2.TxnState.TRANSACTION_ABORTED
      ],
      [exports2.TxnState.TRANSACTION_IN_PROGRESS]: [
        exports2.TxnState.TRANSACTION_IN_PROGRESS,
        exports2.TxnState.TRANSACTION_COMMITTED,
        exports2.TxnState.TRANSACTION_ABORTED
      ],
      [exports2.TxnState.TRANSACTION_COMMITTED]: [
        exports2.TxnState.TRANSACTION_COMMITTED,
        exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports2.TxnState.STARTING_TRANSACTION,
        exports2.TxnState.NO_TRANSACTION
      ],
      [exports2.TxnState.TRANSACTION_ABORTED]: [exports2.TxnState.STARTING_TRANSACTION, exports2.TxnState.NO_TRANSACTION],
      [exports2.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
        exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports2.TxnState.NO_TRANSACTION
      ]
    };
    var ACTIVE_STATES = /* @__PURE__ */ new Set([
      exports2.TxnState.STARTING_TRANSACTION,
      exports2.TxnState.TRANSACTION_IN_PROGRESS
    ]);
    var COMMITTED_STATES = /* @__PURE__ */ new Set([
      exports2.TxnState.TRANSACTION_COMMITTED,
      exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports2.TxnState.TRANSACTION_ABORTED
    ]);
    var Transaction = class {
      /** Create a transaction @internal */
      constructor(options) {
        options = options !== null && options !== void 0 ? options : {};
        this.state = exports2.TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (writeConcern) {
          if (writeConcern.w === 0) {
            throw new error_1.MongoTransactionError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options.readConcern) {
          this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
        }
        if (options.readPreference) {
          this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
        }
        if (options.maxCommitTimeMS) {
          this.options.maxTimeMS = options.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      /** @internal */
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      /** @returns Whether the transaction has started */
      get isStarting() {
        return this.state === exports2.TxnState.STARTING_TRANSACTION;
      }
      /**
       * @returns Whether this session is presently in a transaction
       */
      get isActive() {
        return ACTIVE_STATES.has(this.state);
      }
      get isCommitted() {
        return COMMITTED_STATES.has(this.state);
      }
      /**
       * Transition the transaction in the state machine
       * @internal
       * @param nextState - The new state to transition to
       */
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.includes(nextState)) {
          this.state = nextState;
          if (this.state === exports2.TxnState.NO_TRANSACTION || this.state === exports2.TxnState.STARTING_TRANSACTION || this.state === exports2.TxnState.TRANSACTION_ABORTED) {
            this.unpinServer();
          }
          return;
        }
        throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      /** @internal */
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      /** @internal */
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    exports2.Transaction = Transaction;
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
    exports2.isTransactionCommand = isTransactionCommand;
  }
});

// asset-input/node_modules/mongodb/lib/sessions.js
var require_sessions = __commonJS({
  "asset-input/node_modules/mongodb/lib/sessions.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSessionFromResponse = exports2.applySession = exports2.ServerSessionPool = exports2.ServerSession = exports2.maybeClearPinnedConnection = exports2.ClientSession = void 0;
    var util_1 = require("util");
    var bson_1 = require_bson2();
    var metrics_1 = require_metrics();
    var shared_1 = require_shared();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var execute_operation_1 = require_execute_operation();
    var run_command_1 = require_run_command();
    var promise_provider_1 = require_promise_provider();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils2();
    var minWireVersionForShardedTransactions = 8;
    var kServerSession = Symbol("serverSession");
    var kSnapshotTime = Symbol("snapshotTime");
    var kSnapshotEnabled = Symbol("snapshotEnabled");
    var kPinnedConnection = Symbol("pinnedConnection");
    var kTxnNumberIncrement = Symbol("txnNumberIncrement");
    var ClientSession = class _ClientSession extends mongo_types_1.TypedEventEmitter {
      /**
       * Create a client session.
       * @internal
       * @param client - The current client
       * @param sessionPool - The server session pool (Internal Class)
       * @param options - Optional settings
       * @param clientOptions - Optional settings provided when creating a MongoClient
       */
      constructor(client, sessionPool, options, clientOptions) {
        var _b;
        super();
        this[_a] = false;
        if (client == null) {
          throw new error_1.MongoRuntimeError("ClientSession requires a MongoClient");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new error_1.MongoRuntimeError("ClientSession requires a ServerSessionPool");
        }
        options = options !== null && options !== void 0 ? options : {};
        if (options.snapshot === true) {
          this[kSnapshotEnabled] = true;
          if (options.causalConsistency === true) {
            throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
          }
        }
        this.client = client;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this.explicit = !!options.explicit;
        this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;
        this[kTxnNumberIncrement] = 0;
        const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;
        this.supports = {
          // if we can enable causal consistency, do so by default
          causalConsistency: (_b = options.causalConsistency) !== null && _b !== void 0 ? _b : defaultCausalConsistencyValue
        };
        this.clusterTime = options.initialClusterTime;
        this.operationTime = void 0;
        this.owner = options.owner;
        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
        this.transaction = new transactions_1.Transaction();
      }
      /** The server id associated with this session */
      get id() {
        var _b;
        return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;
      }
      get serverSession() {
        let serverSession = this[kServerSession];
        if (serverSession == null) {
          if (this.explicit) {
            throw new error_1.MongoRuntimeError("Unexpected null serverSession for an explicit session");
          }
          if (this.hasEnded) {
            throw new error_1.MongoRuntimeError("Unexpected null serverSession for an ended implicit session");
          }
          serverSession = this.sessionPool.acquire();
          this[kServerSession] = serverSession;
        }
        return serverSession;
      }
      /** Whether or not this session is configured for snapshot reads */
      get snapshotEnabled() {
        return this[kSnapshotEnabled];
      }
      get loadBalanced() {
        var _b;
        return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;
      }
      /** @internal */
      get pinnedConnection() {
        return this[kPinnedConnection];
      }
      /** @internal */
      pin(conn) {
        if (this[kPinnedConnection]) {
          throw TypeError("Cannot pin multiple connections to the same session");
        }
        this[kPinnedConnection] = conn;
        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
      }
      /** @internal */
      unpin(options) {
        if (this.loadBalanced) {
          return maybeClearPinnedConnection(this, options);
        }
        this.transaction.unpinServer();
      }
      get isPinned() {
        return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
      }
      endSession(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        const finalOptions = { force: true, ...options };
        return (0, utils_1.maybeCallback)(async () => {
          try {
            if (this.inTransaction()) {
              await this.abortTransaction();
            }
            if (!this.hasEnded) {
              const serverSession = this[kServerSession];
              if (serverSession != null) {
                this.sessionPool.release(serverSession);
                Object.defineProperty(this, kServerSession, {
                  value: ServerSession.clone(serverSession),
                  writable: false
                });
              }
              this.hasEnded = true;
              this.emit("ended", this);
            }
          } catch {
          } finally {
            maybeClearPinnedConnection(this, finalOptions);
          }
        }, callback);
      }
      /**
       * Advances the operationTime for a ClientSession.
       *
       * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
       */
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      /**
       * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
       *
       * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
       */
      advanceClusterTime(clusterTime) {
        var _b, _c;
        if (!clusterTime || typeof clusterTime !== "object") {
          throw new error_1.MongoInvalidArgumentError("input cluster time must be an object");
        }
        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== "Timestamp") {
          throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
        }
        if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== "Binary" || typeof clusterTime.signature.keyId !== "number" && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== "Long") {
          throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
        }
        (0, common_1._advanceClusterTime)(this, clusterTime);
      }
      /**
       * Used to determine if this session equals another
       *
       * @param session - The session to compare to
       */
      equals(session) {
        if (!(session instanceof _ClientSession)) {
          return false;
        }
        if (this.id == null || session.id == null) {
          return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
      }
      /**
       * Increment the transaction number on the internal ServerSession
       *
       * @privateRemarks
       * This helper increments a value stored on the client session that will be
       * added to the serverSession's txnNumber upon applying it to a command.
       * This is because the serverSession is lazily acquired after a connection is obtained
       */
      incrementTransactionNumber() {
        this[kTxnNumberIncrement] += 1;
      }
      /** @returns whether this session is currently in a transaction or not */
      inTransaction() {
        return this.transaction.isActive;
      }
      /**
       * Starts a new transaction with the given options.
       *
       * @param options - Options for the transaction
       */
      startTransaction(options) {
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this[kSnapshotEnabled]) {
          throw new error_1.MongoCompatibilityError("Transactions are not supported in snapshot sessions");
        }
        if (this.inTransaction()) {
          throw new error_1.MongoTransactionError("Transaction already in progress");
        }
        if (this.isPinned && this.transaction.isCommitted) {
          this.unpin();
        }
        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
        if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new error_1.MongoCompatibilityError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.incrementTransactionNumber();
        this.transaction = new transactions_1.Transaction({
          readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,
          writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,
          readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,
          maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS
        });
        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
      }
      commitTransaction(callback) {
        return (0, utils_1.maybeCallback)(async () => endTransactionAsync(this, "commitTransaction"), callback);
      }
      abortTransaction(callback) {
        return (0, utils_1.maybeCallback)(async () => endTransactionAsync(this, "abortTransaction"), callback);
      }
      /**
       * This is here to ensure that ClientSession is never serialized to BSON.
       */
      toBSON() {
        throw new error_1.MongoRuntimeError("ClientSession cannot be serialized to BSON.");
      }
      /**
       * Runs a provided callback within a transaction, retrying either the commitTransaction operation
       * or entire transaction as needed (and when the error permits) to better ensure that
       * the transaction can complete successfully.
       *
       * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.
       * Any callbacks that do not return a Promise will result in undefined behavior.
       *
       * @remarks
       * This function:
       * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)
       * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`
       * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback
       *
       * Checkout a descriptive example here:
       * @see https://www.mongodb.com/developer/quickstart/node-transactions/
       *
       * @param fn - callback to run within a transaction
       * @param options - optional settings for the transaction
       * @returns A raw command response or undefined
       */
      withTransaction(fn, options) {
        const startTime = (0, utils_1.now)();
        return attemptTransaction(this, startTime, fn, options);
      }
    };
    exports2.ClientSession = ClientSession;
    _a = kSnapshotEnabled;
    var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = /* @__PURE__ */ new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function hasNotTimedOut(startTime, max) {
      return (0, utils_1.calculateDurationInMs)(startTime) < max;
    }
    function isUnknownTransactionCommitResult(err) {
      const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
      return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
    }
    function maybeClearPinnedConnection(session, options) {
      const conn = session[kPinnedConnection];
      const error = options === null || options === void 0 ? void 0 : options.error;
      if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return;
      }
      const topology = session.client.topology;
      if (conn && topology != null) {
        const servers = Array.from(topology.s.servers.values());
        const loadBalancer = servers[0];
        if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {
          loadBalancer.s.pool.checkIn(conn);
          conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
          if (options === null || options === void 0 ? void 0 : options.forceClear) {
            loadBalancer.s.pool.clear({ serviceId: conn.serviceId });
          }
        }
        session[kPinnedConnection] = void 0;
      }
    }
    exports2.maybeClearPinnedConnection = maybeClearPinnedConnection;
    function isMaxTimeMSExpiredError(err) {
      if (err == null || !(err instanceof error_1.MongoServerError)) {
        return false;
      }
      return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
    }
    function attemptTransactionCommit(session, startTime, fn, options) {
      return session.commitTransaction().catch((err) => {
        if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
          if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {
            return attemptTransactionCommit(session, startTime, fn, options);
          }
          if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
            return attemptTransaction(session, startTime, fn, options);
          }
        }
        throw err;
      });
    }
    var USER_EXPLICIT_TXN_END_STATES = /* @__PURE__ */ new Set([
      transactions_1.TxnState.NO_TRANSACTION,
      transactions_1.TxnState.TRANSACTION_COMMITTED,
      transactions_1.TxnState.TRANSACTION_ABORTED
    ]);
    function userExplicitlyEndedTransaction(session) {
      return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
    }
    function attemptTransaction(session, startTime, fn, options) {
      var _b;
      session.startTransaction(options);
      let promise;
      try {
        promise = fn(session);
      } catch (err) {
        const PromiseConstructor = (_b = promise_provider_1.PromiseProvider.get()) !== null && _b !== void 0 ? _b : Promise;
        promise = PromiseConstructor.reject(err);
      }
      if (!(0, utils_1.isPromiseLike)(promise)) {
        session.abortTransaction().catch(() => null);
        throw new error_1.MongoInvalidArgumentError("Function provided to `withTransaction` must return a Promise");
      }
      return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
          return;
        }
        return attemptTransactionCommit(session, startTime, fn, options);
      }, (err) => {
        function maybeRetryOrThrow(err2) {
          if (err2 instanceof error_1.MongoError && err2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
            return attemptTransaction(session, startTime, fn, options);
          }
          if (isMaxTimeMSExpiredError(err2)) {
            err2.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
          }
          throw err2;
        }
        if (session.inTransaction()) {
          return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
      });
    }
    var endTransactionAsync = (0, util_1.promisify)(endTransaction);
    function endTransaction(session, commandName, callback) {
      const txnState = session.transaction.state;
      if (txnState === transactions_1.TxnState.NO_TRANSACTION) {
        callback(new error_1.MongoTransactionError("No transaction started"));
        return;
      }
      if (commandName === "commitTransaction") {
        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
          session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
          callback();
          return;
        }
        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
          callback(new error_1.MongoTransactionError("Cannot call commitTransaction after calling abortTransaction"));
          return;
        }
      } else {
        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {
          session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
          callback();
          return;
        }
        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
          callback(new error_1.MongoTransactionError("Cannot call abortTransaction twice"));
          return;
        }
        if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
          callback(new error_1.MongoTransactionError("Cannot call abortTransaction after calling commitTransaction"));
          return;
        }
      }
      const command = { [commandName]: 1 };
      let writeConcern;
      if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
      } else if (session.clientOptions && session.clientOptions.writeConcern) {
        writeConcern = { w: session.clientOptions.writeConcern.w };
      }
      if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({ wtimeout: 1e4 }, writeConcern, { w: "majority" });
      }
      if (writeConcern) {
        Object.assign(command, { writeConcern });
      }
      if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
      }
      function commandHandler(error, result) {
        if (commandName !== "commitTransaction") {
          session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
          if (session.loadBalanced) {
            maybeClearPinnedConnection(session, { force: false });
          }
          return callback();
        }
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
        if (error instanceof error_1.MongoError) {
          if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {
            if (isUnknownTransactionCommitResult(error)) {
              error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
              session.unpin({ error });
            }
          } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
            session.unpin({ error });
          }
        }
        callback(error, result);
      }
      if (session.transaction.recoveryToken) {
        command.recoveryToken = session.transaction.recoveryToken;
      }
      (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(void 0, command, {
        session,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
      }), (error, result) => {
        if (command.abortTransaction) {
          session.unpin();
        }
        if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {
          if (command.commitTransaction) {
            session.unpin({ force: true });
            command.writeConcern = Object.assign({ wtimeout: 1e4 }, command.writeConcern, {
              w: "majority"
            });
          }
          return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(void 0, command, {
            session,
            readPreference: read_preference_1.ReadPreference.primary,
            bypassPinningCheck: true
          }), commandHandler);
        }
        commandHandler(error, result);
      });
    }
    var ServerSession = class _ServerSession {
      /** @internal */
      constructor() {
        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
        this.lastUse = (0, utils_1.now)();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      /**
       * Determines if the server session has timed out.
       *
       * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
       */
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
      /**
       * @internal
       * Cloning meant to keep a readable reference to the server session data
       * after ClientSession has ended
       */
      static clone(serverSession) {
        const arrayBuffer = new ArrayBuffer(16);
        const idBytes = Buffer.from(arrayBuffer);
        idBytes.set(serverSession.id.id.buffer);
        const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);
        return Object.setPrototypeOf({
          id: { id },
          lastUse: serverSession.lastUse,
          txnNumber: serverSession.txnNumber,
          isDirty: serverSession.isDirty
        }, _ServerSession.prototype);
      }
    };
    exports2.ServerSession = ServerSession;
    var ServerSessionPool = class {
      constructor(client) {
        if (client == null) {
          throw new error_1.MongoRuntimeError("ServerSessionPool requires a MongoClient");
        }
        this.client = client;
        this.sessions = new utils_1.List();
      }
      /**
       * Acquire a Server Session from the pool.
       * Iterates through each session in the pool, removing any stale sessions
       * along the way. The first non-stale session found is removed from the
       * pool and returned. If no non-stale session is found, a new ServerSession is created.
       */
      acquire() {
        var _b, _c, _d;
        const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;
        let session = null;
        while (this.sessions.length > 0) {
          const potentialSession = this.sessions.shift();
          if (potentialSession != null && (!!((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
            session = potentialSession;
            break;
          }
        }
        if (session == null) {
          session = new ServerSession();
        }
        return session;
      }
      /**
       * Release a session to the session pool
       * Adds the session back to the session pool if the session has not timed out yet.
       * This method also removes any stale sessions from the pool.
       *
       * @param session - The session to release to the pool
       */
      release(session) {
        var _b, _c, _d;
        const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;
        if (((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) && !sessionTimeoutMinutes) {
          this.sessions.unshift(session);
        }
        if (!sessionTimeoutMinutes) {
          return;
        }
        this.sessions.prune((session2) => session2.hasTimedOut(sessionTimeoutMinutes));
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    exports2.ServerSessionPool = ServerSessionPool;
    function applySession(session, command, options) {
      var _b, _c;
      if (session.hasEnded) {
        return new error_1.MongoExpiredSessionError();
      }
      const serverSession = session.serverSession;
      if (serverSession == null) {
        return new error_1.MongoRuntimeError("Unable to acquire server session");
      }
      if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {
        if (session && session.explicit) {
          return new error_1.MongoAPIError("Cannot have explicit session with unacknowledged writes");
        }
        return;
      }
      serverSession.lastUse = (0, utils_1.now)();
      command.lsid = serverSession.id;
      const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
      const isRetryableWrite = !!options.willRetryWrite;
      if (isRetryableWrite || inTxnOrTxnCommand) {
        serverSession.txnNumber += session[kTxnNumberIncrement];
        session[kTxnNumberIncrement] = 0;
        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTxnOrTxnCommand) {
        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
          session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        } else if (session[kSnapshotEnabled]) {
          command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
          if (session[kSnapshotTime] != null) {
            Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });
          }
        }
        return;
      }
      command.autocommit = false;
      if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
      }
      return;
    }
    exports2.applySession = applySession;
    function updateSessionFromResponse(session, document2) {
      var _b;
      if (document2.$clusterTime) {
        (0, common_1._advanceClusterTime)(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
      if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {
        const atClusterTime = ((_b = document2.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document2.atClusterTime;
        if (atClusterTime) {
          session[kSnapshotTime] = atClusterTime;
        }
      }
    }
    exports2.updateSessionFromResponse = updateSessionFromResponse;
  }
});

// asset-input/node_modules/mongodb/lib/cursor/abstract_cursor.js
var require_abstract_cursor = __commonJS({
  "asset-input/node_modules/mongodb/lib/cursor/abstract_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertUninitialized = exports2.next = exports2.AbstractCursor = exports2.CURSOR_FLAGS = void 0;
    var stream_1 = require("stream");
    var util_1 = require("util");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var execute_operation_1 = require_execute_operation();
    var get_more_1 = require_get_more();
    var kill_cursors_1 = require_kill_cursors();
    var promise_provider_1 = require_promise_provider();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var sessions_1 = require_sessions();
    var utils_1 = require_utils2();
    var kId = Symbol("id");
    var kDocuments = Symbol("documents");
    var kServer = Symbol("server");
    var kNamespace = Symbol("namespace");
    var kClient = Symbol("client");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kTransform = Symbol("transform");
    var kInitialized = Symbol("initialized");
    var kClosed = Symbol("closed");
    var kKilled = Symbol("killed");
    var kInit = Symbol("kInit");
    exports2.CURSOR_FLAGS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "exhaust",
      "partial"
    ];
    var AbstractCursor = class extends mongo_types_1.TypedEventEmitter {
      /** @internal */
      constructor(client, namespace, options = {}) {
        super();
        if (!client.s.isMongoClient) {
          throw new error_1.MongoRuntimeError("Cursor must be constructed with MongoClient");
        }
        this[kClient] = client;
        this[kNamespace] = namespace;
        this[kId] = null;
        this[kDocuments] = new utils_1.List();
        this[kInitialized] = false;
        this[kClosed] = false;
        this[kKilled] = false;
        this[kOptions] = {
          readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,
          ...(0, bson_1.pluckBSONSerializeOptions)(options)
        };
        const readConcern = read_concern_1.ReadConcern.fromOptions(options);
        if (readConcern) {
          this[kOptions].readConcern = readConcern;
        }
        if (typeof options.batchSize === "number") {
          this[kOptions].batchSize = options.batchSize;
        }
        if (options.comment !== void 0) {
          this[kOptions].comment = options.comment;
        }
        if (typeof options.maxTimeMS === "number") {
          this[kOptions].maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.maxAwaitTimeMS === "number") {
          this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;
        }
        if (options.session instanceof sessions_1.ClientSession) {
          this[kSession] = options.session;
        } else {
          this[kSession] = this[kClient].startSession({ owner: this, explicit: false });
        }
      }
      get id() {
        var _a;
        return (_a = this[kId]) !== null && _a !== void 0 ? _a : void 0;
      }
      /** @internal */
      get client() {
        return this[kClient];
      }
      /** @internal */
      get server() {
        return this[kServer];
      }
      get namespace() {
        return this[kNamespace];
      }
      get readPreference() {
        return this[kOptions].readPreference;
      }
      get readConcern() {
        return this[kOptions].readConcern;
      }
      /** @internal */
      get session() {
        return this[kSession];
      }
      set session(clientSession) {
        this[kSession] = clientSession;
      }
      /** @internal */
      get cursorOptions() {
        return this[kOptions];
      }
      get closed() {
        return this[kClosed];
      }
      get killed() {
        return this[kKilled];
      }
      get loadBalanced() {
        var _a;
        return !!((_a = this[kClient].topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);
      }
      /** Returns current buffered documents length */
      bufferedCount() {
        return this[kDocuments].length;
      }
      /** Returns current buffered documents */
      readBufferedDocuments(number) {
        const bufferedDocs = [];
        const documentsToRead = Math.min(number !== null && number !== void 0 ? number : this[kDocuments].length, this[kDocuments].length);
        for (let count = 0; count < documentsToRead; count++) {
          const document2 = this[kDocuments].shift();
          if (document2 != null) {
            bufferedDocs.push(document2);
          }
        }
        return bufferedDocs;
      }
      [Symbol.asyncIterator]() {
        async function* nativeAsyncIterator() {
          if (this.closed) {
            return;
          }
          while (true) {
            const document2 = await this.next();
            if (document2 === null) {
              if (!this.closed) {
                const message = "Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.";
                await cleanupCursorAsync(this, { needsToEmitClosed: true }).catch(() => null);
                throw new error_1.MongoAPIError(message);
              }
              break;
            }
            yield document2;
            if (this[kId] === bson_1.Long.ZERO) {
              break;
            }
          }
        }
        const iterator = nativeAsyncIterator.call(this);
        if (promise_provider_1.PromiseProvider.get() == null) {
          return iterator;
        }
        return {
          next: () => (0, utils_1.maybeCallback)(() => iterator.next(), null)
        };
      }
      stream(options) {
        if (options === null || options === void 0 ? void 0 : options.transform) {
          const transform = options.transform;
          const readable = new ReadableCursorStream(this);
          return readable.pipe(new stream_1.Transform({
            objectMode: true,
            highWaterMark: 1,
            transform(chunk, _, callback) {
              try {
                const transformed = transform(chunk);
                callback(void 0, transformed);
              } catch (err) {
                callback(err);
              }
            }
          }));
        }
        return new ReadableCursorStream(this);
      }
      hasNext(callback) {
        return (0, utils_1.maybeCallback)(async () => {
          if (this[kId] === bson_1.Long.ZERO) {
            return false;
          }
          if (this[kDocuments].length !== 0) {
            return true;
          }
          const doc = await nextAsync(this, true);
          if (doc) {
            this[kDocuments].unshift(doc);
            return true;
          }
          return false;
        }, callback);
      }
      next(callback) {
        return (0, utils_1.maybeCallback)(async () => {
          if (this[kId] === bson_1.Long.ZERO) {
            throw new error_1.MongoCursorExhaustedError();
          }
          return nextAsync(this, true);
        }, callback);
      }
      tryNext(callback) {
        return (0, utils_1.maybeCallback)(async () => {
          if (this[kId] === bson_1.Long.ZERO) {
            throw new error_1.MongoCursorExhaustedError();
          }
          return nextAsync(this, false);
        }, callback);
      }
      forEach(iterator, callback) {
        if (typeof iterator !== "function") {
          throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
        }
        return (0, utils_1.maybeCallback)(async () => {
          for await (const document2 of this) {
            const result = iterator(document2);
            if (result === false) {
              break;
            }
          }
        }, callback);
      }
      close(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        const needsToEmitClosed = !this[kClosed];
        this[kClosed] = true;
        return (0, utils_1.maybeCallback)(async () => cleanupCursorAsync(this, { needsToEmitClosed }), callback);
      }
      toArray(callback) {
        return (0, utils_1.maybeCallback)(async () => {
          const array = [];
          for await (const document2 of this) {
            array.push(document2);
          }
          return array;
        }, callback);
      }
      /**
       * Add a cursor flag to the cursor
       *
       * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
       * @param value - The flag boolean value.
       */
      addCursorFlag(flag, value) {
        assertUninitialized(this);
        if (!exports2.CURSOR_FLAGS.includes(flag)) {
          throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports2.CURSOR_FLAGS}`);
        }
        if (typeof value !== "boolean") {
          throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
        }
        this[kOptions][flag] = value;
        return this;
      }
      /**
       * Map all documents using the provided function
       * If there is a transform set on the cursor, that will be called first and the result passed to
       * this function's transform.
       *
       * @remarks
       *
       * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping
       * function that maps values to `null` will result in the cursor closing itself before it has finished iterating
       * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:
       *
       * ```typescript
       * const cursor = collection.find({});
       * cursor.map(() => null);
       *
       * const documents = await cursor.toArray();
       * // documents is always [], regardless of how many documents are in the collection.
       * ```
       *
       * Other falsey values are allowed:
       *
       * ```typescript
       * const cursor = collection.find({});
       * cursor.map(() => '');
       *
       * const documents = await cursor.toArray();
       * // documents is now an array of empty strings
       * ```
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling map,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: FindCursor<Document> = coll.find();
       * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
       * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
       * ```
       * @param transform - The mapping transformation method.
       */
      map(transform) {
        assertUninitialized(this);
        const oldTransform = this[kTransform];
        if (oldTransform) {
          this[kTransform] = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this[kTransform] = transform;
        }
        return this;
      }
      /**
       * Set the ReadPreference for the cursor.
       *
       * @param readPreference - The new read preference for the cursor.
       */
      withReadPreference(readPreference) {
        assertUninitialized(this);
        if (readPreference instanceof read_preference_1.ReadPreference) {
          this[kOptions].readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);
        } else {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
        }
        return this;
      }
      /**
       * Set the ReadPreference for the cursor.
       *
       * @param readPreference - The new read preference for the cursor.
       */
      withReadConcern(readConcern) {
        assertUninitialized(this);
        const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
        if (resolvedReadConcern) {
          this[kOptions].readConcern = resolvedReadConcern;
        }
        return this;
      }
      /**
       * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
       *
       * @param value - Number of milliseconds to wait before aborting the query.
       */
      maxTimeMS(value) {
        assertUninitialized(this);
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
        }
        this[kOptions].maxTimeMS = value;
        return this;
      }
      /**
       * Set the batch size for the cursor.
       *
       * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.
       */
      batchSize(value) {
        assertUninitialized(this);
        if (this[kOptions].tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support batchSize");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
        }
        this[kOptions].batchSize = value;
        return this;
      }
      /**
       * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
       * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
       * if the resultant data has already been retrieved by this cursor.
       */
      rewind() {
        if (!this[kInitialized]) {
          return;
        }
        this[kId] = null;
        this[kDocuments].clear();
        this[kClosed] = false;
        this[kKilled] = false;
        this[kInitialized] = false;
        const session = this[kSession];
        if (session) {
          if (session.explicit === false) {
            if (!session.hasEnded) {
              session.endSession().catch(() => null);
            }
            this[kSession] = this.client.startSession({ owner: this, explicit: false });
          }
        }
      }
      /** @internal */
      _getMore(batchSize, callback) {
        const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], {
          ...this[kOptions],
          session: this[kSession],
          batchSize
        });
        (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);
      }
      /**
       * @internal
       *
       * This function is exposed for the unified test runner's createChangeStream
       * operation.  We cannot refactor to use the abstract _initialize method without
       * a significant refactor.
       */
      [kInit](callback) {
        this._initialize(this[kSession], (error, state) => {
          if (state) {
            const response = state.response;
            this[kServer] = state.server;
            if (response.cursor) {
              this[kId] = typeof response.cursor.id === "number" ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;
              if (response.cursor.ns) {
                this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);
              }
              this[kDocuments].pushMany(response.cursor.firstBatch);
            }
            if (this[kId] == null) {
              this[kId] = bson_1.Long.ZERO;
              this[kDocuments].push(state.response);
            }
          }
          this[kInitialized] = true;
          if (error) {
            return cleanupCursor(this, { error }, () => callback(error, void 0));
          }
          if (cursorIsDead(this)) {
            return cleanupCursor(this, void 0, () => callback());
          }
          callback();
        });
      }
    };
    exports2.AbstractCursor = AbstractCursor;
    AbstractCursor.CLOSE = "close";
    function nextDocument(cursor) {
      const doc = cursor[kDocuments].shift();
      if (doc && cursor[kTransform]) {
        return cursor[kTransform](doc);
      }
      return doc;
    }
    var nextAsync = (0, util_1.promisify)(next);
    function next(cursor, blocking, callback) {
      const cursorId = cursor[kId];
      if (cursor.closed) {
        return callback(void 0, null);
      }
      if (cursor[kDocuments].length !== 0) {
        callback(void 0, nextDocument(cursor));
        return;
      }
      if (cursorId == null) {
        cursor[kInit]((err) => {
          if (err)
            return callback(err);
          return next(cursor, blocking, callback);
        });
        return;
      }
      if (cursorIsDead(cursor)) {
        return cleanupCursor(cursor, void 0, () => callback(void 0, null));
      }
      const batchSize = cursor[kOptions].batchSize || 1e3;
      cursor._getMore(batchSize, (error, response) => {
        if (response) {
          const cursorId2 = typeof response.cursor.id === "number" ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;
          cursor[kDocuments].pushMany(response.cursor.nextBatch);
          cursor[kId] = cursorId2;
        }
        if (error || cursorIsDead(cursor)) {
          return cleanupCursor(cursor, { error }, () => callback(error, nextDocument(cursor)));
        }
        if (cursor[kDocuments].length === 0 && blocking === false) {
          return callback(void 0, null);
        }
        next(cursor, blocking, callback);
      });
    }
    exports2.next = next;
    function cursorIsDead(cursor) {
      const cursorId = cursor[kId];
      return !!cursorId && cursorId.isZero();
    }
    var cleanupCursorAsync = (0, util_1.promisify)(cleanupCursor);
    function cleanupCursor(cursor, options, callback) {
      var _a;
      const cursorId = cursor[kId];
      const cursorNs = cursor[kNamespace];
      const server = cursor[kServer];
      const session = cursor[kSession];
      const error = options === null || options === void 0 ? void 0 : options.error;
      const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;
      if (error) {
        if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {
          return completeCleanup();
        }
      }
      if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {
        if (needsToEmitClosed) {
          cursor[kClosed] = true;
          cursor[kId] = bson_1.Long.ZERO;
          cursor.emit(AbstractCursor.CLOSE);
        }
        if (session) {
          if (session.owner === cursor) {
            return session.endSession({ error }, callback);
          }
          if (!session.inTransaction()) {
            (0, sessions_1.maybeClearPinnedConnection)(session, { error });
          }
        }
        return callback();
      }
      function completeCleanup() {
        if (session) {
          if (session.owner === cursor) {
            return session.endSession({ error }, () => {
              cursor.emit(AbstractCursor.CLOSE);
              callback();
            });
          }
          if (!session.inTransaction()) {
            (0, sessions_1.maybeClearPinnedConnection)(session, { error });
          }
        }
        cursor.emit(AbstractCursor.CLOSE);
        return callback();
      }
      cursor[kKilled] = true;
      return (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, { session }), completeCleanup);
    }
    function assertUninitialized(cursor) {
      if (cursor[kInitialized]) {
        throw new error_1.MongoCursorInUseError();
      }
    }
    exports2.assertUninitialized = assertUninitialized;
    var ReadableCursorStream = class extends stream_1.Readable {
      constructor(cursor) {
        super({
          objectMode: true,
          autoDestroy: false,
          highWaterMark: 1
        });
        this._readInProgress = false;
        this._cursor = cursor;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _read(size) {
        if (!this._readInProgress) {
          this._readInProgress = true;
          this._readNext();
        }
      }
      _destroy(error, callback) {
        this._cursor.close((err) => process.nextTick(callback, err || error));
      }
      _readNext() {
        next(this._cursor, true, (err, result) => {
          if (err) {
            if (err.message.match(/server is closed/)) {
              this._cursor.close().catch(() => null);
              return this.push(null);
            }
            if (err.message.match(/operation was interrupted/)) {
              return this.push(null);
            }
            return this.destroy(err);
          }
          if (result == null) {
            this.push(null);
          } else if (this.destroyed) {
            this._cursor.close().catch(() => null);
          } else {
            if (this.push(result)) {
              return this._readNext();
            }
            this._readInProgress = false;
          }
        });
      }
    };
  }
});

// asset-input/node_modules/mongodb/lib/cursor/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "asset-input/node_modules/mongodb/lib/cursor/aggregation_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AggregationCursor = void 0;
    var aggregate_1 = require_aggregate();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils2();
    var abstract_cursor_1 = require_abstract_cursor();
    var kPipeline = Symbol("pipeline");
    var kOptions = Symbol("options");
    var AggregationCursor = class _AggregationCursor extends abstract_cursor_1.AbstractCursor {
      /** @internal */
      constructor(client, namespace, pipeline2 = [], options = {}) {
        super(client, namespace, options);
        this[kPipeline] = pipeline2;
        this[kOptions] = options;
      }
      get pipeline() {
        return this[kPipeline];
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);
        delete clonedOptions.session;
        return new _AggregationCursor(this.client, this.namespace, this[kPipeline], {
          ...clonedOptions
        });
      }
      map(transform) {
        return super.map(transform);
      }
      /** @internal */
      _initialize(session, callback) {
        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {
          ...this[kOptions],
          ...this.cursorOptions,
          session
        });
        (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, (err, response) => {
          if (err || response == null)
            return callback(err);
          callback(void 0, { server: aggregateOperation.server, session, response });
        });
      }
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity == null)
          verbosity = true;
        return (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {
          ...this[kOptions],
          ...this.cursorOptions,
          explain: verbosity
        }), callback);
      }
      group($group) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $group });
        return this;
      }
      /** Add a limit stage to the aggregation pipeline */
      limit($limit) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $limit });
        return this;
      }
      /** Add a match stage to the aggregation pipeline */
      match($match) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $match });
        return this;
      }
      /** Add an out stage to the aggregation pipeline */
      out($out) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $out });
        return this;
      }
      /**
       * Add a project stage to the aggregation pipeline
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.
       * You should specify a parameterized type to have assertions on your final results.
       *
       * @example
       * ```typescript
       * // Best way
       * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
       * // Flexible way
       * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });
       * ```
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling project,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
       * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
       * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
       *
       * // or always use chaining and save the final cursor
       *
       * const cursor = coll.aggregate().project<{ a: string }>({
       *   _id: 0,
       *   a: { $convert: { input: '$a', to: 'string' }
       * }});
       * ```
       */
      project($project) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $project });
        return this;
      }
      /** Add a lookup stage to the aggregation pipeline */
      lookup($lookup) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $lookup });
        return this;
      }
      /** Add a redact stage to the aggregation pipeline */
      redact($redact) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $redact });
        return this;
      }
      /** Add a skip stage to the aggregation pipeline */
      skip($skip) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $skip });
        return this;
      }
      /** Add a sort stage to the aggregation pipeline */
      sort($sort) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $sort });
        return this;
      }
      /** Add a unwind stage to the aggregation pipeline */
      unwind($unwind) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $unwind });
        return this;
      }
      /** Add a geoNear stage to the aggregation pipeline */
      geoNear($geoNear) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kPipeline].push({ $geoNear });
        return this;
      }
    };
    exports2.AggregationCursor = AggregationCursor;
  }
});

// asset-input/node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CountOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var CountOperation = class extends command_1.CommandOperation {
      constructor(namespace, filter, options) {
        super({ s: { namespace } }, options);
        this.options = options;
        this.collectionName = namespace.collection;
        this.query = filter;
      }
      execute(server, session, callback) {
        const options = this.options;
        const cmd = {
          count: this.collectionName,
          query: this.query
        };
        if (typeof options.limit === "number") {
          cmd.limit = options.limit;
        }
        if (typeof options.skip === "number") {
          cmd.skip = options.skip;
        }
        if (options.hint != null) {
          cmd.hint = options.hint;
        }
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        super.executeCommand(server, session, cmd, (err, result) => {
          callback(err, result ? result.n : 0);
        });
      }
    };
    exports2.CountOperation = CountOperation;
    (0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
  }
});

// asset-input/node_modules/mongodb/lib/sort.js
var require_sort = __commonJS({
  "asset-input/node_modules/mongodb/lib/sort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatSort = void 0;
    var error_1 = require_error();
    function prepareDirection(direction = 1) {
      const value = `${direction}`.toLowerCase();
      if (isMeta(direction))
        return direction;
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
      }
    }
    function isMeta(t) {
      return typeof t === "object" && t != null && "$meta" in t && typeof t.$meta === "string";
    }
    function isPair(t) {
      if (Array.isArray(t) && t.length === 2) {
        try {
          prepareDirection(t[1]);
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    }
    function isDeep(t) {
      return Array.isArray(t) && Array.isArray(t[0]);
    }
    function isMap(t) {
      return t instanceof Map && t.size > 0;
    }
    function pairToMap(v) {
      return /* @__PURE__ */ new Map([[`${v[0]}`, prepareDirection([v[1]])]]);
    }
    function deepToMap(t) {
      const sortEntries = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);
      return new Map(sortEntries);
    }
    function stringsToMap(t) {
      const sortEntries = t.map((key) => [`${key}`, 1]);
      return new Map(sortEntries);
    }
    function objectToMap(t) {
      const sortEntries = Object.entries(t).map(([k, v]) => [
        `${k}`,
        prepareDirection(v)
      ]);
      return new Map(sortEntries);
    }
    function mapToMap(t) {
      const sortEntries = Array.from(t).map(([k, v]) => [
        `${k}`,
        prepareDirection(v)
      ]);
      return new Map(sortEntries);
    }
    function formatSort(sort, direction) {
      if (sort == null)
        return void 0;
      if (typeof sort === "string")
        return /* @__PURE__ */ new Map([[sort, prepareDirection(direction)]]);
      if (typeof sort !== "object") {
        throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
      }
      if (!Array.isArray(sort)) {
        return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : void 0;
      }
      if (!sort.length)
        return void 0;
      if (isDeep(sort))
        return deepToMap(sort);
      if (isPair(sort))
        return pairToMap(sort);
      return stringsToMap(sort);
    }
    exports2.formatSort = formatSort;
  }
});

// asset-input/node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/find.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindOperation = void 0;
    var error_1 = require_error();
    var read_concern_1 = require_read_concern();
    var sort_1 = require_sort();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var FindOperation = class extends command_1.CommandOperation {
      constructor(collection, ns, filter = {}, options = {}) {
        super(collection, options);
        this.options = { ...options };
        delete this.options.writeConcern;
        this.ns = ns;
        if (typeof filter !== "object" || Array.isArray(filter)) {
          throw new error_1.MongoInvalidArgumentError("Query filter must be a plain object or ObjectId");
        }
        if (Buffer.isBuffer(filter)) {
          const objectSize = filter[0] | filter[1] << 8 | filter[2] << 16 | filter[3] << 24;
          if (objectSize !== filter.length) {
            throw new error_1.MongoInvalidArgumentError(`Query filter raw message size does not match message header size [${filter.length}] != [${objectSize}]`);
          }
        }
        this.filter = filter != null && filter._bsontype === "ObjectID" ? { _id: filter } : filter;
      }
      execute(server, session, callback) {
        this.server = server;
        const options = this.options;
        let findCommand = makeFindCommand(this.ns, this.filter, options);
        if (this.explain) {
          findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);
        }
        server.command(this.ns, findCommand, {
          ...this.options,
          ...this.bsonOptions,
          documentsReturnedIn: "firstBatch",
          session
        }, callback);
      }
    };
    exports2.FindOperation = FindOperation;
    function makeFindCommand(ns, filter, options) {
      const findCommand = {
        find: ns.collection,
        filter
      };
      if (options.sort) {
        findCommand.sort = (0, sort_1.formatSort)(options.sort);
      }
      if (options.projection) {
        let projection = options.projection;
        if (projection && Array.isArray(projection)) {
          projection = projection.length ? projection.reduce((result, field) => {
            result[field] = 1;
            return result;
          }, {}) : { _id: 1 };
        }
        findCommand.projection = projection;
      }
      if (options.hint) {
        findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
      }
      if (typeof options.skip === "number") {
        findCommand.skip = options.skip;
      }
      if (typeof options.limit === "number") {
        if (options.limit < 0) {
          findCommand.limit = -options.limit;
          findCommand.singleBatch = true;
        } else {
          findCommand.limit = options.limit;
        }
      }
      if (typeof options.batchSize === "number") {
        if (options.batchSize < 0) {
          if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
            findCommand.limit = -options.batchSize;
          }
          findCommand.singleBatch = true;
        } else {
          findCommand.batchSize = options.batchSize;
        }
      }
      if (typeof options.singleBatch === "boolean") {
        findCommand.singleBatch = options.singleBatch;
      }
      if (options.comment !== void 0) {
        findCommand.comment = options.comment;
      }
      if (typeof options.maxTimeMS === "number") {
        findCommand.maxTimeMS = options.maxTimeMS;
      }
      const readConcern = read_concern_1.ReadConcern.fromOptions(options);
      if (readConcern) {
        findCommand.readConcern = readConcern.toJSON();
      }
      if (options.max) {
        findCommand.max = options.max;
      }
      if (options.min) {
        findCommand.min = options.min;
      }
      if (typeof options.returnKey === "boolean") {
        findCommand.returnKey = options.returnKey;
      }
      if (typeof options.showRecordId === "boolean") {
        findCommand.showRecordId = options.showRecordId;
      }
      if (typeof options.tailable === "boolean") {
        findCommand.tailable = options.tailable;
      }
      if (typeof options.oplogReplay === "boolean") {
        findCommand.oplogReplay = options.oplogReplay;
      }
      if (typeof options.timeout === "boolean") {
        findCommand.noCursorTimeout = !options.timeout;
      } else if (typeof options.noCursorTimeout === "boolean") {
        findCommand.noCursorTimeout = options.noCursorTimeout;
      }
      if (typeof options.awaitData === "boolean") {
        findCommand.awaitData = options.awaitData;
      }
      if (typeof options.allowPartialResults === "boolean") {
        findCommand.allowPartialResults = options.allowPartialResults;
      }
      if (options.collation) {
        findCommand.collation = options.collation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options.allowDiskUse;
      }
      if (options.let) {
        findCommand.let = options.let;
      }
      return findCommand;
    }
    (0, operation_1.defineAspects)(FindOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/cursor/find_cursor.js
var require_find_cursor = __commonJS({
  "asset-input/node_modules/mongodb/lib/cursor/find_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindCursor = exports2.FLAGS = void 0;
    var error_1 = require_error();
    var count_1 = require_count();
    var execute_operation_1 = require_execute_operation();
    var find_1 = require_find();
    var sort_1 = require_sort();
    var utils_1 = require_utils2();
    var abstract_cursor_1 = require_abstract_cursor();
    var kFilter = Symbol("filter");
    var kNumReturned = Symbol("numReturned");
    var kBuiltOptions = Symbol("builtOptions");
    exports2.FLAGS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "exhaust",
      "partial"
    ];
    var FindCursor = class _FindCursor extends abstract_cursor_1.AbstractCursor {
      /** @internal */
      constructor(client, namespace, filter, options = {}) {
        super(client, namespace, options);
        this[kFilter] = filter || {};
        this[kBuiltOptions] = options;
        if (options.sort != null) {
          this[kBuiltOptions].sort = (0, sort_1.formatSort)(options.sort);
        }
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this[kBuiltOptions]);
        delete clonedOptions.session;
        return new _FindCursor(this.client, this.namespace, this[kFilter], {
          ...clonedOptions
        });
      }
      map(transform) {
        return super.map(transform);
      }
      /** @internal */
      _initialize(session, callback) {
        const findOperation = new find_1.FindOperation(void 0, this.namespace, this[kFilter], {
          ...this[kBuiltOptions],
          ...this.cursorOptions,
          session
        });
        (0, execute_operation_1.executeOperation)(this.client, findOperation, (err, response) => {
          if (err || response == null)
            return callback(err);
          if (response.cursor) {
            this[kNumReturned] = response.cursor.firstBatch.length;
          } else {
            this[kNumReturned] = response.documents ? response.documents.length : 0;
          }
          callback(void 0, { server: findOperation.server, session, response });
        });
      }
      /** @internal */
      _getMore(batchSize, callback) {
        const numReturned = this[kNumReturned];
        if (numReturned) {
          const limit = this[kBuiltOptions].limit;
          batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
          if (batchSize <= 0) {
            return this.close(callback);
          }
        }
        super._getMore(batchSize, (err, response) => {
          if (err)
            return callback(err);
          if (response) {
            this[kNumReturned] = this[kNumReturned] + response.cursor.nextBatch.length;
          }
          callback(void 0, response);
        });
      }
      count(options, callback) {
        (0, utils_1.emitWarningOnce)("cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ");
        if (typeof options === "boolean") {
          throw new error_1.MongoInvalidArgumentError("Invalid first parameter to count");
        }
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this[kFilter], {
          ...this[kBuiltOptions],
          ...this.cursorOptions,
          ...options
        }), callback);
      }
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity == null)
          verbosity = true;
        return (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(void 0, this.namespace, this[kFilter], {
          ...this[kBuiltOptions],
          ...this.cursorOptions,
          explain: verbosity
        }), callback);
      }
      /** Set the cursor query */
      filter(filter) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kFilter] = filter;
        return this;
      }
      /**
       * Set the cursor hint
       *
       * @param hint - If specified, then the query system will only consider plans using the hinted index.
       */
      hint(hint) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].hint = hint;
        return this;
      }
      /**
       * Set the cursor min
       *
       * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
       */
      min(min) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].min = min;
        return this;
      }
      /**
       * Set the cursor max
       *
       * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
       */
      max(max) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].max = max;
        return this;
      }
      /**
       * Set the cursor returnKey.
       * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.
       * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.
       *
       * @param value - the returnKey value.
       */
      returnKey(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].returnKey = value;
        return this;
      }
      /**
       * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.
       *
       * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
       */
      showRecordId(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].showRecordId = value;
        return this;
      }
      /**
       * Add a query modifier to the cursor query
       *
       * @param name - The query modifier (must start with $, such as $orderby etc)
       * @param value - The modifier value.
       */
      addQueryModifier(name, value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        if (name[0] !== "$") {
          throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
        }
        const field = name.substr(1);
        switch (field) {
          case "comment":
            this[kBuiltOptions].comment = value;
            break;
          case "explain":
            this[kBuiltOptions].explain = value;
            break;
          case "hint":
            this[kBuiltOptions].hint = value;
            break;
          case "max":
            this[kBuiltOptions].max = value;
            break;
          case "maxTimeMS":
            this[kBuiltOptions].maxTimeMS = value;
            break;
          case "min":
            this[kBuiltOptions].min = value;
            break;
          case "orderby":
            this[kBuiltOptions].sort = (0, sort_1.formatSort)(value);
            break;
          case "query":
            this[kFilter] = value;
            break;
          case "returnKey":
            this[kBuiltOptions].returnKey = value;
            break;
          case "showDiskLoc":
            this[kBuiltOptions].showRecordId = value;
            break;
          default:
            throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
        }
        return this;
      }
      /**
       * Add a comment to the cursor query allowing for tracking the comment in the log.
       *
       * @param value - The comment attached to this query.
       */
      comment(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].comment = value;
        return this;
      }
      /**
       * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
       *
       * @param value - Number of milliseconds to wait before aborting the tailed query.
       */
      maxAwaitTimeMS(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxAwaitTimeMS must be a number");
        }
        this[kBuiltOptions].maxAwaitTimeMS = value;
        return this;
      }
      /**
       * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
       *
       * @param value - Number of milliseconds to wait before aborting the query.
       */
      maxTimeMS(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
        }
        this[kBuiltOptions].maxTimeMS = value;
        return this;
      }
      /**
       * Add a project stage to the aggregation pipeline
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * By default chaining a projection to your cursor changes the returned type to the generic
       * {@link Document} type.
       * You should specify a parameterized type to have assertions on your final results.
       *
       * @example
       * ```typescript
       * // Best way
       * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
       * // Flexible way
       * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });
       * ```
       *
       * @remarks
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling project,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: FindCursor<{ a: number; b: string }> = coll.find();
       * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
       * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
       *
       * // or always use chaining and save the final cursor
       *
       * const cursor = coll.find().project<{ a: string }>({
       *   _id: 0,
       *   a: { $convert: { input: '$a', to: 'string' }
       * }});
       * ```
       */
      project(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].projection = value;
        return this;
      }
      /**
       * Sets the sort order of the cursor query.
       *
       * @param sort - The key or keys set for the sort.
       * @param direction - The direction of the sorting (1 or -1).
       */
      sort(sort, direction) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        if (this[kBuiltOptions].tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support sorting");
        }
        this[kBuiltOptions].sort = (0, sort_1.formatSort)(sort, direction);
        return this;
      }
      /**
       * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)
       *
       * @remarks
       * {@link https://docs.mongodb.com/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}
       */
      allowDiskUse(allow = true) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        if (!this[kBuiltOptions].sort) {
          throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
        }
        if (!allow) {
          this[kBuiltOptions].allowDiskUse = false;
          return this;
        }
        this[kBuiltOptions].allowDiskUse = true;
        return this;
      }
      /**
       * Set the collation options for the cursor.
       *
       * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
       */
      collation(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        this[kBuiltOptions].collation = value;
        return this;
      }
      /**
       * Set the limit for the cursor.
       *
       * @param value - The limit for the cursor query.
       */
      limit(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        if (this[kBuiltOptions].tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support limit");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
        }
        this[kBuiltOptions].limit = value;
        return this;
      }
      /**
       * Set the skip for the cursor.
       *
       * @param value - The skip for the cursor query.
       */
      skip(value) {
        (0, abstract_cursor_1.assertUninitialized)(this);
        if (this[kBuiltOptions].tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support skip");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
        }
        this[kBuiltOptions].skip = value;
        return this;
      }
    };
    exports2.FindCursor = FindCursor;
  }
});

// asset-input/node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/indexes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexInformationOperation = exports2.IndexExistsOperation = exports2.ListIndexesOperation = exports2.DropIndexesOperation = exports2.DropIndexOperation = exports2.EnsureIndexOperation = exports2.CreateIndexOperation = exports2.CreateIndexesOperation = exports2.IndexesOperation = void 0;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var common_functions_1 = require_common_functions();
    var operation_1 = require_operation();
    var VALID_INDEX_OPTIONS = /* @__PURE__ */ new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "hidden",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "version",
      // text indexes
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      // 2d-sphere indexes
      "2dsphereIndexVersion",
      // 2d indexes
      "bits",
      "min",
      "max",
      // geoHaystack Indexes
      "bucketSize",
      // wildcard indexes
      "wildcardProjection"
    ]);
    function isIndexDirection(x) {
      return typeof x === "number" || x === "2d" || x === "2dsphere" || x === "text" || x === "geoHaystack";
    }
    function isSingleIndexTuple(t) {
      return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
    }
    function makeIndexSpec(indexSpec, options) {
      var _a;
      const key = /* @__PURE__ */ new Map();
      const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
      for (const spec of indexSpecs) {
        if (typeof spec === "string") {
          key.set(spec, 1);
        } else if (Array.isArray(spec)) {
          key.set(spec[0], (_a = spec[1]) !== null && _a !== void 0 ? _a : 1);
        } else if (spec instanceof Map) {
          for (const [property, value] of spec) {
            key.set(property, value);
          }
        } else if ((0, utils_1.isObject)(spec)) {
          for (const [property, value] of Object.entries(spec)) {
            key.set(property, value);
          }
        }
      }
      return { ...options, key };
    }
    var IndexesOperation = class extends operation_1.AbstractOperation {
      constructor(collection, options) {
        super(options);
        this.options = options;
        this.collection = collection;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        const options = this.options;
        (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { full: true, ...options, readPreference: this.readPreference, session }, callback);
      }
    };
    exports2.IndexesOperation = IndexesOperation;
    var CreateIndexesOperation = class extends command_1.CommandOperation {
      constructor(parent, collectionName, indexes, options) {
        super(parent, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.collectionName = collectionName;
        this.indexes = indexes.map((userIndex) => {
          const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
          const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join("_");
          const validIndexOptions = Object.fromEntries(Object.entries({ ...userIndex }).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName)));
          return {
            ...validIndexOptions,
            name,
            key
          };
        });
      }
      execute(server, session, callback) {
        const options = this.options;
        const indexes = this.indexes;
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const cmd = { createIndexes: this.collectionName, indexes };
        if (options.commitQuorum != null) {
          if (serverWireVersion < 9) {
            callback(new error_1.MongoCompatibilityError("Option `commitQuorum` for `createIndexes` not supported on servers < 4.4"));
            return;
          }
          cmd.commitQuorum = options.commitQuorum;
        }
        this.options.collation = void 0;
        super.executeCommand(server, session, cmd, (err) => {
          if (err) {
            callback(err);
            return;
          }
          const indexNames = indexes.map((index) => index.name || "");
          callback(void 0, indexNames);
        });
      }
    };
    exports2.CreateIndexesOperation = CreateIndexesOperation;
    var CreateIndexOperation = class extends CreateIndexesOperation {
      constructor(parent, collectionName, indexSpec, options) {
        super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, indexNames) => {
          if (err || !indexNames)
            return callback(err);
          return callback(void 0, indexNames[0]);
        });
      }
    };
    exports2.CreateIndexOperation = CreateIndexOperation;
    var EnsureIndexOperation = class extends CreateIndexOperation {
      constructor(db, collectionName, indexSpec, options) {
        super(db, collectionName, indexSpec, options);
        this.readPreference = read_preference_1.ReadPreference.primary;
        this.db = db;
        this.collectionName = collectionName;
      }
      execute(server, session, callback) {
        const indexName = this.indexes[0].name;
        const cursor = this.db.collection(this.collectionName).listIndexes({ session });
        cursor.toArray((err, indexes) => {
          if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
            return callback(err);
          }
          if (indexes) {
            indexes = Array.isArray(indexes) ? indexes : [indexes];
            if (indexes.some((index) => index.name === indexName)) {
              callback(void 0, indexName);
              return;
            }
          }
          super.execute(server, session, callback);
        });
      }
    };
    exports2.EnsureIndexOperation = EnsureIndexOperation;
    var DropIndexOperation = class extends command_1.CommandOperation {
      constructor(collection, indexName, options) {
        super(collection, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.collection = collection;
        this.indexName = indexName;
      }
      execute(server, session, callback) {
        const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
        super.executeCommand(server, session, cmd, callback);
      }
    };
    exports2.DropIndexOperation = DropIndexOperation;
    var DropIndexesOperation = class extends DropIndexOperation {
      constructor(collection, options) {
        super(collection, "*", options);
      }
      execute(server, session, callback) {
        super.execute(server, session, (err) => {
          if (err)
            return callback(err, false);
          callback(void 0, true);
        });
      }
    };
    exports2.DropIndexesOperation = DropIndexesOperation;
    var ListIndexesOperation = class extends command_1.CommandOperation {
      constructor(collection, options) {
        super(collection, options);
        this.options = { ...options };
        delete this.options.writeConcern;
        this.collectionNamespace = collection.s.namespace;
      }
      execute(server, session, callback) {
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
        const command = { listIndexes: this.collectionNamespace.collection, cursor };
        if (serverWireVersion >= 9 && this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.ListIndexesOperation = ListIndexesOperation;
    var IndexExistsOperation = class extends operation_1.AbstractOperation {
      constructor(collection, indexes, options) {
        super(options);
        this.options = options;
        this.collection = collection;
        this.indexes = indexes;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        const indexes = this.indexes;
        (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { ...this.options, readPreference: this.readPreference, session }, (err, indexInformation) => {
          if (err != null)
            return callback(err);
          if (!Array.isArray(indexes))
            return callback(void 0, indexInformation[indexes] != null);
          for (let i = 0; i < indexes.length; i++) {
            if (indexInformation[indexes[i]] == null) {
              return callback(void 0, false);
            }
          }
          return callback(void 0, true);
        });
      }
    };
    exports2.IndexExistsOperation = IndexExistsOperation;
    var IndexInformationOperation = class extends operation_1.AbstractOperation {
      constructor(db, name, options) {
        super(options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.db = db;
        this.name = name;
      }
      execute(server, session, callback) {
        const db = this.db;
        const name = this.name;
        (0, common_functions_1.indexInformation)(db, name, { ...this.options, readPreference: this.readPreference, session }, callback);
      }
    };
    exports2.IndexInformationOperation = IndexInformationOperation;
    (0, operation_1.defineAspects)(ListIndexesOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
    (0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/cursor/list_indexes_cursor.js
var require_list_indexes_cursor = __commonJS({
  "asset-input/node_modules/mongodb/lib/cursor/list_indexes_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListIndexesCursor = void 0;
    var execute_operation_1 = require_execute_operation();
    var indexes_1 = require_indexes();
    var abstract_cursor_1 = require_abstract_cursor();
    var ListIndexesCursor = class _ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
      constructor(collection, options) {
        super(collection.s.db.s.client, collection.s.namespace, options);
        this.parent = collection;
        this.options = options;
      }
      clone() {
        return new _ListIndexesCursor(this.parent, {
          ...this.options,
          ...this.cursorOptions
        });
      }
      /** @internal */
      _initialize(session, callback) {
        const operation = new indexes_1.ListIndexesOperation(this.parent, {
          ...this.cursorOptions,
          ...this.options,
          session
        });
        (0, execute_operation_1.executeOperation)(this.parent.s.db.s.client, operation, (err, response) => {
          if (err || response == null)
            return callback(err);
          callback(void 0, { server: operation.server, session, response });
        });
      }
    };
    exports2.ListIndexesCursor = ListIndexesCursor;
  }
});

// asset-input/node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/count_documents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CountDocumentsOperation = void 0;
    var aggregate_1 = require_aggregate();
    var CountDocumentsOperation = class extends aggregate_1.AggregateOperation {
      constructor(collection, query, options) {
        const pipeline2 = [];
        pipeline2.push({ $match: query });
        if (typeof options.skip === "number") {
          pipeline2.push({ $skip: options.skip });
        }
        if (typeof options.limit === "number") {
          pipeline2.push({ $limit: options.limit });
        }
        pipeline2.push({ $group: { _id: 1, n: { $sum: 1 } } });
        super(collection.s.namespace, pipeline2, options);
      }
      execute(server, session, callback) {
        super.execute(server, session, (err, result) => {
          if (err || !result) {
            callback(err);
            return;
          }
          const response = result;
          if (response.cursor == null || response.cursor.firstBatch == null) {
            callback(void 0, 0);
            return;
          }
          const docs = response.cursor.firstBatch;
          callback(void 0, docs.length ? docs[0].n : 0);
        });
      }
    };
    exports2.CountDocumentsOperation = CountDocumentsOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/distinct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DistinctOperation = void 0;
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DistinctOperation = class extends command_1.CommandOperation {
      /**
       * Construct a Distinct operation.
       *
       * @param collection - Collection instance.
       * @param key - Field of the document to find distinct values for.
       * @param query - The query for filtering the set of documents to which we apply the distinct filter.
       * @param options - Optional settings. See Collection.prototype.distinct for a list of options.
       */
      constructor(collection, key, query, options) {
        super(collection, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.comment !== "undefined") {
          cmd.comment = options.comment;
        }
        (0, utils_1.decorateWithReadConcern)(cmd, coll, options);
        try {
          (0, utils_1.decorateWithCollation)(cmd, coll, options);
        } catch (err) {
          return callback(err);
        }
        super.executeCommand(server, session, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(void 0, this.explain ? result : result.values);
        });
      }
    };
    exports2.DistinctOperation = DistinctOperation;
    (0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/drop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DropDatabaseOperation = exports2.DropCollectionOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DropCollectionOperation = class _DropCollectionOperation extends command_1.CommandOperation {
      constructor(db, name, options = {}) {
        super(db, options);
        this.db = db;
        this.options = options;
        this.name = name;
      }
      execute(server, session, callback) {
        (async () => {
          var _a, _b, _c, _d;
          const db = this.db;
          const options = this.options;
          const name = this.name;
          const encryptedFieldsMap = (_a = db.s.client.options.autoEncryption) === null || _a === void 0 ? void 0 : _a.encryptedFieldsMap;
          let encryptedFields = (_b = options.encryptedFields) !== null && _b !== void 0 ? _b : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap[`${db.databaseName}.${name}`];
          if (!encryptedFields && encryptedFieldsMap) {
            const listCollectionsResult = await db.listCollections({ name }, { nameOnly: false }).toArray();
            encryptedFields = (_d = (_c = listCollectionsResult === null || listCollectionsResult === void 0 ? void 0 : listCollectionsResult[0]) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.encryptedFields;
          }
          if (encryptedFields) {
            const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
            const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
            for (const collectionName of [escCollection, ecocCollection]) {
              const dropOp = new _DropCollectionOperation(db, collectionName);
              try {
                await dropOp.executeWithoutEncryptedFieldsCheck(server, session);
              } catch (err) {
                if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
                  throw err;
                }
              }
            }
          }
          return this.executeWithoutEncryptedFieldsCheck(server, session);
        })().then((result) => callback(void 0, result), (err) => callback(err));
      }
      executeWithoutEncryptedFieldsCheck(server, session) {
        return new Promise((resolve, reject) => {
          super.executeCommand(server, session, { drop: this.name }, (err, result) => {
            if (err)
              return reject(err);
            resolve(!!result.ok);
          });
        });
      }
    };
    exports2.DropCollectionOperation = DropCollectionOperation;
    var DropDatabaseOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options;
      }
      execute(server, session, callback) {
        super.executeCommand(server, session, { dropDatabase: 1 }, (err, result) => {
          if (err)
            return callback(err);
          if (result.ok)
            return callback(void 0, true);
          callback(void 0, false);
        });
      }
    };
    exports2.DropDatabaseOperation = DropDatabaseOperation;
    (0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EstimatedDocumentCountOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var EstimatedDocumentCountOperation = class extends command_1.CommandOperation {
      constructor(collection, options = {}) {
        super(collection, options);
        this.options = options;
        this.collectionName = collection.collectionName;
      }
      execute(server, session, callback) {
        const cmd = { count: this.collectionName };
        if (typeof this.options.maxTimeMS === "number") {
          cmd.maxTimeMS = this.options.maxTimeMS;
        }
        if (this.options.comment !== void 0) {
          cmd.comment = this.options.comment;
        }
        super.executeCommand(server, session, cmd, (err, response) => {
          if (err) {
            callback(err);
            return;
          }
          callback(void 0, (response === null || response === void 0 ? void 0 : response.n) || 0);
        });
      }
    };
    exports2.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
    (0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/find_and_modify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindOneAndUpdateOperation = exports2.FindOneAndReplaceOperation = exports2.FindOneAndDeleteOperation = exports2.ReturnDocument = void 0;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var sort_1 = require_sort();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    exports2.ReturnDocument = Object.freeze({
      BEFORE: "before",
      AFTER: "after"
    });
    function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {
      cmdBase.new = options.returnDocument === exports2.ReturnDocument.AFTER;
      cmdBase.upsert = options.upsert === true;
      if (options.bypassDocumentValidation === true) {
        cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      return cmdBase;
    }
    var FindAndModifyOperation = class extends command_1.CommandOperation {
      constructor(collection, query, options) {
        super(collection, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.cmdBase = {
          remove: false,
          new: false,
          upsert: false
        };
        const sort = (0, sort_1.formatSort)(options.sort);
        if (sort) {
          this.cmdBase.sort = sort;
        }
        if (options.projection) {
          this.cmdBase.fields = options.projection;
        }
        if (options.maxTimeMS) {
          this.cmdBase.maxTimeMS = options.maxTimeMS;
        }
        if (options.writeConcern) {
          this.cmdBase.writeConcern = options.writeConcern;
        }
        if (options.let) {
          this.cmdBase.let = options.let;
        }
        if (options.comment !== void 0) {
          this.cmdBase.comment = options.comment;
        }
        this.readPreference = read_preference_1.ReadPreference.primary;
        this.collection = collection;
        this.query = query;
      }
      execute(server, session, callback) {
        var _a;
        const coll = this.collection;
        const query = this.query;
        const options = { ...this.options, ...this.bsonOptions };
        const cmd = {
          findAndModify: coll.collectionName,
          query,
          ...this.cmdBase
        };
        try {
          (0, utils_1.decorateWithCollation)(cmd, coll, options);
        } catch (err) {
          return callback(err);
        }
        if (options.hint) {
          const unacknowledgedWrite = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) === 0;
          if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
            callback(new error_1.MongoCompatibilityError("The current topology does not support a hint on findAndModify commands"));
            return;
          }
          cmd.hint = options.hint;
        }
        super.executeCommand(server, session, cmd, (err, result) => {
          if (err)
            return callback(err);
          return callback(void 0, result);
        });
      }
    };
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, options) {
        if (filter == null || typeof filter !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        super(collection, filter, options);
        this.cmdBase.remove = true;
      }
    };
    exports2.FindOneAndDeleteOperation = FindOneAndDeleteOperation;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, replacement, options) {
        if (filter == null || typeof filter !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
        }
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
        }
        super(collection, filter, options);
        this.cmdBase.update = replacement;
        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
      }
    };
    exports2.FindOneAndReplaceOperation = FindOneAndReplaceOperation;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, update, options) {
        if (filter == null || typeof filter !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        if (update == null || typeof update !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
        }
        if (!(0, utils_1.hasAtomicOperators)(update)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
        super(collection, filter, options);
        this.cmdBase.update = update;
        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
        if (options.arrayFilters) {
          this.cmdBase.arrayFilters = options.arrayFilters;
        }
      }
    };
    exports2.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
    (0, operation_1.defineAspects)(FindAndModifyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/is_capped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsCappedOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var IsCappedOperation = class extends operation_1.AbstractOperation {
      constructor(collection, options) {
        super(options);
        this.options = options;
        this.collection = collection;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray((err, collections) => {
          if (err || !collections)
            return callback(err);
          if (collections.length === 0) {
            return callback(new error_1.MongoAPIError(`collection ${coll.namespace} not found`));
          }
          const collOptions = collections[0].options;
          callback(void 0, !!(collOptions && collOptions.capped));
        });
      }
    };
    exports2.IsCappedOperation = IsCappedOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/map_reduce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapReduceOperation = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var exclusionList = [
      "explain",
      "readPreference",
      "readConcern",
      "session",
      "bypassDocumentValidation",
      "writeConcern",
      "raw",
      "fieldsAsRaw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "serializeFunctions",
      "ignoreUndefined",
      "enableUtf8Validation",
      "scope"
      // this option is reformatted thus exclude the original
    ];
    var MapReduceOperation = class extends command_1.CommandOperation {
      /**
       * Constructs a MapReduce operation.
       *
       * @param collection - Collection instance.
       * @param map - The mapping function.
       * @param reduce - The reduce function.
       * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.
       */
      constructor(collection, map, reduce, options) {
        super(collection, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.collection = collection;
        this.map = map;
        this.reduce = reduce;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        const map = this.map;
        const reduce = this.reduce;
        let options = this.options;
        const mapCommandHash = {
          mapReduce: coll.collectionName,
          map,
          reduce
        };
        if (options.scope) {
          mapCommandHash.scope = processScope(options.scope);
        }
        for (const n in options) {
          if (exclusionList.indexOf(n) === -1) {
            mapCommandHash[n] = options[n];
          }
        }
        options = Object.assign({}, options);
        if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== "inline") {
          options.readPreference = read_preference_1.ReadPreference.primary;
          (0, utils_1.applyWriteConcern)(mapCommandHash, { db: coll.s.db, collection: coll }, options);
        } else {
          (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);
        }
        if (options.bypassDocumentValidation === true) {
          mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        try {
          (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);
        } catch (err) {
          return callback(err);
        }
        if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {
          callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));
          return;
        }
        super.executeCommand(server, session, mapCommandHash, (err, result) => {
          if (err)
            return callback(err);
          if (1 !== result.ok || result.err || result.errmsg) {
            return callback(new error_1.MongoServerError(result));
          }
          if (this.explain)
            return callback(void 0, result);
          const stats = {};
          if (result.timeMillis)
            stats["processtime"] = result.timeMillis;
          if (result.counts)
            stats["counts"] = result.counts;
          if (result.timing)
            stats["timing"] = result.timing;
          if (result.results) {
            if (options["verbose"] == null || !options["verbose"]) {
              return callback(void 0, result.results);
            }
            return callback(void 0, { results: result.results, stats });
          }
          let collection = null;
          if (result.result != null && typeof result.result === "object") {
            const doc = result.result;
            collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);
          } else {
            collection = coll.s.db.collection(result.result);
          }
          if (options["verbose"] == null || !options["verbose"]) {
            return callback(err, collection);
          }
          callback(err, { collection, stats });
        });
      }
    };
    exports2.MapReduceOperation = MapReduceOperation;
    function processScope(scope) {
      if (!(0, utils_1.isObject)(scope) || scope._bsontype === "ObjectID") {
        return scope;
      }
      const newScope = {};
      for (const key of Object.keys(scope)) {
        if ("function" === typeof scope[key]) {
          newScope[key] = new bson_1.Code(String(scope[key]));
        } else if (scope[key]._bsontype === "Code") {
          newScope[key] = scope[key];
        } else {
          newScope[key] = processScope(scope[key]);
        }
      }
      return newScope;
    }
    (0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/options_operation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptionsOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var OptionsOperation = class extends operation_1.AbstractOperation {
      constructor(collection, options) {
        super(options);
        this.options = options;
        this.collection = collection;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray((err, collections) => {
          if (err || !collections)
            return callback(err);
          if (collections.length === 0) {
            return callback(new error_1.MongoAPIError(`collection ${coll.namespace} not found`));
          }
          callback(err, collections[0].options);
        });
      }
    };
    exports2.OptionsOperation = OptionsOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/rename.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RenameOperation = void 0;
    var collection_1 = require_collection();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var operation_1 = require_operation();
    var run_command_1 = require_run_command();
    var RenameOperation = class extends run_command_1.RunAdminCommandOperation {
      constructor(collection, newName, options) {
        (0, utils_1.checkCollectionName)(newName);
        const renameCollection = collection.namespace;
        const toCollection = collection.s.namespace.withCollection(newName).toString();
        const dropTarget = typeof options.dropTarget === "boolean" ? options.dropTarget : false;
        const cmd = { renameCollection, to: toCollection, dropTarget };
        super(collection, cmd, options);
        this.options = options;
        this.collection = collection;
        this.newName = newName;
      }
      execute(server, session, callback) {
        const coll = this.collection;
        super.execute(server, session, (err, doc) => {
          if (err)
            return callback(err);
          if (doc === null || doc === void 0 ? void 0 : doc.errmsg) {
            return callback(new error_1.MongoServerError(doc));
          }
          let newColl;
          try {
            newColl = new collection_1.Collection(coll.s.db, this.newName, coll.s.options);
          } catch (err2) {
            return callback(err2);
          }
          return callback(void 0, newColl);
        });
      }
    };
    exports2.RenameOperation = RenameOperation;
    (0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/stats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DbStatsOperation = exports2.CollStatsOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var CollStatsOperation = class extends command_1.CommandOperation {
      /**
       * Construct a Stats operation.
       *
       * @param collection - Collection instance
       * @param options - Optional settings. See Collection.prototype.stats for a list of options.
       */
      constructor(collection, options) {
        super(collection, options);
        this.options = options !== null && options !== void 0 ? options : {};
        this.collectionName = collection.collectionName;
      }
      execute(server, session, callback) {
        const command = { collStats: this.collectionName };
        if (this.options.scale != null) {
          command.scale = this.options.scale;
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.CollStatsOperation = CollStatsOperation;
    var DbStatsOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options;
      }
      execute(server, session, callback) {
        const command = { dbStats: true };
        if (this.options.scale != null) {
          command.scale = this.options.scale;
        }
        super.executeCommand(server, session, command, callback);
      }
    };
    exports2.DbStatsOperation = DbStatsOperation;
    (0, operation_1.defineAspects)(CollStatsOperation, [operation_1.Aspect.READ_OPERATION]);
    (0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "asset-input/node_modules/mongodb/lib/collection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Collection = void 0;
    var bson_1 = require_bson2();
    var ordered_1 = require_ordered();
    var unordered_1 = require_unordered();
    var change_stream_1 = require_change_stream();
    var aggregation_cursor_1 = require_aggregation_cursor();
    var find_cursor_1 = require_find_cursor();
    var list_indexes_cursor_1 = require_list_indexes_cursor();
    var error_1 = require_error();
    var bulk_write_1 = require_bulk_write();
    var count_1 = require_count();
    var count_documents_1 = require_count_documents();
    var delete_1 = require_delete();
    var distinct_1 = require_distinct();
    var drop_1 = require_drop();
    var estimated_document_count_1 = require_estimated_document_count();
    var execute_operation_1 = require_execute_operation();
    var find_and_modify_1 = require_find_and_modify();
    var indexes_1 = require_indexes();
    var insert_1 = require_insert();
    var is_capped_1 = require_is_capped();
    var map_reduce_1 = require_map_reduce();
    var options_operation_1 = require_options_operation();
    var rename_1 = require_rename();
    var stats_1 = require_stats();
    var update_1 = require_update();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils2();
    var write_concern_1 = require_write_concern();
    var Collection = class {
      /**
       * Create a new Collection instance
       * @internal
       */
      constructor(db, name, options) {
        var _a, _b;
        (0, utils_1.checkCollectionName)(name);
        this.s = {
          db,
          options,
          namespace: new utils_1.MongoDBNamespace(db.databaseName, name),
          pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,
          readPreference: read_preference_1.ReadPreference.fromOptions(options),
          bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
          readConcern: read_concern_1.ReadConcern.fromOptions(options),
          writeConcern: write_concern_1.WriteConcern.fromOptions(options)
        };
      }
      /**
       * The name of the database this collection belongs to
       */
      get dbName() {
        return this.s.namespace.db;
      }
      /**
       * The name of this collection
       */
      get collectionName() {
        return this.s.namespace.collection;
      }
      /**
       * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`
       */
      get namespace() {
        return this.s.namespace.toString();
      }
      /**
       * The current readConcern of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get readConcern() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
      /**
       * The current readPreference of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get readPreference() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      /**
       * The current writeConcern of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get writeConcern() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
      /** The current index hint for the collection */
      get hint() {
        return this.s.collectionHint;
      }
      set hint(v) {
        this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
      }
      insertOne(doc, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (options && Reflect.get(options, "w")) {
          options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, "w"));
        }
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      insertMany(docs, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options ? Object.assign({}, options) : { ordered: true };
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      bulkWrite(operations, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || { ordered: true };
        if (!Array.isArray(operations)) {
          throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
        }
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      updateOne(filter, update, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      replaceOne(filter, replacement, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      updateMany(filter, update, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      deleteOne(filter, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      deleteMany(filter, options, callback) {
        if (filter == null) {
          filter = {};
          options = {};
          callback = void 0;
        } else if (typeof filter === "function") {
          callback = filter;
          filter = {};
          options = {};
        } else if (typeof options === "function") {
          callback = options;
          options = {};
        }
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      rename(newName, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new rename_1.RenameOperation(this, newName, {
          ...options,
          readPreference: read_preference_1.ReadPreference.PRIMARY
        }), callback);
      }
      drop(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);
      }
      findOne(filter, options, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new error_1.MongoInvalidArgumentError("Third parameter to `findOne()` must be a callback or undefined");
        }
        if (typeof filter === "function") {
          callback = filter;
          filter = {};
          options = {};
        }
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        const finalFilter = filter !== null && filter !== void 0 ? filter : {};
        const finalOptions = options !== null && options !== void 0 ? options : {};
        return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);
      }
      find(filter, options) {
        if (arguments.length > 2) {
          throw new error_1.MongoInvalidArgumentError('Method "collection.find()" accepts at most two arguments');
        }
        if (typeof options === "function") {
          throw new error_1.MongoInvalidArgumentError('Argument "options" must not be function');
        }
        return new find_cursor_1.FindCursor(this.s.db.s.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
      }
      options(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      isCapped(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      createIndex(indexSpec, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      createIndexes(indexSpecs, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options ? Object.assign({}, options) : {};
        if (typeof options.maxTimeMS !== "number")
          delete options.maxTimeMS;
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      dropIndex(indexName, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = (0, utils_1.resolveOptions)(this, options);
        options.readPreference = read_preference_1.ReadPreference.primary;
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexOperation(this, indexName, options), callback);
      }
      dropIndexes(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      /**
       * Get the list of all indexes information for the collection.
       *
       * @param options - Optional settings for the command
       */
      listIndexes(options) {
        return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
      }
      indexExists(indexes, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      indexInformation(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      estimatedDocumentCount(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      countDocuments(filter, options, callback) {
        if (filter == null) {
          filter = {}, options = {}, callback = void 0;
        } else if (typeof filter === "function") {
          callback = filter, filter = {}, options = {};
        } else {
          if (arguments.length === 2) {
            if (typeof options === "function")
              callback = options, options = {};
          }
        }
        filter !== null && filter !== void 0 ? filter : filter = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      // Implementation
      distinct(key, filter, options, callback) {
        if (typeof filter === "function") {
          callback = filter, filter = {}, options = {};
        } else {
          if (arguments.length === 3 && typeof options === "function") {
            callback = options, options = {};
          }
        }
        filter !== null && filter !== void 0 ? filter : filter = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      indexes(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      stats(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new stats_1.CollStatsOperation(this, options), callback);
      }
      findOneAndDelete(filter, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      findOneAndReplace(filter, replacement, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      findOneAndUpdate(filter, update, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      /**
       * Execute an aggregation framework pipeline against the collection, needs MongoDB \>= 2.2
       *
       * @param pipeline - An array of aggregation pipelines to execute
       * @param options - Optional settings for the command
       */
      aggregate(pipeline2 = [], options) {
        if (arguments.length > 2) {
          throw new error_1.MongoInvalidArgumentError('Method "collection.aggregate()" accepts at most two arguments');
        }
        if (!Array.isArray(pipeline2)) {
          throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
        }
        if (typeof options === "function") {
          throw new error_1.MongoInvalidArgumentError('Argument "options" must not be function');
        }
        return new aggregation_cursor_1.AggregationCursor(this.s.db.s.client, this.s.namespace, pipeline2, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to override the schema that may be defined for this specific collection
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       * @example
       * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`
       * ```ts
       * collection.watch<{ _id: number }>()
       *   .on('change', change => console.log(change._id.toFixed(4)));
       * ```
       *
       * @example
       * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.
       * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.
       * No need start from scratch on the ChangeStreamInsertDocument type!
       * By using an intersection we can save time and ensure defaults remain the same type!
       * ```ts
       * collection
       *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([
       *     { $addFields: { comment: 'big changes' } },
       *     { $match: { operationType: 'insert' } }
       *   ])
       *   .on('change', change => {
       *     change.comment.startsWith('big');
       *     change.operationType === 'insert';
       *     // No need to narrow in code because the generics did that for us!
       *     expectType<Schema>(change.fullDocument);
       *   });
       * ```
       *
       * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TLocal - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline2 = [], options = {}) {
        if (!Array.isArray(pipeline2)) {
          options = pipeline2;
          pipeline2 = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline2, (0, utils_1.resolveOptions)(this, options));
      }
      mapReduce(map, reduce, options, callback) {
        (0, utils_1.emitWarningOnce)("collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.");
        if ("function" === typeof options)
          callback = options, options = {};
        if ((options === null || options === void 0 ? void 0 : options.out) == null) {
          throw new error_1.MongoInvalidArgumentError('Option "out" must be defined, see mongodb docs for possible values');
        }
        if ("function" === typeof map) {
          map = map.toString();
        }
        if ("function" === typeof reduce) {
          reduce = reduce.toString();
        }
        if ("function" === typeof options.finalize) {
          options.finalize = options.finalize.toString();
        }
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new map_reduce_1.MapReduceOperation(this, map, reduce, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      /**
       * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
       *
       * @throws MongoNotConnectedError
       * @remarks
       * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
       * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
       */
      initializeUnorderedBulkOp(options) {
        return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
       *
       * @throws MongoNotConnectedError
       * @remarks
       * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
       * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
       */
      initializeOrderedBulkOp(options) {
        return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
      }
      /** Get the db scoped logger */
      getLogger() {
        return this.s.db.s.logger;
      }
      get logger() {
        return this.s.db.s.logger;
      }
      /**
       * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
       * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
       * can be overridden by setting the **forceServerObjectId** flag.
       *
       * @deprecated Use insertOne, insertMany or bulkWrite instead. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance
       * @param docs - The documents to insert
       * @param options - Optional settings for the command
       * @param callback - An optional callback, a Promise will be returned if none is provided
       */
      insert(docs, options, callback) {
        (0, utils_1.emitWarningOnce)("collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
        if (typeof options === "function")
          callback = options, options = {};
        options = options || { ordered: false };
        docs = !Array.isArray(docs) ? [docs] : docs;
        if (options.keepGoing === true) {
          options.ordered = false;
        }
        return this.insertMany(docs, options, callback);
      }
      /**
       * Updates documents.
       *
       * @deprecated use updateOne, updateMany or bulkWrite. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance
       * @param filter - The filter for the update operation.
       * @param update - The update operations to be applied to the documents
       * @param options - Optional settings for the command
       * @param callback - An optional callback, a Promise will be returned if none is provided
       */
      update(filter, update, options, callback) {
        (0, utils_1.emitWarningOnce)("collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.updateMany(filter, update, options, callback);
      }
      /**
       * Remove documents.
       *
       * @deprecated use deleteOne, deleteMany or bulkWrite. Callbacks are deprecated and will be removed in the next major version. See [mongodb-legacy](https://github.com/mongodb-js/nodejs-mongodb-legacy) for migration assistance
       * @param filter - The filter for the remove operation.
       * @param options - Optional settings for the command
       * @param callback - An optional callback, a Promise will be returned if none is provided
       */
      remove(filter, options, callback) {
        (0, utils_1.emitWarningOnce)("collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.deleteMany(filter, options, callback);
      }
      count(filter, options, callback) {
        if (typeof filter === "function") {
          callback = filter, filter = {}, options = {};
        } else {
          if (typeof options === "function")
            callback = options, options = {};
        }
        filter !== null && filter !== void 0 ? filter : filter = {};
        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_1.CountOperation(utils_1.MongoDBNamespace.fromString(this.namespace), filter, (0, utils_1.resolveOptions)(this, options)), callback);
      }
    };
    exports2.Collection = Collection;
  }
});

// asset-input/node_modules/mongodb/lib/cursor/change_stream_cursor.js
var require_change_stream_cursor = __commonJS({
  "asset-input/node_modules/mongodb/lib/cursor/change_stream_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChangeStreamCursor = void 0;
    var change_stream_1 = require_change_stream();
    var constants_1 = require_constants3();
    var aggregate_1 = require_aggregate();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils2();
    var abstract_cursor_1 = require_abstract_cursor();
    var ChangeStreamCursor = class _ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
      constructor(client, namespace, pipeline2 = [], options = {}) {
        super(client, namespace, options);
        this.pipeline = pipeline2;
        this.options = options;
        this._resumeToken = null;
        this.startAtOperationTime = options.startAtOperationTime;
        if (options.startAfter) {
          this.resumeToken = options.startAfter;
        } else if (options.resumeAfter) {
          this.resumeToken = options.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const options = {
          ...this.options
        };
        for (const key of ["resumeAfter", "startAfter", "startAtOperationTime"]) {
          delete options[key];
        }
        if (this.resumeToken != null) {
          if (this.options.startAfter && !this.hasReceived) {
            options.startAfter = this.resumeToken;
          } else {
            options.resumeAfter = this.resumeToken;
          }
        } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
          options.startAtOperationTime = this.startAtOperationTime;
        }
        return options;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
          this.resumeToken = this.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(response) {
        const cursor = response.cursor;
        if (cursor.postBatchResumeToken) {
          this.postBatchResumeToken = response.cursor.postBatchResumeToken;
          const batch = "firstBatch" in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;
          if (batch.length === 0) {
            this.resumeToken = cursor.postBatchResumeToken;
          }
        }
      }
      clone() {
        return new _ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
          ...this.cursorOptions
        });
      }
      _initialize(session, callback) {
        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
          ...this.cursorOptions,
          ...this.options,
          session
        });
        (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, (err, response) => {
          if (err || response == null) {
            return callback(err);
          }
          const server = aggregateOperation.server;
          this.maxWireVersion = (0, utils_1.maxWireVersion)(server);
          if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {
            this.startAtOperationTime = response.operationTime;
          }
          this._processBatch(response);
          this.emit(constants_1.INIT, response);
          this.emit(constants_1.RESPONSE);
          callback(void 0, { server, session, response });
        });
      }
      _getMore(batchSize, callback) {
        super._getMore(batchSize, (err, response) => {
          if (err) {
            return callback(err);
          }
          this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
          this._processBatch(response);
          this.emit(change_stream_1.ChangeStream.MORE, response);
          this.emit(change_stream_1.ChangeStream.RESPONSE);
          callback(err, response);
        });
      }
    };
    exports2.ChangeStreamCursor = ChangeStreamCursor;
  }
});

// asset-input/node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/list_collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListCollectionsOperation = void 0;
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ListCollectionsOperation = class extends command_1.CommandOperation {
      constructor(db, filter, options) {
        super(db, options);
        this.options = { ...options };
        delete this.options.writeConcern;
        this.db = db;
        this.filter = filter;
        this.nameOnly = !!this.options.nameOnly;
        this.authorizedCollections = !!this.options.authorizedCollections;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      execute(server, session, callback) {
        return super.executeCommand(server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), callback);
      }
      /* This is here for the purpose of unit testing the final command that gets sent. */
      generateCommand(wireVersion) {
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? { batchSize: this.batchSize } : {},
          nameOnly: this.nameOnly,
          authorizedCollections: this.authorizedCollections
        };
        if (wireVersion >= 9 && this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        return command;
      }
    };
    exports2.ListCollectionsOperation = ListCollectionsOperation;
    (0, operation_1.defineAspects)(ListCollectionsOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/cursor/list_collections_cursor.js
var require_list_collections_cursor = __commonJS({
  "asset-input/node_modules/mongodb/lib/cursor/list_collections_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListCollectionsCursor = void 0;
    var execute_operation_1 = require_execute_operation();
    var list_collections_1 = require_list_collections();
    var abstract_cursor_1 = require_abstract_cursor();
    var ListCollectionsCursor = class _ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
      constructor(db, filter, options) {
        super(db.s.client, db.s.namespace, options);
        this.parent = db;
        this.filter = filter;
        this.options = options;
      }
      clone() {
        return new _ListCollectionsCursor(this.parent, this.filter, {
          ...this.options,
          ...this.cursorOptions
        });
      }
      /** @internal */
      _initialize(session, callback) {
        const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
          ...this.cursorOptions,
          ...this.options,
          session
        });
        (0, execute_operation_1.executeOperation)(this.parent.s.client, operation, (err, response) => {
          if (err || response == null)
            return callback(err);
          callback(void 0, { server: operation.server, session, response });
        });
      }
    };
    exports2.ListCollectionsCursor = ListCollectionsCursor;
  }
});

// asset-input/node_modules/mongodb/lib/logger.js
var require_logger = __commonJS({
  "asset-input/node_modules/mongodb/lib/logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Logger = exports2.LoggerLevel = void 0;
    var util_1 = require("util");
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var classFilters = {};
    var filteredClasses = {};
    var level;
    var pid = process.pid;
    var currentLogger = console.warn;
    exports2.LoggerLevel = Object.freeze({
      ERROR: "error",
      WARN: "warn",
      INFO: "info",
      DEBUG: "debug",
      error: "error",
      warn: "warn",
      info: "info",
      debug: "debug"
    });
    var Logger = class _Logger {
      /**
       * Creates a new Logger instance
       *
       * @param className - The Class name associated with the logging instance
       * @param options - Optional logging settings
       */
      constructor(className, options) {
        options = options !== null && options !== void 0 ? options : {};
        this.className = className;
        if (!(options.logger instanceof _Logger) && typeof options.logger === "function") {
          currentLogger = options.logger;
        }
        if (options.loggerLevel) {
          level = options.loggerLevel || exports2.LoggerLevel.ERROR;
        }
        if (filteredClasses[this.className] == null) {
          classFilters[this.className] = true;
        }
      }
      /**
       * Log a message at the debug level
       *
       * @param message - The message to log
       * @param object - Additional meta data to log
       */
      debug(message, object) {
        if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
          const dateTime = (/* @__PURE__ */ new Date()).getTime();
          const msg = (0, util_1.format)("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
          const state = {
            type: exports2.LoggerLevel.DEBUG,
            message,
            className: this.className,
            pid,
            date: dateTime
          };
          if (object)
            state.meta = object;
          currentLogger(msg, state);
        }
      }
      /**
       * Log a message at the warn level
       *
       * @param message - The message to log
       * @param object - Additional meta data to log
       */
      warn(message, object) {
        if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
          const dateTime = (/* @__PURE__ */ new Date()).getTime();
          const msg = (0, util_1.format)("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
          const state = {
            type: exports2.LoggerLevel.WARN,
            message,
            className: this.className,
            pid,
            date: dateTime
          };
          if (object)
            state.meta = object;
          currentLogger(msg, state);
        }
      }
      /**
       * Log a message at the info level
       *
       * @param message - The message to log
       * @param object - Additional meta data to log
       */
      info(message, object) {
        if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
          const dateTime = (/* @__PURE__ */ new Date()).getTime();
          const msg = (0, util_1.format)("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
          const state = {
            type: exports2.LoggerLevel.INFO,
            message,
            className: this.className,
            pid,
            date: dateTime
          };
          if (object)
            state.meta = object;
          currentLogger(msg, state);
        }
      }
      /**
       * Log a message at the error level
       *
       * @param message - The message to log
       * @param object - Additional meta data to log
       */
      error(message, object) {
        if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
          const dateTime = (/* @__PURE__ */ new Date()).getTime();
          const msg = (0, util_1.format)("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
          const state = {
            type: exports2.LoggerLevel.ERROR,
            message,
            className: this.className,
            pid,
            date: dateTime
          };
          if (object)
            state.meta = object;
          currentLogger(msg, state);
        }
      }
      /** Is the logger set at info level */
      isInfo() {
        return level === exports2.LoggerLevel.INFO || level === exports2.LoggerLevel.DEBUG;
      }
      /** Is the logger set at error level */
      isError() {
        return level === exports2.LoggerLevel.ERROR || level === exports2.LoggerLevel.INFO || level === exports2.LoggerLevel.DEBUG;
      }
      /** Is the logger set at error level */
      isWarn() {
        return level === exports2.LoggerLevel.ERROR || level === exports2.LoggerLevel.WARN || level === exports2.LoggerLevel.INFO || level === exports2.LoggerLevel.DEBUG;
      }
      /** Is the logger set at debug level */
      isDebug() {
        return level === exports2.LoggerLevel.DEBUG;
      }
      /** Resets the logger to default settings, error and no filtered classes */
      static reset() {
        level = exports2.LoggerLevel.ERROR;
        filteredClasses = {};
      }
      /** Get the current logger function */
      static currentLogger() {
        return currentLogger;
      }
      /**
       * Set the current logger function
       *
       * @param logger - Custom logging function
       */
      static setCurrentLogger(logger) {
        if (typeof logger !== "function") {
          throw new error_1.MongoInvalidArgumentError("Current logger must be a function");
        }
        currentLogger = logger;
      }
      /**
       * Filter log messages for a particular class
       *
       * @param type - The type of filter (currently only class)
       * @param values - The filters to apply
       */
      static filter(type, values) {
        if (type === "class" && Array.isArray(values)) {
          filteredClasses = {};
          values.forEach((x) => filteredClasses[x] = true);
        }
      }
      /**
       * Set the current log level
       *
       * @param newLevel - Set current log level (debug, warn, info, error)
       */
      static setLevel(newLevel) {
        if (newLevel !== exports2.LoggerLevel.INFO && newLevel !== exports2.LoggerLevel.ERROR && newLevel !== exports2.LoggerLevel.DEBUG && newLevel !== exports2.LoggerLevel.WARN) {
          throw new error_1.MongoInvalidArgumentError(`Argument "newLevel" should be one of ${(0, utils_1.enumToString)(exports2.LoggerLevel)}`);
        }
        level = newLevel;
      }
    };
    exports2.Logger = Logger;
  }
});

// asset-input/node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollectionsOperation = void 0;
    var collection_1 = require_collection();
    var operation_1 = require_operation();
    var CollectionsOperation = class extends operation_1.AbstractOperation {
      constructor(db, options) {
        super(options);
        this.options = options;
        this.db = db;
      }
      execute(server, session, callback) {
        const db = this.db;
        db.listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session }).toArray((err, documents) => {
          if (err || !documents)
            return callback(err);
          documents = documents.filter((doc) => doc.name.indexOf("$") === -1);
          callback(void 0, documents.map((d) => {
            return new collection_1.Collection(db, d.name, db.s.options);
          }));
        });
      }
    };
    exports2.CollectionsOperation = CollectionsOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/create_collection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CreateCollectionOperation = void 0;
    var constants_1 = require_constants2();
    var collection_1 = require_collection();
    var error_1 = require_error();
    var command_1 = require_command();
    var indexes_1 = require_indexes();
    var operation_1 = require_operation();
    var ILLEGAL_COMMAND_FIELDS = /* @__PURE__ */ new Set([
      "w",
      "wtimeout",
      "j",
      "fsync",
      "autoIndexId",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern",
      "raw",
      "fieldsAsRaw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "serializeFunctions",
      "ignoreUndefined",
      "enableUtf8Validation"
    ]);
    var INVALID_QE_VERSION = "Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.";
    var CreateCollectionOperation = class _CreateCollectionOperation extends command_1.CommandOperation {
      constructor(db, name, options = {}) {
        super(db, options);
        this.options = options;
        this.db = db;
        this.name = name;
      }
      execute(server, session, callback) {
        (async () => {
          var _a, _b, _c, _d, _e;
          const db = this.db;
          const name = this.name;
          const options = this.options;
          const encryptedFields = (_a = options.encryptedFields) !== null && _a !== void 0 ? _a : (_c = (_b = db.s.client.options.autoEncryption) === null || _b === void 0 ? void 0 : _b.encryptedFieldsMap) === null || _c === void 0 ? void 0 : _c[`${db.databaseName}.${name}`];
          if (encryptedFields) {
            if (server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
              throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
            }
            const escCollection = (_d = encryptedFields.escCollection) !== null && _d !== void 0 ? _d : `enxcol_.${name}.esc`;
            const ecocCollection = (_e = encryptedFields.ecocCollection) !== null && _e !== void 0 ? _e : `enxcol_.${name}.ecoc`;
            for (const collectionName of [escCollection, ecocCollection]) {
              const createOp = new _CreateCollectionOperation(db, collectionName, {
                clusteredIndex: {
                  key: { _id: 1 },
                  unique: true
                }
              });
              await createOp.executeWithoutEncryptedFieldsCheck(server, session);
            }
            if (!options.encryptedFields) {
              this.options = { ...this.options, encryptedFields };
            }
          }
          const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);
          if (encryptedFields) {
            const createIndexOp = new indexes_1.CreateIndexOperation(db, name, { __safeContent__: 1 }, {});
            await new Promise((resolve, reject) => {
              createIndexOp.execute(server, session, (err) => err ? reject(err) : resolve());
            });
          }
          return coll;
        })().then((coll) => callback(void 0, coll), (err) => callback(err));
      }
      executeWithoutEncryptedFieldsCheck(server, session) {
        return new Promise((resolve, reject) => {
          const db = this.db;
          const name = this.name;
          const options = this.options;
          const done = (err) => {
            if (err) {
              return reject(err);
            }
            resolve(new collection_1.Collection(db, name, options));
          };
          const cmd = { create: name };
          for (const n in options) {
            if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
              cmd[n] = options[n];
            }
          }
          super.executeCommand(server, session, cmd, done);
        });
      }
    };
    exports2.CreateCollectionOperation = CreateCollectionOperation;
    (0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// asset-input/node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/profiling_level.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProfilingLevelOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var ProfilingLevelOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options;
      }
      execute(server, session, callback) {
        super.executeCommand(server, session, { profile: -1 }, (err, doc) => {
          if (err == null && doc.ok === 1) {
            const was = doc.was;
            if (was === 0)
              return callback(void 0, "off");
            if (was === 1)
              return callback(void 0, "slow_only");
            if (was === 2)
              return callback(void 0, "all");
            return callback(new error_1.MongoRuntimeError(`Illegal profiling level value ${was}`));
          } else {
            err != null ? callback(err) : callback(new error_1.MongoRuntimeError("Error with profile command"));
          }
        });
      }
    };
    exports2.ProfilingLevelOperation = ProfilingLevelOperation;
  }
});

// asset-input/node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "asset-input/node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetProfilingLevelOperation = exports2.ProfilingLevel = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var command_1 = require_command();
    var levelValues = /* @__PURE__ */ new Set(["off", "slow_only", "all"]);
    exports2.ProfilingLevel = Object.freeze({
      off: "off",
      slowOnly: "slow_only",
      all: "all"
    });
    var SetProfilingLevelOperation = class extends command_1.CommandOperation {
      constructor(db, level, options) {
        super(db, options);
        this.options = options;
        switch (level) {
          case exports2.ProfilingLevel.off:
            this.profile = 0;
            break;
          case exports2.ProfilingLevel.slowOnly:
            this.profile = 1;
            break;
          case exports2.ProfilingLevel.all:
            this.profile = 2;
            break;
          default:
            this.profile = 0;
            break;
        }
        this.level = level;
      }
      execute(server, session, callback) {
        const level = this.level;
        if (!levelValues.has(level)) {
          return callback(new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports2.ProfilingLevel)}"`));
        }
        super.executeCommand(server, session, { profile: this.profile }, (err, doc) => {
          if (err == null && doc.ok === 1)
            return callback(void 0, level);
          return err != null ? callback(err) : callback(new error_1.MongoRuntimeError("Error with profile command"));
        });
      }
    };
    exports2.SetProfilingLevelOperation = SetProfilingLevelOperation;
  }
});

// asset-input/node_modules/mongodb/lib/db.js
var require_db = __commonJS({
  "asset-input/node_modules/mongodb/lib/db.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Db = void 0;
    var admin_1 = require_admin();
    var bson_1 = require_bson2();
    var change_stream_1 = require_change_stream();
    var collection_1 = require_collection();
    var CONSTANTS = require_constants3();
    var aggregation_cursor_1 = require_aggregation_cursor();
    var list_collections_cursor_1 = require_list_collections_cursor();
    var error_1 = require_error();
    var logger_1 = require_logger();
    var add_user_1 = require_add_user();
    var collections_1 = require_collections();
    var create_collection_1 = require_create_collection();
    var drop_1 = require_drop();
    var execute_operation_1 = require_execute_operation();
    var indexes_1 = require_indexes();
    var profiling_level_1 = require_profiling_level();
    var remove_user_1 = require_remove_user();
    var rename_1 = require_rename();
    var run_command_1 = require_run_command();
    var set_profiling_level_1 = require_set_profiling_level();
    var stats_1 = require_stats();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils2();
    var write_concern_1 = require_write_concern();
    var DB_OPTIONS_ALLOW_LIST = [
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "authSource",
      "ignoreUndefined",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "loggerLevel",
      "logger",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp",
      "enableUtf8Validation",
      "promoteValues",
      "compression",
      "retryWrites"
    ];
    var Db = class {
      /**
       * Creates a new Db instance
       *
       * @param client - The MongoClient for the database.
       * @param databaseName - The name of the database this instance represents.
       * @param options - Optional settings for Db construction
       */
      constructor(client, databaseName, options) {
        var _a;
        options = options !== null && options !== void 0 ? options : {};
        options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);
        validateDatabaseName(databaseName);
        this.s = {
          // Client
          client,
          // Options
          options,
          // Logger instance
          logger: new logger_1.Logger("Db", options),
          // Unpack read preference
          readPreference: read_preference_1.ReadPreference.fromOptions(options),
          // Merge bson options
          bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
          // Set up the primary key factory or fallback to ObjectId
          pkFactory: (_a = options === null || options === void 0 ? void 0 : options.pkFactory) !== null && _a !== void 0 ? _a : utils_1.DEFAULT_PK_FACTORY,
          // ReadConcern
          readConcern: read_concern_1.ReadConcern.fromOptions(options),
          writeConcern: write_concern_1.WriteConcern.fromOptions(options),
          // Namespace
          namespace: new utils_1.MongoDBNamespace(databaseName)
        };
      }
      get databaseName() {
        return this.s.namespace.db;
      }
      // Options
      get options() {
        return this.s.options;
      }
      /**
       * slaveOk specified
       * @deprecated Use secondaryOk instead
       */
      get slaveOk() {
        return this.secondaryOk;
      }
      /**
       * Check if a secondary can be used (because the read preference is *not* set to primary)
       */
      get secondaryOk() {
        var _a;
        return ((_a = this.s.readPreference) === null || _a === void 0 ? void 0 : _a.preference) !== "primary" || false;
      }
      get readConcern() {
        return this.s.readConcern;
      }
      /**
       * The current readPreference of the Db. If not explicitly defined for
       * this Db, will be inherited from the parent MongoClient
       */
      get readPreference() {
        if (this.s.readPreference == null) {
          return this.s.client.readPreference;
        }
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      // get the write Concern
      get writeConcern() {
        return this.s.writeConcern;
      }
      get namespace() {
        return this.s.namespace.toString();
      }
      createCollection(name, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      command(command, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new run_command_1.RunCommandOperation(this, command, options !== null && options !== void 0 ? options : {}), callback);
      }
      /**
       * Execute an aggregation framework pipeline against the database, needs MongoDB \>= 3.6
       *
       * @param pipeline - An array of aggregation stages to be executed
       * @param options - Optional settings for the command
       */
      aggregate(pipeline2 = [], options) {
        if (arguments.length > 2) {
          throw new error_1.MongoInvalidArgumentError('Method "db.aggregate()" accepts at most two arguments');
        }
        if (typeof pipeline2 === "function") {
          throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must not be function');
        }
        if (typeof options === "function") {
          throw new error_1.MongoInvalidArgumentError('Argument "options" must not be function');
        }
        return new aggregation_cursor_1.AggregationCursor(this.s.client, this.s.namespace, pipeline2, (0, utils_1.resolveOptions)(this, options));
      }
      /** Return the Admin db instance */
      admin() {
        return new admin_1.Admin(this);
      }
      /**
       * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
       *
       * @param name - the collection name we wish to access.
       * @returns return the new Collection instance
       */
      collection(name, options = {}) {
        if (typeof options === "function") {
          throw new error_1.MongoInvalidArgumentError("The callback form of this helper has been removed.");
        }
        const finalOptions = (0, utils_1.resolveOptions)(this, options);
        return new collection_1.Collection(this, name, finalOptions);
      }
      stats(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      listCollections(filter = {}, options = {}) {
        return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
      }
      renameCollection(fromCollection, toCollection, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = { ...options, readPreference: read_preference_1.ReadPreference.PRIMARY };
        options.new_collection = true;
        return (0, execute_operation_1.executeOperation)(this.s.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, options), callback);
      }
      dropCollection(name, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      dropDatabase(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      collections(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      createIndex(name, indexSpec, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new indexes_1.CreateIndexOperation(this, name, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      addUser(username, password, options, callback) {
        if (typeof password === "function") {
          callback = password, password = void 0, options = {};
        } else if (typeof password !== "string") {
          if (typeof options === "function") {
            callback = options, options = password, password = void 0;
          } else {
            options = password, callback = void 0, password = void 0;
          }
        } else {
          if (typeof options === "function")
            callback = options, options = {};
        }
        return (0, execute_operation_1.executeOperation)(this.s.client, new add_user_1.AddUserOperation(this, username, password, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      removeUser(username, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      setProfilingLevel(level, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      profilingLevel(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      indexInformation(name, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        return (0, execute_operation_1.executeOperation)(this.s.client, new indexes_1.IndexInformationOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);
      }
      /**
       * Unref all sockets
       * @deprecated This function is deprecated and will be removed in the next major version.
       */
      unref() {
        (0, utils_1.getTopology)(this).unref();
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates,
       * replacements, deletions, and invalidations) in this database. Will ignore all
       * changes to system collections.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to provide the schema that may be defined for all the collections within this database
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       *
       * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TSchema - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline2 = [], options = {}) {
        if (!Array.isArray(pipeline2)) {
          options = pipeline2;
          pipeline2 = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline2, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Return the db logger
       * @deprecated The Legacy Logger is deprecated and will be removed in the next major version.
       */
      getLogger() {
        return this.s.logger;
      }
      /** @deprecated The Legacy Logger is deprecated and will be removed in the next major version. */
      get logger() {
        return this.s.logger;
      }
    };
    exports2.Db = Db;
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    function validateDatabaseName(databaseName) {
      if (typeof databaseName !== "string")
        throw new error_1.MongoInvalidArgumentError("Database name must be a string");
      if (databaseName.length === 0)
        throw new error_1.MongoInvalidArgumentError("Database name cannot be the empty string");
      if (databaseName === "$external")
        return;
      const invalidChars = [" ", ".", "$", "/", "\\"];
      for (let i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) !== -1)
          throw new error_1.MongoAPIError(`database names cannot contain the character '${invalidChars[i]}'`);
      }
    }
  }
});

// asset-input/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "asset-input/node_modules/webidl-conversions/lib/index.js"(exports2) {
    "use strict";
    function makeException(ErrorType, message, options) {
      if (options.globals) {
        ErrorType = options.globals[ErrorType.name];
      }
      return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
    }
    function toNumber(value, options) {
      if (typeof value === "bigint") {
        throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
      }
      if (!options.globals) {
        return Number(value);
      }
      return options.globals.Number(value);
    }
    function evenRound(x) {
      if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
        return censorNegativeZero(Math.floor(x));
      }
      return censorNegativeZero(Math.round(x));
    }
    function integerPart(n) {
      return censorNegativeZero(Math.trunc(n));
    }
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function modulo(x, y) {
      const signMightNotMatch = x % y;
      if (sign(y) !== sign(signMightNotMatch)) {
        return signMightNotMatch + y;
      }
      return signMightNotMatch;
    }
    function censorNegativeZero(x) {
      return x === 0 ? 0 : x;
    }
    function createIntegerConversion(bitLength, { unsigned }) {
      let lowerBound, upperBound;
      if (unsigned) {
        lowerBound = 0;
        upperBound = 2 ** bitLength - 1;
      } else {
        lowerBound = -(2 ** (bitLength - 1));
        upperBound = 2 ** (bitLength - 1) - 1;
      }
      const twoToTheBitLength = 2 ** bitLength;
      const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
      return (value, options = {}) => {
        let x = toNumber(value, options);
        x = censorNegativeZero(x);
        if (options.enforceRange) {
          if (!Number.isFinite(x)) {
            throw makeException(TypeError, "is not a finite number", options);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options
            );
          }
          return x;
        }
        if (!Number.isNaN(x) && options.clamp) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          x = evenRound(x);
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = integerPart(x);
        if (x >= lowerBound && x <= upperBound) {
          return x;
        }
        x = modulo(x, twoToTheBitLength);
        if (!unsigned && x >= twoToOneLessThanTheBitLength) {
          return x - twoToTheBitLength;
        }
        return x;
      };
    }
    function createLongLongConversion(bitLength, { unsigned }) {
      const upperBound = Number.MAX_SAFE_INTEGER;
      const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
      const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
      return (value, options = {}) => {
        let x = toNumber(value, options);
        x = censorNegativeZero(x);
        if (options.enforceRange) {
          if (!Number.isFinite(x)) {
            throw makeException(TypeError, "is not a finite number", options);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options
            );
          }
          return x;
        }
        if (!Number.isNaN(x) && options.clamp) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          x = evenRound(x);
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        let xBigInt = BigInt(integerPart(x));
        xBigInt = asBigIntN(bitLength, xBigInt);
        return Number(xBigInt);
      };
    }
    exports2.any = (value) => {
      return value;
    };
    exports2.undefined = () => {
      return void 0;
    };
    exports2.boolean = (value) => {
      return Boolean(value);
    };
    exports2.byte = createIntegerConversion(8, { unsigned: false });
    exports2.octet = createIntegerConversion(8, { unsigned: true });
    exports2.short = createIntegerConversion(16, { unsigned: false });
    exports2["unsigned short"] = createIntegerConversion(16, { unsigned: true });
    exports2.long = createIntegerConversion(32, { unsigned: false });
    exports2["unsigned long"] = createIntegerConversion(32, { unsigned: true });
    exports2["long long"] = createLongLongConversion(64, { unsigned: false });
    exports2["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
    exports2.double = (value, options = {}) => {
      const x = toNumber(value, options);
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", options);
      }
      return x;
    };
    exports2["unrestricted double"] = (value, options = {}) => {
      const x = toNumber(value, options);
      return x;
    };
    exports2.float = (value, options = {}) => {
      const x = toNumber(value, options);
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", options);
      }
      if (Object.is(x, -0)) {
        return x;
      }
      const y = Math.fround(x);
      if (!Number.isFinite(y)) {
        throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
      }
      return y;
    };
    exports2["unrestricted float"] = (value, options = {}) => {
      const x = toNumber(value, options);
      if (isNaN(x)) {
        return x;
      }
      if (Object.is(x, -0)) {
        return x;
      }
      return Math.fround(x);
    };
    exports2.DOMString = (value, options = {}) => {
      if (options.treatNullAsEmptyString && value === null) {
        return "";
      }
      if (typeof value === "symbol") {
        throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
      }
      const StringCtor = options.globals ? options.globals.String : String;
      return StringCtor(value);
    };
    exports2.ByteString = (value, options = {}) => {
      const x = exports2.DOMString(value, options);
      let c;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw makeException(TypeError, "is not a valid ByteString", options);
        }
      }
      return x;
    };
    exports2.USVString = (value, options = {}) => {
      const S = exports2.DOMString(value, options);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
      return U.join("");
    };
    exports2.object = (value, options = {}) => {
      if (value === null || typeof value !== "object" && typeof value !== "function") {
        throw makeException(TypeError, "is not an object", options);
      }
      return value;
    };
    var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
    function isNonSharedArrayBuffer(value) {
      try {
        abByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isSharedArrayBuffer(value) {
      try {
        sabByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isArrayBufferDetached(value) {
      try {
        new Uint8Array(value);
        return false;
      } catch {
        return true;
      }
    }
    exports2.ArrayBuffer = (value, options = {}) => {
      if (!isNonSharedArrayBuffer(value)) {
        if (options.allowShared && !isSharedArrayBuffer(value)) {
          throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
        }
        throw makeException(TypeError, "is not an ArrayBuffer", options);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options);
      }
      return value;
    };
    var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
    exports2.DataView = (value, options = {}) => {
      try {
        dvByteLengthGetter.call(value);
      } catch (e) {
        throw makeException(TypeError, "is not a DataView", options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
      }
      return value;
    };
    var typedArrayNameGetter = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(Uint8Array).prototype,
      Symbol.toStringTag
    ).get;
    [
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Uint8ClampedArray,
      Float32Array,
      Float64Array
    ].forEach((func) => {
      const { name } = func;
      const article = /^[AEIOU]/u.test(name) ? "an" : "a";
      exports2[name] = (value, options = {}) => {
        if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
          throw makeException(TypeError, `is not ${article} ${name} object`, options);
        }
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
        }
        return value;
      };
    });
    exports2.ArrayBufferView = (value, options = {}) => {
      if (!ArrayBuffer.isView(value)) {
        throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    };
    exports2.BufferSource = (value, options = {}) => {
      if (ArrayBuffer.isView(value)) {
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
        }
        return value;
      }
      if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
      }
      if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options);
      }
      return value;
    };
    exports2.DOMTimeStamp = exports2["unsigned long long"];
  }
});

// asset-input/node_modules/whatwg-url/lib/utils.js
var require_utils3 = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    function isObject(value) {
      return typeof value === "object" && value !== null || typeof value === "function";
    }
    var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
    function define2(target, source) {
      for (const key of Reflect.ownKeys(source)) {
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
          throw new TypeError(`Cannot redefine property: ${String(key)}`);
        }
      }
    }
    function newObjectInRealm(globalObject, object) {
      const ctorRegistry = initCtorRegistry(globalObject);
      return Object.defineProperties(
        Object.create(ctorRegistry["%Object.prototype%"]),
        Object.getOwnPropertyDescriptors(object)
      );
    }
    var wrapperSymbol = Symbol("wrapper");
    var implSymbol = Symbol("impl");
    var sameObjectCaches = Symbol("SameObject caches");
    var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
    var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);
    function initCtorRegistry(globalObject) {
      if (hasOwn(globalObject, ctorRegistrySymbol)) {
        return globalObject[ctorRegistrySymbol];
      }
      const ctorRegistry = /* @__PURE__ */ Object.create(null);
      ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
      ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(
        Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())
      );
      try {
        ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(
          Object.getPrototypeOf(
            globalObject.eval("(async function* () {})").prototype
          )
        );
      } catch {
        ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
      }
      globalObject[ctorRegistrySymbol] = ctorRegistry;
      return ctorRegistry;
    }
    function getSameObject(wrapper, prop, creator) {
      if (!wrapper[sameObjectCaches]) {
        wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
      }
      if (prop in wrapper[sameObjectCaches]) {
        return wrapper[sameObjectCaches][prop];
      }
      wrapper[sameObjectCaches][prop] = creator();
      return wrapper[sameObjectCaches][prop];
    }
    function wrapperForImpl(impl) {
      return impl ? impl[wrapperSymbol] : null;
    }
    function implForWrapper(wrapper) {
      return wrapper ? wrapper[implSymbol] : null;
    }
    function tryWrapperForImpl(impl) {
      const wrapper = wrapperForImpl(impl);
      return wrapper ? wrapper : impl;
    }
    function tryImplForWrapper(wrapper) {
      const impl = implForWrapper(wrapper);
      return impl ? impl : wrapper;
    }
    var iterInternalSymbol = Symbol("internal");
    function isArrayIndexPropName(P) {
      if (typeof P !== "string") {
        return false;
      }
      const i = P >>> 0;
      if (i === 2 ** 32 - 1) {
        return false;
      }
      const s = `${i}`;
      if (P !== s) {
        return false;
      }
      return true;
    }
    var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    function isArrayBuffer(value) {
      try {
        byteLengthGetter.call(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    function iteratorResult([key, value], kind) {
      let result;
      switch (kind) {
        case "key":
          result = key;
          break;
        case "value":
          result = value;
          break;
        case "key+value":
          result = [key, value];
          break;
      }
      return { value: result, done: false };
    }
    var supportsPropertyIndex = Symbol("supports property index");
    var supportedPropertyIndices = Symbol("supported property indices");
    var supportsPropertyName = Symbol("supports property name");
    var supportedPropertyNames = Symbol("supported property names");
    var indexedGet = Symbol("indexed property get");
    var indexedSetNew = Symbol("indexed property set new");
    var indexedSetExisting = Symbol("indexed property set existing");
    var namedGet = Symbol("named property get");
    var namedSetNew = Symbol("named property set new");
    var namedSetExisting = Symbol("named property set existing");
    var namedDelete = Symbol("named property delete");
    var asyncIteratorNext = Symbol("async iterator get the next iteration result");
    var asyncIteratorReturn = Symbol("async iterator return steps");
    var asyncIteratorInit = Symbol("async iterator initialization steps");
    var asyncIteratorEOI = Symbol("async iterator end of iteration");
    module2.exports = exports2 = {
      isObject,
      hasOwn,
      define: define2,
      newObjectInRealm,
      wrapperSymbol,
      implSymbol,
      getSameObject,
      ctorRegistrySymbol,
      initCtorRegistry,
      wrapperForImpl,
      implForWrapper,
      tryWrapperForImpl,
      tryImplForWrapper,
      iterInternalSymbol,
      isArrayBuffer,
      isArrayIndexPropName,
      supportsPropertyIndex,
      supportedPropertyIndices,
      supportsPropertyName,
      supportedPropertyNames,
      indexedGet,
      indexedSetNew,
      indexedSetExisting,
      namedGet,
      namedSetNew,
      namedSetExisting,
      namedDelete,
      asyncIteratorNext,
      asyncIteratorReturn,
      asyncIteratorInit,
      asyncIteratorEOI,
      iteratorResult
    };
  }
});

// asset-input/node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS({
  "asset-input/node_modules/tr46/lib/regexes.js"(exports2, module2) {
    "use strict";
    var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
    var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}]/u;
    var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u08A0-\u08A9\u08AF\u08B0\u08B3\u08B4\u08B6-\u08B8\u08BA-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0855\u0860\u0862-\u0865\u0867-\u086A\u08A0-\u08AC\u08AE-\u08B4\u08B6-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{1E900}-\u{1E943}]/u;
    var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1342E}\u{13430}-\u{13438}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B150}-\u{1B152}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B738}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
    var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0898-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11FD5}-\u{11FF1}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DD}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F773}\u{1F780}-\u{1F7D8}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7C}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAAC}\u{1FAB0}-\u{1FABA}\u{1FAC0}-\u{1FAC5}\u{1FAD0}-\u{1FAD9}\u{1FAE0}-\u{1FAE7}\u{1FAF0}-\u{1FAF6}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
    var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}]/u;
    var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B50-\u1B7E\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E3\u31F0-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1123E}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1342E}\u{13430}-\u{13438}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B150}-\u{1B152}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DD}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F773}\u{1F780}-\u{1F7D8}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7C}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAAC}\u{1FAB0}-\u{1FABA}\u{1FAC0}-\u{1FAC5}\u{1FAD0}-\u{1FAD9}\u{1FAE0}-\u{1FAE7}\u{1FAF0}-\u{1FAF6}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B738}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
    var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1342E}\u{13430}-\u{13438}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B150}-\u{1B152}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B738}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    module2.exports = {
      combiningMarks,
      combiningClassVirama,
      validZWNJ,
      bidiDomain,
      bidiS1LTR,
      bidiS1RTL,
      bidiS2,
      bidiS3,
      bidiS4EN,
      bidiS4AN,
      bidiS5,
      bidiS6
    };
  }
});

// asset-input/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "asset-input/node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], 4], [[45, 46], 2], [47, 4], [[48, 57], 2], [[58, 64], 4], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 4], [[97, 122], 2], [[123, 127], 4], [[128, 159], 3], [160, 5, " "], [[161, 167], 2], [168, 5, " \u0308"], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 5, " \u0304"], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 5, " \u0301"], [181, 1, "\u03BC"], [182, 2], [183, 2], [184, 5, " \u0327"], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "1\u20444"], [189, 1, "1\u20442"], [190, 1, "3\u20444"], [191, 2], [192, 1, "\xE0"], [193, 1, "\xE1"], [194, 1, "\xE2"], [195, 1, "\xE3"], [196, 1, "\xE4"], [197, 1, "\xE5"], [198, 1, "\xE6"], [199, 1, "\xE7"], [200, 1, "\xE8"], [201, 1, "\xE9"], [202, 1, "\xEA"], [203, 1, "\xEB"], [204, 1, "\xEC"], [205, 1, "\xED"], [206, 1, "\xEE"], [207, 1, "\xEF"], [208, 1, "\xF0"], [209, 1, "\xF1"], [210, 1, "\xF2"], [211, 1, "\xF3"], [212, 1, "\xF4"], [213, 1, "\xF5"], [214, 1, "\xF6"], [215, 2], [216, 1, "\xF8"], [217, 1, "\xF9"], [218, 1, "\xFA"], [219, 1, "\xFB"], [220, 1, "\xFC"], [221, 1, "\xFD"], [222, 1, "\xFE"], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, "\u0101"], [257, 2], [258, 1, "\u0103"], [259, 2], [260, 1, "\u0105"], [261, 2], [262, 1, "\u0107"], [263, 2], [264, 1, "\u0109"], [265, 2], [266, 1, "\u010B"], [267, 2], [268, 1, "\u010D"], [269, 2], [270, 1, "\u010F"], [271, 2], [272, 1, "\u0111"], [273, 2], [274, 1, "\u0113"], [275, 2], [276, 1, "\u0115"], [277, 2], [278, 1, "\u0117"], [279, 2], [280, 1, "\u0119"], [281, 2], [282, 1, "\u011B"], [283, 2], [284, 1, "\u011D"], [285, 2], [286, 1, "\u011F"], [287, 2], [288, 1, "\u0121"], [289, 2], [290, 1, "\u0123"], [291, 2], [292, 1, "\u0125"], [293, 2], [294, 1, "\u0127"], [295, 2], [296, 1, "\u0129"], [297, 2], [298, 1, "\u012B"], [299, 2], [300, 1, "\u012D"], [301, 2], [302, 1, "\u012F"], [303, 2], [304, 1, "i\u0307"], [305, 2], [[306, 307], 1, "ij"], [308, 1, "\u0135"], [309, 2], [310, 1, "\u0137"], [[311, 312], 2], [313, 1, "\u013A"], [314, 2], [315, 1, "\u013C"], [316, 2], [317, 1, "\u013E"], [318, 2], [[319, 320], 1, "l\xB7"], [321, 1, "\u0142"], [322, 2], [323, 1, "\u0144"], [324, 2], [325, 1, "\u0146"], [326, 2], [327, 1, "\u0148"], [328, 2], [329, 1, "\u02BCn"], [330, 1, "\u014B"], [331, 2], [332, 1, "\u014D"], [333, 2], [334, 1, "\u014F"], [335, 2], [336, 1, "\u0151"], [337, 2], [338, 1, "\u0153"], [339, 2], [340, 1, "\u0155"], [341, 2], [342, 1, "\u0157"], [343, 2], [344, 1, "\u0159"], [345, 2], [346, 1, "\u015B"], [347, 2], [348, 1, "\u015D"], [349, 2], [350, 1, "\u015F"], [351, 2], [352, 1, "\u0161"], [353, 2], [354, 1, "\u0163"], [355, 2], [356, 1, "\u0165"], [357, 2], [358, 1, "\u0167"], [359, 2], [360, 1, "\u0169"], [361, 2], [362, 1, "\u016B"], [363, 2], [364, 1, "\u016D"], [365, 2], [366, 1, "\u016F"], [367, 2], [368, 1, "\u0171"], [369, 2], [370, 1, "\u0173"], [371, 2], [372, 1, "\u0175"], [373, 2], [374, 1, "\u0177"], [375, 2], [376, 1, "\xFF"], [377, 1, "\u017A"], [378, 2], [379, 1, "\u017C"], [380, 2], [381, 1, "\u017E"], [382, 2], [383, 1, "s"], [384, 2], [385, 1, "\u0253"], [386, 1, "\u0183"], [387, 2], [388, 1, "\u0185"], [389, 2], [390, 1, "\u0254"], [391, 1, "\u0188"], [392, 2], [393, 1, "\u0256"], [394, 1, "\u0257"], [395, 1, "\u018C"], [[396, 397], 2], [398, 1, "\u01DD"], [399, 1, "\u0259"], [400, 1, "\u025B"], [401, 1, "\u0192"], [402, 2], [403, 1, "\u0260"], [404, 1, "\u0263"], [405, 2], [406, 1, "\u0269"], [407, 1, "\u0268"], [408, 1, "\u0199"], [[409, 411], 2], [412, 1, "\u026F"], [413, 1, "\u0272"], [414, 2], [415, 1, "\u0275"], [416, 1, "\u01A1"], [417, 2], [418, 1, "\u01A3"], [419, 2], [420, 1, "\u01A5"], [421, 2], [422, 1, "\u0280"], [423, 1, "\u01A8"], [424, 2], [425, 1, "\u0283"], [[426, 427], 2], [428, 1, "\u01AD"], [429, 2], [430, 1, "\u0288"], [431, 1, "\u01B0"], [432, 2], [433, 1, "\u028A"], [434, 1, "\u028B"], [435, 1, "\u01B4"], [436, 2], [437, 1, "\u01B6"], [438, 2], [439, 1, "\u0292"], [440, 1, "\u01B9"], [[441, 443], 2], [444, 1, "\u01BD"], [[445, 451], 2], [[452, 454], 1, "d\u017E"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, "\u01CE"], [462, 2], [463, 1, "\u01D0"], [464, 2], [465, 1, "\u01D2"], [466, 2], [467, 1, "\u01D4"], [468, 2], [469, 1, "\u01D6"], [470, 2], [471, 1, "\u01D8"], [472, 2], [473, 1, "\u01DA"], [474, 2], [475, 1, "\u01DC"], [[476, 477], 2], [478, 1, "\u01DF"], [479, 2], [480, 1, "\u01E1"], [481, 2], [482, 1, "\u01E3"], [483, 2], [484, 1, "\u01E5"], [485, 2], [486, 1, "\u01E7"], [487, 2], [488, 1, "\u01E9"], [489, 2], [490, 1, "\u01EB"], [491, 2], [492, 1, "\u01ED"], [493, 2], [494, 1, "\u01EF"], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, "\u01F5"], [501, 2], [502, 1, "\u0195"], [503, 1, "\u01BF"], [504, 1, "\u01F9"], [505, 2], [506, 1, "\u01FB"], [507, 2], [508, 1, "\u01FD"], [509, 2], [510, 1, "\u01FF"], [511, 2], [512, 1, "\u0201"], [513, 2], [514, 1, "\u0203"], [515, 2], [516, 1, "\u0205"], [517, 2], [518, 1, "\u0207"], [519, 2], [520, 1, "\u0209"], [521, 2], [522, 1, "\u020B"], [523, 2], [524, 1, "\u020D"], [525, 2], [526, 1, "\u020F"], [527, 2], [528, 1, "\u0211"], [529, 2], [530, 1, "\u0213"], [531, 2], [532, 1, "\u0215"], [533, 2], [534, 1, "\u0217"], [535, 2], [536, 1, "\u0219"], [537, 2], [538, 1, "\u021B"], [539, 2], [540, 1, "\u021D"], [541, 2], [542, 1, "\u021F"], [543, 2], [544, 1, "\u019E"], [545, 2], [546, 1, "\u0223"], [547, 2], [548, 1, "\u0225"], [549, 2], [550, 1, "\u0227"], [551, 2], [552, 1, "\u0229"], [553, 2], [554, 1, "\u022B"], [555, 2], [556, 1, "\u022D"], [557, 2], [558, 1, "\u022F"], [559, 2], [560, 1, "\u0231"], [561, 2], [562, 1, "\u0233"], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, "\u2C65"], [571, 1, "\u023C"], [572, 2], [573, 1, "\u019A"], [574, 1, "\u2C66"], [[575, 576], 2], [577, 1, "\u0242"], [578, 2], [579, 1, "\u0180"], [580, 1, "\u0289"], [581, 1, "\u028C"], [582, 1, "\u0247"], [583, 2], [584, 1, "\u0249"], [585, 2], [586, 1, "\u024B"], [587, 2], [588, 1, "\u024D"], [589, 2], [590, 1, "\u024F"], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, "\u0266"], [690, 1, "j"], [691, 1, "r"], [692, 1, "\u0279"], [693, 1, "\u027B"], [694, 1, "\u0281"], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 5, " \u0306"], [729, 5, " \u0307"], [730, 5, " \u030A"], [731, 5, " \u0328"], [732, 5, " \u0303"], [733, 5, " \u030B"], [734, 2], [735, 2], [736, 1, "\u0263"], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, "\u0295"], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, "\u0300"], [833, 1, "\u0301"], [834, 2], [835, 1, "\u0313"], [836, 1, "\u0308\u0301"], [837, 1, "\u03B9"], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, "\u0371"], [881, 2], [882, 1, "\u0373"], [883, 2], [884, 1, "\u02B9"], [885, 2], [886, 1, "\u0377"], [887, 2], [[888, 889], 3], [890, 5, " \u03B9"], [[891, 893], 2], [894, 5, ";"], [895, 1, "\u03F3"], [[896, 899], 3], [900, 5, " \u0301"], [901, 5, " \u0308\u0301"], [902, 1, "\u03AC"], [903, 1, "\xB7"], [904, 1, "\u03AD"], [905, 1, "\u03AE"], [906, 1, "\u03AF"], [907, 3], [908, 1, "\u03CC"], [909, 3], [910, 1, "\u03CD"], [911, 1, "\u03CE"], [912, 2], [913, 1, "\u03B1"], [914, 1, "\u03B2"], [915, 1, "\u03B3"], [916, 1, "\u03B4"], [917, 1, "\u03B5"], [918, 1, "\u03B6"], [919, 1, "\u03B7"], [920, 1, "\u03B8"], [921, 1, "\u03B9"], [922, 1, "\u03BA"], [923, 1, "\u03BB"], [924, 1, "\u03BC"], [925, 1, "\u03BD"], [926, 1, "\u03BE"], [927, 1, "\u03BF"], [928, 1, "\u03C0"], [929, 1, "\u03C1"], [930, 3], [931, 1, "\u03C3"], [932, 1, "\u03C4"], [933, 1, "\u03C5"], [934, 1, "\u03C6"], [935, 1, "\u03C7"], [936, 1, "\u03C8"], [937, 1, "\u03C9"], [938, 1, "\u03CA"], [939, 1, "\u03CB"], [[940, 961], 2], [962, 6, "\u03C3"], [[963, 974], 2], [975, 1, "\u03D7"], [976, 1, "\u03B2"], [977, 1, "\u03B8"], [978, 1, "\u03C5"], [979, 1, "\u03CD"], [980, 1, "\u03CB"], [981, 1, "\u03C6"], [982, 1, "\u03C0"], [983, 2], [984, 1, "\u03D9"], [985, 2], [986, 1, "\u03DB"], [987, 2], [988, 1, "\u03DD"], [989, 2], [990, 1, "\u03DF"], [991, 2], [992, 1, "\u03E1"], [993, 2], [994, 1, "\u03E3"], [995, 2], [996, 1, "\u03E5"], [997, 2], [998, 1, "\u03E7"], [999, 2], [1e3, 1, "\u03E9"], [1001, 2], [1002, 1, "\u03EB"], [1003, 2], [1004, 1, "\u03ED"], [1005, 2], [1006, 1, "\u03EF"], [1007, 2], [1008, 1, "\u03BA"], [1009, 1, "\u03C1"], [1010, 1, "\u03C3"], [1011, 2], [1012, 1, "\u03B8"], [1013, 1, "\u03B5"], [1014, 2], [1015, 1, "\u03F8"], [1016, 2], [1017, 1, "\u03C3"], [1018, 1, "\u03FB"], [1019, 2], [1020, 2], [1021, 1, "\u037B"], [1022, 1, "\u037C"], [1023, 1, "\u037D"], [1024, 1, "\u0450"], [1025, 1, "\u0451"], [1026, 1, "\u0452"], [1027, 1, "\u0453"], [1028, 1, "\u0454"], [1029, 1, "\u0455"], [1030, 1, "\u0456"], [1031, 1, "\u0457"], [1032, 1, "\u0458"], [1033, 1, "\u0459"], [1034, 1, "\u045A"], [1035, 1, "\u045B"], [1036, 1, "\u045C"], [1037, 1, "\u045D"], [1038, 1, "\u045E"], [1039, 1, "\u045F"], [1040, 1, "\u0430"], [1041, 1, "\u0431"], [1042, 1, "\u0432"], [1043, 1, "\u0433"], [1044, 1, "\u0434"], [1045, 1, "\u0435"], [1046, 1, "\u0436"], [1047, 1, "\u0437"], [1048, 1, "\u0438"], [1049, 1, "\u0439"], [1050, 1, "\u043A"], [1051, 1, "\u043B"], [1052, 1, "\u043C"], [1053, 1, "\u043D"], [1054, 1, "\u043E"], [1055, 1, "\u043F"], [1056, 1, "\u0440"], [1057, 1, "\u0441"], [1058, 1, "\u0442"], [1059, 1, "\u0443"], [1060, 1, "\u0444"], [1061, 1, "\u0445"], [1062, 1, "\u0446"], [1063, 1, "\u0447"], [1064, 1, "\u0448"], [1065, 1, "\u0449"], [1066, 1, "\u044A"], [1067, 1, "\u044B"], [1068, 1, "\u044C"], [1069, 1, "\u044D"], [1070, 1, "\u044E"], [1071, 1, "\u044F"], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, "\u0461"], [1121, 2], [1122, 1, "\u0463"], [1123, 2], [1124, 1, "\u0465"], [1125, 2], [1126, 1, "\u0467"], [1127, 2], [1128, 1, "\u0469"], [1129, 2], [1130, 1, "\u046B"], [1131, 2], [1132, 1, "\u046D"], [1133, 2], [1134, 1, "\u046F"], [1135, 2], [1136, 1, "\u0471"], [1137, 2], [1138, 1, "\u0473"], [1139, 2], [1140, 1, "\u0475"], [1141, 2], [1142, 1, "\u0477"], [1143, 2], [1144, 1, "\u0479"], [1145, 2], [1146, 1, "\u047B"], [1147, 2], [1148, 1, "\u047D"], [1149, 2], [1150, 1, "\u047F"], [1151, 2], [1152, 1, "\u0481"], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, "\u048B"], [1163, 2], [1164, 1, "\u048D"], [1165, 2], [1166, 1, "\u048F"], [1167, 2], [1168, 1, "\u0491"], [1169, 2], [1170, 1, "\u0493"], [1171, 2], [1172, 1, "\u0495"], [1173, 2], [1174, 1, "\u0497"], [1175, 2], [1176, 1, "\u0499"], [1177, 2], [1178, 1, "\u049B"], [1179, 2], [1180, 1, "\u049D"], [1181, 2], [1182, 1, "\u049F"], [1183, 2], [1184, 1, "\u04A1"], [1185, 2], [1186, 1, "\u04A3"], [1187, 2], [1188, 1, "\u04A5"], [1189, 2], [1190, 1, "\u04A7"], [1191, 2], [1192, 1, "\u04A9"], [1193, 2], [1194, 1, "\u04AB"], [1195, 2], [1196, 1, "\u04AD"], [1197, 2], [1198, 1, "\u04AF"], [1199, 2], [1200, 1, "\u04B1"], [1201, 2], [1202, 1, "\u04B3"], [1203, 2], [1204, 1, "\u04B5"], [1205, 2], [1206, 1, "\u04B7"], [1207, 2], [1208, 1, "\u04B9"], [1209, 2], [1210, 1, "\u04BB"], [1211, 2], [1212, 1, "\u04BD"], [1213, 2], [1214, 1, "\u04BF"], [1215, 2], [1216, 3], [1217, 1, "\u04C2"], [1218, 2], [1219, 1, "\u04C4"], [1220, 2], [1221, 1, "\u04C6"], [1222, 2], [1223, 1, "\u04C8"], [1224, 2], [1225, 1, "\u04CA"], [1226, 2], [1227, 1, "\u04CC"], [1228, 2], [1229, 1, "\u04CE"], [1230, 2], [1231, 2], [1232, 1, "\u04D1"], [1233, 2], [1234, 1, "\u04D3"], [1235, 2], [1236, 1, "\u04D5"], [1237, 2], [1238, 1, "\u04D7"], [1239, 2], [1240, 1, "\u04D9"], [1241, 2], [1242, 1, "\u04DB"], [1243, 2], [1244, 1, "\u04DD"], [1245, 2], [1246, 1, "\u04DF"], [1247, 2], [1248, 1, "\u04E1"], [1249, 2], [1250, 1, "\u04E3"], [1251, 2], [1252, 1, "\u04E5"], [1253, 2], [1254, 1, "\u04E7"], [1255, 2], [1256, 1, "\u04E9"], [1257, 2], [1258, 1, "\u04EB"], [1259, 2], [1260, 1, "\u04ED"], [1261, 2], [1262, 1, "\u04EF"], [1263, 2], [1264, 1, "\u04F1"], [1265, 2], [1266, 1, "\u04F3"], [1267, 2], [1268, 1, "\u04F5"], [1269, 2], [1270, 1, "\u04F7"], [1271, 2], [1272, 1, "\u04F9"], [1273, 2], [1274, 1, "\u04FB"], [1275, 2], [1276, 1, "\u04FD"], [1277, 2], [1278, 1, "\u04FF"], [1279, 2], [1280, 1, "\u0501"], [1281, 2], [1282, 1, "\u0503"], [1283, 2], [1284, 1, "\u0505"], [1285, 2], [1286, 1, "\u0507"], [1287, 2], [1288, 1, "\u0509"], [1289, 2], [1290, 1, "\u050B"], [1291, 2], [1292, 1, "\u050D"], [1293, 2], [1294, 1, "\u050F"], [1295, 2], [1296, 1, "\u0511"], [1297, 2], [1298, 1, "\u0513"], [1299, 2], [1300, 1, "\u0515"], [1301, 2], [1302, 1, "\u0517"], [1303, 2], [1304, 1, "\u0519"], [1305, 2], [1306, 1, "\u051B"], [1307, 2], [1308, 1, "\u051D"], [1309, 2], [1310, 1, "\u051F"], [1311, 2], [1312, 1, "\u0521"], [1313, 2], [1314, 1, "\u0523"], [1315, 2], [1316, 1, "\u0525"], [1317, 2], [1318, 1, "\u0527"], [1319, 2], [1320, 1, "\u0529"], [1321, 2], [1322, 1, "\u052B"], [1323, 2], [1324, 1, "\u052D"], [1325, 2], [1326, 1, "\u052F"], [1327, 2], [1328, 3], [1329, 1, "\u0561"], [1330, 1, "\u0562"], [1331, 1, "\u0563"], [1332, 1, "\u0564"], [1333, 1, "\u0565"], [1334, 1, "\u0566"], [1335, 1, "\u0567"], [1336, 1, "\u0568"], [1337, 1, "\u0569"], [1338, 1, "\u056A"], [1339, 1, "\u056B"], [1340, 1, "\u056C"], [1341, 1, "\u056D"], [1342, 1, "\u056E"], [1343, 1, "\u056F"], [1344, 1, "\u0570"], [1345, 1, "\u0571"], [1346, 1, "\u0572"], [1347, 1, "\u0573"], [1348, 1, "\u0574"], [1349, 1, "\u0575"], [1350, 1, "\u0576"], [1351, 1, "\u0577"], [1352, 1, "\u0578"], [1353, 1, "\u0579"], [1354, 1, "\u057A"], [1355, 1, "\u057B"], [1356, 1, "\u057C"], [1357, 1, "\u057D"], [1358, 1, "\u057E"], [1359, 1, "\u057F"], [1360, 1, "\u0580"], [1361, 1, "\u0581"], [1362, 1, "\u0582"], [1363, 1, "\u0583"], [1364, 1, "\u0584"], [1365, 1, "\u0585"], [1366, 1, "\u0586"], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, "\u0565\u0582"], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, "\u0627\u0674"], [1654, 1, "\u0648\u0674"], [1655, 1, "\u06C7\u0674"], [1656, 1, "\u064A\u0674"], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2199], 3], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, "\u0915\u093C"], [2393, 1, "\u0916\u093C"], [2394, 1, "\u0917\u093C"], [2395, 1, "\u091C\u093C"], [2396, 1, "\u0921\u093C"], [2397, 1, "\u0922\u093C"], [2398, 1, "\u092B\u093C"], [2399, 1, "\u092F\u093C"], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, "\u09A1\u09BC"], [2525, 1, "\u09A2\u09BC"], [2526, 3], [2527, 1, "\u09AF\u09BC"], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, "\u0A32\u0A3C"], [2612, 3], [2613, 2], [2614, 1, "\u0A38\u0A3C"], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, "\u0A16\u0A3C"], [2650, 1, "\u0A17\u0A3C"], [2651, 1, "\u0A1C\u0A3C"], [2652, 2], [2653, 3], [2654, 1, "\u0A2B\u0A3C"], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, "\u0B21\u0B3C"], [2909, 1, "\u0B22\u0B3C"], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [[3315, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, "\u0E4D\u0E32"], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, "\u0ECD\u0EB2"], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [[3790, 3791], 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, "\u0EAB\u0E99"], [3805, 1, "\u0EAB\u0EA1"], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, "\u0F0B"], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, "\u0F42\u0FB7"], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, "\u0F4C\u0FB7"], [[3918, 3921], 2], [3922, 1, "\u0F51\u0FB7"], [[3923, 3926], 2], [3927, 1, "\u0F56\u0FB7"], [[3928, 3931], 2], [3932, 1, "\u0F5B\u0FB7"], [[3933, 3944], 2], [3945, 1, "\u0F40\u0FB5"], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, "\u0F71\u0F72"], [3956, 2], [3957, 1, "\u0F71\u0F74"], [3958, 1, "\u0FB2\u0F80"], [3959, 1, "\u0FB2\u0F71\u0F80"], [3960, 1, "\u0FB3\u0F80"], [3961, 1, "\u0FB3\u0F71\u0F80"], [[3962, 3968], 2], [3969, 1, "\u0F71\u0F80"], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, "\u0F92\u0FB7"], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, "\u0F9C\u0FB7"], [[3998, 4001], 2], [4002, 1, "\u0FA1\u0FB7"], [[4003, 4006], 2], [4007, 1, "\u0FA6\u0FB7"], [[4008, 4011], 2], [4012, 1, "\u0FAB\u0FB7"], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, "\u0F90\u0FB5"], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [[4256, 4293], 3], [4294, 3], [4295, 1, "\u2D27"], [[4296, 4300], 3], [4301, 1, "\u2D2D"], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, "\u10DC"], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 3], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, "\u13F0"], [5113, 1, "\u13F1"], [5114, 1, "\u13F2"], [5115, 1, "\u13F3"], [5116, 1, "\u13F4"], [5117, 1, "\u13F5"], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6e3], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 3], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6149], 2], [6150, 3], [[6151, 6154], 2], [[6155, 6157], 7], [6158, 3], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [[6989, 6991], 3], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 3], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, "\u0432"], [7297, 1, "\u0434"], [7298, 1, "\u043E"], [7299, 1, "\u0441"], [[7300, 7301], 1, "\u0442"], [7302, 1, "\u044A"], [7303, 1, "\u0463"], [7304, 1, "\uA64B"], [[7305, 7311], 3], [7312, 1, "\u10D0"], [7313, 1, "\u10D1"], [7314, 1, "\u10D2"], [7315, 1, "\u10D3"], [7316, 1, "\u10D4"], [7317, 1, "\u10D5"], [7318, 1, "\u10D6"], [7319, 1, "\u10D7"], [7320, 1, "\u10D8"], [7321, 1, "\u10D9"], [7322, 1, "\u10DA"], [7323, 1, "\u10DB"], [7324, 1, "\u10DC"], [7325, 1, "\u10DD"], [7326, 1, "\u10DE"], [7327, 1, "\u10DF"], [7328, 1, "\u10E0"], [7329, 1, "\u10E1"], [7330, 1, "\u10E2"], [7331, 1, "\u10E3"], [7332, 1, "\u10E4"], [7333, 1, "\u10E5"], [7334, 1, "\u10E6"], [7335, 1, "\u10E7"], [7336, 1, "\u10E8"], [7337, 1, "\u10E9"], [7338, 1, "\u10EA"], [7339, 1, "\u10EB"], [7340, 1, "\u10EC"], [7341, 1, "\u10ED"], [7342, 1, "\u10EE"], [7343, 1, "\u10EF"], [7344, 1, "\u10F0"], [7345, 1, "\u10F1"], [7346, 1, "\u10F2"], [7347, 1, "\u10F3"], [7348, 1, "\u10F4"], [7349, 1, "\u10F5"], [7350, 1, "\u10F6"], [7351, 1, "\u10F7"], [7352, 1, "\u10F8"], [7353, 1, "\u10F9"], [7354, 1, "\u10FA"], [[7355, 7356], 3], [7357, 1, "\u10FD"], [7358, 1, "\u10FE"], [7359, 1, "\u10FF"], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, "\xE6"], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, "\u01DD"], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, "\u0223"], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, "\u0250"], [7493, 1, "\u0251"], [7494, 1, "\u1D02"], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, "\u0259"], [7499, 1, "\u025B"], [7500, 1, "\u025C"], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, "\u014B"], [7506, 1, "o"], [7507, 1, "\u0254"], [7508, 1, "\u1D16"], [7509, 1, "\u1D17"], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, "\u1D1D"], [7514, 1, "\u026F"], [7515, 1, "v"], [7516, 1, "\u1D25"], [7517, 1, "\u03B2"], [7518, 1, "\u03B3"], [7519, 1, "\u03B4"], [7520, 1, "\u03C6"], [7521, 1, "\u03C7"], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, "\u03B2"], [7527, 1, "\u03B3"], [7528, 1, "\u03C1"], [7529, 1, "\u03C6"], [7530, 1, "\u03C7"], [7531, 2], [[7532, 7543], 2], [7544, 1, "\u043D"], [[7545, 7578], 2], [7579, 1, "\u0252"], [7580, 1, "c"], [7581, 1, "\u0255"], [7582, 1, "\xF0"], [7583, 1, "\u025C"], [7584, 1, "f"], [7585, 1, "\u025F"], [7586, 1, "\u0261"], [7587, 1, "\u0265"], [7588, 1, "\u0268"], [7589, 1, "\u0269"], [7590, 1, "\u026A"], [7591, 1, "\u1D7B"], [7592, 1, "\u029D"], [7593, 1, "\u026D"], [7594, 1, "\u1D85"], [7595, 1, "\u029F"], [7596, 1, "\u0271"], [7597, 1, "\u0270"], [7598, 1, "\u0272"], [7599, 1, "\u0273"], [7600, 1, "\u0274"], [7601, 1, "\u0275"], [7602, 1, "\u0278"], [7603, 1, "\u0282"], [7604, 1, "\u0283"], [7605, 1, "\u01AB"], [7606, 1, "\u0289"], [7607, 1, "\u028A"], [7608, 1, "\u1D1C"], [7609, 1, "\u028B"], [7610, 1, "\u028C"], [7611, 1, "z"], [7612, 1, "\u0290"], [7613, 1, "\u0291"], [7614, 1, "\u0292"], [7615, 1, "\u03B8"], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, "\u1E01"], [7681, 2], [7682, 1, "\u1E03"], [7683, 2], [7684, 1, "\u1E05"], [7685, 2], [7686, 1, "\u1E07"], [7687, 2], [7688, 1, "\u1E09"], [7689, 2], [7690, 1, "\u1E0B"], [7691, 2], [7692, 1, "\u1E0D"], [7693, 2], [7694, 1, "\u1E0F"], [7695, 2], [7696, 1, "\u1E11"], [7697, 2], [7698, 1, "\u1E13"], [7699, 2], [7700, 1, "\u1E15"], [7701, 2], [7702, 1, "\u1E17"], [7703, 2], [7704, 1, "\u1E19"], [7705, 2], [7706, 1, "\u1E1B"], [7707, 2], [7708, 1, "\u1E1D"], [7709, 2], [7710, 1, "\u1E1F"], [7711, 2], [7712, 1, "\u1E21"], [7713, 2], [7714, 1, "\u1E23"], [7715, 2], [7716, 1, "\u1E25"], [7717, 2], [7718, 1, "\u1E27"], [7719, 2], [7720, 1, "\u1E29"], [7721, 2], [7722, 1, "\u1E2B"], [7723, 2], [7724, 1, "\u1E2D"], [7725, 2], [7726, 1, "\u1E2F"], [7727, 2], [7728, 1, "\u1E31"], [7729, 2], [7730, 1, "\u1E33"], [7731, 2], [7732, 1, "\u1E35"], [7733, 2], [7734, 1, "\u1E37"], [7735, 2], [7736, 1, "\u1E39"], [7737, 2], [7738, 1, "\u1E3B"], [7739, 2], [7740, 1, "\u1E3D"], [7741, 2], [7742, 1, "\u1E3F"], [7743, 2], [7744, 1, "\u1E41"], [7745, 2], [7746, 1, "\u1E43"], [7747, 2], [7748, 1, "\u1E45"], [7749, 2], [7750, 1, "\u1E47"], [7751, 2], [7752, 1, "\u1E49"], [7753, 2], [7754, 1, "\u1E4B"], [7755, 2], [7756, 1, "\u1E4D"], [7757, 2], [7758, 1, "\u1E4F"], [7759, 2], [7760, 1, "\u1E51"], [7761, 2], [7762, 1, "\u1E53"], [7763, 2], [7764, 1, "\u1E55"], [7765, 2], [7766, 1, "\u1E57"], [7767, 2], [7768, 1, "\u1E59"], [7769, 2], [7770, 1, "\u1E5B"], [7771, 2], [7772, 1, "\u1E5D"], [7773, 2], [7774, 1, "\u1E5F"], [7775, 2], [7776, 1, "\u1E61"], [7777, 2], [7778, 1, "\u1E63"], [7779, 2], [7780, 1, "\u1E65"], [7781, 2], [7782, 1, "\u1E67"], [7783, 2], [7784, 1, "\u1E69"], [7785, 2], [7786, 1, "\u1E6B"], [7787, 2], [7788, 1, "\u1E6D"], [7789, 2], [7790, 1, "\u1E6F"], [7791, 2], [7792, 1, "\u1E71"], [7793, 2], [7794, 1, "\u1E73"], [7795, 2], [7796, 1, "\u1E75"], [7797, 2], [7798, 1, "\u1E77"], [7799, 2], [7800, 1, "\u1E79"], [7801, 2], [7802, 1, "\u1E7B"], [7803, 2], [7804, 1, "\u1E7D"], [7805, 2], [7806, 1, "\u1E7F"], [7807, 2], [7808, 1, "\u1E81"], [7809, 2], [7810, 1, "\u1E83"], [7811, 2], [7812, 1, "\u1E85"], [7813, 2], [7814, 1, "\u1E87"], [7815, 2], [7816, 1, "\u1E89"], [7817, 2], [7818, 1, "\u1E8B"], [7819, 2], [7820, 1, "\u1E8D"], [7821, 2], [7822, 1, "\u1E8F"], [7823, 2], [7824, 1, "\u1E91"], [7825, 2], [7826, 1, "\u1E93"], [7827, 2], [7828, 1, "\u1E95"], [[7829, 7833], 2], [7834, 1, "a\u02BE"], [7835, 1, "\u1E61"], [[7836, 7837], 2], [7838, 1, "ss"], [7839, 2], [7840, 1, "\u1EA1"], [7841, 2], [7842, 1, "\u1EA3"], [7843, 2], [7844, 1, "\u1EA5"], [7845, 2], [7846, 1, "\u1EA7"], [7847, 2], [7848, 1, "\u1EA9"], [7849, 2], [7850, 1, "\u1EAB"], [7851, 2], [7852, 1, "\u1EAD"], [7853, 2], [7854, 1, "\u1EAF"], [7855, 2], [7856, 1, "\u1EB1"], [7857, 2], [7858, 1, "\u1EB3"], [7859, 2], [7860, 1, "\u1EB5"], [7861, 2], [7862, 1, "\u1EB7"], [7863, 2], [7864, 1, "\u1EB9"], [7865, 2], [7866, 1, "\u1EBB"], [7867, 2], [7868, 1, "\u1EBD"], [7869, 2], [7870, 1, "\u1EBF"], [7871, 2], [7872, 1, "\u1EC1"], [7873, 2], [7874, 1, "\u1EC3"], [7875, 2], [7876, 1, "\u1EC5"], [7877, 2], [7878, 1, "\u1EC7"], [7879, 2], [7880, 1, "\u1EC9"], [7881, 2], [7882, 1, "\u1ECB"], [7883, 2], [7884, 1, "\u1ECD"], [7885, 2], [7886, 1, "\u1ECF"], [7887, 2], [7888, 1, "\u1ED1"], [7889, 2], [7890, 1, "\u1ED3"], [7891, 2], [7892, 1, "\u1ED5"], [7893, 2], [7894, 1, "\u1ED7"], [7895, 2], [7896, 1, "\u1ED9"], [7897, 2], [7898, 1, "\u1EDB"], [7899, 2], [7900, 1, "\u1EDD"], [7901, 2], [7902, 1, "\u1EDF"], [7903, 2], [7904, 1, "\u1EE1"], [7905, 2], [7906, 1, "\u1EE3"], [7907, 2], [7908, 1, "\u1EE5"], [7909, 2], [7910, 1, "\u1EE7"], [7911, 2], [7912, 1, "\u1EE9"], [7913, 2], [7914, 1, "\u1EEB"], [7915, 2], [7916, 1, "\u1EED"], [7917, 2], [7918, 1, "\u1EEF"], [7919, 2], [7920, 1, "\u1EF1"], [7921, 2], [7922, 1, "\u1EF3"], [7923, 2], [7924, 1, "\u1EF5"], [7925, 2], [7926, 1, "\u1EF7"], [7927, 2], [7928, 1, "\u1EF9"], [7929, 2], [7930, 1, "\u1EFB"], [7931, 2], [7932, 1, "\u1EFD"], [7933, 2], [7934, 1, "\u1EFF"], [7935, 2], [[7936, 7943], 2], [7944, 1, "\u1F00"], [7945, 1, "\u1F01"], [7946, 1, "\u1F02"], [7947, 1, "\u1F03"], [7948, 1, "\u1F04"], [7949, 1, "\u1F05"], [7950, 1, "\u1F06"], [7951, 1, "\u1F07"], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, "\u1F10"], [7961, 1, "\u1F11"], [7962, 1, "\u1F12"], [7963, 1, "\u1F13"], [7964, 1, "\u1F14"], [7965, 1, "\u1F15"], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, "\u1F20"], [7977, 1, "\u1F21"], [7978, 1, "\u1F22"], [7979, 1, "\u1F23"], [7980, 1, "\u1F24"], [7981, 1, "\u1F25"], [7982, 1, "\u1F26"], [7983, 1, "\u1F27"], [[7984, 7991], 2], [7992, 1, "\u1F30"], [7993, 1, "\u1F31"], [7994, 1, "\u1F32"], [7995, 1, "\u1F33"], [7996, 1, "\u1F34"], [7997, 1, "\u1F35"], [7998, 1, "\u1F36"], [7999, 1, "\u1F37"], [[8e3, 8005], 2], [[8006, 8007], 3], [8008, 1, "\u1F40"], [8009, 1, "\u1F41"], [8010, 1, "\u1F42"], [8011, 1, "\u1F43"], [8012, 1, "\u1F44"], [8013, 1, "\u1F45"], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, "\u1F51"], [8026, 3], [8027, 1, "\u1F53"], [8028, 3], [8029, 1, "\u1F55"], [8030, 3], [8031, 1, "\u1F57"], [[8032, 8039], 2], [8040, 1, "\u1F60"], [8041, 1, "\u1F61"], [8042, 1, "\u1F62"], [8043, 1, "\u1F63"], [8044, 1, "\u1F64"], [8045, 1, "\u1F65"], [8046, 1, "\u1F66"], [8047, 1, "\u1F67"], [8048, 2], [8049, 1, "\u03AC"], [8050, 2], [8051, 1, "\u03AD"], [8052, 2], [8053, 1, "\u03AE"], [8054, 2], [8055, 1, "\u03AF"], [8056, 2], [8057, 1, "\u03CC"], [8058, 2], [8059, 1, "\u03CD"], [8060, 2], [8061, 1, "\u03CE"], [[8062, 8063], 3], [8064, 1, "\u1F00\u03B9"], [8065, 1, "\u1F01\u03B9"], [8066, 1, "\u1F02\u03B9"], [8067, 1, "\u1F03\u03B9"], [8068, 1, "\u1F04\u03B9"], [8069, 1, "\u1F05\u03B9"], [8070, 1, "\u1F06\u03B9"], [8071, 1, "\u1F07\u03B9"], [8072, 1, "\u1F00\u03B9"], [8073, 1, "\u1F01\u03B9"], [8074, 1, "\u1F02\u03B9"], [8075, 1, "\u1F03\u03B9"], [8076, 1, "\u1F04\u03B9"], [8077, 1, "\u1F05\u03B9"], [8078, 1, "\u1F06\u03B9"], [8079, 1, "\u1F07\u03B9"], [8080, 1, "\u1F20\u03B9"], [8081, 1, "\u1F21\u03B9"], [8082, 1, "\u1F22\u03B9"], [8083, 1, "\u1F23\u03B9"], [8084, 1, "\u1F24\u03B9"], [8085, 1, "\u1F25\u03B9"], [8086, 1, "\u1F26\u03B9"], [8087, 1, "\u1F27\u03B9"], [8088, 1, "\u1F20\u03B9"], [8089, 1, "\u1F21\u03B9"], [8090, 1, "\u1F22\u03B9"], [8091, 1, "\u1F23\u03B9"], [8092, 1, "\u1F24\u03B9"], [8093, 1, "\u1F25\u03B9"], [8094, 1, "\u1F26\u03B9"], [8095, 1, "\u1F27\u03B9"], [8096, 1, "\u1F60\u03B9"], [8097, 1, "\u1F61\u03B9"], [8098, 1, "\u1F62\u03B9"], [8099, 1, "\u1F63\u03B9"], [8100, 1, "\u1F64\u03B9"], [8101, 1, "\u1F65\u03B9"], [8102, 1, "\u1F66\u03B9"], [8103, 1, "\u1F67\u03B9"], [8104, 1, "\u1F60\u03B9"], [8105, 1, "\u1F61\u03B9"], [8106, 1, "\u1F62\u03B9"], [8107, 1, "\u1F63\u03B9"], [8108, 1, "\u1F64\u03B9"], [8109, 1, "\u1F65\u03B9"], [8110, 1, "\u1F66\u03B9"], [8111, 1, "\u1F67\u03B9"], [[8112, 8113], 2], [8114, 1, "\u1F70\u03B9"], [8115, 1, "\u03B1\u03B9"], [8116, 1, "\u03AC\u03B9"], [8117, 3], [8118, 2], [8119, 1, "\u1FB6\u03B9"], [8120, 1, "\u1FB0"], [8121, 1, "\u1FB1"], [8122, 1, "\u1F70"], [8123, 1, "\u03AC"], [8124, 1, "\u03B1\u03B9"], [8125, 5, " \u0313"], [8126, 1, "\u03B9"], [8127, 5, " \u0313"], [8128, 5, " \u0342"], [8129, 5, " \u0308\u0342"], [8130, 1, "\u1F74\u03B9"], [8131, 1, "\u03B7\u03B9"], [8132, 1, "\u03AE\u03B9"], [8133, 3], [8134, 2], [8135, 1, "\u1FC6\u03B9"], [8136, 1, "\u1F72"], [8137, 1, "\u03AD"], [8138, 1, "\u1F74"], [8139, 1, "\u03AE"], [8140, 1, "\u03B7\u03B9"], [8141, 5, " \u0313\u0300"], [8142, 5, " \u0313\u0301"], [8143, 5, " \u0313\u0342"], [[8144, 8146], 2], [8147, 1, "\u0390"], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, "\u1FD0"], [8153, 1, "\u1FD1"], [8154, 1, "\u1F76"], [8155, 1, "\u03AF"], [8156, 3], [8157, 5, " \u0314\u0300"], [8158, 5, " \u0314\u0301"], [8159, 5, " \u0314\u0342"], [[8160, 8162], 2], [8163, 1, "\u03B0"], [[8164, 8167], 2], [8168, 1, "\u1FE0"], [8169, 1, "\u1FE1"], [8170, 1, "\u1F7A"], [8171, 1, "\u03CD"], [8172, 1, "\u1FE5"], [8173, 5, " \u0308\u0300"], [8174, 5, " \u0308\u0301"], [8175, 5, "`"], [[8176, 8177], 3], [8178, 1, "\u1F7C\u03B9"], [8179, 1, "\u03C9\u03B9"], [8180, 1, "\u03CE\u03B9"], [8181, 3], [8182, 2], [8183, 1, "\u1FF6\u03B9"], [8184, 1, "\u1F78"], [8185, 1, "\u03CC"], [8186, 1, "\u1F7C"], [8187, 1, "\u03CE"], [8188, 1, "\u03C9\u03B9"], [8189, 5, " \u0301"], [8190, 5, " \u0314"], [8191, 3], [[8192, 8202], 5, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, "\u2010"], [[8210, 8214], 2], [8215, 5, " \u0333"], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 5, " "], [[8240, 8242], 2], [8243, 1, "\u2032\u2032"], [8244, 1, "\u2032\u2032\u2032"], [8245, 2], [8246, 1, "\u2035\u2035"], [8247, 1, "\u2035\u2035\u2035"], [[8248, 8251], 2], [8252, 5, "!!"], [8253, 2], [8254, 5, " \u0305"], [[8255, 8262], 2], [8263, 5, "??"], [8264, 5, "?!"], [8265, 5, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, "\u2032\u2032\u2032\u2032"], [[8280, 8286], 2], [8287, 5, " "], [8288, 7], [[8289, 8291], 3], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 3], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 5, "+"], [8315, 1, "\u2212"], [8316, 5, "="], [8317, 5, "("], [8318, 5, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 5, "+"], [8331, 1, "\u2212"], [8332, 5, "="], [8333, 5, "("], [8334, 5, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, "\u0259"], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 5, "a/c"], [8449, 5, "a/s"], [8450, 1, "c"], [8451, 1, "\xB0c"], [8452, 2], [8453, 5, "c/o"], [8454, 5, "c/u"], [8455, 1, "\u025B"], [8456, 2], [8457, 1, "\xB0f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, "\u0127"], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, "\u03C9"], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, "\xE5"], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 3], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, "\u05D0"], [8502, 1, "\u05D1"], [8503, 1, "\u05D2"], [8504, 1, "\u05D3"], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, "\u03C0"], [[8509, 8510], 1, "\u03B3"], [8511, 1, "\u03C0"], [8512, 1, "\u2211"], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "1\u20447"], [8529, 1, "1\u20449"], [8530, 1, "1\u204410"], [8531, 1, "1\u20443"], [8532, 1, "2\u20443"], [8533, 1, "1\u20445"], [8534, 1, "2\u20445"], [8535, 1, "3\u20445"], [8536, 1, "4\u20445"], [8537, 1, "1\u20446"], [8538, 1, "5\u20446"], [8539, 1, "1\u20448"], [8540, 1, "3\u20448"], [8541, 1, "5\u20448"], [8542, 1, "7\u20448"], [8543, 1, "1\u2044"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 3], [8580, 2], [[8581, 8584], 2], [8585, 1, "0\u20443"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, "\u222B\u222B"], [8749, 1, "\u222B\u222B\u222B"], [8750, 2], [8751, 1, "\u222E\u222E"], [8752, 1, "\u222E\u222E\u222E"], [[8753, 8799], 2], [8800, 4], [[8801, 8813], 2], [[8814, 8815], 4], [[8816, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9e3], 2], [9001, 1, "\u3008"], [9002, 1, "\u3009"], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 5, "(1)"], [9333, 5, "(2)"], [9334, 5, "(3)"], [9335, 5, "(4)"], [9336, 5, "(5)"], [9337, 5, "(6)"], [9338, 5, "(7)"], [9339, 5, "(8)"], [9340, 5, "(9)"], [9341, 5, "(10)"], [9342, 5, "(11)"], [9343, 5, "(12)"], [9344, 5, "(13)"], [9345, 5, "(14)"], [9346, 5, "(15)"], [9347, 5, "(16)"], [9348, 5, "(17)"], [9349, 5, "(18)"], [9350, 5, "(19)"], [9351, 5, "(20)"], [[9352, 9371], 3], [9372, 5, "(a)"], [9373, 5, "(b)"], [9374, 5, "(c)"], [9375, 5, "(d)"], [9376, 5, "(e)"], [9377, 5, "(f)"], [9378, 5, "(g)"], [9379, 5, "(h)"], [9380, 5, "(i)"], [9381, 5, "(j)"], [9382, 5, "(k)"], [9383, 5, "(l)"], [9384, 5, "(m)"], [9385, 5, "(n)"], [9386, 5, "(o)"], [9387, 5, "(p)"], [9388, 5, "(q)"], [9389, 5, "(r)"], [9390, 5, "(s)"], [9391, 5, "(t)"], [9392, 5, "(u)"], [9393, 5, "(v)"], [9394, 5, "(w)"], [9395, 5, "(x)"], [9396, 5, "(y)"], [9397, 5, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, "\u222B\u222B\u222B\u222B"], [[10765, 10867], 2], [10868, 5, "::="], [10869, 5, "=="], [10870, 5, "==="], [[10871, 10971], 2], [10972, 1, "\u2ADD\u0338"], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, "\u2C30"], [11265, 1, "\u2C31"], [11266, 1, "\u2C32"], [11267, 1, "\u2C33"], [11268, 1, "\u2C34"], [11269, 1, "\u2C35"], [11270, 1, "\u2C36"], [11271, 1, "\u2C37"], [11272, 1, "\u2C38"], [11273, 1, "\u2C39"], [11274, 1, "\u2C3A"], [11275, 1, "\u2C3B"], [11276, 1, "\u2C3C"], [11277, 1, "\u2C3D"], [11278, 1, "\u2C3E"], [11279, 1, "\u2C3F"], [11280, 1, "\u2C40"], [11281, 1, "\u2C41"], [11282, 1, "\u2C42"], [11283, 1, "\u2C43"], [11284, 1, "\u2C44"], [11285, 1, "\u2C45"], [11286, 1, "\u2C46"], [11287, 1, "\u2C47"], [11288, 1, "\u2C48"], [11289, 1, "\u2C49"], [11290, 1, "\u2C4A"], [11291, 1, "\u2C4B"], [11292, 1, "\u2C4C"], [11293, 1, "\u2C4D"], [11294, 1, "\u2C4E"], [11295, 1, "\u2C4F"], [11296, 1, "\u2C50"], [11297, 1, "\u2C51"], [11298, 1, "\u2C52"], [11299, 1, "\u2C53"], [11300, 1, "\u2C54"], [11301, 1, "\u2C55"], [11302, 1, "\u2C56"], [11303, 1, "\u2C57"], [11304, 1, "\u2C58"], [11305, 1, "\u2C59"], [11306, 1, "\u2C5A"], [11307, 1, "\u2C5B"], [11308, 1, "\u2C5C"], [11309, 1, "\u2C5D"], [11310, 1, "\u2C5E"], [11311, 1, "\u2C5F"], [[11312, 11358], 2], [11359, 2], [11360, 1, "\u2C61"], [11361, 2], [11362, 1, "\u026B"], [11363, 1, "\u1D7D"], [11364, 1, "\u027D"], [[11365, 11366], 2], [11367, 1, "\u2C68"], [11368, 2], [11369, 1, "\u2C6A"], [11370, 2], [11371, 1, "\u2C6C"], [11372, 2], [11373, 1, "\u0251"], [11374, 1, "\u0271"], [11375, 1, "\u0250"], [11376, 1, "\u0252"], [11377, 2], [11378, 1, "\u2C73"], [11379, 2], [11380, 2], [11381, 1, "\u2C76"], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, "\u023F"], [11391, 1, "\u0240"], [11392, 1, "\u2C81"], [11393, 2], [11394, 1, "\u2C83"], [11395, 2], [11396, 1, "\u2C85"], [11397, 2], [11398, 1, "\u2C87"], [11399, 2], [11400, 1, "\u2C89"], [11401, 2], [11402, 1, "\u2C8B"], [11403, 2], [11404, 1, "\u2C8D"], [11405, 2], [11406, 1, "\u2C8F"], [11407, 2], [11408, 1, "\u2C91"], [11409, 2], [11410, 1, "\u2C93"], [11411, 2], [11412, 1, "\u2C95"], [11413, 2], [11414, 1, "\u2C97"], [11415, 2], [11416, 1, "\u2C99"], [11417, 2], [11418, 1, "\u2C9B"], [11419, 2], [11420, 1, "\u2C9D"], [11421, 2], [11422, 1, "\u2C9F"], [11423, 2], [11424, 1, "\u2CA1"], [11425, 2], [11426, 1, "\u2CA3"], [11427, 2], [11428, 1, "\u2CA5"], [11429, 2], [11430, 1, "\u2CA7"], [11431, 2], [11432, 1, "\u2CA9"], [11433, 2], [11434, 1, "\u2CAB"], [11435, 2], [11436, 1, "\u2CAD"], [11437, 2], [11438, 1, "\u2CAF"], [11439, 2], [11440, 1, "\u2CB1"], [11441, 2], [11442, 1, "\u2CB3"], [11443, 2], [11444, 1, "\u2CB5"], [11445, 2], [11446, 1, "\u2CB7"], [11447, 2], [11448, 1, "\u2CB9"], [11449, 2], [11450, 1, "\u2CBB"], [11451, 2], [11452, 1, "\u2CBD"], [11453, 2], [11454, 1, "\u2CBF"], [11455, 2], [11456, 1, "\u2CC1"], [11457, 2], [11458, 1, "\u2CC3"], [11459, 2], [11460, 1, "\u2CC5"], [11461, 2], [11462, 1, "\u2CC7"], [11463, 2], [11464, 1, "\u2CC9"], [11465, 2], [11466, 1, "\u2CCB"], [11467, 2], [11468, 1, "\u2CCD"], [11469, 2], [11470, 1, "\u2CCF"], [11471, 2], [11472, 1, "\u2CD1"], [11473, 2], [11474, 1, "\u2CD3"], [11475, 2], [11476, 1, "\u2CD5"], [11477, 2], [11478, 1, "\u2CD7"], [11479, 2], [11480, 1, "\u2CD9"], [11481, 2], [11482, 1, "\u2CDB"], [11483, 2], [11484, 1, "\u2CDD"], [11485, 2], [11486, 1, "\u2CDF"], [11487, 2], [11488, 1, "\u2CE1"], [11489, 2], [11490, 1, "\u2CE3"], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, "\u2CEC"], [11500, 2], [11501, 1, "\u2CEE"], [[11502, 11505], 2], [11506, 1, "\u2CF3"], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, "\u2D61"], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, "\u6BCD"], [[11936, 12018], 2], [12019, 1, "\u9F9F"], [[12020, 12031], 3], [12032, 1, "\u4E00"], [12033, 1, "\u4E28"], [12034, 1, "\u4E36"], [12035, 1, "\u4E3F"], [12036, 1, "\u4E59"], [12037, 1, "\u4E85"], [12038, 1, "\u4E8C"], [12039, 1, "\u4EA0"], [12040, 1, "\u4EBA"], [12041, 1, "\u513F"], [12042, 1, "\u5165"], [12043, 1, "\u516B"], [12044, 1, "\u5182"], [12045, 1, "\u5196"], [12046, 1, "\u51AB"], [12047, 1, "\u51E0"], [12048, 1, "\u51F5"], [12049, 1, "\u5200"], [12050, 1, "\u529B"], [12051, 1, "\u52F9"], [12052, 1, "\u5315"], [12053, 1, "\u531A"], [12054, 1, "\u5338"], [12055, 1, "\u5341"], [12056, 1, "\u535C"], [12057, 1, "\u5369"], [12058, 1, "\u5382"], [12059, 1, "\u53B6"], [12060, 1, "\u53C8"], [12061, 1, "\u53E3"], [12062, 1, "\u56D7"], [12063, 1, "\u571F"], [12064, 1, "\u58EB"], [12065, 1, "\u5902"], [12066, 1, "\u590A"], [12067, 1, "\u5915"], [12068, 1, "\u5927"], [12069, 1, "\u5973"], [12070, 1, "\u5B50"], [12071, 1, "\u5B80"], [12072, 1, "\u5BF8"], [12073, 1, "\u5C0F"], [12074, 1, "\u5C22"], [12075, 1, "\u5C38"], [12076, 1, "\u5C6E"], [12077, 1, "\u5C71"], [12078, 1, "\u5DDB"], [12079, 1, "\u5DE5"], [12080, 1, "\u5DF1"], [12081, 1, "\u5DFE"], [12082, 1, "\u5E72"], [12083, 1, "\u5E7A"], [12084, 1, "\u5E7F"], [12085, 1, "\u5EF4"], [12086, 1, "\u5EFE"], [12087, 1, "\u5F0B"], [12088, 1, "\u5F13"], [12089, 1, "\u5F50"], [12090, 1, "\u5F61"], [12091, 1, "\u5F73"], [12092, 1, "\u5FC3"], [12093, 1, "\u6208"], [12094, 1, "\u6236"], [12095, 1, "\u624B"], [12096, 1, "\u652F"], [12097, 1, "\u6534"], [12098, 1, "\u6587"], [12099, 1, "\u6597"], [12100, 1, "\u65A4"], [12101, 1, "\u65B9"], [12102, 1, "\u65E0"], [12103, 1, "\u65E5"], [12104, 1, "\u66F0"], [12105, 1, "\u6708"], [12106, 1, "\u6728"], [12107, 1, "\u6B20"], [12108, 1, "\u6B62"], [12109, 1, "\u6B79"], [12110, 1, "\u6BB3"], [12111, 1, "\u6BCB"], [12112, 1, "\u6BD4"], [12113, 1, "\u6BDB"], [12114, 1, "\u6C0F"], [12115, 1, "\u6C14"], [12116, 1, "\u6C34"], [12117, 1, "\u706B"], [12118, 1, "\u722A"], [12119, 1, "\u7236"], [12120, 1, "\u723B"], [12121, 1, "\u723F"], [12122, 1, "\u7247"], [12123, 1, "\u7259"], [12124, 1, "\u725B"], [12125, 1, "\u72AC"], [12126, 1, "\u7384"], [12127, 1, "\u7389"], [12128, 1, "\u74DC"], [12129, 1, "\u74E6"], [12130, 1, "\u7518"], [12131, 1, "\u751F"], [12132, 1, "\u7528"], [12133, 1, "\u7530"], [12134, 1, "\u758B"], [12135, 1, "\u7592"], [12136, 1, "\u7676"], [12137, 1, "\u767D"], [12138, 1, "\u76AE"], [12139, 1, "\u76BF"], [12140, 1, "\u76EE"], [12141, 1, "\u77DB"], [12142, 1, "\u77E2"], [12143, 1, "\u77F3"], [12144, 1, "\u793A"], [12145, 1, "\u79B8"], [12146, 1, "\u79BE"], [12147, 1, "\u7A74"], [12148, 1, "\u7ACB"], [12149, 1, "\u7AF9"], [12150, 1, "\u7C73"], [12151, 1, "\u7CF8"], [12152, 1, "\u7F36"], [12153, 1, "\u7F51"], [12154, 1, "\u7F8A"], [12155, 1, "\u7FBD"], [12156, 1, "\u8001"], [12157, 1, "\u800C"], [12158, 1, "\u8012"], [12159, 1, "\u8033"], [12160, 1, "\u807F"], [12161, 1, "\u8089"], [12162, 1, "\u81E3"], [12163, 1, "\u81EA"], [12164, 1, "\u81F3"], [12165, 1, "\u81FC"], [12166, 1, "\u820C"], [12167, 1, "\u821B"], [12168, 1, "\u821F"], [12169, 1, "\u826E"], [12170, 1, "\u8272"], [12171, 1, "\u8278"], [12172, 1, "\u864D"], [12173, 1, "\u866B"], [12174, 1, "\u8840"], [12175, 1, "\u884C"], [12176, 1, "\u8863"], [12177, 1, "\u897E"], [12178, 1, "\u898B"], [12179, 1, "\u89D2"], [12180, 1, "\u8A00"], [12181, 1, "\u8C37"], [12182, 1, "\u8C46"], [12183, 1, "\u8C55"], [12184, 1, "\u8C78"], [12185, 1, "\u8C9D"], [12186, 1, "\u8D64"], [12187, 1, "\u8D70"], [12188, 1, "\u8DB3"], [12189, 1, "\u8EAB"], [12190, 1, "\u8ECA"], [12191, 1, "\u8F9B"], [12192, 1, "\u8FB0"], [12193, 1, "\u8FB5"], [12194, 1, "\u9091"], [12195, 1, "\u9149"], [12196, 1, "\u91C6"], [12197, 1, "\u91CC"], [12198, 1, "\u91D1"], [12199, 1, "\u9577"], [12200, 1, "\u9580"], [12201, 1, "\u961C"], [12202, 1, "\u96B6"], [12203, 1, "\u96B9"], [12204, 1, "\u96E8"], [12205, 1, "\u9751"], [12206, 1, "\u975E"], [12207, 1, "\u9762"], [12208, 1, "\u9769"], [12209, 1, "\u97CB"], [12210, 1, "\u97ED"], [12211, 1, "\u97F3"], [12212, 1, "\u9801"], [12213, 1, "\u98A8"], [12214, 1, "\u98DB"], [12215, 1, "\u98DF"], [12216, 1, "\u9996"], [12217, 1, "\u9999"], [12218, 1, "\u99AC"], [12219, 1, "\u9AA8"], [12220, 1, "\u9AD8"], [12221, 1, "\u9ADF"], [12222, 1, "\u9B25"], [12223, 1, "\u9B2F"], [12224, 1, "\u9B32"], [12225, 1, "\u9B3C"], [12226, 1, "\u9B5A"], [12227, 1, "\u9CE5"], [12228, 1, "\u9E75"], [12229, 1, "\u9E7F"], [12230, 1, "\u9EA5"], [12231, 1, "\u9EBB"], [12232, 1, "\u9EC3"], [12233, 1, "\u9ECD"], [12234, 1, "\u9ED1"], [12235, 1, "\u9EF9"], [12236, 1, "\u9EFD"], [12237, 1, "\u9F0E"], [12238, 1, "\u9F13"], [12239, 1, "\u9F20"], [12240, 1, "\u9F3B"], [12241, 1, "\u9F4A"], [12242, 1, "\u9F52"], [12243, 1, "\u9F8D"], [12244, 1, "\u9F9C"], [12245, 1, "\u9FA0"], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 5, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, "\u3012"], [12343, 2], [12344, 1, "\u5341"], [12345, 1, "\u5344"], [12346, 1, "\u5345"], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 5, " \u3099"], [12444, 5, " \u309A"], [[12445, 12446], 2], [12447, 1, "\u3088\u308A"], [12448, 2], [[12449, 12542], 2], [12543, 1, "\u30B3\u30C8"], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, "\u1100"], [12594, 1, "\u1101"], [12595, 1, "\u11AA"], [12596, 1, "\u1102"], [12597, 1, "\u11AC"], [12598, 1, "\u11AD"], [12599, 1, "\u1103"], [12600, 1, "\u1104"], [12601, 1, "\u1105"], [12602, 1, "\u11B0"], [12603, 1, "\u11B1"], [12604, 1, "\u11B2"], [12605, 1, "\u11B3"], [12606, 1, "\u11B4"], [12607, 1, "\u11B5"], [12608, 1, "\u111A"], [12609, 1, "\u1106"], [12610, 1, "\u1107"], [12611, 1, "\u1108"], [12612, 1, "\u1121"], [12613, 1, "\u1109"], [12614, 1, "\u110A"], [12615, 1, "\u110B"], [12616, 1, "\u110C"], [12617, 1, "\u110D"], [12618, 1, "\u110E"], [12619, 1, "\u110F"], [12620, 1, "\u1110"], [12621, 1, "\u1111"], [12622, 1, "\u1112"], [12623, 1, "\u1161"], [12624, 1, "\u1162"], [12625, 1, "\u1163"], [12626, 1, "\u1164"], [12627, 1, "\u1165"], [12628, 1, "\u1166"], [12629, 1, "\u1167"], [12630, 1, "\u1168"], [12631, 1, "\u1169"], [12632, 1, "\u116A"], [12633, 1, "\u116B"], [12634, 1, "\u116C"], [12635, 1, "\u116D"], [12636, 1, "\u116E"], [12637, 1, "\u116F"], [12638, 1, "\u1170"], [12639, 1, "\u1171"], [12640, 1, "\u1172"], [12641, 1, "\u1173"], [12642, 1, "\u1174"], [12643, 1, "\u1175"], [12644, 3], [12645, 1, "\u1114"], [12646, 1, "\u1115"], [12647, 1, "\u11C7"], [12648, 1, "\u11C8"], [12649, 1, "\u11CC"], [12650, 1, "\u11CE"], [12651, 1, "\u11D3"], [12652, 1, "\u11D7"], [12653, 1, "\u11D9"], [12654, 1, "\u111C"], [12655, 1, "\u11DD"], [12656, 1, "\u11DF"], [12657, 1, "\u111D"], [12658, 1, "\u111E"], [12659, 1, "\u1120"], [12660, 1, "\u1122"], [12661, 1, "\u1123"], [12662, 1, "\u1127"], [12663, 1, "\u1129"], [12664, 1, "\u112B"], [12665, 1, "\u112C"], [12666, 1, "\u112D"], [12667, 1, "\u112E"], [12668, 1, "\u112F"], [12669, 1, "\u1132"], [12670, 1, "\u1136"], [12671, 1, "\u1140"], [12672, 1, "\u1147"], [12673, 1, "\u114C"], [12674, 1, "\u11F1"], [12675, 1, "\u11F2"], [12676, 1, "\u1157"], [12677, 1, "\u1158"], [12678, 1, "\u1159"], [12679, 1, "\u1184"], [12680, 1, "\u1185"], [12681, 1, "\u1188"], [12682, 1, "\u1191"], [12683, 1, "\u1192"], [12684, 1, "\u1194"], [12685, 1, "\u119E"], [12686, 1, "\u11A1"], [12687, 3], [[12688, 12689], 2], [12690, 1, "\u4E00"], [12691, 1, "\u4E8C"], [12692, 1, "\u4E09"], [12693, 1, "\u56DB"], [12694, 1, "\u4E0A"], [12695, 1, "\u4E2D"], [12696, 1, "\u4E0B"], [12697, 1, "\u7532"], [12698, 1, "\u4E59"], [12699, 1, "\u4E19"], [12700, 1, "\u4E01"], [12701, 1, "\u5929"], [12702, 1, "\u5730"], [12703, 1, "\u4EBA"], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12783], 3], [[12784, 12799], 2], [12800, 5, "(\u1100)"], [12801, 5, "(\u1102)"], [12802, 5, "(\u1103)"], [12803, 5, "(\u1105)"], [12804, 5, "(\u1106)"], [12805, 5, "(\u1107)"], [12806, 5, "(\u1109)"], [12807, 5, "(\u110B)"], [12808, 5, "(\u110C)"], [12809, 5, "(\u110E)"], [12810, 5, "(\u110F)"], [12811, 5, "(\u1110)"], [12812, 5, "(\u1111)"], [12813, 5, "(\u1112)"], [12814, 5, "(\uAC00)"], [12815, 5, "(\uB098)"], [12816, 5, "(\uB2E4)"], [12817, 5, "(\uB77C)"], [12818, 5, "(\uB9C8)"], [12819, 5, "(\uBC14)"], [12820, 5, "(\uC0AC)"], [12821, 5, "(\uC544)"], [12822, 5, "(\uC790)"], [12823, 5, "(\uCC28)"], [12824, 5, "(\uCE74)"], [12825, 5, "(\uD0C0)"], [12826, 5, "(\uD30C)"], [12827, 5, "(\uD558)"], [12828, 5, "(\uC8FC)"], [12829, 5, "(\uC624\uC804)"], [12830, 5, "(\uC624\uD6C4)"], [12831, 3], [12832, 5, "(\u4E00)"], [12833, 5, "(\u4E8C)"], [12834, 5, "(\u4E09)"], [12835, 5, "(\u56DB)"], [12836, 5, "(\u4E94)"], [12837, 5, "(\u516D)"], [12838, 5, "(\u4E03)"], [12839, 5, "(\u516B)"], [12840, 5, "(\u4E5D)"], [12841, 5, "(\u5341)"], [12842, 5, "(\u6708)"], [12843, 5, "(\u706B)"], [12844, 5, "(\u6C34)"], [12845, 5, "(\u6728)"], [12846, 5, "(\u91D1)"], [12847, 5, "(\u571F)"], [12848, 5, "(\u65E5)"], [12849, 5, "(\u682A)"], [12850, 5, "(\u6709)"], [12851, 5, "(\u793E)"], [12852, 5, "(\u540D)"], [12853, 5, "(\u7279)"], [12854, 5, "(\u8CA1)"], [12855, 5, "(\u795D)"], [12856, 5, "(\u52B4)"], [12857, 5, "(\u4EE3)"], [12858, 5, "(\u547C)"], [12859, 5, "(\u5B66)"], [12860, 5, "(\u76E3)"], [12861, 5, "(\u4F01)"], [12862, 5, "(\u8CC7)"], [12863, 5, "(\u5354)"], [12864, 5, "(\u796D)"], [12865, 5, "(\u4F11)"], [12866, 5, "(\u81EA)"], [12867, 5, "(\u81F3)"], [12868, 1, "\u554F"], [12869, 1, "\u5E7C"], [12870, 1, "\u6587"], [12871, 1, "\u7B8F"], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, "\u1100"], [12897, 1, "\u1102"], [12898, 1, "\u1103"], [12899, 1, "\u1105"], [12900, 1, "\u1106"], [12901, 1, "\u1107"], [12902, 1, "\u1109"], [12903, 1, "\u110B"], [12904, 1, "\u110C"], [12905, 1, "\u110E"], [12906, 1, "\u110F"], [12907, 1, "\u1110"], [12908, 1, "\u1111"], [12909, 1, "\u1112"], [12910, 1, "\uAC00"], [12911, 1, "\uB098"], [12912, 1, "\uB2E4"], [12913, 1, "\uB77C"], [12914, 1, "\uB9C8"], [12915, 1, "\uBC14"], [12916, 1, "\uC0AC"], [12917, 1, "\uC544"], [12918, 1, "\uC790"], [12919, 1, "\uCC28"], [12920, 1, "\uCE74"], [12921, 1, "\uD0C0"], [12922, 1, "\uD30C"], [12923, 1, "\uD558"], [12924, 1, "\uCC38\uACE0"], [12925, 1, "\uC8FC\uC758"], [12926, 1, "\uC6B0"], [12927, 2], [12928, 1, "\u4E00"], [12929, 1, "\u4E8C"], [12930, 1, "\u4E09"], [12931, 1, "\u56DB"], [12932, 1, "\u4E94"], [12933, 1, "\u516D"], [12934, 1, "\u4E03"], [12935, 1, "\u516B"], [12936, 1, "\u4E5D"], [12937, 1, "\u5341"], [12938, 1, "\u6708"], [12939, 1, "\u706B"], [12940, 1, "\u6C34"], [12941, 1, "\u6728"], [12942, 1, "\u91D1"], [12943, 1, "\u571F"], [12944, 1, "\u65E5"], [12945, 1, "\u682A"], [12946, 1, "\u6709"], [12947, 1, "\u793E"], [12948, 1, "\u540D"], [12949, 1, "\u7279"], [12950, 1, "\u8CA1"], [12951, 1, "\u795D"], [12952, 1, "\u52B4"], [12953, 1, "\u79D8"], [12954, 1, "\u7537"], [12955, 1, "\u5973"], [12956, 1, "\u9069"], [12957, 1, "\u512A"], [12958, 1, "\u5370"], [12959, 1, "\u6CE8"], [12960, 1, "\u9805"], [12961, 1, "\u4F11"], [12962, 1, "\u5199"], [12963, 1, "\u6B63"], [12964, 1, "\u4E0A"], [12965, 1, "\u4E2D"], [12966, 1, "\u4E0B"], [12967, 1, "\u5DE6"], [12968, 1, "\u53F3"], [12969, 1, "\u533B"], [12970, 1, "\u5B97"], [12971, 1, "\u5B66"], [12972, 1, "\u76E3"], [12973, 1, "\u4F01"], [12974, 1, "\u8CC7"], [12975, 1, "\u5354"], [12976, 1, "\u591C"], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1\u6708"], [12993, 1, "2\u6708"], [12994, 1, "3\u6708"], [12995, 1, "4\u6708"], [12996, 1, "5\u6708"], [12997, 1, "6\u6708"], [12998, 1, "7\u6708"], [12999, 1, "8\u6708"], [13e3, 1, "9\u6708"], [13001, 1, "10\u6708"], [13002, 1, "11\u6708"], [13003, 1, "12\u6708"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, "\u30A2"], [13009, 1, "\u30A4"], [13010, 1, "\u30A6"], [13011, 1, "\u30A8"], [13012, 1, "\u30AA"], [13013, 1, "\u30AB"], [13014, 1, "\u30AD"], [13015, 1, "\u30AF"], [13016, 1, "\u30B1"], [13017, 1, "\u30B3"], [13018, 1, "\u30B5"], [13019, 1, "\u30B7"], [13020, 1, "\u30B9"], [13021, 1, "\u30BB"], [13022, 1, "\u30BD"], [13023, 1, "\u30BF"], [13024, 1, "\u30C1"], [13025, 1, "\u30C4"], [13026, 1, "\u30C6"], [13027, 1, "\u30C8"], [13028, 1, "\u30CA"], [13029, 1, "\u30CB"], [13030, 1, "\u30CC"], [13031, 1, "\u30CD"], [13032, 1, "\u30CE"], [13033, 1, "\u30CF"], [13034, 1, "\u30D2"], [13035, 1, "\u30D5"], [13036, 1, "\u30D8"], [13037, 1, "\u30DB"], [13038, 1, "\u30DE"], [13039, 1, "\u30DF"], [13040, 1, "\u30E0"], [13041, 1, "\u30E1"], [13042, 1, "\u30E2"], [13043, 1, "\u30E4"], [13044, 1, "\u30E6"], [13045, 1, "\u30E8"], [13046, 1, "\u30E9"], [13047, 1, "\u30EA"], [13048, 1, "\u30EB"], [13049, 1, "\u30EC"], [13050, 1, "\u30ED"], [13051, 1, "\u30EF"], [13052, 1, "\u30F0"], [13053, 1, "\u30F1"], [13054, 1, "\u30F2"], [13055, 1, "\u4EE4\u548C"], [13056, 1, "\u30A2\u30D1\u30FC\u30C8"], [13057, 1, "\u30A2\u30EB\u30D5\u30A1"], [13058, 1, "\u30A2\u30F3\u30DA\u30A2"], [13059, 1, "\u30A2\u30FC\u30EB"], [13060, 1, "\u30A4\u30CB\u30F3\u30B0"], [13061, 1, "\u30A4\u30F3\u30C1"], [13062, 1, "\u30A6\u30A9\u30F3"], [13063, 1, "\u30A8\u30B9\u30AF\u30FC\u30C9"], [13064, 1, "\u30A8\u30FC\u30AB\u30FC"], [13065, 1, "\u30AA\u30F3\u30B9"], [13066, 1, "\u30AA\u30FC\u30E0"], [13067, 1, "\u30AB\u30A4\u30EA"], [13068, 1, "\u30AB\u30E9\u30C3\u30C8"], [13069, 1, "\u30AB\u30ED\u30EA\u30FC"], [13070, 1, "\u30AC\u30ED\u30F3"], [13071, 1, "\u30AC\u30F3\u30DE"], [13072, 1, "\u30AE\u30AC"], [13073, 1, "\u30AE\u30CB\u30FC"], [13074, 1, "\u30AD\u30E5\u30EA\u30FC"], [13075, 1, "\u30AE\u30EB\u30C0\u30FC"], [13076, 1, "\u30AD\u30ED"], [13077, 1, "\u30AD\u30ED\u30B0\u30E9\u30E0"], [13078, 1, "\u30AD\u30ED\u30E1\u30FC\u30C8\u30EB"], [13079, 1, "\u30AD\u30ED\u30EF\u30C3\u30C8"], [13080, 1, "\u30B0\u30E9\u30E0"], [13081, 1, "\u30B0\u30E9\u30E0\u30C8\u30F3"], [13082, 1, "\u30AF\u30EB\u30BC\u30A4\u30ED"], [13083, 1, "\u30AF\u30ED\u30FC\u30CD"], [13084, 1, "\u30B1\u30FC\u30B9"], [13085, 1, "\u30B3\u30EB\u30CA"], [13086, 1, "\u30B3\u30FC\u30DD"], [13087, 1, "\u30B5\u30A4\u30AF\u30EB"], [13088, 1, "\u30B5\u30F3\u30C1\u30FC\u30E0"], [13089, 1, "\u30B7\u30EA\u30F3\u30B0"], [13090, 1, "\u30BB\u30F3\u30C1"], [13091, 1, "\u30BB\u30F3\u30C8"], [13092, 1, "\u30C0\u30FC\u30B9"], [13093, 1, "\u30C7\u30B7"], [13094, 1, "\u30C9\u30EB"], [13095, 1, "\u30C8\u30F3"], [13096, 1, "\u30CA\u30CE"], [13097, 1, "\u30CE\u30C3\u30C8"], [13098, 1, "\u30CF\u30A4\u30C4"], [13099, 1, "\u30D1\u30FC\u30BB\u30F3\u30C8"], [13100, 1, "\u30D1\u30FC\u30C4"], [13101, 1, "\u30D0\u30FC\u30EC\u30EB"], [13102, 1, "\u30D4\u30A2\u30B9\u30C8\u30EB"], [13103, 1, "\u30D4\u30AF\u30EB"], [13104, 1, "\u30D4\u30B3"], [13105, 1, "\u30D3\u30EB"], [13106, 1, "\u30D5\u30A1\u30E9\u30C3\u30C9"], [13107, 1, "\u30D5\u30A3\u30FC\u30C8"], [13108, 1, "\u30D6\u30C3\u30B7\u30A7\u30EB"], [13109, 1, "\u30D5\u30E9\u30F3"], [13110, 1, "\u30D8\u30AF\u30BF\u30FC\u30EB"], [13111, 1, "\u30DA\u30BD"], [13112, 1, "\u30DA\u30CB\u30D2"], [13113, 1, "\u30D8\u30EB\u30C4"], [13114, 1, "\u30DA\u30F3\u30B9"], [13115, 1, "\u30DA\u30FC\u30B8"], [13116, 1, "\u30D9\u30FC\u30BF"], [13117, 1, "\u30DD\u30A4\u30F3\u30C8"], [13118, 1, "\u30DC\u30EB\u30C8"], [13119, 1, "\u30DB\u30F3"], [13120, 1, "\u30DD\u30F3\u30C9"], [13121, 1, "\u30DB\u30FC\u30EB"], [13122, 1, "\u30DB\u30FC\u30F3"], [13123, 1, "\u30DE\u30A4\u30AF\u30ED"], [13124, 1, "\u30DE\u30A4\u30EB"], [13125, 1, "\u30DE\u30C3\u30CF"], [13126, 1, "\u30DE\u30EB\u30AF"], [13127, 1, "\u30DE\u30F3\u30B7\u30E7\u30F3"], [13128, 1, "\u30DF\u30AF\u30ED\u30F3"], [13129, 1, "\u30DF\u30EA"], [13130, 1, "\u30DF\u30EA\u30D0\u30FC\u30EB"], [13131, 1, "\u30E1\u30AC"], [13132, 1, "\u30E1\u30AC\u30C8\u30F3"], [13133, 1, "\u30E1\u30FC\u30C8\u30EB"], [13134, 1, "\u30E4\u30FC\u30C9"], [13135, 1, "\u30E4\u30FC\u30EB"], [13136, 1, "\u30E6\u30A2\u30F3"], [13137, 1, "\u30EA\u30C3\u30C8\u30EB"], [13138, 1, "\u30EA\u30E9"], [13139, 1, "\u30EB\u30D4\u30FC"], [13140, 1, "\u30EB\u30FC\u30D6\u30EB"], [13141, 1, "\u30EC\u30E0"], [13142, 1, "\u30EC\u30F3\u30C8\u30B2\u30F3"], [13143, 1, "\u30EF\u30C3\u30C8"], [13144, 1, "0\u70B9"], [13145, 1, "1\u70B9"], [13146, 1, "2\u70B9"], [13147, 1, "3\u70B9"], [13148, 1, "4\u70B9"], [13149, 1, "5\u70B9"], [13150, 1, "6\u70B9"], [13151, 1, "7\u70B9"], [13152, 1, "8\u70B9"], [13153, 1, "9\u70B9"], [13154, 1, "10\u70B9"], [13155, 1, "11\u70B9"], [13156, 1, "12\u70B9"], [13157, 1, "13\u70B9"], [13158, 1, "14\u70B9"], [13159, 1, "15\u70B9"], [13160, 1, "16\u70B9"], [13161, 1, "17\u70B9"], [13162, 1, "18\u70B9"], [13163, 1, "19\u70B9"], [13164, 1, "20\u70B9"], [13165, 1, "21\u70B9"], [13166, 1, "22\u70B9"], [13167, 1, "23\u70B9"], [13168, 1, "24\u70B9"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, "\u5E73\u6210"], [13180, 1, "\u662D\u548C"], [13181, 1, "\u5927\u6B63"], [13182, 1, "\u660E\u6CBB"], [13183, 1, "\u682A\u5F0F\u4F1A\u793E"], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "\u03BCa"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "\u03BCf"], [13197, 1, "\u03BCg"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "\u03BCl"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "\u03BCm"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "m\u2215s"], [13224, 1, "m\u2215s2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rad\u2215s"], [13231, 1, "rad\u2215s2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "\u03BCs"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "\u03BCv"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "\u03BCw"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "k\u03C9"], [13249, 1, "m\u03C9"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "c\u2215kg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "v\u2215m"], [13279, 1, "a\u2215m"], [13280, 1, "1\u65E5"], [13281, 1, "2\u65E5"], [13282, 1, "3\u65E5"], [13283, 1, "4\u65E5"], [13284, 1, "5\u65E5"], [13285, 1, "6\u65E5"], [13286, 1, "7\u65E5"], [13287, 1, "8\u65E5"], [13288, 1, "9\u65E5"], [13289, 1, "10\u65E5"], [13290, 1, "11\u65E5"], [13291, 1, "12\u65E5"], [13292, 1, "13\u65E5"], [13293, 1, "14\u65E5"], [13294, 1, "15\u65E5"], [13295, 1, "16\u65E5"], [13296, 1, "17\u65E5"], [13297, 1, "18\u65E5"], [13298, 1, "19\u65E5"], [13299, 1, "20\u65E5"], [13300, 1, "21\u65E5"], [13301, 1, "22\u65E5"], [13302, 1, "23\u65E5"], [13303, 1, "24\u65E5"], [13304, 1, "25\u65E5"], [13305, 1, "26\u65E5"], [13306, 1, "27\u65E5"], [13307, 1, "28\u65E5"], [13308, 1, "29\u65E5"], [13309, 1, "30\u65E5"], [13310, 1, "31\u65E5"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, "\uA641"], [42561, 2], [42562, 1, "\uA643"], [42563, 2], [42564, 1, "\uA645"], [42565, 2], [42566, 1, "\uA647"], [42567, 2], [42568, 1, "\uA649"], [42569, 2], [42570, 1, "\uA64B"], [42571, 2], [42572, 1, "\uA64D"], [42573, 2], [42574, 1, "\uA64F"], [42575, 2], [42576, 1, "\uA651"], [42577, 2], [42578, 1, "\uA653"], [42579, 2], [42580, 1, "\uA655"], [42581, 2], [42582, 1, "\uA657"], [42583, 2], [42584, 1, "\uA659"], [42585, 2], [42586, 1, "\uA65B"], [42587, 2], [42588, 1, "\uA65D"], [42589, 2], [42590, 1, "\uA65F"], [42591, 2], [42592, 1, "\uA661"], [42593, 2], [42594, 1, "\uA663"], [42595, 2], [42596, 1, "\uA665"], [42597, 2], [42598, 1, "\uA667"], [42599, 2], [42600, 1, "\uA669"], [42601, 2], [42602, 1, "\uA66B"], [42603, 2], [42604, 1, "\uA66D"], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, "\uA681"], [42625, 2], [42626, 1, "\uA683"], [42627, 2], [42628, 1, "\uA685"], [42629, 2], [42630, 1, "\uA687"], [42631, 2], [42632, 1, "\uA689"], [42633, 2], [42634, 1, "\uA68B"], [42635, 2], [42636, 1, "\uA68D"], [42637, 2], [42638, 1, "\uA68F"], [42639, 2], [42640, 1, "\uA691"], [42641, 2], [42642, 1, "\uA693"], [42643, 2], [42644, 1, "\uA695"], [42645, 2], [42646, 1, "\uA697"], [42647, 2], [42648, 1, "\uA699"], [42649, 2], [42650, 1, "\uA69B"], [42651, 2], [42652, 1, "\u044A"], [42653, 1, "\u044C"], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, "\uA723"], [42787, 2], [42788, 1, "\uA725"], [42789, 2], [42790, 1, "\uA727"], [42791, 2], [42792, 1, "\uA729"], [42793, 2], [42794, 1, "\uA72B"], [42795, 2], [42796, 1, "\uA72D"], [42797, 2], [42798, 1, "\uA72F"], [[42799, 42801], 2], [42802, 1, "\uA733"], [42803, 2], [42804, 1, "\uA735"], [42805, 2], [42806, 1, "\uA737"], [42807, 2], [42808, 1, "\uA739"], [42809, 2], [42810, 1, "\uA73B"], [42811, 2], [42812, 1, "\uA73D"], [42813, 2], [42814, 1, "\uA73F"], [42815, 2], [42816, 1, "\uA741"], [42817, 2], [42818, 1, "\uA743"], [42819, 2], [42820, 1, "\uA745"], [42821, 2], [42822, 1, "\uA747"], [42823, 2], [42824, 1, "\uA749"], [42825, 2], [42826, 1, "\uA74B"], [42827, 2], [42828, 1, "\uA74D"], [42829, 2], [42830, 1, "\uA74F"], [42831, 2], [42832, 1, "\uA751"], [42833, 2], [42834, 1, "\uA753"], [42835, 2], [42836, 1, "\uA755"], [42837, 2], [42838, 1, "\uA757"], [42839, 2], [42840, 1, "\uA759"], [42841, 2], [42842, 1, "\uA75B"], [42843, 2], [42844, 1, "\uA75D"], [42845, 2], [42846, 1, "\uA75F"], [42847, 2], [42848, 1, "\uA761"], [42849, 2], [42850, 1, "\uA763"], [42851, 2], [42852, 1, "\uA765"], [42853, 2], [42854, 1, "\uA767"], [42855, 2], [42856, 1, "\uA769"], [42857, 2], [42858, 1, "\uA76B"], [42859, 2], [42860, 1, "\uA76D"], [42861, 2], [42862, 1, "\uA76F"], [42863, 2], [42864, 1, "\uA76F"], [[42865, 42872], 2], [42873, 1, "\uA77A"], [42874, 2], [42875, 1, "\uA77C"], [42876, 2], [42877, 1, "\u1D79"], [42878, 1, "\uA77F"], [42879, 2], [42880, 1, "\uA781"], [42881, 2], [42882, 1, "\uA783"], [42883, 2], [42884, 1, "\uA785"], [42885, 2], [42886, 1, "\uA787"], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, "\uA78C"], [42892, 2], [42893, 1, "\u0265"], [42894, 2], [42895, 2], [42896, 1, "\uA791"], [42897, 2], [42898, 1, "\uA793"], [42899, 2], [[42900, 42901], 2], [42902, 1, "\uA797"], [42903, 2], [42904, 1, "\uA799"], [42905, 2], [42906, 1, "\uA79B"], [42907, 2], [42908, 1, "\uA79D"], [42909, 2], [42910, 1, "\uA79F"], [42911, 2], [42912, 1, "\uA7A1"], [42913, 2], [42914, 1, "\uA7A3"], [42915, 2], [42916, 1, "\uA7A5"], [42917, 2], [42918, 1, "\uA7A7"], [42919, 2], [42920, 1, "\uA7A9"], [42921, 2], [42922, 1, "\u0266"], [42923, 1, "\u025C"], [42924, 1, "\u0261"], [42925, 1, "\u026C"], [42926, 1, "\u026A"], [42927, 2], [42928, 1, "\u029E"], [42929, 1, "\u0287"], [42930, 1, "\u029D"], [42931, 1, "\uAB53"], [42932, 1, "\uA7B5"], [42933, 2], [42934, 1, "\uA7B7"], [42935, 2], [42936, 1, "\uA7B9"], [42937, 2], [42938, 1, "\uA7BB"], [42939, 2], [42940, 1, "\uA7BD"], [42941, 2], [42942, 1, "\uA7BF"], [42943, 2], [42944, 1, "\uA7C1"], [42945, 2], [42946, 1, "\uA7C3"], [42947, 2], [42948, 1, "\uA794"], [42949, 1, "\u0282"], [42950, 1, "\u1D8E"], [42951, 1, "\uA7C8"], [42952, 2], [42953, 1, "\uA7CA"], [42954, 2], [[42955, 42959], 3], [42960, 1, "\uA7D1"], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, "\uA7D7"], [42967, 2], [42968, 1, "\uA7D9"], [42969, 2], [[42970, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, "\uA7F6"], [42998, 2], [42999, 2], [43e3, 1, "\u0127"], [43001, 1, "\u0153"], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, "\uA727"], [43869, 1, "\uAB37"], [43870, 1, "\u026B"], [43871, 1, "\uAB52"], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, "\u028D"], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, "\u13A0"], [43889, 1, "\u13A1"], [43890, 1, "\u13A2"], [43891, 1, "\u13A3"], [43892, 1, "\u13A4"], [43893, 1, "\u13A5"], [43894, 1, "\u13A6"], [43895, 1, "\u13A7"], [43896, 1, "\u13A8"], [43897, 1, "\u13A9"], [43898, 1, "\u13AA"], [43899, 1, "\u13AB"], [43900, 1, "\u13AC"], [43901, 1, "\u13AD"], [43902, 1, "\u13AE"], [43903, 1, "\u13AF"], [43904, 1, "\u13B0"], [43905, 1, "\u13B1"], [43906, 1, "\u13B2"], [43907, 1, "\u13B3"], [43908, 1, "\u13B4"], [43909, 1, "\u13B5"], [43910, 1, "\u13B6"], [43911, 1, "\u13B7"], [43912, 1, "\u13B8"], [43913, 1, "\u13B9"], [43914, 1, "\u13BA"], [43915, 1, "\u13BB"], [43916, 1, "\u13BC"], [43917, 1, "\u13BD"], [43918, 1, "\u13BE"], [43919, 1, "\u13BF"], [43920, 1, "\u13C0"], [43921, 1, "\u13C1"], [43922, 1, "\u13C2"], [43923, 1, "\u13C3"], [43924, 1, "\u13C4"], [43925, 1, "\u13C5"], [43926, 1, "\u13C6"], [43927, 1, "\u13C7"], [43928, 1, "\u13C8"], [43929, 1, "\u13C9"], [43930, 1, "\u13CA"], [43931, 1, "\u13CB"], [43932, 1, "\u13CC"], [43933, 1, "\u13CD"], [43934, 1, "\u13CE"], [43935, 1, "\u13CF"], [43936, 1, "\u13D0"], [43937, 1, "\u13D1"], [43938, 1, "\u13D2"], [43939, 1, "\u13D3"], [43940, 1, "\u13D4"], [43941, 1, "\u13D5"], [43942, 1, "\u13D6"], [43943, 1, "\u13D7"], [43944, 1, "\u13D8"], [43945, 1, "\u13D9"], [43946, 1, "\u13DA"], [43947, 1, "\u13DB"], [43948, 1, "\u13DC"], [43949, 1, "\u13DD"], [43950, 1, "\u13DE"], [43951, 1, "\u13DF"], [43952, 1, "\u13E0"], [43953, 1, "\u13E1"], [43954, 1, "\u13E2"], [43955, 1, "\u13E3"], [43956, 1, "\u13E4"], [43957, 1, "\u13E5"], [43958, 1, "\u13E6"], [43959, 1, "\u13E7"], [43960, 1, "\u13E8"], [43961, 1, "\u13E9"], [43962, 1, "\u13EA"], [43963, 1, "\u13EB"], [43964, 1, "\u13EC"], [43965, 1, "\u13ED"], [43966, 1, "\u13EE"], [43967, 1, "\u13EF"], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, "\u8C48"], [63745, 1, "\u66F4"], [63746, 1, "\u8ECA"], [63747, 1, "\u8CC8"], [63748, 1, "\u6ED1"], [63749, 1, "\u4E32"], [63750, 1, "\u53E5"], [[63751, 63752], 1, "\u9F9C"], [63753, 1, "\u5951"], [63754, 1, "\u91D1"], [63755, 1, "\u5587"], [63756, 1, "\u5948"], [63757, 1, "\u61F6"], [63758, 1, "\u7669"], [63759, 1, "\u7F85"], [63760, 1, "\u863F"], [63761, 1, "\u87BA"], [63762, 1, "\u88F8"], [63763, 1, "\u908F"], [63764, 1, "\u6A02"], [63765, 1, "\u6D1B"], [63766, 1, "\u70D9"], [63767, 1, "\u73DE"], [63768, 1, "\u843D"], [63769, 1, "\u916A"], [63770, 1, "\u99F1"], [63771, 1, "\u4E82"], [63772, 1, "\u5375"], [63773, 1, "\u6B04"], [63774, 1, "\u721B"], [63775, 1, "\u862D"], [63776, 1, "\u9E1E"], [63777, 1, "\u5D50"], [63778, 1, "\u6FEB"], [63779, 1, "\u85CD"], [63780, 1, "\u8964"], [63781, 1, "\u62C9"], [63782, 1, "\u81D8"], [63783, 1, "\u881F"], [63784, 1, "\u5ECA"], [63785, 1, "\u6717"], [63786, 1, "\u6D6A"], [63787, 1, "\u72FC"], [63788, 1, "\u90CE"], [63789, 1, "\u4F86"], [63790, 1, "\u51B7"], [63791, 1, "\u52DE"], [63792, 1, "\u64C4"], [63793, 1, "\u6AD3"], [63794, 1, "\u7210"], [63795, 1, "\u76E7"], [63796, 1, "\u8001"], [63797, 1, "\u8606"], [63798, 1, "\u865C"], [63799, 1, "\u8DEF"], [63800, 1, "\u9732"], [63801, 1, "\u9B6F"], [63802, 1, "\u9DFA"], [63803, 1, "\u788C"], [63804, 1, "\u797F"], [63805, 1, "\u7DA0"], [63806, 1, "\u83C9"], [63807, 1, "\u9304"], [63808, 1, "\u9E7F"], [63809, 1, "\u8AD6"], [63810, 1, "\u58DF"], [63811, 1, "\u5F04"], [63812, 1, "\u7C60"], [63813, 1, "\u807E"], [63814, 1, "\u7262"], [63815, 1, "\u78CA"], [63816, 1, "\u8CC2"], [63817, 1, "\u96F7"], [63818, 1, "\u58D8"], [63819, 1, "\u5C62"], [63820, 1, "\u6A13"], [63821, 1, "\u6DDA"], [63822, 1, "\u6F0F"], [63823, 1, "\u7D2F"], [63824, 1, "\u7E37"], [63825, 1, "\u964B"], [63826, 1, "\u52D2"], [63827, 1, "\u808B"], [63828, 1, "\u51DC"], [63829, 1, "\u51CC"], [63830, 1, "\u7A1C"], [63831, 1, "\u7DBE"], [63832, 1, "\u83F1"], [63833, 1, "\u9675"], [63834, 1, "\u8B80"], [63835, 1, "\u62CF"], [63836, 1, "\u6A02"], [63837, 1, "\u8AFE"], [63838, 1, "\u4E39"], [63839, 1, "\u5BE7"], [63840, 1, "\u6012"], [63841, 1, "\u7387"], [63842, 1, "\u7570"], [63843, 1, "\u5317"], [63844, 1, "\u78FB"], [63845, 1, "\u4FBF"], [63846, 1, "\u5FA9"], [63847, 1, "\u4E0D"], [63848, 1, "\u6CCC"], [63849, 1, "\u6578"], [63850, 1, "\u7D22"], [63851, 1, "\u53C3"], [63852, 1, "\u585E"], [63853, 1, "\u7701"], [63854, 1, "\u8449"], [63855, 1, "\u8AAA"], [63856, 1, "\u6BBA"], [63857, 1, "\u8FB0"], [63858, 1, "\u6C88"], [63859, 1, "\u62FE"], [63860, 1, "\u82E5"], [63861, 1, "\u63A0"], [63862, 1, "\u7565"], [63863, 1, "\u4EAE"], [63864, 1, "\u5169"], [63865, 1, "\u51C9"], [63866, 1, "\u6881"], [63867, 1, "\u7CE7"], [63868, 1, "\u826F"], [63869, 1, "\u8AD2"], [63870, 1, "\u91CF"], [63871, 1, "\u52F5"], [63872, 1, "\u5442"], [63873, 1, "\u5973"], [63874, 1, "\u5EEC"], [63875, 1, "\u65C5"], [63876, 1, "\u6FFE"], [63877, 1, "\u792A"], [63878, 1, "\u95AD"], [63879, 1, "\u9A6A"], [63880, 1, "\u9E97"], [63881, 1, "\u9ECE"], [63882, 1, "\u529B"], [63883, 1, "\u66C6"], [63884, 1, "\u6B77"], [63885, 1, "\u8F62"], [63886, 1, "\u5E74"], [63887, 1, "\u6190"], [63888, 1, "\u6200"], [63889, 1, "\u649A"], [63890, 1, "\u6F23"], [63891, 1, "\u7149"], [63892, 1, "\u7489"], [63893, 1, "\u79CA"], [63894, 1, "\u7DF4"], [63895, 1, "\u806F"], [63896, 1, "\u8F26"], [63897, 1, "\u84EE"], [63898, 1, "\u9023"], [63899, 1, "\u934A"], [63900, 1, "\u5217"], [63901, 1, "\u52A3"], [63902, 1, "\u54BD"], [63903, 1, "\u70C8"], [63904, 1, "\u88C2"], [63905, 1, "\u8AAA"], [63906, 1, "\u5EC9"], [63907, 1, "\u5FF5"], [63908, 1, "\u637B"], [63909, 1, "\u6BAE"], [63910, 1, "\u7C3E"], [63911, 1, "\u7375"], [63912, 1, "\u4EE4"], [63913, 1, "\u56F9"], [63914, 1, "\u5BE7"], [63915, 1, "\u5DBA"], [63916, 1, "\u601C"], [63917, 1, "\u73B2"], [63918, 1, "\u7469"], [63919, 1, "\u7F9A"], [63920, 1, "\u8046"], [63921, 1, "\u9234"], [63922, 1, "\u96F6"], [63923, 1, "\u9748"], [63924, 1, "\u9818"], [63925, 1, "\u4F8B"], [63926, 1, "\u79AE"], [63927, 1, "\u91B4"], [63928, 1, "\u96B8"], [63929, 1, "\u60E1"], [63930, 1, "\u4E86"], [63931, 1, "\u50DA"], [63932, 1, "\u5BEE"], [63933, 1, "\u5C3F"], [63934, 1, "\u6599"], [63935, 1, "\u6A02"], [63936, 1, "\u71CE"], [63937, 1, "\u7642"], [63938, 1, "\u84FC"], [63939, 1, "\u907C"], [63940, 1, "\u9F8D"], [63941, 1, "\u6688"], [63942, 1, "\u962E"], [63943, 1, "\u5289"], [63944, 1, "\u677B"], [63945, 1, "\u67F3"], [63946, 1, "\u6D41"], [63947, 1, "\u6E9C"], [63948, 1, "\u7409"], [63949, 1, "\u7559"], [63950, 1, "\u786B"], [63951, 1, "\u7D10"], [63952, 1, "\u985E"], [63953, 1, "\u516D"], [63954, 1, "\u622E"], [63955, 1, "\u9678"], [63956, 1, "\u502B"], [63957, 1, "\u5D19"], [63958, 1, "\u6DEA"], [63959, 1, "\u8F2A"], [63960, 1, "\u5F8B"], [63961, 1, "\u6144"], [63962, 1, "\u6817"], [63963, 1, "\u7387"], [63964, 1, "\u9686"], [63965, 1, "\u5229"], [63966, 1, "\u540F"], [63967, 1, "\u5C65"], [63968, 1, "\u6613"], [63969, 1, "\u674E"], [63970, 1, "\u68A8"], [63971, 1, "\u6CE5"], [63972, 1, "\u7406"], [63973, 1, "\u75E2"], [63974, 1, "\u7F79"], [63975, 1, "\u88CF"], [63976, 1, "\u88E1"], [63977, 1, "\u91CC"], [63978, 1, "\u96E2"], [63979, 1, "\u533F"], [63980, 1, "\u6EBA"], [63981, 1, "\u541D"], [63982, 1, "\u71D0"], [63983, 1, "\u7498"], [63984, 1, "\u85FA"], [63985, 1, "\u96A3"], [63986, 1, "\u9C57"], [63987, 1, "\u9E9F"], [63988, 1, "\u6797"], [63989, 1, "\u6DCB"], [63990, 1, "\u81E8"], [63991, 1, "\u7ACB"], [63992, 1, "\u7B20"], [63993, 1, "\u7C92"], [63994, 1, "\u72C0"], [63995, 1, "\u7099"], [63996, 1, "\u8B58"], [63997, 1, "\u4EC0"], [63998, 1, "\u8336"], [63999, 1, "\u523A"], [64e3, 1, "\u5207"], [64001, 1, "\u5EA6"], [64002, 1, "\u62D3"], [64003, 1, "\u7CD6"], [64004, 1, "\u5B85"], [64005, 1, "\u6D1E"], [64006, 1, "\u66B4"], [64007, 1, "\u8F3B"], [64008, 1, "\u884C"], [64009, 1, "\u964D"], [64010, 1, "\u898B"], [64011, 1, "\u5ED3"], [64012, 1, "\u5140"], [64013, 1, "\u55C0"], [[64014, 64015], 2], [64016, 1, "\u585A"], [64017, 2], [64018, 1, "\u6674"], [[64019, 64020], 2], [64021, 1, "\u51DE"], [64022, 1, "\u732A"], [64023, 1, "\u76CA"], [64024, 1, "\u793C"], [64025, 1, "\u795E"], [64026, 1, "\u7965"], [64027, 1, "\u798F"], [64028, 1, "\u9756"], [64029, 1, "\u7CBE"], [64030, 1, "\u7FBD"], [64031, 2], [64032, 1, "\u8612"], [64033, 2], [64034, 1, "\u8AF8"], [[64035, 64036], 2], [64037, 1, "\u9038"], [64038, 1, "\u90FD"], [[64039, 64041], 2], [64042, 1, "\u98EF"], [64043, 1, "\u98FC"], [64044, 1, "\u9928"], [64045, 1, "\u9DB4"], [64046, 1, "\u90DE"], [64047, 1, "\u96B7"], [64048, 1, "\u4FAE"], [64049, 1, "\u50E7"], [64050, 1, "\u514D"], [64051, 1, "\u52C9"], [64052, 1, "\u52E4"], [64053, 1, "\u5351"], [64054, 1, "\u559D"], [64055, 1, "\u5606"], [64056, 1, "\u5668"], [64057, 1, "\u5840"], [64058, 1, "\u58A8"], [64059, 1, "\u5C64"], [64060, 1, "\u5C6E"], [64061, 1, "\u6094"], [64062, 1, "\u6168"], [64063, 1, "\u618E"], [64064, 1, "\u61F2"], [64065, 1, "\u654F"], [64066, 1, "\u65E2"], [64067, 1, "\u6691"], [64068, 1, "\u6885"], [64069, 1, "\u6D77"], [64070, 1, "\u6E1A"], [64071, 1, "\u6F22"], [64072, 1, "\u716E"], [64073, 1, "\u722B"], [64074, 1, "\u7422"], [64075, 1, "\u7891"], [64076, 1, "\u793E"], [64077, 1, "\u7949"], [64078, 1, "\u7948"], [64079, 1, "\u7950"], [64080, 1, "\u7956"], [64081, 1, "\u795D"], [64082, 1, "\u798D"], [64083, 1, "\u798E"], [64084, 1, "\u7A40"], [64085, 1, "\u7A81"], [64086, 1, "\u7BC0"], [64087, 1, "\u7DF4"], [64088, 1, "\u7E09"], [64089, 1, "\u7E41"], [64090, 1, "\u7F72"], [64091, 1, "\u8005"], [64092, 1, "\u81ED"], [[64093, 64094], 1, "\u8279"], [64095, 1, "\u8457"], [64096, 1, "\u8910"], [64097, 1, "\u8996"], [64098, 1, "\u8B01"], [64099, 1, "\u8B39"], [64100, 1, "\u8CD3"], [64101, 1, "\u8D08"], [64102, 1, "\u8FB6"], [64103, 1, "\u9038"], [64104, 1, "\u96E3"], [64105, 1, "\u97FF"], [64106, 1, "\u983B"], [64107, 1, "\u6075"], [64108, 1, "\u{242EE}"], [64109, 1, "\u8218"], [[64110, 64111], 3], [64112, 1, "\u4E26"], [64113, 1, "\u51B5"], [64114, 1, "\u5168"], [64115, 1, "\u4F80"], [64116, 1, "\u5145"], [64117, 1, "\u5180"], [64118, 1, "\u52C7"], [64119, 1, "\u52FA"], [64120, 1, "\u559D"], [64121, 1, "\u5555"], [64122, 1, "\u5599"], [64123, 1, "\u55E2"], [64124, 1, "\u585A"], [64125, 1, "\u58B3"], [64126, 1, "\u5944"], [64127, 1, "\u5954"], [64128, 1, "\u5A62"], [64129, 1, "\u5B28"], [64130, 1, "\u5ED2"], [64131, 1, "\u5ED9"], [64132, 1, "\u5F69"], [64133, 1, "\u5FAD"], [64134, 1, "\u60D8"], [64135, 1, "\u614E"], [64136, 1, "\u6108"], [64137, 1, "\u618E"], [64138, 1, "\u6160"], [64139, 1, "\u61F2"], [64140, 1, "\u6234"], [64141, 1, "\u63C4"], [64142, 1, "\u641C"], [64143, 1, "\u6452"], [64144, 1, "\u6556"], [64145, 1, "\u6674"], [64146, 1, "\u6717"], [64147, 1, "\u671B"], [64148, 1, "\u6756"], [64149, 1, "\u6B79"], [64150, 1, "\u6BBA"], [64151, 1, "\u6D41"], [64152, 1, "\u6EDB"], [64153, 1, "\u6ECB"], [64154, 1, "\u6F22"], [64155, 1, "\u701E"], [64156, 1, "\u716E"], [64157, 1, "\u77A7"], [64158, 1, "\u7235"], [64159, 1, "\u72AF"], [64160, 1, "\u732A"], [64161, 1, "\u7471"], [64162, 1, "\u7506"], [64163, 1, "\u753B"], [64164, 1, "\u761D"], [64165, 1, "\u761F"], [64166, 1, "\u76CA"], [64167, 1, "\u76DB"], [64168, 1, "\u76F4"], [64169, 1, "\u774A"], [64170, 1, "\u7740"], [64171, 1, "\u78CC"], [64172, 1, "\u7AB1"], [64173, 1, "\u7BC0"], [64174, 1, "\u7C7B"], [64175, 1, "\u7D5B"], [64176, 1, "\u7DF4"], [64177, 1, "\u7F3E"], [64178, 1, "\u8005"], [64179, 1, "\u8352"], [64180, 1, "\u83EF"], [64181, 1, "\u8779"], [64182, 1, "\u8941"], [64183, 1, "\u8986"], [64184, 1, "\u8996"], [64185, 1, "\u8ABF"], [64186, 1, "\u8AF8"], [64187, 1, "\u8ACB"], [64188, 1, "\u8B01"], [64189, 1, "\u8AFE"], [64190, 1, "\u8AED"], [64191, 1, "\u8B39"], [64192, 1, "\u8B8A"], [64193, 1, "\u8D08"], [64194, 1, "\u8F38"], [64195, 1, "\u9072"], [64196, 1, "\u9199"], [64197, 1, "\u9276"], [64198, 1, "\u967C"], [64199, 1, "\u96E3"], [64200, 1, "\u9756"], [64201, 1, "\u97DB"], [64202, 1, "\u97FF"], [64203, 1, "\u980B"], [64204, 1, "\u983B"], [64205, 1, "\u9B12"], [64206, 1, "\u9F9C"], [64207, 1, "\u{2284A}"], [64208, 1, "\u{22844}"], [64209, 1, "\u{233D5}"], [64210, 1, "\u3B9D"], [64211, 1, "\u4018"], [64212, 1, "\u4039"], [64213, 1, "\u{25249}"], [64214, 1, "\u{25CD0}"], [64215, 1, "\u{27ED3}"], [64216, 1, "\u9F43"], [64217, 1, "\u9F8E"], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, "\u0574\u0576"], [64276, 1, "\u0574\u0565"], [64277, 1, "\u0574\u056B"], [64278, 1, "\u057E\u0576"], [64279, 1, "\u0574\u056D"], [[64280, 64284], 3], [64285, 1, "\u05D9\u05B4"], [64286, 2], [64287, 1, "\u05F2\u05B7"], [64288, 1, "\u05E2"], [64289, 1, "\u05D0"], [64290, 1, "\u05D3"], [64291, 1, "\u05D4"], [64292, 1, "\u05DB"], [64293, 1, "\u05DC"], [64294, 1, "\u05DD"], [64295, 1, "\u05E8"], [64296, 1, "\u05EA"], [64297, 5, "+"], [64298, 1, "\u05E9\u05C1"], [64299, 1, "\u05E9\u05C2"], [64300, 1, "\u05E9\u05BC\u05C1"], [64301, 1, "\u05E9\u05BC\u05C2"], [64302, 1, "\u05D0\u05B7"], [64303, 1, "\u05D0\u05B8"], [64304, 1, "\u05D0\u05BC"], [64305, 1, "\u05D1\u05BC"], [64306, 1, "\u05D2\u05BC"], [64307, 1, "\u05D3\u05BC"], [64308, 1, "\u05D4\u05BC"], [64309, 1, "\u05D5\u05BC"], [64310, 1, "\u05D6\u05BC"], [64311, 3], [64312, 1, "\u05D8\u05BC"], [64313, 1, "\u05D9\u05BC"], [64314, 1, "\u05DA\u05BC"], [64315, 1, "\u05DB\u05BC"], [64316, 1, "\u05DC\u05BC"], [64317, 3], [64318, 1, "\u05DE\u05BC"], [64319, 3], [64320, 1, "\u05E0\u05BC"], [64321, 1, "\u05E1\u05BC"], [64322, 3], [64323, 1, "\u05E3\u05BC"], [64324, 1, "\u05E4\u05BC"], [64325, 3], [64326, 1, "\u05E6\u05BC"], [64327, 1, "\u05E7\u05BC"], [64328, 1, "\u05E8\u05BC"], [64329, 1, "\u05E9\u05BC"], [64330, 1, "\u05EA\u05BC"], [64331, 1, "\u05D5\u05B9"], [64332, 1, "\u05D1\u05BF"], [64333, 1, "\u05DB\u05BF"], [64334, 1, "\u05E4\u05BF"], [64335, 1, "\u05D0\u05DC"], [[64336, 64337], 1, "\u0671"], [[64338, 64341], 1, "\u067B"], [[64342, 64345], 1, "\u067E"], [[64346, 64349], 1, "\u0680"], [[64350, 64353], 1, "\u067A"], [[64354, 64357], 1, "\u067F"], [[64358, 64361], 1, "\u0679"], [[64362, 64365], 1, "\u06A4"], [[64366, 64369], 1, "\u06A6"], [[64370, 64373], 1, "\u0684"], [[64374, 64377], 1, "\u0683"], [[64378, 64381], 1, "\u0686"], [[64382, 64385], 1, "\u0687"], [[64386, 64387], 1, "\u068D"], [[64388, 64389], 1, "\u068C"], [[64390, 64391], 1, "\u068E"], [[64392, 64393], 1, "\u0688"], [[64394, 64395], 1, "\u0698"], [[64396, 64397], 1, "\u0691"], [[64398, 64401], 1, "\u06A9"], [[64402, 64405], 1, "\u06AF"], [[64406, 64409], 1, "\u06B3"], [[64410, 64413], 1, "\u06B1"], [[64414, 64415], 1, "\u06BA"], [[64416, 64419], 1, "\u06BB"], [[64420, 64421], 1, "\u06C0"], [[64422, 64425], 1, "\u06C1"], [[64426, 64429], 1, "\u06BE"], [[64430, 64431], 1, "\u06D2"], [[64432, 64433], 1, "\u06D3"], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, "\u06AD"], [[64471, 64472], 1, "\u06C7"], [[64473, 64474], 1, "\u06C6"], [[64475, 64476], 1, "\u06C8"], [64477, 1, "\u06C7\u0674"], [[64478, 64479], 1, "\u06CB"], [[64480, 64481], 1, "\u06C5"], [[64482, 64483], 1, "\u06C9"], [[64484, 64487], 1, "\u06D0"], [[64488, 64489], 1, "\u0649"], [[64490, 64491], 1, "\u0626\u0627"], [[64492, 64493], 1, "\u0626\u06D5"], [[64494, 64495], 1, "\u0626\u0648"], [[64496, 64497], 1, "\u0626\u06C7"], [[64498, 64499], 1, "\u0626\u06C6"], [[64500, 64501], 1, "\u0626\u06C8"], [[64502, 64504], 1, "\u0626\u06D0"], [[64505, 64507], 1, "\u0626\u0649"], [[64508, 64511], 1, "\u06CC"], [64512, 1, "\u0626\u062C"], [64513, 1, "\u0626\u062D"], [64514, 1, "\u0626\u0645"], [64515, 1, "\u0626\u0649"], [64516, 1, "\u0626\u064A"], [64517, 1, "\u0628\u062C"], [64518, 1, "\u0628\u062D"], [64519, 1, "\u0628\u062E"], [64520, 1, "\u0628\u0645"], [64521, 1, "\u0628\u0649"], [64522, 1, "\u0628\u064A"], [64523, 1, "\u062A\u062C"], [64524, 1, "\u062A\u062D"], [64525, 1, "\u062A\u062E"], [64526, 1, "\u062A\u0645"], [64527, 1, "\u062A\u0649"], [64528, 1, "\u062A\u064A"], [64529, 1, "\u062B\u062C"], [64530, 1, "\u062B\u0645"], [64531, 1, "\u062B\u0649"], [64532, 1, "\u062B\u064A"], [64533, 1, "\u062C\u062D"], [64534, 1, "\u062C\u0645"], [64535, 1, "\u062D\u062C"], [64536, 1, "\u062D\u0645"], [64537, 1, "\u062E\u062C"], [64538, 1, "\u062E\u062D"], [64539, 1, "\u062E\u0645"], [64540, 1, "\u0633\u062C"], [64541, 1, "\u0633\u062D"], [64542, 1, "\u0633\u062E"], [64543, 1, "\u0633\u0645"], [64544, 1, "\u0635\u062D"], [64545, 1, "\u0635\u0645"], [64546, 1, "\u0636\u062C"], [64547, 1, "\u0636\u062D"], [64548, 1, "\u0636\u062E"], [64549, 1, "\u0636\u0645"], [64550, 1, "\u0637\u062D"], [64551, 1, "\u0637\u0645"], [64552, 1, "\u0638\u0645"], [64553, 1, "\u0639\u062C"], [64554, 1, "\u0639\u0645"], [64555, 1, "\u063A\u062C"], [64556, 1, "\u063A\u0645"], [64557, 1, "\u0641\u062C"], [64558, 1, "\u0641\u062D"], [64559, 1, "\u0641\u062E"], [64560, 1, "\u0641\u0645"], [64561, 1, "\u0641\u0649"], [64562, 1, "\u0641\u064A"], [64563, 1, "\u0642\u062D"], [64564, 1, "\u0642\u0645"], [64565, 1, "\u0642\u0649"], [64566, 1, "\u0642\u064A"], [64567, 1, "\u0643\u0627"], [64568, 1, "\u0643\u062C"], [64569, 1, "\u0643\u062D"], [64570, 1, "\u0643\u062E"], [64571, 1, "\u0643\u0644"], [64572, 1, "\u0643\u0645"], [64573, 1, "\u0643\u0649"], [64574, 1, "\u0643\u064A"], [64575, 1, "\u0644\u062C"], [64576, 1, "\u0644\u062D"], [64577, 1, "\u0644\u062E"], [64578, 1, "\u0644\u0645"], [64579, 1, "\u0644\u0649"], [64580, 1, "\u0644\u064A"], [64581, 1, "\u0645\u062C"], [64582, 1, "\u0645\u062D"], [64583, 1, "\u0645\u062E"], [64584, 1, "\u0645\u0645"], [64585, 1, "\u0645\u0649"], [64586, 1, "\u0645\u064A"], [64587, 1, "\u0646\u062C"], [64588, 1, "\u0646\u062D"], [64589, 1, "\u0646\u062E"], [64590, 1, "\u0646\u0645"], [64591, 1, "\u0646\u0649"], [64592, 1, "\u0646\u064A"], [64593, 1, "\u0647\u062C"], [64594, 1, "\u0647\u0645"], [64595, 1, "\u0647\u0649"], [64596, 1, "\u0647\u064A"], [64597, 1, "\u064A\u062C"], [64598, 1, "\u064A\u062D"], [64599, 1, "\u064A\u062E"], [64600, 1, "\u064A\u0645"], [64601, 1, "\u064A\u0649"], [64602, 1, "\u064A\u064A"], [64603, 1, "\u0630\u0670"], [64604, 1, "\u0631\u0670"], [64605, 1, "\u0649\u0670"], [64606, 5, " \u064C\u0651"], [64607, 5, " \u064D\u0651"], [64608, 5, " \u064E\u0651"], [64609, 5, " \u064F\u0651"], [64610, 5, " \u0650\u0651"], [64611, 5, " \u0651\u0670"], [64612, 1, "\u0626\u0631"], [64613, 1, "\u0626\u0632"], [64614, 1, "\u0626\u0645"], [64615, 1, "\u0626\u0646"], [64616, 1, "\u0626\u0649"], [64617, 1, "\u0626\u064A"], [64618, 1, "\u0628\u0631"], [64619, 1, "\u0628\u0632"], [64620, 1, "\u0628\u0645"], [64621, 1, "\u0628\u0646"], [64622, 1, "\u0628\u0649"], [64623, 1, "\u0628\u064A"], [64624, 1, "\u062A\u0631"], [64625, 1, "\u062A\u0632"], [64626, 1, "\u062A\u0645"], [64627, 1, "\u062A\u0646"], [64628, 1, "\u062A\u0649"], [64629, 1, "\u062A\u064A"], [64630, 1, "\u062B\u0631"], [64631, 1, "\u062B\u0632"], [64632, 1, "\u062B\u0645"], [64633, 1, "\u062B\u0646"], [64634, 1, "\u062B\u0649"], [64635, 1, "\u062B\u064A"], [64636, 1, "\u0641\u0649"], [64637, 1, "\u0641\u064A"], [64638, 1, "\u0642\u0649"], [64639, 1, "\u0642\u064A"], [64640, 1, "\u0643\u0627"], [64641, 1, "\u0643\u0644"], [64642, 1, "\u0643\u0645"], [64643, 1, "\u0643\u0649"], [64644, 1, "\u0643\u064A"], [64645, 1, "\u0644\u0645"], [64646, 1, "\u0644\u0649"], [64647, 1, "\u0644\u064A"], [64648, 1, "\u0645\u0627"], [64649, 1, "\u0645\u0645"], [64650, 1, "\u0646\u0631"], [64651, 1, "\u0646\u0632"], [64652, 1, "\u0646\u0645"], [64653, 1, "\u0646\u0646"], [64654, 1, "\u0646\u0649"], [64655, 1, "\u0646\u064A"], [64656, 1, "\u0649\u0670"], [64657, 1, "\u064A\u0631"], [64658, 1, "\u064A\u0632"], [64659, 1, "\u064A\u0645"], [64660, 1, "\u064A\u0646"], [64661, 1, "\u064A\u0649"], [64662, 1, "\u064A\u064A"], [64663, 1, "\u0626\u062C"], [64664, 1, "\u0626\u062D"], [64665, 1, "\u0626\u062E"], [64666, 1, "\u0626\u0645"], [64667, 1, "\u0626\u0647"], [64668, 1, "\u0628\u062C"], [64669, 1, "\u0628\u062D"], [64670, 1, "\u0628\u062E"], [64671, 1, "\u0628\u0645"], [64672, 1, "\u0628\u0647"], [64673, 1, "\u062A\u062C"], [64674, 1, "\u062A\u062D"], [64675, 1, "\u062A\u062E"], [64676, 1, "\u062A\u0645"], [64677, 1, "\u062A\u0647"], [64678, 1, "\u062B\u0645"], [64679, 1, "\u062C\u062D"], [64680, 1, "\u062C\u0645"], [64681, 1, "\u062D\u062C"], [64682, 1, "\u062D\u0645"], [64683, 1, "\u062E\u062C"], [64684, 1, "\u062E\u0645"], [64685, 1, "\u0633\u062C"], [64686, 1, "\u0633\u062D"], [64687, 1, "\u0633\u062E"], [64688, 1, "\u0633\u0645"], [64689, 1, "\u0635\u062D"], [64690, 1, "\u0635\u062E"], [64691, 1, "\u0635\u0645"], [64692, 1, "\u0636\u062C"], [64693, 1, "\u0636\u062D"], [64694, 1, "\u0636\u062E"], [64695, 1, "\u0636\u0645"], [64696, 1, "\u0637\u062D"], [64697, 1, "\u0638\u0645"], [64698, 1, "\u0639\u062C"], [64699, 1, "\u0639\u0645"], [64700, 1, "\u063A\u062C"], [64701, 1, "\u063A\u0645"], [64702, 1, "\u0641\u062C"], [64703, 1, "\u0641\u062D"], [64704, 1, "\u0641\u062E"], [64705, 1, "\u0641\u0645"], [64706, 1, "\u0642\u062D"], [64707, 1, "\u0642\u0645"], [64708, 1, "\u0643\u062C"], [64709, 1, "\u0643\u062D"], [64710, 1, "\u0643\u062E"], [64711, 1, "\u0643\u0644"], [64712, 1, "\u0643\u0645"], [64713, 1, "\u0644\u062C"], [64714, 1, "\u0644\u062D"], [64715, 1, "\u0644\u062E"], [64716, 1, "\u0644\u0645"], [64717, 1, "\u0644\u0647"], [64718, 1, "\u0645\u062C"], [64719, 1, "\u0645\u062D"], [64720, 1, "\u0645\u062E"], [64721, 1, "\u0645\u0645"], [64722, 1, "\u0646\u062C"], [64723, 1, "\u0646\u062D"], [64724, 1, "\u0646\u062E"], [64725, 1, "\u0646\u0645"], [64726, 1, "\u0646\u0647"], [64727, 1, "\u0647\u062C"], [64728, 1, "\u0647\u0645"], [64729, 1, "\u0647\u0670"], [64730, 1, "\u064A\u062C"], [64731, 1, "\u064A\u062D"], [64732, 1, "\u064A\u062E"], [64733, 1, "\u064A\u0645"], [64734, 1, "\u064A\u0647"], [64735, 1, "\u0626\u0645"], [64736, 1, "\u0626\u0647"], [64737, 1, "\u0628\u0645"], [64738, 1, "\u0628\u0647"], [64739, 1, "\u062A\u0645"], [64740, 1, "\u062A\u0647"], [64741, 1, "\u062B\u0645"], [64742, 1, "\u062B\u0647"], [64743, 1, "\u0633\u0645"], [64744, 1, "\u0633\u0647"], [64745, 1, "\u0634\u0645"], [64746, 1, "\u0634\u0647"], [64747, 1, "\u0643\u0644"], [64748, 1, "\u0643\u0645"], [64749, 1, "\u0644\u0645"], [64750, 1, "\u0646\u0645"], [64751, 1, "\u0646\u0647"], [64752, 1, "\u064A\u0645"], [64753, 1, "\u064A\u0647"], [64754, 1, "\u0640\u064E\u0651"], [64755, 1, "\u0640\u064F\u0651"], [64756, 1, "\u0640\u0650\u0651"], [64757, 1, "\u0637\u0649"], [64758, 1, "\u0637\u064A"], [64759, 1, "\u0639\u0649"], [64760, 1, "\u0639\u064A"], [64761, 1, "\u063A\u0649"], [64762, 1, "\u063A\u064A"], [64763, 1, "\u0633\u0649"], [64764, 1, "\u0633\u064A"], [64765, 1, "\u0634\u0649"], [64766, 1, "\u0634\u064A"], [64767, 1, "\u062D\u0649"], [64768, 1, "\u062D\u064A"], [64769, 1, "\u062C\u0649"], [64770, 1, "\u062C\u064A"], [64771, 1, "\u062E\u0649"], [64772, 1, "\u062E\u064A"], [64773, 1, "\u0635\u0649"], [64774, 1, "\u0635\u064A"], [64775, 1, "\u0636\u0649"], [64776, 1, "\u0636\u064A"], [64777, 1, "\u0634\u062C"], [64778, 1, "\u0634\u062D"], [64779, 1, "\u0634\u062E"], [64780, 1, "\u0634\u0645"], [64781, 1, "\u0634\u0631"], [64782, 1, "\u0633\u0631"], [64783, 1, "\u0635\u0631"], [64784, 1, "\u0636\u0631"], [64785, 1, "\u0637\u0649"], [64786, 1, "\u0637\u064A"], [64787, 1, "\u0639\u0649"], [64788, 1, "\u0639\u064A"], [64789, 1, "\u063A\u0649"], [64790, 1, "\u063A\u064A"], [64791, 1, "\u0633\u0649"], [64792, 1, "\u0633\u064A"], [64793, 1, "\u0634\u0649"], [64794, 1, "\u0634\u064A"], [64795, 1, "\u062D\u0649"], [64796, 1, "\u062D\u064A"], [64797, 1, "\u062C\u0649"], [64798, 1, "\u062C\u064A"], [64799, 1, "\u062E\u0649"], [64800, 1, "\u062E\u064A"], [64801, 1, "\u0635\u0649"], [64802, 1, "\u0635\u064A"], [64803, 1, "\u0636\u0649"], [64804, 1, "\u0636\u064A"], [64805, 1, "\u0634\u062C"], [64806, 1, "\u0634\u062D"], [64807, 1, "\u0634\u062E"], [64808, 1, "\u0634\u0645"], [64809, 1, "\u0634\u0631"], [64810, 1, "\u0633\u0631"], [64811, 1, "\u0635\u0631"], [64812, 1, "\u0636\u0631"], [64813, 1, "\u0634\u062C"], [64814, 1, "\u0634\u062D"], [64815, 1, "\u0634\u062E"], [64816, 1, "\u0634\u0645"], [64817, 1, "\u0633\u0647"], [64818, 1, "\u0634\u0647"], [64819, 1, "\u0637\u0645"], [64820, 1, "\u0633\u062C"], [64821, 1, "\u0633\u062D"], [64822, 1, "\u0633\u062E"], [64823, 1, "\u0634\u062C"], [64824, 1, "\u0634\u062D"], [64825, 1, "\u0634\u062E"], [64826, 1, "\u0637\u0645"], [64827, 1, "\u0638\u0645"], [[64828, 64829], 1, "\u0627\u064B"], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, "\u062A\u062C\u0645"], [[64849, 64850], 1, "\u062A\u062D\u062C"], [64851, 1, "\u062A\u062D\u0645"], [64852, 1, "\u062A\u062E\u0645"], [64853, 1, "\u062A\u0645\u062C"], [64854, 1, "\u062A\u0645\u062D"], [64855, 1, "\u062A\u0645\u062E"], [[64856, 64857], 1, "\u062C\u0645\u062D"], [64858, 1, "\u062D\u0645\u064A"], [64859, 1, "\u062D\u0645\u0649"], [64860, 1, "\u0633\u062D\u062C"], [64861, 1, "\u0633\u062C\u062D"], [64862, 1, "\u0633\u062C\u0649"], [[64863, 64864], 1, "\u0633\u0645\u062D"], [64865, 1, "\u0633\u0645\u062C"], [[64866, 64867], 1, "\u0633\u0645\u0645"], [[64868, 64869], 1, "\u0635\u062D\u062D"], [64870, 1, "\u0635\u0645\u0645"], [[64871, 64872], 1, "\u0634\u062D\u0645"], [64873, 1, "\u0634\u062C\u064A"], [[64874, 64875], 1, "\u0634\u0645\u062E"], [[64876, 64877], 1, "\u0634\u0645\u0645"], [64878, 1, "\u0636\u062D\u0649"], [[64879, 64880], 1, "\u0636\u062E\u0645"], [[64881, 64882], 1, "\u0637\u0645\u062D"], [64883, 1, "\u0637\u0645\u0645"], [64884, 1, "\u0637\u0645\u064A"], [64885, 1, "\u0639\u062C\u0645"], [[64886, 64887], 1, "\u0639\u0645\u0645"], [64888, 1, "\u0639\u0645\u0649"], [64889, 1, "\u063A\u0645\u0645"], [64890, 1, "\u063A\u0645\u064A"], [64891, 1, "\u063A\u0645\u0649"], [[64892, 64893], 1, "\u0641\u062E\u0645"], [64894, 1, "\u0642\u0645\u062D"], [64895, 1, "\u0642\u0645\u0645"], [64896, 1, "\u0644\u062D\u0645"], [64897, 1, "\u0644\u062D\u064A"], [64898, 1, "\u0644\u062D\u0649"], [[64899, 64900], 1, "\u0644\u062C\u062C"], [[64901, 64902], 1, "\u0644\u062E\u0645"], [[64903, 64904], 1, "\u0644\u0645\u062D"], [64905, 1, "\u0645\u062D\u062C"], [64906, 1, "\u0645\u062D\u0645"], [64907, 1, "\u0645\u062D\u064A"], [64908, 1, "\u0645\u062C\u062D"], [64909, 1, "\u0645\u062C\u0645"], [64910, 1, "\u0645\u062E\u062C"], [64911, 1, "\u0645\u062E\u0645"], [[64912, 64913], 3], [64914, 1, "\u0645\u062C\u062E"], [64915, 1, "\u0647\u0645\u062C"], [64916, 1, "\u0647\u0645\u0645"], [64917, 1, "\u0646\u062D\u0645"], [64918, 1, "\u0646\u062D\u0649"], [[64919, 64920], 1, "\u0646\u062C\u0645"], [64921, 1, "\u0646\u062C\u0649"], [64922, 1, "\u0646\u0645\u064A"], [64923, 1, "\u0646\u0645\u0649"], [[64924, 64925], 1, "\u064A\u0645\u0645"], [64926, 1, "\u0628\u062E\u064A"], [64927, 1, "\u062A\u062C\u064A"], [64928, 1, "\u062A\u062C\u0649"], [64929, 1, "\u062A\u062E\u064A"], [64930, 1, "\u062A\u062E\u0649"], [64931, 1, "\u062A\u0645\u064A"], [64932, 1, "\u062A\u0645\u0649"], [64933, 1, "\u062C\u0645\u064A"], [64934, 1, "\u062C\u062D\u0649"], [64935, 1, "\u062C\u0645\u0649"], [64936, 1, "\u0633\u062E\u0649"], [64937, 1, "\u0635\u062D\u064A"], [64938, 1, "\u0634\u062D\u064A"], [64939, 1, "\u0636\u062D\u064A"], [64940, 1, "\u0644\u062C\u064A"], [64941, 1, "\u0644\u0645\u064A"], [64942, 1, "\u064A\u062D\u064A"], [64943, 1, "\u064A\u062C\u064A"], [64944, 1, "\u064A\u0645\u064A"], [64945, 1, "\u0645\u0645\u064A"], [64946, 1, "\u0642\u0645\u064A"], [64947, 1, "\u0646\u062D\u064A"], [64948, 1, "\u0642\u0645\u062D"], [64949, 1, "\u0644\u062D\u0645"], [64950, 1, "\u0639\u0645\u064A"], [64951, 1, "\u0643\u0645\u064A"], [64952, 1, "\u0646\u062C\u062D"], [64953, 1, "\u0645\u062E\u064A"], [64954, 1, "\u0644\u062C\u0645"], [64955, 1, "\u0643\u0645\u0645"], [64956, 1, "\u0644\u062C\u0645"], [64957, 1, "\u0646\u062C\u062D"], [64958, 1, "\u062C\u062D\u064A"], [64959, 1, "\u062D\u062C\u064A"], [64960, 1, "\u0645\u062C\u064A"], [64961, 1, "\u0641\u0645\u064A"], [64962, 1, "\u0628\u062D\u064A"], [64963, 1, "\u0643\u0645\u0645"], [64964, 1, "\u0639\u062C\u0645"], [64965, 1, "\u0635\u0645\u0645"], [64966, 1, "\u0633\u062E\u064A"], [64967, 1, "\u0646\u062C\u064A"], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, "\u0635\u0644\u06D2"], [65009, 1, "\u0642\u0644\u06D2"], [65010, 1, "\u0627\u0644\u0644\u0647"], [65011, 1, "\u0627\u0643\u0628\u0631"], [65012, 1, "\u0645\u062D\u0645\u062F"], [65013, 1, "\u0635\u0644\u0639\u0645"], [65014, 1, "\u0631\u0633\u0648\u0644"], [65015, 1, "\u0639\u0644\u064A\u0647"], [65016, 1, "\u0648\u0633\u0644\u0645"], [65017, 1, "\u0635\u0644\u0649"], [65018, 5, "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645"], [65019, 5, "\u062C\u0644 \u062C\u0644\u0627\u0644\u0647"], [65020, 1, "\u0631\u06CC\u0627\u0644"], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 5, ","], [65041, 1, "\u3001"], [65042, 3], [65043, 5, ":"], [65044, 5, ";"], [65045, 5, "!"], [65046, 5, "?"], [65047, 1, "\u3016"], [65048, 1, "\u3017"], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, "\u2014"], [65074, 1, "\u2013"], [[65075, 65076], 5, "_"], [65077, 5, "("], [65078, 5, ")"], [65079, 5, "{"], [65080, 5, "}"], [65081, 1, "\u3014"], [65082, 1, "\u3015"], [65083, 1, "\u3010"], [65084, 1, "\u3011"], [65085, 1, "\u300A"], [65086, 1, "\u300B"], [65087, 1, "\u3008"], [65088, 1, "\u3009"], [65089, 1, "\u300C"], [65090, 1, "\u300D"], [65091, 1, "\u300E"], [65092, 1, "\u300F"], [[65093, 65094], 2], [65095, 5, "["], [65096, 5, "]"], [[65097, 65100], 5, " \u0305"], [[65101, 65103], 5, "_"], [65104, 5, ","], [65105, 1, "\u3001"], [65106, 3], [65107, 3], [65108, 5, ";"], [65109, 5, ":"], [65110, 5, "?"], [65111, 5, "!"], [65112, 1, "\u2014"], [65113, 5, "("], [65114, 5, ")"], [65115, 5, "{"], [65116, 5, "}"], [65117, 1, "\u3014"], [65118, 1, "\u3015"], [65119, 5, "#"], [65120, 5, "&"], [65121, 5, "*"], [65122, 5, "+"], [65123, 1, "-"], [65124, 5, "<"], [65125, 5, ">"], [65126, 5, "="], [65127, 3], [65128, 5, "\\"], [65129, 5, "$"], [65130, 5, "%"], [65131, 5, "@"], [[65132, 65135], 3], [65136, 5, " \u064B"], [65137, 1, "\u0640\u064B"], [65138, 5, " \u064C"], [65139, 2], [65140, 5, " \u064D"], [65141, 3], [65142, 5, " \u064E"], [65143, 1, "\u0640\u064E"], [65144, 5, " \u064F"], [65145, 1, "\u0640\u064F"], [65146, 5, " \u0650"], [65147, 1, "\u0640\u0650"], [65148, 5, " \u0651"], [65149, 1, "\u0640\u0651"], [65150, 5, " \u0652"], [65151, 1, "\u0640\u0652"], [65152, 1, "\u0621"], [[65153, 65154], 1, "\u0622"], [[65155, 65156], 1, "\u0623"], [[65157, 65158], 1, "\u0624"], [[65159, 65160], 1, "\u0625"], [[65161, 65164], 1, "\u0626"], [[65165, 65166], 1, "\u0627"], [[65167, 65170], 1, "\u0628"], [[65171, 65172], 1, "\u0629"], [[65173, 65176], 1, "\u062A"], [[65177, 65180], 1, "\u062B"], [[65181, 65184], 1, "\u062C"], [[65185, 65188], 1, "\u062D"], [[65189, 65192], 1, "\u062E"], [[65193, 65194], 1, "\u062F"], [[65195, 65196], 1, "\u0630"], [[65197, 65198], 1, "\u0631"], [[65199, 65200], 1, "\u0632"], [[65201, 65204], 1, "\u0633"], [[65205, 65208], 1, "\u0634"], [[65209, 65212], 1, "\u0635"], [[65213, 65216], 1, "\u0636"], [[65217, 65220], 1, "\u0637"], [[65221, 65224], 1, "\u0638"], [[65225, 65228], 1, "\u0639"], [[65229, 65232], 1, "\u063A"], [[65233, 65236], 1, "\u0641"], [[65237, 65240], 1, "\u0642"], [[65241, 65244], 1, "\u0643"], [[65245, 65248], 1, "\u0644"], [[65249, 65252], 1, "\u0645"], [[65253, 65256], 1, "\u0646"], [[65257, 65260], 1, "\u0647"], [[65261, 65262], 1, "\u0648"], [[65263, 65264], 1, "\u0649"], [[65265, 65268], 1, "\u064A"], [[65269, 65270], 1, "\u0644\u0622"], [[65271, 65272], 1, "\u0644\u0623"], [[65273, 65274], 1, "\u0644\u0625"], [[65275, 65276], 1, "\u0644\u0627"], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 5, "!"], [65282, 5, '"'], [65283, 5, "#"], [65284, 5, "$"], [65285, 5, "%"], [65286, 5, "&"], [65287, 5, "'"], [65288, 5, "("], [65289, 5, ")"], [65290, 5, "*"], [65291, 5, "+"], [65292, 5, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 5, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 5, ":"], [65307, 5, ";"], [65308, 5, "<"], [65309, 5, "="], [65310, 5, ">"], [65311, 5, "?"], [65312, 5, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 5, "["], [65340, 5, "\\"], [65341, 5, "]"], [65342, 5, "^"], [65343, 5, "_"], [65344, 5, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 5, "{"], [65372, 5, "|"], [65373, 5, "}"], [65374, 5, "~"], [65375, 1, "\u2985"], [65376, 1, "\u2986"], [65377, 1, "."], [65378, 1, "\u300C"], [65379, 1, "\u300D"], [65380, 1, "\u3001"], [65381, 1, "\u30FB"], [65382, 1, "\u30F2"], [65383, 1, "\u30A1"], [65384, 1, "\u30A3"], [65385, 1, "\u30A5"], [65386, 1, "\u30A7"], [65387, 1, "\u30A9"], [65388, 1, "\u30E3"], [65389, 1, "\u30E5"], [65390, 1, "\u30E7"], [65391, 1, "\u30C3"], [65392, 1, "\u30FC"], [65393, 1, "\u30A2"], [65394, 1, "\u30A4"], [65395, 1, "\u30A6"], [65396, 1, "\u30A8"], [65397, 1, "\u30AA"], [65398, 1, "\u30AB"], [65399, 1, "\u30AD"], [65400, 1, "\u30AF"], [65401, 1, "\u30B1"], [65402, 1, "\u30B3"], [65403, 1, "\u30B5"], [65404, 1, "\u30B7"], [65405, 1, "\u30B9"], [65406, 1, "\u30BB"], [65407, 1, "\u30BD"], [65408, 1, "\u30BF"], [65409, 1, "\u30C1"], [65410, 1, "\u30C4"], [65411, 1, "\u30C6"], [65412, 1, "\u30C8"], [65413, 1, "\u30CA"], [65414, 1, "\u30CB"], [65415, 1, "\u30CC"], [65416, 1, "\u30CD"], [65417, 1, "\u30CE"], [65418, 1, "\u30CF"], [65419, 1, "\u30D2"], [65420, 1, "\u30D5"], [65421, 1, "\u30D8"], [65422, 1, "\u30DB"], [65423, 1, "\u30DE"], [65424, 1, "\u30DF"], [65425, 1, "\u30E0"], [65426, 1, "\u30E1"], [65427, 1, "\u30E2"], [65428, 1, "\u30E4"], [65429, 1, "\u30E6"], [65430, 1, "\u30E8"], [65431, 1, "\u30E9"], [65432, 1, "\u30EA"], [65433, 1, "\u30EB"], [65434, 1, "\u30EC"], [65435, 1, "\u30ED"], [65436, 1, "\u30EF"], [65437, 1, "\u30F3"], [65438, 1, "\u3099"], [65439, 1, "\u309A"], [65440, 3], [65441, 1, "\u1100"], [65442, 1, "\u1101"], [65443, 1, "\u11AA"], [65444, 1, "\u1102"], [65445, 1, "\u11AC"], [65446, 1, "\u11AD"], [65447, 1, "\u1103"], [65448, 1, "\u1104"], [65449, 1, "\u1105"], [65450, 1, "\u11B0"], [65451, 1, "\u11B1"], [65452, 1, "\u11B2"], [65453, 1, "\u11B3"], [65454, 1, "\u11B4"], [65455, 1, "\u11B5"], [65456, 1, "\u111A"], [65457, 1, "\u1106"], [65458, 1, "\u1107"], [65459, 1, "\u1108"], [65460, 1, "\u1121"], [65461, 1, "\u1109"], [65462, 1, "\u110A"], [65463, 1, "\u110B"], [65464, 1, "\u110C"], [65465, 1, "\u110D"], [65466, 1, "\u110E"], [65467, 1, "\u110F"], [65468, 1, "\u1110"], [65469, 1, "\u1111"], [65470, 1, "\u1112"], [[65471, 65473], 3], [65474, 1, "\u1161"], [65475, 1, "\u1162"], [65476, 1, "\u1163"], [65477, 1, "\u1164"], [65478, 1, "\u1165"], [65479, 1, "\u1166"], [[65480, 65481], 3], [65482, 1, "\u1167"], [65483, 1, "\u1168"], [65484, 1, "\u1169"], [65485, 1, "\u116A"], [65486, 1, "\u116B"], [65487, 1, "\u116C"], [[65488, 65489], 3], [65490, 1, "\u116D"], [65491, 1, "\u116E"], [65492, 1, "\u116F"], [65493, 1, "\u1170"], [65494, 1, "\u1171"], [65495, 1, "\u1172"], [[65496, 65497], 3], [65498, 1, "\u1173"], [65499, 1, "\u1174"], [65500, 1, "\u1175"], [[65501, 65503], 3], [65504, 1, "\xA2"], [65505, 1, "\xA3"], [65506, 1, "\xAC"], [65507, 5, " \u0304"], [65508, 1, "\xA6"], [65509, 1, "\xA5"], [65510, 1, "\u20A9"], [65511, 3], [65512, 1, "\u2502"], [65513, 1, "\u2190"], [65514, 1, "\u2191"], [65515, 1, "\u2192"], [65516, 1, "\u2193"], [65517, 1, "\u25A0"], [65518, 1, "\u25CB"], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66e3, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, "\u{10428}"], [66561, 1, "\u{10429}"], [66562, 1, "\u{1042A}"], [66563, 1, "\u{1042B}"], [66564, 1, "\u{1042C}"], [66565, 1, "\u{1042D}"], [66566, 1, "\u{1042E}"], [66567, 1, "\u{1042F}"], [66568, 1, "\u{10430}"], [66569, 1, "\u{10431}"], [66570, 1, "\u{10432}"], [66571, 1, "\u{10433}"], [66572, 1, "\u{10434}"], [66573, 1, "\u{10435}"], [66574, 1, "\u{10436}"], [66575, 1, "\u{10437}"], [66576, 1, "\u{10438}"], [66577, 1, "\u{10439}"], [66578, 1, "\u{1043A}"], [66579, 1, "\u{1043B}"], [66580, 1, "\u{1043C}"], [66581, 1, "\u{1043D}"], [66582, 1, "\u{1043E}"], [66583, 1, "\u{1043F}"], [66584, 1, "\u{10440}"], [66585, 1, "\u{10441}"], [66586, 1, "\u{10442}"], [66587, 1, "\u{10443}"], [66588, 1, "\u{10444}"], [66589, 1, "\u{10445}"], [66590, 1, "\u{10446}"], [66591, 1, "\u{10447}"], [66592, 1, "\u{10448}"], [66593, 1, "\u{10449}"], [66594, 1, "\u{1044A}"], [66595, 1, "\u{1044B}"], [66596, 1, "\u{1044C}"], [66597, 1, "\u{1044D}"], [66598, 1, "\u{1044E}"], [66599, 1, "\u{1044F}"], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, "\u{104D8}"], [66737, 1, "\u{104D9}"], [66738, 1, "\u{104DA}"], [66739, 1, "\u{104DB}"], [66740, 1, "\u{104DC}"], [66741, 1, "\u{104DD}"], [66742, 1, "\u{104DE}"], [66743, 1, "\u{104DF}"], [66744, 1, "\u{104E0}"], [66745, 1, "\u{104E1}"], [66746, 1, "\u{104E2}"], [66747, 1, "\u{104E3}"], [66748, 1, "\u{104E4}"], [66749, 1, "\u{104E5}"], [66750, 1, "\u{104E6}"], [66751, 1, "\u{104E7}"], [66752, 1, "\u{104E8}"], [66753, 1, "\u{104E9}"], [66754, 1, "\u{104EA}"], [66755, 1, "\u{104EB}"], [66756, 1, "\u{104EC}"], [66757, 1, "\u{104ED}"], [66758, 1, "\u{104EE}"], [66759, 1, "\u{104EF}"], [66760, 1, "\u{104F0}"], [66761, 1, "\u{104F1}"], [66762, 1, "\u{104F2}"], [66763, 1, "\u{104F3}"], [66764, 1, "\u{104F4}"], [66765, 1, "\u{104F5}"], [66766, 1, "\u{104F6}"], [66767, 1, "\u{104F7}"], [66768, 1, "\u{104F8}"], [66769, 1, "\u{104F9}"], [66770, 1, "\u{104FA}"], [66771, 1, "\u{104FB}"], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, "\u{10597}"], [66929, 1, "\u{10598}"], [66930, 1, "\u{10599}"], [66931, 1, "\u{1059A}"], [66932, 1, "\u{1059B}"], [66933, 1, "\u{1059C}"], [66934, 1, "\u{1059D}"], [66935, 1, "\u{1059E}"], [66936, 1, "\u{1059F}"], [66937, 1, "\u{105A0}"], [66938, 1, "\u{105A1}"], [66939, 3], [66940, 1, "\u{105A3}"], [66941, 1, "\u{105A4}"], [66942, 1, "\u{105A5}"], [66943, 1, "\u{105A6}"], [66944, 1, "\u{105A7}"], [66945, 1, "\u{105A8}"], [66946, 1, "\u{105A9}"], [66947, 1, "\u{105AA}"], [66948, 1, "\u{105AB}"], [66949, 1, "\u{105AC}"], [66950, 1, "\u{105AD}"], [66951, 1, "\u{105AE}"], [66952, 1, "\u{105AF}"], [66953, 1, "\u{105B0}"], [66954, 1, "\u{105B1}"], [66955, 3], [66956, 1, "\u{105B3}"], [66957, 1, "\u{105B4}"], [66958, 1, "\u{105B5}"], [66959, 1, "\u{105B6}"], [66960, 1, "\u{105B7}"], [66961, 1, "\u{105B8}"], [66962, 1, "\u{105B9}"], [66963, 3], [66964, 1, "\u{105BB}"], [66965, 1, "\u{105BC}"], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, "\u02D0"], [67458, 1, "\u02D1"], [67459, 1, "\xE6"], [67460, 1, "\u0299"], [67461, 1, "\u0253"], [67462, 3], [67463, 1, "\u02A3"], [67464, 1, "\uAB66"], [67465, 1, "\u02A5"], [67466, 1, "\u02A4"], [67467, 1, "\u0256"], [67468, 1, "\u0257"], [67469, 1, "\u1D91"], [67470, 1, "\u0258"], [67471, 1, "\u025E"], [67472, 1, "\u02A9"], [67473, 1, "\u0264"], [67474, 1, "\u0262"], [67475, 1, "\u0260"], [67476, 1, "\u029B"], [67477, 1, "\u0127"], [67478, 1, "\u029C"], [67479, 1, "\u0267"], [67480, 1, "\u0284"], [67481, 1, "\u02AA"], [67482, 1, "\u02AB"], [67483, 1, "\u026C"], [67484, 1, "\u{1DF04}"], [67485, 1, "\uA78E"], [67486, 1, "\u026E"], [67487, 1, "\u{1DF05}"], [67488, 1, "\u028E"], [67489, 1, "\u{1DF06}"], [67490, 1, "\xF8"], [67491, 1, "\u0276"], [67492, 1, "\u0277"], [67493, 1, "q"], [67494, 1, "\u027A"], [67495, 1, "\u{1DF08}"], [67496, 1, "\u027D"], [67497, 1, "\u027E"], [67498, 1, "\u0280"], [67499, 1, "\u02A8"], [67500, 1, "\u02A6"], [67501, 1, "\uAB67"], [67502, 1, "\u02A7"], [67503, 1, "\u0288"], [67504, 1, "\u2C71"], [67505, 3], [67506, 1, "\u028F"], [67507, 1, "\u02A1"], [67508, 1, "\u02A2"], [67509, 1, "\u0298"], [67510, 1, "\u01C0"], [67511, 1, "\u01C1"], [67512, 1, "\u01C2"], [67513, 1, "\u{1DF0A}"], [67514, 1, "\u{1DF1E}"], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, "\u{10CC0}"], [68737, 1, "\u{10CC1}"], [68738, 1, "\u{10CC2}"], [68739, 1, "\u{10CC3}"], [68740, 1, "\u{10CC4}"], [68741, 1, "\u{10CC5}"], [68742, 1, "\u{10CC6}"], [68743, 1, "\u{10CC7}"], [68744, 1, "\u{10CC8}"], [68745, 1, "\u{10CC9}"], [68746, 1, "\u{10CCA}"], [68747, 1, "\u{10CCB}"], [68748, 1, "\u{10CCC}"], [68749, 1, "\u{10CCD}"], [68750, 1, "\u{10CCE}"], [68751, 1, "\u{10CCF}"], [68752, 1, "\u{10CD0}"], [68753, 1, "\u{10CD1}"], [68754, 1, "\u{10CD2}"], [68755, 1, "\u{10CD3}"], [68756, 1, "\u{10CD4}"], [68757, 1, "\u{10CD5}"], [68758, 1, "\u{10CD6}"], [68759, 1, "\u{10CD7}"], [68760, 1, "\u{10CD8}"], [68761, 1, "\u{10CD9}"], [68762, 1, "\u{10CDA}"], [68763, 1, "\u{10CDB}"], [68764, 1, "\u{10CDC}"], [68765, 1, "\u{10CDD}"], [68766, 1, "\u{10CDE}"], [68767, 1, "\u{10CDF}"], [68768, 1, "\u{10CE0}"], [68769, 1, "\u{10CE1}"], [68770, 1, "\u{10CE2}"], [68771, 1, "\u{10CE3}"], [68772, 1, "\u{10CE4}"], [68773, 1, "\u{10CE5}"], [68774, 1, "\u{10CE6}"], [68775, 1, "\u{10CE7}"], [68776, 1, "\u{10CE8}"], [68777, 1, "\u{10CE9}"], [68778, 1, "\u{10CEA}"], [68779, 1, "\u{10CEB}"], [68780, 1, "\u{10CEC}"], [68781, 1, "\u{10CED}"], [68782, 1, "\u{10CEE}"], [68783, 1, "\u{10CEF}"], [68784, 1, "\u{10CF0}"], [68785, 1, "\u{10CF1}"], [68786, 1, "\u{10CF2}"], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69375], 3], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, "\u{118C0}"], [71841, 1, "\u{118C1}"], [71842, 1, "\u{118C2}"], [71843, 1, "\u{118C3}"], [71844, 1, "\u{118C4}"], [71845, 1, "\u{118C5}"], [71846, 1, "\u{118C6}"], [71847, 1, "\u{118C7}"], [71848, 1, "\u{118C8}"], [71849, 1, "\u{118C9}"], [71850, 1, "\u{118CA}"], [71851, 1, "\u{118CB}"], [71852, 1, "\u{118CC}"], [71853, 1, "\u{118CD}"], [71854, 1, "\u{118CE}"], [71855, 1, "\u{118CF}"], [71856, 1, "\u{118D0}"], [71857, 1, "\u{118D1}"], [71858, 1, "\u{118D2}"], [71859, 1, "\u{118D3}"], [71860, 1, "\u{118D4}"], [71861, 1, "\u{118D5}"], [71862, 1, "\u{118D6}"], [71863, 1, "\u{118D7}"], [71864, 1, "\u{118D8}"], [71865, 1, "\u{118D9}"], [71866, 1, "\u{118DA}"], [71867, 1, "\u{118DB}"], [71868, 1, "\u{118DC}"], [71869, 1, "\u{118DD}"], [71870, 1, "\u{118DE}"], [71871, 1, "\u{118DF}"], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 3], [[78896, 78904], 3], [[78905, 82943], 3], [[82944, 83526], 2], [[83527, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93759], 3], [93760, 1, "\u{16E60}"], [93761, 1, "\u{16E61}"], [93762, 1, "\u{16E62}"], [93763, 1, "\u{16E63}"], [93764, 1, "\u{16E64}"], [93765, 1, "\u{16E65}"], [93766, 1, "\u{16E66}"], [93767, 1, "\u{16E67}"], [93768, 1, "\u{16E68}"], [93769, 1, "\u{16E69}"], [93770, 1, "\u{16E6A}"], [93771, 1, "\u{16E6B}"], [93772, 1, "\u{16E6C}"], [93773, 1, "\u{16E6D}"], [93774, 1, "\u{16E6E}"], [93775, 1, "\u{16E6F}"], [93776, 1, "\u{16E70}"], [93777, 1, "\u{16E71}"], [93778, 1, "\u{16E72}"], [93779, 1, "\u{16E73}"], [93780, 1, "\u{16E74}"], [93781, 1, "\u{16E75}"], [93782, 1, "\u{16E76}"], [93783, 1, "\u{16E77}"], [93784, 1, "\u{16E78}"], [93785, 1, "\u{16E79}"], [93786, 1, "\u{16E7A}"], [93787, 1, "\u{16E7B}"], [93788, 1, "\u{16E7C}"], [93789, 1, "\u{16E7D}"], [93790, 1, "\u{16E7E}"], [93791, 1, "\u{16E7F}"], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101631], 3], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110927], 3], [[110928, 110930], 2], [[110931, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, "\u{1D157}\u{1D165}"], [119135, 1, "\u{1D158}\u{1D165}"], [119136, 1, "\u{1D158}\u{1D165}\u{1D16E}"], [119137, 1, "\u{1D158}\u{1D165}\u{1D16F}"], [119138, 1, "\u{1D158}\u{1D165}\u{1D170}"], [119139, 1, "\u{1D158}\u{1D165}\u{1D171}"], [119140, 1, "\u{1D158}\u{1D165}\u{1D172}"], [[119141, 119154], 2], [[119155, 119162], 3], [[119163, 119226], 2], [119227, 1, "\u{1D1B9}\u{1D165}"], [119228, 1, "\u{1D1BA}\u{1D165}"], [119229, 1, "\u{1D1B9}\u{1D165}\u{1D16E}"], [119230, 1, "\u{1D1BA}\u{1D165}\u{1D16E}"], [119231, 1, "\u{1D1B9}\u{1D165}\u{1D16F}"], [119232, 1, "\u{1D1BA}\u{1D165}\u{1D16F}"], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [12e4, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, "\u0131"], [120485, 1, "\u0237"], [[120486, 120487], 3], [120488, 1, "\u03B1"], [120489, 1, "\u03B2"], [120490, 1, "\u03B3"], [120491, 1, "\u03B4"], [120492, 1, "\u03B5"], [120493, 1, "\u03B6"], [120494, 1, "\u03B7"], [120495, 1, "\u03B8"], [120496, 1, "\u03B9"], [120497, 1, "\u03BA"], [120498, 1, "\u03BB"], [120499, 1, "\u03BC"], [120500, 1, "\u03BD"], [120501, 1, "\u03BE"], [120502, 1, "\u03BF"], [120503, 1, "\u03C0"], [120504, 1, "\u03C1"], [120505, 1, "\u03B8"], [120506, 1, "\u03C3"], [120507, 1, "\u03C4"], [120508, 1, "\u03C5"], [120509, 1, "\u03C6"], [120510, 1, "\u03C7"], [120511, 1, "\u03C8"], [120512, 1, "\u03C9"], [120513, 1, "\u2207"], [120514, 1, "\u03B1"], [120515, 1, "\u03B2"], [120516, 1, "\u03B3"], [120517, 1, "\u03B4"], [120518, 1, "\u03B5"], [120519, 1, "\u03B6"], [120520, 1, "\u03B7"], [120521, 1, "\u03B8"], [120522, 1, "\u03B9"], [120523, 1, "\u03BA"], [120524, 1, "\u03BB"], [120525, 1, "\u03BC"], [120526, 1, "\u03BD"], [120527, 1, "\u03BE"], [120528, 1, "\u03BF"], [120529, 1, "\u03C0"], [120530, 1, "\u03C1"], [[120531, 120532], 1, "\u03C3"], [120533, 1, "\u03C4"], [120534, 1, "\u03C5"], [120535, 1, "\u03C6"], [120536, 1, "\u03C7"], [120537, 1, "\u03C8"], [120538, 1, "\u03C9"], [120539, 1, "\u2202"], [120540, 1, "\u03B5"], [120541, 1, "\u03B8"], [120542, 1, "\u03BA"], [120543, 1, "\u03C6"], [120544, 1, "\u03C1"], [120545, 1, "\u03C0"], [120546, 1, "\u03B1"], [120547, 1, "\u03B2"], [120548, 1, "\u03B3"], [120549, 1, "\u03B4"], [120550, 1, "\u03B5"], [120551, 1, "\u03B6"], [120552, 1, "\u03B7"], [120553, 1, "\u03B8"], [120554, 1, "\u03B9"], [120555, 1, "\u03BA"], [120556, 1, "\u03BB"], [120557, 1, "\u03BC"], [120558, 1, "\u03BD"], [120559, 1, "\u03BE"], [120560, 1, "\u03BF"], [120561, 1, "\u03C0"], [120562, 1, "\u03C1"], [120563, 1, "\u03B8"], [120564, 1, "\u03C3"], [120565, 1, "\u03C4"], [120566, 1, "\u03C5"], [120567, 1, "\u03C6"], [120568, 1, "\u03C7"], [120569, 1, "\u03C8"], [120570, 1, "\u03C9"], [120571, 1, "\u2207"], [120572, 1, "\u03B1"], [120573, 1, "\u03B2"], [120574, 1, "\u03B3"], [120575, 1, "\u03B4"], [120576, 1, "\u03B5"], [120577, 1, "\u03B6"], [120578, 1, "\u03B7"], [120579, 1, "\u03B8"], [120580, 1, "\u03B9"], [120581, 1, "\u03BA"], [120582, 1, "\u03BB"], [120583, 1, "\u03BC"], [120584, 1, "\u03BD"], [120585, 1, "\u03BE"], [120586, 1, "\u03BF"], [120587, 1, "\u03C0"], [120588, 1, "\u03C1"], [[120589, 120590], 1, "\u03C3"], [120591, 1, "\u03C4"], [120592, 1, "\u03C5"], [120593, 1, "\u03C6"], [120594, 1, "\u03C7"], [120595, 1, "\u03C8"], [120596, 1, "\u03C9"], [120597, 1, "\u2202"], [120598, 1, "\u03B5"], [120599, 1, "\u03B8"], [120600, 1, "\u03BA"], [120601, 1, "\u03C6"], [120602, 1, "\u03C1"], [120603, 1, "\u03C0"], [120604, 1, "\u03B1"], [120605, 1, "\u03B2"], [120606, 1, "\u03B3"], [120607, 1, "\u03B4"], [120608, 1, "\u03B5"], [120609, 1, "\u03B6"], [120610, 1, "\u03B7"], [120611, 1, "\u03B8"], [120612, 1, "\u03B9"], [120613, 1, "\u03BA"], [120614, 1, "\u03BB"], [120615, 1, "\u03BC"], [120616, 1, "\u03BD"], [120617, 1, "\u03BE"], [120618, 1, "\u03BF"], [120619, 1, "\u03C0"], [120620, 1, "\u03C1"], [120621, 1, "\u03B8"], [120622, 1, "\u03C3"], [120623, 1, "\u03C4"], [120624, 1, "\u03C5"], [120625, 1, "\u03C6"], [120626, 1, "\u03C7"], [120627, 1, "\u03C8"], [120628, 1, "\u03C9"], [120629, 1, "\u2207"], [120630, 1, "\u03B1"], [120631, 1, "\u03B2"], [120632, 1, "\u03B3"], [120633, 1, "\u03B4"], [120634, 1, "\u03B5"], [120635, 1, "\u03B6"], [120636, 1, "\u03B7"], [120637, 1, "\u03B8"], [120638, 1, "\u03B9"], [120639, 1, "\u03BA"], [120640, 1, "\u03BB"], [120641, 1, "\u03BC"], [120642, 1, "\u03BD"], [120643, 1, "\u03BE"], [120644, 1, "\u03BF"], [120645, 1, "\u03C0"], [120646, 1, "\u03C1"], [[120647, 120648], 1, "\u03C3"], [120649, 1, "\u03C4"], [120650, 1, "\u03C5"], [120651, 1, "\u03C6"], [120652, 1, "\u03C7"], [120653, 1, "\u03C8"], [120654, 1, "\u03C9"], [120655, 1, "\u2202"], [120656, 1, "\u03B5"], [120657, 1, "\u03B8"], [120658, 1, "\u03BA"], [120659, 1, "\u03C6"], [120660, 1, "\u03C1"], [120661, 1, "\u03C0"], [120662, 1, "\u03B1"], [120663, 1, "\u03B2"], [120664, 1, "\u03B3"], [120665, 1, "\u03B4"], [120666, 1, "\u03B5"], [120667, 1, "\u03B6"], [120668, 1, "\u03B7"], [120669, 1, "\u03B8"], [120670, 1, "\u03B9"], [120671, 1, "\u03BA"], [120672, 1, "\u03BB"], [120673, 1, "\u03BC"], [120674, 1, "\u03BD"], [120675, 1, "\u03BE"], [120676, 1, "\u03BF"], [120677, 1, "\u03C0"], [120678, 1, "\u03C1"], [120679, 1, "\u03B8"], [120680, 1, "\u03C3"], [120681, 1, "\u03C4"], [120682, 1, "\u03C5"], [120683, 1, "\u03C6"], [120684, 1, "\u03C7"], [120685, 1, "\u03C8"], [120686, 1, "\u03C9"], [120687, 1, "\u2207"], [120688, 1, "\u03B1"], [120689, 1, "\u03B2"], [120690, 1, "\u03B3"], [120691, 1, "\u03B4"], [120692, 1, "\u03B5"], [120693, 1, "\u03B6"], [120694, 1, "\u03B7"], [120695, 1, "\u03B8"], [120696, 1, "\u03B9"], [120697, 1, "\u03BA"], [120698, 1, "\u03BB"], [120699, 1, "\u03BC"], [120700, 1, "\u03BD"], [120701, 1, "\u03BE"], [120702, 1, "\u03BF"], [120703, 1, "\u03C0"], [120704, 1, "\u03C1"], [[120705, 120706], 1, "\u03C3"], [120707, 1, "\u03C4"], [120708, 1, "\u03C5"], [120709, 1, "\u03C6"], [120710, 1, "\u03C7"], [120711, 1, "\u03C8"], [120712, 1, "\u03C9"], [120713, 1, "\u2202"], [120714, 1, "\u03B5"], [120715, 1, "\u03B8"], [120716, 1, "\u03BA"], [120717, 1, "\u03C6"], [120718, 1, "\u03C1"], [120719, 1, "\u03C0"], [120720, 1, "\u03B1"], [120721, 1, "\u03B2"], [120722, 1, "\u03B3"], [120723, 1, "\u03B4"], [120724, 1, "\u03B5"], [120725, 1, "\u03B6"], [120726, 1, "\u03B7"], [120727, 1, "\u03B8"], [120728, 1, "\u03B9"], [120729, 1, "\u03BA"], [120730, 1, "\u03BB"], [120731, 1, "\u03BC"], [120732, 1, "\u03BD"], [120733, 1, "\u03BE"], [120734, 1, "\u03BF"], [120735, 1, "\u03C0"], [120736, 1, "\u03C1"], [120737, 1, "\u03B8"], [120738, 1, "\u03C3"], [120739, 1, "\u03C4"], [120740, 1, "\u03C5"], [120741, 1, "\u03C6"], [120742, 1, "\u03C7"], [120743, 1, "\u03C8"], [120744, 1, "\u03C9"], [120745, 1, "\u2207"], [120746, 1, "\u03B1"], [120747, 1, "\u03B2"], [120748, 1, "\u03B3"], [120749, 1, "\u03B4"], [120750, 1, "\u03B5"], [120751, 1, "\u03B6"], [120752, 1, "\u03B7"], [120753, 1, "\u03B8"], [120754, 1, "\u03B9"], [120755, 1, "\u03BA"], [120756, 1, "\u03BB"], [120757, 1, "\u03BC"], [120758, 1, "\u03BD"], [120759, 1, "\u03BE"], [120760, 1, "\u03BF"], [120761, 1, "\u03C0"], [120762, 1, "\u03C1"], [[120763, 120764], 1, "\u03C3"], [120765, 1, "\u03C4"], [120766, 1, "\u03C5"], [120767, 1, "\u03C6"], [120768, 1, "\u03C7"], [120769, 1, "\u03C8"], [120770, 1, "\u03C9"], [120771, 1, "\u2202"], [120772, 1, "\u03B5"], [120773, 1, "\u03B8"], [120774, 1, "\u03BA"], [120775, 1, "\u03C6"], [120776, 1, "\u03C1"], [120777, 1, "\u03C0"], [[120778, 120779], 1, "\u03DD"], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, "\u{1E922}"], [125185, 1, "\u{1E923}"], [125186, 1, "\u{1E924}"], [125187, 1, "\u{1E925}"], [125188, 1, "\u{1E926}"], [125189, 1, "\u{1E927}"], [125190, 1, "\u{1E928}"], [125191, 1, "\u{1E929}"], [125192, 1, "\u{1E92A}"], [125193, 1, "\u{1E92B}"], [125194, 1, "\u{1E92C}"], [125195, 1, "\u{1E92D}"], [125196, 1, "\u{1E92E}"], [125197, 1, "\u{1E92F}"], [125198, 1, "\u{1E930}"], [125199, 1, "\u{1E931}"], [125200, 1, "\u{1E932}"], [125201, 1, "\u{1E933}"], [125202, 1, "\u{1E934}"], [125203, 1, "\u{1E935}"], [125204, 1, "\u{1E936}"], [125205, 1, "\u{1E937}"], [125206, 1, "\u{1E938}"], [125207, 1, "\u{1E939}"], [125208, 1, "\u{1E93A}"], [125209, 1, "\u{1E93B}"], [125210, 1, "\u{1E93C}"], [125211, 1, "\u{1E93D}"], [125212, 1, "\u{1E93E}"], [125213, 1, "\u{1E93F}"], [125214, 1, "\u{1E940}"], [125215, 1, "\u{1E941}"], [125216, 1, "\u{1E942}"], [125217, 1, "\u{1E943}"], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, "\u0627"], [126465, 1, "\u0628"], [126466, 1, "\u062C"], [126467, 1, "\u062F"], [126468, 3], [126469, 1, "\u0648"], [126470, 1, "\u0632"], [126471, 1, "\u062D"], [126472, 1, "\u0637"], [126473, 1, "\u064A"], [126474, 1, "\u0643"], [126475, 1, "\u0644"], [126476, 1, "\u0645"], [126477, 1, "\u0646"], [126478, 1, "\u0633"], [126479, 1, "\u0639"], [126480, 1, "\u0641"], [126481, 1, "\u0635"], [126482, 1, "\u0642"], [126483, 1, "\u0631"], [126484, 1, "\u0634"], [126485, 1, "\u062A"], [126486, 1, "\u062B"], [126487, 1, "\u062E"], [126488, 1, "\u0630"], [126489, 1, "\u0636"], [126490, 1, "\u0638"], [126491, 1, "\u063A"], [126492, 1, "\u066E"], [126493, 1, "\u06BA"], [126494, 1, "\u06A1"], [126495, 1, "\u066F"], [126496, 3], [126497, 1, "\u0628"], [126498, 1, "\u062C"], [126499, 3], [126500, 1, "\u0647"], [[126501, 126502], 3], [126503, 1, "\u062D"], [126504, 3], [126505, 1, "\u064A"], [126506, 1, "\u0643"], [126507, 1, "\u0644"], [126508, 1, "\u0645"], [126509, 1, "\u0646"], [126510, 1, "\u0633"], [126511, 1, "\u0639"], [126512, 1, "\u0641"], [126513, 1, "\u0635"], [126514, 1, "\u0642"], [126515, 3], [126516, 1, "\u0634"], [126517, 1, "\u062A"], [126518, 1, "\u062B"], [126519, 1, "\u062E"], [126520, 3], [126521, 1, "\u0636"], [126522, 3], [126523, 1, "\u063A"], [[126524, 126529], 3], [126530, 1, "\u062C"], [[126531, 126534], 3], [126535, 1, "\u062D"], [126536, 3], [126537, 1, "\u064A"], [126538, 3], [126539, 1, "\u0644"], [126540, 3], [126541, 1, "\u0646"], [126542, 1, "\u0633"], [126543, 1, "\u0639"], [126544, 3], [126545, 1, "\u0635"], [126546, 1, "\u0642"], [126547, 3], [126548, 1, "\u0634"], [[126549, 126550], 3], [126551, 1, "\u062E"], [126552, 3], [126553, 1, "\u0636"], [126554, 3], [126555, 1, "\u063A"], [126556, 3], [126557, 1, "\u06BA"], [126558, 3], [126559, 1, "\u066F"], [126560, 3], [126561, 1, "\u0628"], [126562, 1, "\u062C"], [126563, 3], [126564, 1, "\u0647"], [[126565, 126566], 3], [126567, 1, "\u062D"], [126568, 1, "\u0637"], [126569, 1, "\u064A"], [126570, 1, "\u0643"], [126571, 3], [126572, 1, "\u0645"], [126573, 1, "\u0646"], [126574, 1, "\u0633"], [126575, 1, "\u0639"], [126576, 1, "\u0641"], [126577, 1, "\u0635"], [126578, 1, "\u0642"], [126579, 3], [126580, 1, "\u0634"], [126581, 1, "\u062A"], [126582, 1, "\u062B"], [126583, 1, "\u062E"], [126584, 3], [126585, 1, "\u0636"], [126586, 1, "\u0638"], [126587, 1, "\u063A"], [126588, 1, "\u066E"], [126589, 3], [126590, 1, "\u06A1"], [126591, 3], [126592, 1, "\u0627"], [126593, 1, "\u0628"], [126594, 1, "\u062C"], [126595, 1, "\u062F"], [126596, 1, "\u0647"], [126597, 1, "\u0648"], [126598, 1, "\u0632"], [126599, 1, "\u062D"], [126600, 1, "\u0637"], [126601, 1, "\u064A"], [126602, 3], [126603, 1, "\u0644"], [126604, 1, "\u0645"], [126605, 1, "\u0646"], [126606, 1, "\u0633"], [126607, 1, "\u0639"], [126608, 1, "\u0641"], [126609, 1, "\u0635"], [126610, 1, "\u0642"], [126611, 1, "\u0631"], [126612, 1, "\u0634"], [126613, 1, "\u062A"], [126614, 1, "\u062B"], [126615, 1, "\u062E"], [126616, 1, "\u0630"], [126617, 1, "\u0636"], [126618, 1, "\u0638"], [126619, 1, "\u063A"], [[126620, 126624], 3], [126625, 1, "\u0628"], [126626, 1, "\u062C"], [126627, 1, "\u062F"], [126628, 3], [126629, 1, "\u0648"], [126630, 1, "\u0632"], [126631, 1, "\u062D"], [126632, 1, "\u0637"], [126633, 1, "\u064A"], [126634, 3], [126635, 1, "\u0644"], [126636, 1, "\u0645"], [126637, 1, "\u0646"], [126638, 1, "\u0633"], [126639, 1, "\u0639"], [126640, 1, "\u0641"], [126641, 1, "\u0635"], [126642, 1, "\u0642"], [126643, 1, "\u0631"], [126644, 1, "\u0634"], [126645, 1, "\u062A"], [126646, 1, "\u062B"], [126647, 1, "\u062E"], [126648, 1, "\u0630"], [126649, 1, "\u0636"], [126650, 1, "\u0638"], [126651, 1, "\u063A"], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 5, "0,"], [127234, 5, "1,"], [127235, 5, "2,"], [127236, 5, "3,"], [127237, 5, "4,"], [127238, 5, "5,"], [127239, 5, "6,"], [127240, 5, "7,"], [127241, 5, "8,"], [127242, 5, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 5, "(a)"], [127249, 5, "(b)"], [127250, 5, "(c)"], [127251, 5, "(d)"], [127252, 5, "(e)"], [127253, 5, "(f)"], [127254, 5, "(g)"], [127255, 5, "(h)"], [127256, 5, "(i)"], [127257, 5, "(j)"], [127258, 5, "(k)"], [127259, 5, "(l)"], [127260, 5, "(m)"], [127261, 5, "(n)"], [127262, 5, "(o)"], [127263, 5, "(p)"], [127264, 5, "(q)"], [127265, 5, "(r)"], [127266, 5, "(s)"], [127267, 5, "(t)"], [127268, 5, "(u)"], [127269, 5, "(v)"], [127270, 5, "(w)"], [127271, 5, "(x)"], [127272, 5, "(y)"], [127273, 5, "(z)"], [127274, 1, "\u3014s\u3015"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, "\u307B\u304B"], [127489, 1, "\u30B3\u30B3"], [127490, 1, "\u30B5"], [[127491, 127503], 3], [127504, 1, "\u624B"], [127505, 1, "\u5B57"], [127506, 1, "\u53CC"], [127507, 1, "\u30C7"], [127508, 1, "\u4E8C"], [127509, 1, "\u591A"], [127510, 1, "\u89E3"], [127511, 1, "\u5929"], [127512, 1, "\u4EA4"], [127513, 1, "\u6620"], [127514, 1, "\u7121"], [127515, 1, "\u6599"], [127516, 1, "\u524D"], [127517, 1, "\u5F8C"], [127518, 1, "\u518D"], [127519, 1, "\u65B0"], [127520, 1, "\u521D"], [127521, 1, "\u7D42"], [127522, 1, "\u751F"], [127523, 1, "\u8CA9"], [127524, 1, "\u58F0"], [127525, 1, "\u5439"], [127526, 1, "\u6F14"], [127527, 1, "\u6295"], [127528, 1, "\u6355"], [127529, 1, "\u4E00"], [127530, 1, "\u4E09"], [127531, 1, "\u904A"], [127532, 1, "\u5DE6"], [127533, 1, "\u4E2D"], [127534, 1, "\u53F3"], [127535, 1, "\u6307"], [127536, 1, "\u8D70"], [127537, 1, "\u6253"], [127538, 1, "\u7981"], [127539, 1, "\u7A7A"], [127540, 1, "\u5408"], [127541, 1, "\u6E80"], [127542, 1, "\u6709"], [127543, 1, "\u6708"], [127544, 1, "\u7533"], [127545, 1, "\u5272"], [127546, 1, "\u55B6"], [127547, 1, "\u914D"], [[127548, 127551], 3], [127552, 1, "\u3014\u672C\u3015"], [127553, 1, "\u3014\u4E09\u3015"], [127554, 1, "\u3014\u4E8C\u3015"], [127555, 1, "\u3014\u5B89\u3015"], [127556, 1, "\u3014\u70B9\u3015"], [127557, 1, "\u3014\u6253\u3015"], [127558, 1, "\u3014\u76D7\u3015"], [127559, 1, "\u3014\u52DD\u3015"], [127560, 1, "\u3014\u6557\u3015"], [[127561, 127567], 3], [127568, 1, "\u5F97"], [127569, 1, "\u53EF"], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128e3, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128732], 3], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128895], 3], [[128896, 128980], 2], [[128981, 128984], 2], [[128985, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 3], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129679], 3], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 3], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129727], 3], [[129728, 129730], 2], [[129731, 129733], 2], [[129734, 129743], 3], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129759], 3], [[129760, 129767], 2], [[129768, 129775], 3], [[129776, 129782], 2], [[129783, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 3], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [[177977, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 194559], 3], [194560, 1, "\u4E3D"], [194561, 1, "\u4E38"], [194562, 1, "\u4E41"], [194563, 1, "\u{20122}"], [194564, 1, "\u4F60"], [194565, 1, "\u4FAE"], [194566, 1, "\u4FBB"], [194567, 1, "\u5002"], [194568, 1, "\u507A"], [194569, 1, "\u5099"], [194570, 1, "\u50E7"], [194571, 1, "\u50CF"], [194572, 1, "\u349E"], [194573, 1, "\u{2063A}"], [194574, 1, "\u514D"], [194575, 1, "\u5154"], [194576, 1, "\u5164"], [194577, 1, "\u5177"], [194578, 1, "\u{2051C}"], [194579, 1, "\u34B9"], [194580, 1, "\u5167"], [194581, 1, "\u518D"], [194582, 1, "\u{2054B}"], [194583, 1, "\u5197"], [194584, 1, "\u51A4"], [194585, 1, "\u4ECC"], [194586, 1, "\u51AC"], [194587, 1, "\u51B5"], [194588, 1, "\u{291DF}"], [194589, 1, "\u51F5"], [194590, 1, "\u5203"], [194591, 1, "\u34DF"], [194592, 1, "\u523B"], [194593, 1, "\u5246"], [194594, 1, "\u5272"], [194595, 1, "\u5277"], [194596, 1, "\u3515"], [194597, 1, "\u52C7"], [194598, 1, "\u52C9"], [194599, 1, "\u52E4"], [194600, 1, "\u52FA"], [194601, 1, "\u5305"], [194602, 1, "\u5306"], [194603, 1, "\u5317"], [194604, 1, "\u5349"], [194605, 1, "\u5351"], [194606, 1, "\u535A"], [194607, 1, "\u5373"], [194608, 1, "\u537D"], [[194609, 194611], 1, "\u537F"], [194612, 1, "\u{20A2C}"], [194613, 1, "\u7070"], [194614, 1, "\u53CA"], [194615, 1, "\u53DF"], [194616, 1, "\u{20B63}"], [194617, 1, "\u53EB"], [194618, 1, "\u53F1"], [194619, 1, "\u5406"], [194620, 1, "\u549E"], [194621, 1, "\u5438"], [194622, 1, "\u5448"], [194623, 1, "\u5468"], [194624, 1, "\u54A2"], [194625, 1, "\u54F6"], [194626, 1, "\u5510"], [194627, 1, "\u5553"], [194628, 1, "\u5563"], [[194629, 194630], 1, "\u5584"], [194631, 1, "\u5599"], [194632, 1, "\u55AB"], [194633, 1, "\u55B3"], [194634, 1, "\u55C2"], [194635, 1, "\u5716"], [194636, 1, "\u5606"], [194637, 1, "\u5717"], [194638, 1, "\u5651"], [194639, 1, "\u5674"], [194640, 1, "\u5207"], [194641, 1, "\u58EE"], [194642, 1, "\u57CE"], [194643, 1, "\u57F4"], [194644, 1, "\u580D"], [194645, 1, "\u578B"], [194646, 1, "\u5832"], [194647, 1, "\u5831"], [194648, 1, "\u58AC"], [194649, 1, "\u{214E4}"], [194650, 1, "\u58F2"], [194651, 1, "\u58F7"], [194652, 1, "\u5906"], [194653, 1, "\u591A"], [194654, 1, "\u5922"], [194655, 1, "\u5962"], [194656, 1, "\u{216A8}"], [194657, 1, "\u{216EA}"], [194658, 1, "\u59EC"], [194659, 1, "\u5A1B"], [194660, 1, "\u5A27"], [194661, 1, "\u59D8"], [194662, 1, "\u5A66"], [194663, 1, "\u36EE"], [194664, 3], [194665, 1, "\u5B08"], [[194666, 194667], 1, "\u5B3E"], [194668, 1, "\u{219C8}"], [194669, 1, "\u5BC3"], [194670, 1, "\u5BD8"], [194671, 1, "\u5BE7"], [194672, 1, "\u5BF3"], [194673, 1, "\u{21B18}"], [194674, 1, "\u5BFF"], [194675, 1, "\u5C06"], [194676, 3], [194677, 1, "\u5C22"], [194678, 1, "\u3781"], [194679, 1, "\u5C60"], [194680, 1, "\u5C6E"], [194681, 1, "\u5CC0"], [194682, 1, "\u5C8D"], [194683, 1, "\u{21DE4}"], [194684, 1, "\u5D43"], [194685, 1, "\u{21DE6}"], [194686, 1, "\u5D6E"], [194687, 1, "\u5D6B"], [194688, 1, "\u5D7C"], [194689, 1, "\u5DE1"], [194690, 1, "\u5DE2"], [194691, 1, "\u382F"], [194692, 1, "\u5DFD"], [194693, 1, "\u5E28"], [194694, 1, "\u5E3D"], [194695, 1, "\u5E69"], [194696, 1, "\u3862"], [194697, 1, "\u{22183}"], [194698, 1, "\u387C"], [194699, 1, "\u5EB0"], [194700, 1, "\u5EB3"], [194701, 1, "\u5EB6"], [194702, 1, "\u5ECA"], [194703, 1, "\u{2A392}"], [194704, 1, "\u5EFE"], [[194705, 194706], 1, "\u{22331}"], [194707, 1, "\u8201"], [[194708, 194709], 1, "\u5F22"], [194710, 1, "\u38C7"], [194711, 1, "\u{232B8}"], [194712, 1, "\u{261DA}"], [194713, 1, "\u5F62"], [194714, 1, "\u5F6B"], [194715, 1, "\u38E3"], [194716, 1, "\u5F9A"], [194717, 1, "\u5FCD"], [194718, 1, "\u5FD7"], [194719, 1, "\u5FF9"], [194720, 1, "\u6081"], [194721, 1, "\u393A"], [194722, 1, "\u391C"], [194723, 1, "\u6094"], [194724, 1, "\u{226D4}"], [194725, 1, "\u60C7"], [194726, 1, "\u6148"], [194727, 1, "\u614C"], [194728, 1, "\u614E"], [194729, 1, "\u614C"], [194730, 1, "\u617A"], [194731, 1, "\u618E"], [194732, 1, "\u61B2"], [194733, 1, "\u61A4"], [194734, 1, "\u61AF"], [194735, 1, "\u61DE"], [194736, 1, "\u61F2"], [194737, 1, "\u61F6"], [194738, 1, "\u6210"], [194739, 1, "\u621B"], [194740, 1, "\u625D"], [194741, 1, "\u62B1"], [194742, 1, "\u62D4"], [194743, 1, "\u6350"], [194744, 1, "\u{22B0C}"], [194745, 1, "\u633D"], [194746, 1, "\u62FC"], [194747, 1, "\u6368"], [194748, 1, "\u6383"], [194749, 1, "\u63E4"], [194750, 1, "\u{22BF1}"], [194751, 1, "\u6422"], [194752, 1, "\u63C5"], [194753, 1, "\u63A9"], [194754, 1, "\u3A2E"], [194755, 1, "\u6469"], [194756, 1, "\u647E"], [194757, 1, "\u649D"], [194758, 1, "\u6477"], [194759, 1, "\u3A6C"], [194760, 1, "\u654F"], [194761, 1, "\u656C"], [194762, 1, "\u{2300A}"], [194763, 1, "\u65E3"], [194764, 1, "\u66F8"], [194765, 1, "\u6649"], [194766, 1, "\u3B19"], [194767, 1, "\u6691"], [194768, 1, "\u3B08"], [194769, 1, "\u3AE4"], [194770, 1, "\u5192"], [194771, 1, "\u5195"], [194772, 1, "\u6700"], [194773, 1, "\u669C"], [194774, 1, "\u80AD"], [194775, 1, "\u43D9"], [194776, 1, "\u6717"], [194777, 1, "\u671B"], [194778, 1, "\u6721"], [194779, 1, "\u675E"], [194780, 1, "\u6753"], [194781, 1, "\u{233C3}"], [194782, 1, "\u3B49"], [194783, 1, "\u67FA"], [194784, 1, "\u6785"], [194785, 1, "\u6852"], [194786, 1, "\u6885"], [194787, 1, "\u{2346D}"], [194788, 1, "\u688E"], [194789, 1, "\u681F"], [194790, 1, "\u6914"], [194791, 1, "\u3B9D"], [194792, 1, "\u6942"], [194793, 1, "\u69A3"], [194794, 1, "\u69EA"], [194795, 1, "\u6AA8"], [194796, 1, "\u{236A3}"], [194797, 1, "\u6ADB"], [194798, 1, "\u3C18"], [194799, 1, "\u6B21"], [194800, 1, "\u{238A7}"], [194801, 1, "\u6B54"], [194802, 1, "\u3C4E"], [194803, 1, "\u6B72"], [194804, 1, "\u6B9F"], [194805, 1, "\u6BBA"], [194806, 1, "\u6BBB"], [194807, 1, "\u{23A8D}"], [194808, 1, "\u{21D0B}"], [194809, 1, "\u{23AFA}"], [194810, 1, "\u6C4E"], [194811, 1, "\u{23CBC}"], [194812, 1, "\u6CBF"], [194813, 1, "\u6CCD"], [194814, 1, "\u6C67"], [194815, 1, "\u6D16"], [194816, 1, "\u6D3E"], [194817, 1, "\u6D77"], [194818, 1, "\u6D41"], [194819, 1, "\u6D69"], [194820, 1, "\u6D78"], [194821, 1, "\u6D85"], [194822, 1, "\u{23D1E}"], [194823, 1, "\u6D34"], [194824, 1, "\u6E2F"], [194825, 1, "\u6E6E"], [194826, 1, "\u3D33"], [194827, 1, "\u6ECB"], [194828, 1, "\u6EC7"], [194829, 1, "\u{23ED1}"], [194830, 1, "\u6DF9"], [194831, 1, "\u6F6E"], [194832, 1, "\u{23F5E}"], [194833, 1, "\u{23F8E}"], [194834, 1, "\u6FC6"], [194835, 1, "\u7039"], [194836, 1, "\u701E"], [194837, 1, "\u701B"], [194838, 1, "\u3D96"], [194839, 1, "\u704A"], [194840, 1, "\u707D"], [194841, 1, "\u7077"], [194842, 1, "\u70AD"], [194843, 1, "\u{20525}"], [194844, 1, "\u7145"], [194845, 1, "\u{24263}"], [194846, 1, "\u719C"], [194847, 3], [194848, 1, "\u7228"], [194849, 1, "\u7235"], [194850, 1, "\u7250"], [194851, 1, "\u{24608}"], [194852, 1, "\u7280"], [194853, 1, "\u7295"], [194854, 1, "\u{24735}"], [194855, 1, "\u{24814}"], [194856, 1, "\u737A"], [194857, 1, "\u738B"], [194858, 1, "\u3EAC"], [194859, 1, "\u73A5"], [[194860, 194861], 1, "\u3EB8"], [194862, 1, "\u7447"], [194863, 1, "\u745C"], [194864, 1, "\u7471"], [194865, 1, "\u7485"], [194866, 1, "\u74CA"], [194867, 1, "\u3F1B"], [194868, 1, "\u7524"], [194869, 1, "\u{24C36}"], [194870, 1, "\u753E"], [194871, 1, "\u{24C92}"], [194872, 1, "\u7570"], [194873, 1, "\u{2219F}"], [194874, 1, "\u7610"], [194875, 1, "\u{24FA1}"], [194876, 1, "\u{24FB8}"], [194877, 1, "\u{25044}"], [194878, 1, "\u3FFC"], [194879, 1, "\u4008"], [194880, 1, "\u76F4"], [194881, 1, "\u{250F3}"], [194882, 1, "\u{250F2}"], [194883, 1, "\u{25119}"], [194884, 1, "\u{25133}"], [194885, 1, "\u771E"], [[194886, 194887], 1, "\u771F"], [194888, 1, "\u774A"], [194889, 1, "\u4039"], [194890, 1, "\u778B"], [194891, 1, "\u4046"], [194892, 1, "\u4096"], [194893, 1, "\u{2541D}"], [194894, 1, "\u784E"], [194895, 1, "\u788C"], [194896, 1, "\u78CC"], [194897, 1, "\u40E3"], [194898, 1, "\u{25626}"], [194899, 1, "\u7956"], [194900, 1, "\u{2569A}"], [194901, 1, "\u{256C5}"], [194902, 1, "\u798F"], [194903, 1, "\u79EB"], [194904, 1, "\u412F"], [194905, 1, "\u7A40"], [194906, 1, "\u7A4A"], [194907, 1, "\u7A4F"], [194908, 1, "\u{2597C}"], [[194909, 194910], 1, "\u{25AA7}"], [194911, 3], [194912, 1, "\u4202"], [194913, 1, "\u{25BAB}"], [194914, 1, "\u7BC6"], [194915, 1, "\u7BC9"], [194916, 1, "\u4227"], [194917, 1, "\u{25C80}"], [194918, 1, "\u7CD2"], [194919, 1, "\u42A0"], [194920, 1, "\u7CE8"], [194921, 1, "\u7CE3"], [194922, 1, "\u7D00"], [194923, 1, "\u{25F86}"], [194924, 1, "\u7D63"], [194925, 1, "\u4301"], [194926, 1, "\u7DC7"], [194927, 1, "\u7E02"], [194928, 1, "\u7E45"], [194929, 1, "\u4334"], [194930, 1, "\u{26228}"], [194931, 1, "\u{26247}"], [194932, 1, "\u4359"], [194933, 1, "\u{262D9}"], [194934, 1, "\u7F7A"], [194935, 1, "\u{2633E}"], [194936, 1, "\u7F95"], [194937, 1, "\u7FFA"], [194938, 1, "\u8005"], [194939, 1, "\u{264DA}"], [194940, 1, "\u{26523}"], [194941, 1, "\u8060"], [194942, 1, "\u{265A8}"], [194943, 1, "\u8070"], [194944, 1, "\u{2335F}"], [194945, 1, "\u43D5"], [194946, 1, "\u80B2"], [194947, 1, "\u8103"], [194948, 1, "\u440B"], [194949, 1, "\u813E"], [194950, 1, "\u5AB5"], [194951, 1, "\u{267A7}"], [194952, 1, "\u{267B5}"], [194953, 1, "\u{23393}"], [194954, 1, "\u{2339C}"], [194955, 1, "\u8201"], [194956, 1, "\u8204"], [194957, 1, "\u8F9E"], [194958, 1, "\u446B"], [194959, 1, "\u8291"], [194960, 1, "\u828B"], [194961, 1, "\u829D"], [194962, 1, "\u52B3"], [194963, 1, "\u82B1"], [194964, 1, "\u82B3"], [194965, 1, "\u82BD"], [194966, 1, "\u82E6"], [194967, 1, "\u{26B3C}"], [194968, 1, "\u82E5"], [194969, 1, "\u831D"], [194970, 1, "\u8363"], [194971, 1, "\u83AD"], [194972, 1, "\u8323"], [194973, 1, "\u83BD"], [194974, 1, "\u83E7"], [194975, 1, "\u8457"], [194976, 1, "\u8353"], [194977, 1, "\u83CA"], [194978, 1, "\u83CC"], [194979, 1, "\u83DC"], [194980, 1, "\u{26C36}"], [194981, 1, "\u{26D6B}"], [194982, 1, "\u{26CD5}"], [194983, 1, "\u452B"], [194984, 1, "\u84F1"], [194985, 1, "\u84F3"], [194986, 1, "\u8516"], [194987, 1, "\u{273CA}"], [194988, 1, "\u8564"], [194989, 1, "\u{26F2C}"], [194990, 1, "\u455D"], [194991, 1, "\u4561"], [194992, 1, "\u{26FB1}"], [194993, 1, "\u{270D2}"], [194994, 1, "\u456B"], [194995, 1, "\u8650"], [194996, 1, "\u865C"], [194997, 1, "\u8667"], [194998, 1, "\u8669"], [194999, 1, "\u86A9"], [195e3, 1, "\u8688"], [195001, 1, "\u870E"], [195002, 1, "\u86E2"], [195003, 1, "\u8779"], [195004, 1, "\u8728"], [195005, 1, "\u876B"], [195006, 1, "\u8786"], [195007, 3], [195008, 1, "\u87E1"], [195009, 1, "\u8801"], [195010, 1, "\u45F9"], [195011, 1, "\u8860"], [195012, 1, "\u8863"], [195013, 1, "\u{27667}"], [195014, 1, "\u88D7"], [195015, 1, "\u88DE"], [195016, 1, "\u4635"], [195017, 1, "\u88FA"], [195018, 1, "\u34BB"], [195019, 1, "\u{278AE}"], [195020, 1, "\u{27966}"], [195021, 1, "\u46BE"], [195022, 1, "\u46C7"], [195023, 1, "\u8AA0"], [195024, 1, "\u8AED"], [195025, 1, "\u8B8A"], [195026, 1, "\u8C55"], [195027, 1, "\u{27CA8}"], [195028, 1, "\u8CAB"], [195029, 1, "\u8CC1"], [195030, 1, "\u8D1B"], [195031, 1, "\u8D77"], [195032, 1, "\u{27F2F}"], [195033, 1, "\u{20804}"], [195034, 1, "\u8DCB"], [195035, 1, "\u8DBC"], [195036, 1, "\u8DF0"], [195037, 1, "\u{208DE}"], [195038, 1, "\u8ED4"], [195039, 1, "\u8F38"], [195040, 1, "\u{285D2}"], [195041, 1, "\u{285ED}"], [195042, 1, "\u9094"], [195043, 1, "\u90F1"], [195044, 1, "\u9111"], [195045, 1, "\u{2872E}"], [195046, 1, "\u911B"], [195047, 1, "\u9238"], [195048, 1, "\u92D7"], [195049, 1, "\u92D8"], [195050, 1, "\u927C"], [195051, 1, "\u93F9"], [195052, 1, "\u9415"], [195053, 1, "\u{28BFA}"], [195054, 1, "\u958B"], [195055, 1, "\u4995"], [195056, 1, "\u95B7"], [195057, 1, "\u{28D77}"], [195058, 1, "\u49E6"], [195059, 1, "\u96C3"], [195060, 1, "\u5DB2"], [195061, 1, "\u9723"], [195062, 1, "\u{29145}"], [195063, 1, "\u{2921A}"], [195064, 1, "\u4A6E"], [195065, 1, "\u4A76"], [195066, 1, "\u97E0"], [195067, 1, "\u{2940A}"], [195068, 1, "\u4AB2"], [195069, 1, "\u{29496}"], [[195070, 195071], 1, "\u980B"], [195072, 1, "\u9829"], [195073, 1, "\u{295B6}"], [195074, 1, "\u98E2"], [195075, 1, "\u4B33"], [195076, 1, "\u9929"], [195077, 1, "\u99A7"], [195078, 1, "\u99C2"], [195079, 1, "\u99FE"], [195080, 1, "\u4BCE"], [195081, 1, "\u{29B30}"], [195082, 1, "\u9B12"], [195083, 1, "\u9C40"], [195084, 1, "\u9CFD"], [195085, 1, "\u4CCE"], [195086, 1, "\u4CED"], [195087, 1, "\u9D67"], [195088, 1, "\u{2A0CE}"], [195089, 1, "\u4CF8"], [195090, 1, "\u{2A105}"], [195091, 1, "\u{2A20E}"], [195092, 1, "\u{2A291}"], [195093, 1, "\u9EBB"], [195094, 1, "\u4D56"], [195095, 1, "\u9EF9"], [195096, 1, "\u9EFE"], [195097, 1, "\u9F05"], [195098, 1, "\u9F0F"], [195099, 1, "\u9F16"], [195100, 1, "\u9F3B"], [195101, 1, "\u{2A600}"], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918e3, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
  }
});

// asset-input/node_modules/tr46/lib/statusMapping.js
var require_statusMapping = __commonJS({
  "asset-input/node_modules/tr46/lib/statusMapping.js"(exports2, module2) {
    "use strict";
    module2.exports.STATUS_MAPPING = {
      mapped: 1,
      valid: 2,
      disallowed: 3,
      disallowed_STD3_valid: 4,
      disallowed_STD3_mapped: 5,
      deviation: 6,
      ignored: 7
    };
  }
});

// asset-input/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "asset-input/node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var regexes = require_regexes();
    var mappingTable = require_mappingTable();
    var { STATUS_MAPPING } = require_statusMapping();
    function containsNonASCII(str) {
      return /[^\x00-\x7F]/u.test(str);
    }
    function findStatus(val, { useSTD3ASCIIRules }) {
      let start = 0;
      let end = mappingTable.length - 1;
      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        const target = mappingTable[mid];
        const min = Array.isArray(target[0]) ? target[0][0] : target[0];
        const max = Array.isArray(target[0]) ? target[0][1] : target[0];
        if (min <= val && max >= val) {
          if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
            return [STATUS_MAPPING.disallowed, ...target.slice(2)];
          } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {
            return [STATUS_MAPPING.valid, ...target.slice(2)];
          } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
            return [STATUS_MAPPING.mapped, ...target.slice(2)];
          }
          return target.slice(1);
        } else if (min > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    function mapChars(domainName, { useSTD3ASCIIRules, processingOption }) {
      let hasError = false;
      let processed = "";
      for (const ch of domainName) {
        const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
        switch (status) {
          case STATUS_MAPPING.disallowed:
            hasError = true;
            processed += ch;
            break;
          case STATUS_MAPPING.ignored:
            break;
          case STATUS_MAPPING.mapped:
            processed += mapping;
            break;
          case STATUS_MAPPING.deviation:
            if (processingOption === "transitional") {
              processed += mapping;
            } else {
              processed += ch;
            }
            break;
          case STATUS_MAPPING.valid:
            processed += ch;
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    function validateLabel(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {
      if (label.normalize("NFC") !== label) {
        return false;
      }
      const codePoints = Array.from(label);
      if (checkHyphens) {
        if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
          return false;
        }
      }
      if (label.includes(".") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {
        return false;
      }
      for (const ch of codePoints) {
        const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
        if (processingOption === "transitional" && status !== STATUS_MAPPING.valid || processingOption === "nontransitional" && status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
          return false;
        }
      }
      if (checkJoiners) {
        let last = 0;
        for (const [i, ch] of codePoints.entries()) {
          if (ch === "\u200C" || ch === "\u200D") {
            if (i > 0) {
              if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
                continue;
              }
              if (ch === "\u200C") {
                const next = codePoints.indexOf("\u200C", i + 1);
                const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
                if (regexes.validZWNJ.test(test.join(""))) {
                  last = i + 1;
                  continue;
                }
              }
            }
            return false;
          }
        }
      }
      if (checkBidi) {
        let rtl;
        if (regexes.bidiS1LTR.test(codePoints[0])) {
          rtl = false;
        } else if (regexes.bidiS1RTL.test(codePoints[0])) {
          rtl = true;
        } else {
          return false;
        }
        if (rtl) {
          if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
            return false;
          }
        } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
          return false;
        }
      }
      return true;
    }
    function isBidiDomain(labels) {
      const domain = labels.map((label) => {
        if (label.startsWith("xn--")) {
          try {
            return punycode.decode(label.substring(4));
          } catch (err) {
            return "";
          }
        }
        return label;
      }).join(".");
      return regexes.bidiDomain.test(domain);
    }
    function processing(domainName, options) {
      const { processingOption } = options;
      let { string, error } = mapChars(domainName, options);
      string = string.normalize("NFC");
      const labels = string.split(".");
      const isBidi = isBidiDomain(labels);
      for (const [i, origLabel] of labels.entries()) {
        let label = origLabel;
        let curProcessing = processingOption;
        if (label.startsWith("xn--")) {
          try {
            label = punycode.decode(label.substring(4));
            labels[i] = label;
          } catch (err) {
            error = true;
            continue;
          }
          curProcessing = "nontransitional";
        }
        if (error) {
          continue;
        }
        const validation = validateLabel(label, {
          ...options,
          processingOption: curProcessing,
          checkBidi: options.checkBidi && isBidi
        });
        if (!validation) {
          error = true;
        }
      }
      return {
        string: labels.join("."),
        error
      };
    }
    function toASCII(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false,
      processingOption = "nontransitional",
      verifyDNSLength = false
    } = {}) {
      if (processingOption !== "transitional" && processingOption !== "nontransitional") {
        throw new RangeError("processingOption must be either transitional or nontransitional");
      }
      const result = processing(domainName, {
        processingOption,
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules
      });
      let labels = result.string.split(".");
      labels = labels.map((l) => {
        if (containsNonASCII(l)) {
          try {
            return `xn--${punycode.encode(l)}`;
          } catch (e) {
            result.error = true;
          }
        }
        return l;
      });
      if (verifyDNSLength) {
        const total = labels.join(".").length;
        if (total > 253 || total === 0) {
          result.error = true;
        }
        for (let i = 0; i < labels.length; ++i) {
          if (labels[i].length > 63 || labels[i].length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) {
        return null;
      }
      return labels.join(".");
    }
    function toUnicode(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false,
      processingOption = "nontransitional"
    } = {}) {
      const result = processing(domainName, {
        processingOption,
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules
      });
      return {
        domain: result.string,
        error: result.error
      };
    }
    module2.exports = {
      toASCII,
      toUnicode
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/infra.js"(exports2, module2) {
    "use strict";
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    module2.exports = {
      isASCIIDigit,
      isASCIIAlpha,
      isASCIIAlphanumeric,
      isASCIIHex
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/encoding.js
var require_encoding = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/encoding.js"(exports2, module2) {
    "use strict";
    var utf8Encoder = new TextEncoder();
    var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
    function utf8Encode(string) {
      return utf8Encoder.encode(string);
    }
    function utf8DecodeWithoutBOM(bytes) {
      return utf8Decoder.decode(bytes);
    }
    module2.exports = {
      utf8Encode,
      utf8DecodeWithoutBOM
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/percent-encoding.js
var require_percent_encoding = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/percent-encoding.js"(exports2, module2) {
    "use strict";
    var { isASCIIHex } = require_infra();
    var { utf8Encode } = require_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = `0${hex}`;
      }
      return `%${hex}`;
    }
    function percentDecodeBytes(input) {
      const output = new Uint8Array(input.byteLength);
      let outputIndex = 0;
      for (let i = 0; i < input.byteLength; ++i) {
        const byte = input[i];
        if (byte !== 37) {
          output[outputIndex++] = byte;
        } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
          output[outputIndex++] = byte;
        } else {
          const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
          output[outputIndex++] = bytePoint;
          i += 2;
        }
      }
      return output.slice(0, outputIndex);
    }
    function percentDecodeString(input) {
      const bytes = utf8Encode(input);
      return percentDecodeBytes(bytes);
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("<"), p(">"), p("`")]);
    function isFragmentPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
    }
    var extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("#"), p("<"), p(">")]);
    function isQueryPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
    }
    function isSpecialQueryPercentEncode(c) {
      return isQueryPercentEncode(c) || c === p("'");
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p("?"), p("`"), p("{"), p("}")]);
    function isPathPercentEncode(c) {
      return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("^"), p("|")]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    var extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
    function isComponentPercentEncode(c) {
      return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
    }
    var extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
    function isURLEncodedPercentEncode(c) {
      return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
    }
    function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
      const bytes = utf8Encode(codePoint);
      let output = "";
      for (const byte of bytes) {
        if (!percentEncodePredicate(byte)) {
          output += String.fromCharCode(byte);
        } else {
          output += percentEncode(byte);
        }
      }
      return output;
    }
    function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
      return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
    }
    function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
      let output = "";
      for (const codePoint of input) {
        if (spaceAsPlus && codePoint === " ") {
          output += "+";
        } else {
          output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
        }
      }
      return output;
    }
    module2.exports = {
      isC0ControlPercentEncode,
      isFragmentPercentEncode,
      isQueryPercentEncode,
      isSpecialQueryPercentEncode,
      isPathPercentEncode,
      isUserinfoPercentEncode,
      isURLEncodedPercentEncode,
      percentDecodeString,
      percentDecodeBytes,
      utf8PercentEncodeString,
      utf8PercentEncodeCodePoint
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var tr46 = require_tr46();
    var infra = require_infra();
    var { utf8DecodeWithoutBOM } = require_encoding();
    var {
      percentDecodeString,
      utf8PercentEncodeCodePoint,
      utf8PercentEncodeString,
      isC0ControlPercentEncode,
      isFragmentPercentEncode,
      isQueryPercentEncode,
      isSpecialQueryPercentEncode,
      isPathPercentEncode,
      isUserinfoPercentEncode
    } = require_percent_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return [...str].length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function isNotSpecial(url) {
      return !isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function parseIPv4Number(input) {
      if (input === "") {
        return failure;
      }
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      let regex = /[^0-7]/u;
      if (R === 10) {
        regex = /[^0-9]/u;
      }
      if (R === 16) {
        regex = /[^0-9A-Fa-f]/u;
      }
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return failure;
      }
      const numbers = [];
      for (const part of parts) {
        const n = parseIPv4Number(part);
        if (n === failure) {
          return failure;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * 256 ** (3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = `.${output}`;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = Array.from(input, (c) => c.codePointAt(0));
      if (input[pointer] === p(":")) {
        if (input[pointer + 1] !== p(":")) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === p(":")) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && infra.isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === p(".")) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === p(".") && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!infra.isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (infra.isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === p(":")) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const compress = findLongestZeroSequence(address);
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isNotSpecialArg = false) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (isNotSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
      const asciiDomain = domainToASCII(domain);
      if (asciiDomain === failure) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      if (endsInANumber(asciiDomain)) {
        return parseIPv4(asciiDomain);
      }
      return asciiDomain;
    }
    function endsInANumber(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length === 1) {
          return false;
        }
        parts.pop();
      }
      const last = parts[parts.length - 1];
      if (parseIPv4Number(last) !== failure) {
        return true;
      }
      if (/^[0-9]+$/u.test(last)) {
        return true;
      }
      return false;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      return utf8PercentEncodeString(input, isC0ControlPercentEncode);
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        return currStart;
      }
      return maxIdx;
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return `[${serializeIPv6(host)}]`;
      }
      return host;
    }
    function domainToASCII(domain, beStrict = false) {
      const result = tr46.toASCII(domain, {
        checkBidi: true,
        checkHyphens: false,
        checkJoiners: true,
        useSTD3ASCIIRules: beStrict,
        verifyDNSLength: beStrict
      });
      if (result === null || result === "") {
        return failure;
      }
      return result;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/ug, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/ug, "");
    }
    function shortenPath(url) {
      const { path } = url;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || hasAnOpaquePath(url) || url.scheme === "file";
    }
    function hasAnOpaquePath(url) {
      return typeof url.path === "string";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/u.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = Array.from(this.input, (c) => c.codePointAt(0));
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this[`parse ${this.state}`](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (infra.isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
        this.buffer += cStr.toLowerCase();
      } else if (c === p(":")) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && this.url.host === "") {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        if (this.stateOverride) {
          if (this.url.port === defaultPort(this.url.scheme)) {
            this.url.port = null;
          }
          return false;
        }
        this.buffer = "";
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === p("/")) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.path = "";
          this.state = "opaque path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || hasAnOpaquePath(this.base) && c !== p("#")) {
        return failure;
      } else if (hasAnOpaquePath(this.base) && c === p("#")) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path;
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === p("/")) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (c === p("/")) {
        this.state = "relative slash";
      } else if (isSpecial(this.url) && c === p("\\")) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          this.url.path.pop();
          this.state = "path";
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === p("/")) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== p("/") && c !== p("\\")) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === p("@")) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = `%40${this.buffer}`;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === p(":") && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        if (this.stateOverride === "hostname") {
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === p("[")) {
          this.arrFlag = true;
        } else if (c === p("]")) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (infra.isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\") || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > 2 ** 16 - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p("/"), p("\\"), p("?"), p("#")]);
    function startsWithWindowsDriveLetter(input, pointer) {
      const length = input.length - pointer;
      return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
    }
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      this.url.host = "";
      if (c === p("/") || c === p("\\")) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
            shortenPath(this.url);
          } else {
            this.parseError = true;
            this.url.path = [];
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === p("/") || c === p("\\")) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          }
          this.url.host = this.base.host;
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isNotSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== p("/") && c !== p("\\")) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== p("/")) {
          --this.pointer;
        }
      } else if (this.stateOverride && this.url.host === null) {
        this.url.path.push("");
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === p("/") || isSpecial(this.url) && c === p("\\") || !this.stateOverride && (c === p("?") || c === p("#"))) {
        if (isSpecial(this.url) && c === p("\\")) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            this.buffer = `${this.buffer[0]}:`;
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== p("%")) {
          this.parseError = true;
        }
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      if (!this.stateOverride && c === p("#") || isNaN(c)) {
        const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
        this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
        this.buffer = "";
        if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else if (!isNaN(c)) {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (!isNaN(c)) {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = `${url.scheme}:`;
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += `:${url.password}`;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += `:${url.port}`;
        }
      }
      if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
        output += "/.";
      }
      output += serializePath(url);
      if (url.query !== null) {
        output += `?${url.query}`;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += `#${url.fragment}`;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = `${tuple.scheme}://`;
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += `:${tuple.port}`;
      }
      return result;
    }
    function serializePath(url) {
      if (hasAnOpaquePath(url)) {
        return url.path;
      }
      let output = "";
      for (const segment of url.path) {
        output += `/${segment}`;
      }
      return output;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializePath = serializePath;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(serializePath(url)));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "null";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return null;
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.hasAnOpaquePath = hasAnOpaquePath;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/urlencoded.js"(exports2, module2) {
    "use strict";
    var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
    var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    function parseUrlencoded(input) {
      const sequences = strictlySplitByteSequence(input, p("&"));
      const output = [];
      for (const bytes of sequences) {
        if (bytes.length === 0) {
          continue;
        }
        let name, value;
        const indexOfEqual = bytes.indexOf(p("="));
        if (indexOfEqual >= 0) {
          name = bytes.slice(0, indexOfEqual);
          value = bytes.slice(indexOfEqual + 1);
        } else {
          name = bytes;
          value = new Uint8Array(0);
        }
        name = replaceByteInByteSequence(name, 43, 32);
        value = replaceByteInByteSequence(value, 43, 32);
        const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
        const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
        output.push([nameString, valueString]);
      }
      return output;
    }
    function parseUrlencodedString(input) {
      return parseUrlencoded(utf8Encode(input));
    }
    function serializeUrlencoded(tuples, encodingOverride = void 0) {
      let encoding = "utf-8";
      if (encodingOverride !== void 0) {
        encoding = encodingOverride;
      }
      let output = "";
      for (const [i, tuple] of tuples.entries()) {
        const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
        let value = tuple[1];
        if (tuple.length > 2 && tuple[2] !== void 0) {
          if (tuple[2] === "hidden" && name === "_charset_") {
            value = encoding;
          } else if (tuple[2] === "file") {
            value = value.name;
          }
        }
        value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);
        if (i !== 0) {
          output += "&";
        }
        output += `${name}=${value}`;
      }
      return output;
    }
    function strictlySplitByteSequence(buf, cp) {
      const list = [];
      let last = 0;
      let i = buf.indexOf(cp);
      while (i >= 0) {
        list.push(buf.slice(last, i));
        last = i + 1;
        i = buf.indexOf(cp, last);
      }
      if (last !== buf.length) {
        list.push(buf.slice(last));
      }
      return list;
    }
    function replaceByteInByteSequence(buf, from, to) {
      let i = buf.indexOf(from);
      while (i >= 0) {
        buf[i] = to;
        i = buf.indexOf(from, i + 1);
      }
      return buf;
    }
    module2.exports = {
      parseUrlencodedString,
      serializeUrlencoded
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/Function.js
var require_Function = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/Function.js"(exports2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils3();
    exports2.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (typeof value !== "function") {
        throw new globalObject.TypeError(context + " is not a function");
      }
      function invokeTheCallbackFunction(...args) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        for (let i = 0; i < args.length; i++) {
          args[i] = utils.tryWrapperForImpl(args[i]);
        }
        callResult = Reflect.apply(value, thisArg, args);
        callResult = conversions["any"](callResult, { context, globals: globalObject });
        return callResult;
      }
      invokeTheCallbackFunction.construct = (...args) => {
        for (let i = 0; i < args.length; i++) {
          args[i] = utils.tryWrapperForImpl(args[i]);
        }
        let callResult = Reflect.construct(value, args);
        callResult = conversions["any"](callResult, { context, globals: globalObject });
        return callResult;
      };
      invokeTheCallbackFunction[utils.wrapperSymbol] = value;
      invokeTheCallbackFunction.objectReference = value;
      return invokeTheCallbackFunction;
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/URLSearchParams-impl.js"(exports2) {
    "use strict";
    var urlencoded = require_urlencoded();
    exports2.implementation = class URLSearchParamsImpl {
      constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
        let init = constructorArgs[0];
        this._list = [];
        this._url = null;
        if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
          init = init.slice(1);
        }
        if (Array.isArray(init)) {
          for (const pair of init) {
            if (pair.length !== 2) {
              throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
            }
            this._list.push([pair[0], pair[1]]);
          }
        } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
          for (const name of Object.keys(init)) {
            const value = init[name];
            this._list.push([name, value]);
          }
        } else {
          this._list = urlencoded.parseUrlencodedString(init);
        }
      }
      _updateSteps() {
        if (this._url !== null) {
          let query = urlencoded.serializeUrlencoded(this._list);
          if (query === "") {
            query = null;
          }
          this._url._url.query = query;
        }
      }
      append(name, value) {
        this._list.push([name, value]);
        this._updateSteps();
      }
      delete(name) {
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name) {
            this._list.splice(i, 1);
          } else {
            i++;
          }
        }
        this._updateSteps();
      }
      get(name) {
        for (const tuple of this._list) {
          if (tuple[0] === name) {
            return tuple[1];
          }
        }
        return null;
      }
      getAll(name) {
        const output = [];
        for (const tuple of this._list) {
          if (tuple[0] === name) {
            output.push(tuple[1]);
          }
        }
        return output;
      }
      has(name) {
        for (const tuple of this._list) {
          if (tuple[0] === name) {
            return true;
          }
        }
        return false;
      }
      set(name, value) {
        let found = false;
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name) {
            if (found) {
              this._list.splice(i, 1);
            } else {
              found = true;
              this._list[i][1] = value;
              i++;
            }
          } else {
            i++;
          }
        }
        if (!found) {
          this._list.push([name, value]);
        }
        this._updateSteps();
      }
      sort() {
        this._list.sort((a, b) => {
          if (a[0] < b[0]) {
            return -1;
          }
          if (a[0] > b[0]) {
            return 1;
          }
          return 0;
        });
        this._updateSteps();
      }
      [Symbol.iterator]() {
        return this._list[Symbol.iterator]();
      }
      toString() {
        return urlencoded.serializeUrlencoded(this._list);
      }
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/URLSearchParams.js"(exports2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils3();
    var Function2 = require_Function();
    var newObjectInRealm = utils.newObjectInRealm;
    var implSymbol = utils.implSymbol;
    var ctorRegistrySymbol = utils.ctorRegistrySymbol;
    var interfaceName = "URLSearchParams";
    exports2.is = (value) => {
      return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports2.isImpl = (value) => {
      return utils.isObject(value) && value instanceof Impl.implementation;
    };
    exports2.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports2.is(value)) {
        return utils.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
    };
    exports2.createDefaultIterator = (globalObject, target, kind) => {
      const ctorRegistry = globalObject[ctorRegistrySymbol];
      const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
      const iterator = Object.create(iteratorPrototype);
      Object.defineProperty(iterator, utils.iterInternalSymbol, {
        value: { target, kind, index: 0 },
        configurable: true
      });
      return iterator;
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
      }
      return Object.create(proto);
    }
    exports2.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports2.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports2.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports2.create(globalObject, constructorArgs, privateData);
      return utils.implForWrapper(wrapper);
    };
    exports2._internalSetup = (wrapper, globalObject) => {
    };
    exports2.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports2.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports2.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils.initCtorRegistry(globalObject);
      class URLSearchParams {
        constructor() {
          const args = [];
          {
            let curArg = arguments[0];
            if (curArg !== void 0) {
              if (utils.isObject(curArg)) {
                if (curArg[Symbol.iterator] !== void 0) {
                  if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object."
                    );
                  } else {
                    const V = [];
                    const tmp = curArg;
                    for (let nextItem of tmp) {
                      if (!utils.isObject(nextItem)) {
                        throw new globalObject.TypeError(
                          "Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object."
                        );
                      } else {
                        const V2 = [];
                        const tmp2 = nextItem;
                        for (let nextItem2 of tmp2) {
                          nextItem2 = conversions["USVString"](nextItem2, {
                            context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                            globals: globalObject
                          });
                          V2.push(nextItem2);
                        }
                        nextItem = V2;
                      }
                      V.push(nextItem);
                    }
                    curArg = V;
                  }
                } else {
                  if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 record is not an object."
                    );
                  } else {
                    const result = /* @__PURE__ */ Object.create(null);
                    for (const key of Reflect.ownKeys(curArg)) {
                      const desc = Object.getOwnPropertyDescriptor(curArg, key);
                      if (desc && desc.enumerable) {
                        let typedKey = key;
                        typedKey = conversions["USVString"](typedKey, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                          globals: globalObject
                        });
                        let typedValue = curArg[key];
                        typedValue = conversions["USVString"](typedValue, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                          globals: globalObject
                        });
                        result[typedKey] = typedValue;
                      }
                    }
                    curArg = result;
                  }
                }
              } else {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to construct 'URLSearchParams': parameter 1",
                  globals: globalObject
                });
              }
            } else {
              curArg = "";
            }
            args.push(curArg);
          }
          return exports2.setup(Object.create(new.target.prototype), globalObject, args);
        }
        append(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'append' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
        }
        delete(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'delete' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
        }
        get(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return esValue[implSymbol].get(...args);
        }
        getAll(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'getAll' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
        }
        has(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return esValue[implSymbol].has(...args);
        }
        set(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
        }
        sort() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].sort());
        }
        toString() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'toString' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return esValue[implSymbol].toString();
        }
        keys() {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
          }
          return exports2.createDefaultIterator(globalObject, this, "key");
        }
        values() {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError(
              "'values' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports2.createDefaultIterator(globalObject, this, "value");
        }
        entries() {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError(
              "'entries' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports2.createDefaultIterator(globalObject, this, "key+value");
        }
        forEach(callback) {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError(
              "'forEach' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              "Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present."
            );
          }
          callback = Function2.convert(globalObject, callback, {
            context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
          });
          const thisArg = arguments[1];
          let pairs = Array.from(this[implSymbol]);
          let i = 0;
          while (i < pairs.length) {
            const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
            callback.call(thisArg, value, key, this);
            pairs = Array.from(this[implSymbol]);
            i++;
          }
        }
      }
      Object.defineProperties(URLSearchParams.prototype, {
        append: { enumerable: true },
        delete: { enumerable: true },
        get: { enumerable: true },
        getAll: { enumerable: true },
        has: { enumerable: true },
        set: { enumerable: true },
        sort: { enumerable: true },
        toString: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true },
        forEach: { enumerable: true },
        [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
        [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
      });
      ctorRegistry[interfaceName] = URLSearchParams;
      ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
        [Symbol.toStringTag]: {
          configurable: true,
          value: "URLSearchParams Iterator"
        }
      });
      utils.define(ctorRegistry["URLSearchParams Iterator"], {
        next() {
          const internal = this && this[utils.iterInternalSymbol];
          if (!internal) {
            throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
          }
          const { target, kind, index } = internal;
          const values = Array.from(target[implSymbol]);
          const len = values.length;
          if (index >= len) {
            return newObjectInRealm(globalObject, { value: void 0, done: true });
          }
          const pair = values[index];
          internal.index = index + 1;
          return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
        }
      });
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URLSearchParams
      });
    };
    var Impl = require_URLSearchParams_impl();
  }
});

// asset-input/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    var urlencoded = require_urlencoded();
    var URLSearchParams = require_URLSearchParams();
    exports2.implementation = class URLImpl {
      constructor(globalObject, constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === null) {
            throw new TypeError(`Invalid base URL: ${base}`);
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${url}`);
        }
        const query = parsedURL.query !== null ? parsedURL.query : "";
        this._url = parsedURL;
        this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
        this._query._url = this;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${v}`);
        }
        this._url = parsedURL;
        this._query._list.splice(0);
        const { query } = parsedURL;
        if (query !== null) {
          this._query._list = urlencoded.parseUrlencodedString(query);
        }
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return `${this._url.scheme}:`;
      }
      set protocol(v) {
        usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
      }
      set host(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        return usm.serializePath(this._url);
      }
      set pathname(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return `?${this._url.query}`;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          this._query._list = [];
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
        this._query._list = urlencoded.parseUrlencodedString(input);
      }
      get searchParams() {
        return this._query;
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return `#${this._url.fragment}`;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// asset-input/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "asset-input/node_modules/whatwg-url/lib/URL.js"(exports2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils3();
    var implSymbol = utils.implSymbol;
    var ctorRegistrySymbol = utils.ctorRegistrySymbol;
    var interfaceName = "URL";
    exports2.is = (value) => {
      return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports2.isImpl = (value) => {
      return utils.isObject(value) && value instanceof Impl.implementation;
    };
    exports2.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports2.is(value)) {
        return utils.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
      }
      return Object.create(proto);
    }
    exports2.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports2.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports2.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports2.create(globalObject, constructorArgs, privateData);
      return utils.implForWrapper(wrapper);
    };
    exports2._internalSetup = (wrapper, globalObject) => {
    };
    exports2.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports2.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports2.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils.initCtorRegistry(globalObject);
      class URL {
        constructor(url) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return exports2.setup(Object.create(new.target.prototype), globalObject, args);
        }
        toJSON() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol].toJSON();
        }
        get href() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        set href(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'href' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["href"] = V;
        }
        toString() {
          const esValue = this;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        get origin() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["origin"];
        }
        get protocol() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["protocol"];
        }
        set protocol(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'protocol' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["protocol"] = V;
        }
        get username() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["username"];
        }
        set username(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'username' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["username"] = V;
        }
        get password() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["password"];
        }
        set password(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'password' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["password"] = V;
        }
        get host() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["host"];
        }
        set host(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'host' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["host"] = V;
        }
        get hostname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hostname"];
        }
        set hostname(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'hostname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hostname"] = V;
        }
        get port() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["port"];
        }
        set port(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'port' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["port"] = V;
        }
        get pathname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["pathname"];
        }
        set pathname(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'pathname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["pathname"] = V;
        }
        get search() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["search"];
        }
        set search(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'search' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["search"] = V;
        }
        get searchParams() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
          }
          return utils.getSameObject(this, "searchParams", () => {
            return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
          });
        }
        get hash() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hash"];
        }
        set hash(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'hash' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hash"] = V;
        }
      }
      Object.defineProperties(URL.prototype, {
        toJSON: { enumerable: true },
        href: { enumerable: true },
        toString: { enumerable: true },
        origin: { enumerable: true },
        protocol: { enumerable: true },
        username: { enumerable: true },
        password: { enumerable: true },
        host: { enumerable: true },
        hostname: { enumerable: true },
        port: { enumerable: true },
        pathname: { enumerable: true },
        search: { enumerable: true },
        searchParams: { enumerable: true },
        hash: { enumerable: true },
        [Symbol.toStringTag]: { value: "URL", configurable: true }
      });
      ctorRegistry[interfaceName] = URL;
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URL
      });
      if (globalNames.includes("Window")) {
        Object.defineProperty(globalObject, "webkitURL", {
          configurable: true,
          writable: true,
          value: URL
        });
      }
    };
    var Impl = require_URL_impl();
  }
});

// asset-input/node_modules/whatwg-url/webidl2js-wrapper.js
var require_webidl2js_wrapper = __commonJS({
  "asset-input/node_modules/whatwg-url/webidl2js-wrapper.js"(exports2) {
    "use strict";
    var URL = require_URL();
    var URLSearchParams = require_URLSearchParams();
    exports2.URL = URL;
    exports2.URLSearchParams = URLSearchParams;
  }
});

// asset-input/node_modules/whatwg-url/index.js
var require_whatwg_url = __commonJS({
  "asset-input/node_modules/whatwg-url/index.js"(exports2) {
    "use strict";
    var { URL, URLSearchParams } = require_webidl2js_wrapper();
    var urlStateMachine = require_url_state_machine();
    var percentEncoding = require_percent_encoding();
    var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
    URL.install(sharedGlobalObject, ["Window"]);
    URLSearchParams.install(sharedGlobalObject, ["Window"]);
    exports2.URL = sharedGlobalObject.URL;
    exports2.URLSearchParams = sharedGlobalObject.URLSearchParams;
    exports2.parseURL = urlStateMachine.parseURL;
    exports2.basicURLParse = urlStateMachine.basicURLParse;
    exports2.serializeURL = urlStateMachine.serializeURL;
    exports2.serializePath = urlStateMachine.serializePath;
    exports2.serializeHost = urlStateMachine.serializeHost;
    exports2.serializeInteger = urlStateMachine.serializeInteger;
    exports2.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
    exports2.setTheUsername = urlStateMachine.setTheUsername;
    exports2.setThePassword = urlStateMachine.setThePassword;
    exports2.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
    exports2.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
    exports2.percentDecodeString = percentEncoding.percentDecodeString;
    exports2.percentDecodeBytes = percentEncoding.percentDecodeBytes;
  }
});

// asset-input/node_modules/mongodb-connection-string-url/lib/redact.js
var require_redact = __commonJS({
  "asset-input/node_modules/mongodb-connection-string-url/lib/redact.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redactConnectionString = exports2.redactValidConnectionString = void 0;
    var index_1 = __importStar(require_lib2());
    function redactValidConnectionString(inputUrl, options) {
      var _a, _b;
      const url = inputUrl.clone();
      const replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : "_credentials_";
      const redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;
      if ((url.username || url.password) && redactUsernames) {
        url.username = replacementString;
        url.password = "";
      } else if (url.password) {
        url.password = replacementString;
      }
      if (url.searchParams.has("authMechanismProperties")) {
        const props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get("authMechanismProperties"));
        if (props.get("AWS_SESSION_TOKEN")) {
          props.set("AWS_SESSION_TOKEN", replacementString);
          url.searchParams.set("authMechanismProperties", props.toString());
        }
      }
      if (url.searchParams.has("tlsCertificateKeyFilePassword")) {
        url.searchParams.set("tlsCertificateKeyFilePassword", replacementString);
      }
      if (url.searchParams.has("proxyUsername") && redactUsernames) {
        url.searchParams.set("proxyUsername", replacementString);
      }
      if (url.searchParams.has("proxyPassword")) {
        url.searchParams.set("proxyPassword", replacementString);
      }
      return url;
    }
    exports2.redactValidConnectionString = redactValidConnectionString;
    function redactConnectionString(uri, options) {
      var _a, _b;
      const replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : "<credentials>";
      const redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;
      let parsed;
      try {
        parsed = new index_1.default(uri);
      } catch (_c) {
      }
      if (parsed) {
        options = { ...options, replacementString: "___credentials___" };
        return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
      }
      const R = replacementString;
      const replacements = [
        (uri2) => uri2.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `$1${R}$3`),
        (uri2) => uri2.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `$1${R}`),
        (uri2) => uri2.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `$1${R}`),
        (uri2) => redactUsernames ? uri2.replace(/(proxyUsername=)([^&]+)/gi, `$1${R}`) : uri2,
        (uri2) => uri2.replace(/(proxyPassword=)([^&]+)/gi, `$1${R}`)
      ];
      for (const replacer of replacements) {
        uri = replacer(uri);
      }
      return uri;
    }
    exports2.redactConnectionString = redactConnectionString;
  }
});

// asset-input/node_modules/mongodb-connection-string-url/lib/index.js
var require_lib2 = __commonJS({
  "asset-input/node_modules/mongodb-connection-string-url/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommaAndColonSeparatedRecord = exports2.ConnectionString = exports2.redactConnectionString = void 0;
    var whatwg_url_1 = require_whatwg_url();
    var redact_1 = require_redact();
    Object.defineProperty(exports2, "redactConnectionString", { enumerable: true, get: function() {
      return redact_1.redactConnectionString;
    } });
    var DUMMY_HOSTNAME = "__this_is_a_placeholder__";
    function connectionStringHasValidScheme(connectionString) {
      return connectionString.startsWith("mongodb://") || connectionString.startsWith("mongodb+srv://");
    }
    var HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;
    var CaseInsensitiveMap = class extends Map {
      delete(name) {
        return super.delete(this._normalizeKey(name));
      }
      get(name) {
        return super.get(this._normalizeKey(name));
      }
      has(name) {
        return super.has(this._normalizeKey(name));
      }
      set(name, value) {
        return super.set(this._normalizeKey(name), value);
      }
      _normalizeKey(name) {
        name = `${name}`;
        for (const key of this.keys()) {
          if (key.toLowerCase() === name.toLowerCase()) {
            name = key;
            break;
          }
        }
        return name;
      }
    };
    function caseInsenstiveURLSearchParams(Ctor) {
      return class CaseInsenstiveURLSearchParams extends Ctor {
        append(name, value) {
          return super.append(this._normalizeKey(name), value);
        }
        delete(name) {
          return super.delete(this._normalizeKey(name));
        }
        get(name) {
          return super.get(this._normalizeKey(name));
        }
        getAll(name) {
          return super.getAll(this._normalizeKey(name));
        }
        has(name) {
          return super.has(this._normalizeKey(name));
        }
        set(name, value) {
          return super.set(this._normalizeKey(name), value);
        }
        keys() {
          return super.keys();
        }
        values() {
          return super.values();
        }
        entries() {
          return super.entries();
        }
        [Symbol.iterator]() {
          return super[Symbol.iterator]();
        }
        _normalizeKey(name) {
          return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
        }
      };
    }
    var URLWithoutHost = class extends whatwg_url_1.URL {
    };
    var MongoParseError = class extends Error {
      get name() {
        return "MongoParseError";
      }
    };
    var ConnectionString = class _ConnectionString extends URLWithoutHost {
      constructor(uri, options = {}) {
        var _a;
        const { looseValidation } = options;
        if (!looseValidation && !connectionStringHasValidScheme(uri)) {
          throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
        }
        const match = uri.match(HOSTS_REGEX);
        if (!match) {
          throw new MongoParseError(`Invalid connection string "${uri}"`);
        }
        const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};
        if (!looseValidation) {
          if (!protocol || !hosts) {
            throw new MongoParseError(`Protocol and host list are required in "${uri}"`);
          }
          try {
            decodeURIComponent(username !== null && username !== void 0 ? username : "");
            decodeURIComponent(password !== null && password !== void 0 ? password : "");
          } catch (err) {
            throw new MongoParseError(err.message);
          }
          const illegalCharacters = /[:/?#[\]@]/gi;
          if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {
            throw new MongoParseError(`Username contains unescaped characters ${username}`);
          }
          if (!username || !password) {
            const uriWithoutProtocol = uri.replace(`${protocol}://`, "");
            if (uriWithoutProtocol.startsWith("@") || uriWithoutProtocol.startsWith(":")) {
              throw new MongoParseError("URI contained empty userinfo section");
            }
          }
          if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {
            throw new MongoParseError("Password contains unescaped characters");
          }
        }
        let authString = "";
        if (typeof username === "string")
          authString += username;
        if (typeof password === "string")
          authString += `:${password}`;
        if (authString)
          authString += "@";
        try {
          super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
        } catch (err) {
          if (looseValidation) {
            new _ConnectionString(uri, {
              ...options,
              looseValidation: false
            });
          }
          if (typeof err.message === "string") {
            err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
          }
          throw err;
        }
        this._hosts = hosts.split(",");
        if (!looseValidation) {
          if (this.isSRV && this.hosts.length !== 1) {
            throw new MongoParseError("mongodb+srv URI cannot have multiple service names");
          }
          if (this.isSRV && this.hosts.some((host) => host.includes(":"))) {
            throw new MongoParseError("mongodb+srv URI cannot have port number");
          }
        }
        if (!this.pathname) {
          this.pathname = "/";
        }
        Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
      }
      get host() {
        return DUMMY_HOSTNAME;
      }
      set host(_ignored) {
        throw new Error("No single host for connection string");
      }
      get hostname() {
        return DUMMY_HOSTNAME;
      }
      set hostname(_ignored) {
        throw new Error("No single host for connection string");
      }
      get port() {
        return "";
      }
      set port(_ignored) {
        throw new Error("No single host for connection string");
      }
      get href() {
        return this.toString();
      }
      set href(_ignored) {
        throw new Error("Cannot set href for connection strings");
      }
      get isSRV() {
        return this.protocol.includes("srv");
      }
      get hosts() {
        return this._hosts;
      }
      set hosts(list) {
        this._hosts = list;
      }
      toString() {
        return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(","));
      }
      clone() {
        return new _ConnectionString(this.toString(), {
          looseValidation: true
        });
      }
      redact(options) {
        return (0, redact_1.redactValidConnectionString)(this, options);
      }
      typedSearchParams() {
        const sametype = false;
        return this.searchParams;
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash } = this;
        return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash };
      }
    };
    exports2.ConnectionString = ConnectionString;
    var CommaAndColonSeparatedRecord = class extends CaseInsensitiveMap {
      constructor(from) {
        super();
        for (const entry of (from !== null && from !== void 0 ? from : "").split(",")) {
          if (!entry)
            continue;
          const colonIndex = entry.indexOf(":");
          if (colonIndex === -1) {
            this.set(entry, "");
          } else {
            this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
          }
        }
      }
      toString() {
        return [...this].map((entry) => entry.join(":")).join(",");
      }
    };
    exports2.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
    exports2.default = ConnectionString;
  }
});

// asset-input/node_modules/@mongodb-js/saslprep/dist/index.js
var require_dist = __commonJS({
  "asset-input/node_modules/@mongodb-js/saslprep/dist/index.js"(exports2, module2) {
    "use strict";
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l }, input, opts = {}) {
      const mapping2space = non_ASCII_space_characters;
      const mapping2nothing = commonly_mapped_to_nothing;
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
    saslprep.saslprep = saslprep;
    saslprep.default = saslprep;
    module2.exports = saslprep;
  }
});

// asset-input/node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "asset-input/node_modules/memory-pager/index.js"(exports2, module2) {
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager)) return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate)) page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates) return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length) return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate) return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate) return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length) this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length) this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page) page.buffer = b;
      else arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index) {
      while (pager.maxPages < index) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len) return buf;
      if (buf.length > len) return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc) return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// asset-input/node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "asset-input/node_modules/sparse-bitfield/index.js"(exports2, module2) {
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield)) return new Bitfield(opts);
      if (!opts) opts = {};
      if (Buffer.isBuffer(opts)) opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize)) throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next) next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b) return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates) this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc) return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// asset-input/node_modules/@mongodb-js/saslprep/dist/memory-code-points.js
var require_memory_code_points = __commonJS({
  "asset-input/node_modules/@mongodb-js/saslprep/dist/memory-code-points.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMemoryCodePoints = void 0;
    var sparse_bitfield_1 = __importDefault(require_sparse_bitfield());
    function createMemoryCodePoints(data) {
      let offset = 0;
      function read() {
        const size = data.readUInt32BE(offset);
        offset += 4;
        const codepoints = data.slice(offset, offset + size);
        offset += size;
        return (0, sparse_bitfield_1.default)({ buffer: codepoints });
      }
      const unassigned_code_points = read();
      const commonly_mapped_to_nothing = read();
      const non_ASCII_space_characters = read();
      const prohibited_characters = read();
      const bidirectional_r_al = read();
      const bidirectional_l = read();
      return {
        unassigned_code_points,
        commonly_mapped_to_nothing,
        non_ASCII_space_characters,
        prohibited_characters,
        bidirectional_r_al,
        bidirectional_l
      };
    }
    exports2.createMemoryCodePoints = createMemoryCodePoints;
  }
});

// asset-input/node_modules/@mongodb-js/saslprep/dist/code-points-data.js
var require_code_points_data = __commonJS({
  "asset-input/node_modules/@mongodb-js/saslprep/dist/code-points-data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var zlib_1 = require("zlib");
    exports2.default = (0, zlib_1.gunzipSync)(Buffer.from("H4sIAAAAAAACA+3dTYgcaRkA4LemO9Mhxm0FITnE9Cwr4jHgwgZ22B6YywqCJ0HQg5CL4sGTuOjCtGSF4CkHEW856MlTQHD3EJnWkU0Owh5VxE3LHlYQdNxd2U6mU59UV/d09fw4M2EySSXPAzNdP1/9fX/99bzVNZEN4jisRDulVFnQmLxm1aXF9Id/2/xMxNJ4XZlg576yuYlGt9gupV6xoFf8jhu9YvulVrFlp5XSx+lfvYhORGPXvqIRWSxERKtIm8bKFd10WNfKDS5Fo9jJWrq2+M2IlW+8uHgl/+BsROfPF4v5L7148Ur68Sha6dqZpYiVVy8tvLCWXo80Sf/lS89dGX2wHGvpzoXVn75/YWH5wmqe8uika82ViJXTy83Ve2k5Urozm38wm4/ls6t5uT6yfsTSJ7J3T0VKt8c5ExEXI8aFkH729c3eT+7EC6ca8cVULZUiYacX0R5PNWNxlh9L1y90q5kyzrpyy+9WcvOV6URntqw7La9sNVstXyczWVaWYbaaTYqzOHpr7pyiNT3/YzKuT63Z/FqKZlFTiuXtFM2vVOtIq7jiyKJbWZaOWD0euz0yoV2Z7kY0xq2x0YhfzVpmM5px9nTEH7JZ0ot5u39p0ma75Z472/s/H+2yr2inYyuq7fMvJivH2rM72N/Z3lyL31F2b1ya1P0zn816k2KP6JU9UzseucdQH5YqVeH/lFajSN2udg+TLJ9rksNxlvV2lki19rXKI43TPLejFu4ov7k3nMbhyhfY3Xb37f8BAGCf0eMTOH5szf154KmnNgKcnLb+Fzi2AfXktbN7fJelwTAiO/W5uQ2KINXRYu+znqo/WTAdLadURHmy3qciazd3bra4T3w16/f7t7Ms9U5gfJu10955sx1r3vmhBAAAAAAAgId20J1iZbDowNvIjuH427Gr5l/eiC+8OplZON8sVjx/qr9y+Pj+YRItT+NqAM+kkZs3AAAAAID6yfx1FwCAI97/dCh1/ub6SA0AAAAAAAAAgNoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hutp5SiQpYAAAAAAAAAQO2MIpZiT804flnAE2fhwjOeAZXr76kOAAAAAAAA8FjNf4N/l0NE3U/vuVQskLpSd4/Yh2xu9xTu0tFeeNYsLI2f/VMdNxTzj6Je9E/+6pp6Nn3awW3A54goe4Bss6v+PGsjQGMAAAAAAOBp5XEgwH6e7J7rwEQHRb/XvAMAAAAAAAA8yzoDeQDwVGjIAgAAAAAAAACoPfF/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqL/GSkSkClkCAAAAAAAAALXTSAAAAAAAAABA3Y1kAQAAAAAAAADUX8RSXZ9dsHC9+M8Fg2Ex/em1lAZpEBGttcrVjZqLEa+k0XpKw9mG4zWx4ukPUMhkAQAAAAAAABzBqbSe3//rXOS9HxGdo4TqR2XkutCdBu+LaPZw/lBbO7cbHnh2C7N7AIo4evEznllqLqWUp/LnYOtpM2bnOH66wI1+9GO4sOuISwv/TOlumu56FDv3NZhc4mR9v7zYIrafr40j/Cccvj9Xns3t3mu99E7qxUv3bqS0/ouNH/08++RGemfQ+nsx/5uNXsQPGulynPvv3ZTW37zd+1ovrqaYpP/122X6Xpx779Z3zr/3YOPKW1lkaRDf31pPaf3j/msRsVGkL+d/f+/m4sJsPm1cfSsr16e8m9Ldj/KsnyIuR3nXw83Is3EhxLd/2V773ks3m/cj/THKUummdP9qKhIOImuOU0Xjwb3y+oqt735rpTetVbF9n8R4x9crRfO77TKqVOZpDclv5bfK18lMnk+q0K18UpxF/RrGXE0Zxtqx3tWSj+vxbL4XaasfKb0dRbtLW73JsfPGg177H+OmGKlfvS1msllt7JEJm9XOJqXR+Fkfo1H66uy5H1v3Xx5+uJmGLw9jro2u7Loj4PnuR6+f+e3d261+eazNhzrL7X83MohoHpS4PddV8ki1it61//pw1g7z6p1U/26Nm2llST57B5rUvuG0XqSU/rPd7jYrqWcbd+beJQ77BgPMDwn37/8BAGCf0eMTOH4cPlufv9VGgJOzqf8Fjm1APXkd7B7f5dF57GPMaWy/MTvjvNvtXj6h8W2+GXvnzXaseeeHEgAAAAAAAB7aQXeKlcGiadBoEOeLb2dtpGOL2MyOtf391a3P/zD96c3JzIP3t4oV797vrh8+vn+YRL5bBuj/AQAAAABqJvfHXQAAHkX82zfXAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeAgkAAAAAAAAAqLuRLAAAAAAAAACA2hv9D1iu/VAYaAYA", "base64"));
  }
});

// asset-input/node_modules/@mongodb-js/saslprep/dist/node.js
var require_node = __commonJS({
  "asset-input/node_modules/@mongodb-js/saslprep/dist/node.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var index_1 = __importDefault(require_dist());
    var memory_code_points_1 = require_memory_code_points();
    var code_points_data_1 = __importDefault(require_code_points_data());
    var codePoints = (0, memory_code_points_1.createMemoryCodePoints)(code_points_data_1.default);
    function saslprep(input, opts) {
      return (0, index_1.default)(codePoints, input, opts);
    }
    saslprep.saslprep = saslprep;
    saslprep.default = saslprep;
    module2.exports = saslprep;
  }
});

// asset-input/node_modules/mongodb/lib/deps.js
var require_deps = __commonJS({
  "asset-input/node_modules/mongodb/lib/deps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoEncryptionLoggerLevel = exports2.aws4 = exports2.saslprep = exports2.Snappy = exports2.getAwsCredentialProvider = exports2.ZStandard = exports2.Kerberos = exports2.PKG_VERSION = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    exports2.PKG_VERSION = Symbol("kPkgVersion");
    function makeErrorModule(error) {
      const props = error ? { kModuleError: error } : {};
      return new Proxy(props, {
        get: (_, key) => {
          if (key === "kModuleError") {
            return error;
          }
          throw error;
        },
        set: () => {
          throw error;
        }
      });
    }
    exports2.Kerberos = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `kerberos` not found. Please install it to enable kerberos authentication"));
    try {
      exports2.Kerberos = require("kerberos");
    } catch {
    }
    exports2.ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression"));
    try {
      exports2.ZStandard = require("@mongodb-js/zstd");
    } catch {
    }
    function getAwsCredentialProvider() {
      try {
        const credentialProvider = require("@aws-sdk/credential-providers");
        return credentialProvider;
      } catch {
        return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@aws-sdk/credential-providers` not found. Please install it to enable getting aws credentials via the official sdk."));
      }
    }
    exports2.getAwsCredentialProvider = getAwsCredentialProvider;
    exports2.Snappy = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `snappy` not found. Please install it to enable snappy compression"));
    try {
      exports2.Snappy = require("snappy");
      try {
        exports2.Snappy[exports2.PKG_VERSION] = (0, utils_1.parsePackageVersion)(require("snappy/package.json"));
      } catch {
      }
    } catch {
    }
    exports2.saslprep = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/saslprep` not found. Please install it to enable Stringprep Profile for User Names and Passwords"));
    try {
      exports2.saslprep = require_node();
    } catch {
    }
    exports2.aws4 = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `aws4` not found. Please install it to enable AWS authentication"));
    try {
      exports2.aws4 = require("aws4");
    } catch {
    }
    exports2.AutoEncryptionLoggerLevel = Object.freeze({
      FatalError: 0,
      Error: 1,
      Warning: 2,
      Info: 3,
      Trace: 4
    });
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/auth_provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthProvider = exports2.AuthContext = void 0;
    var error_1 = require_error();
    var AuthContext = class {
      constructor(connection, credentials, options) {
        this.connection = connection;
        this.credentials = credentials;
        this.options = options;
      }
    };
    exports2.AuthContext = AuthContext;
    var AuthProvider = class {
      /**
       * Prepare the handshake document before the initial handshake.
       *
       * @param handshakeDoc - The document used for the initial handshake on a connection
       * @param authContext - Context for authentication flow
       */
      prepare(handshakeDoc, authContext, callback) {
        callback(void 0, handshakeDoc);
      }
      /**
       * Authenticate
       *
       * @param context - A shared context for authentication flow
       * @param callback - The callback to return the result from the authentication
       */
      auth(context, callback) {
        callback(new error_1.MongoRuntimeError("`auth` method must be overridden by subclass"));
      }
    };
    exports2.AuthProvider = AuthProvider;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/gssapi.js
var require_gssapi = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/gssapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveCname = exports2.performGSSAPICanonicalizeHostName = exports2.GSSAPI = exports2.GSSAPICanonicalizationValue = void 0;
    var dns = require("dns");
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var auth_provider_1 = require_auth_provider();
    exports2.GSSAPICanonicalizationValue = Object.freeze({
      on: true,
      off: false,
      none: "none",
      forward: "forward",
      forwardAndReverse: "forwardAndReverse"
    });
    var GSSAPI = class extends auth_provider_1.AuthProvider {
      auth(authContext, callback) {
        const { connection, credentials } = authContext;
        if (credentials == null)
          return callback(new error_1.MongoMissingCredentialsError("Credentials required for GSSAPI authentication"));
        const { username } = credentials;
        function externalCommand(command, cb) {
          return connection.command((0, utils_1.ns)("$external.$cmd"), command, void 0, cb);
        }
        makeKerberosClient(authContext, (err, client) => {
          if (err)
            return callback(err);
          if (client == null)
            return callback(new error_1.MongoMissingDependencyError("GSSAPI client missing"));
          client.step("", (err2, payload) => {
            if (err2)
              return callback(err2);
            externalCommand(saslStart(payload), (err3, result) => {
              if (err3)
                return callback(err3);
              if (result == null)
                return callback();
              negotiate(client, 10, result.payload, (err4, payload2) => {
                if (err4)
                  return callback(err4);
                externalCommand(saslContinue(payload2, result.conversationId), (err5, result2) => {
                  if (err5)
                    return callback(err5);
                  if (result2 == null)
                    return callback();
                  finalize(client, username, result2.payload, (err6, payload3) => {
                    if (err6)
                      return callback(err6);
                    externalCommand({
                      saslContinue: 1,
                      conversationId: result2.conversationId,
                      payload: payload3
                    }, (err7, result3) => {
                      if (err7)
                        return callback(err7);
                      callback(void 0, result3);
                    });
                  });
                });
              });
            });
          });
        });
      }
    };
    exports2.GSSAPI = GSSAPI;
    function makeKerberosClient(authContext, callback) {
      var _a;
      const { hostAddress } = authContext.options;
      const { credentials } = authContext;
      if (!hostAddress || typeof hostAddress.host !== "string" || !credentials) {
        return callback(new error_1.MongoInvalidArgumentError("Connection must have host and port and credentials defined."));
      }
      if ("kModuleError" in deps_1.Kerberos) {
        return callback(deps_1.Kerberos["kModuleError"]);
      }
      const { initializeClient } = deps_1.Kerberos;
      const { username, password } = credentials;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = (_a = mechanismProperties.SERVICE_NAME) !== null && _a !== void 0 ? _a : "mongodb";
      performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties, (err, host) => {
        var _a2;
        if (err)
          return callback(err);
        const initOptions = {};
        if (password != null) {
          Object.assign(initOptions, { user: username, password });
        }
        const spnHost = (_a2 = mechanismProperties.SERVICE_HOST) !== null && _a2 !== void 0 ? _a2 : host;
        let spn = `${serviceName}${process.platform === "win32" ? "/" : "@"}${spnHost}`;
        if ("SERVICE_REALM" in mechanismProperties) {
          spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
        }
        initializeClient(spn, initOptions, (err2, client) => {
          if (err2)
            return callback(new error_1.MongoRuntimeError(err2));
          callback(void 0, client);
        });
      });
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    function negotiate(client, retries, payload, callback) {
      client.step(payload, (err, response) => {
        if (err && retries === 0)
          return callback(err);
        if (err)
          return negotiate(client, retries - 1, payload, callback);
        callback(void 0, response || "");
      });
    }
    function finalize(client, user, payload, callback) {
      client.unwrap(payload, (err, response) => {
        if (err)
          return callback(err);
        client.wrap(response || "", { user }, (err2, wrapped) => {
          if (err2)
            return callback(err2);
          callback(void 0, wrapped);
        });
      });
    }
    function performGSSAPICanonicalizeHostName(host, mechanismProperties, callback) {
      const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
      if (!mode || mode === exports2.GSSAPICanonicalizationValue.none) {
        return callback(void 0, host);
      }
      if (mode === exports2.GSSAPICanonicalizationValue.on || mode === exports2.GSSAPICanonicalizationValue.forwardAndReverse) {
        dns.lookup(host, (error, address) => {
          if (error)
            return callback(error);
          dns.resolvePtr(address, (err, results) => {
            if (err) {
              return resolveCname(host, callback);
            }
            callback(void 0, results.length > 0 ? results[0] : host);
          });
        });
      } else {
        resolveCname(host, callback);
      }
    }
    exports2.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
    function resolveCname(host, callback) {
      dns.resolveCname(host, (err, r) => {
        if (err)
          return callback(void 0, host);
        if (r.length > 0) {
          return callback(void 0, r[0]);
        }
        callback(void 0, host);
      });
    }
    exports2.resolveCname = resolveCname;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/providers.js
var require_providers = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/providers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports2.AuthMechanism = void 0;
    exports2.AuthMechanism = Object.freeze({
      MONGODB_AWS: "MONGODB-AWS",
      MONGODB_CR: "MONGODB-CR",
      MONGODB_DEFAULT: "DEFAULT",
      MONGODB_GSSAPI: "GSSAPI",
      MONGODB_PLAIN: "PLAIN",
      MONGODB_SCRAM_SHA1: "SCRAM-SHA-1",
      MONGODB_SCRAM_SHA256: "SCRAM-SHA-256",
      MONGODB_X509: "MONGODB-X509"
    });
    exports2.AUTH_MECHS_AUTH_SRC_EXTERNAL = /* @__PURE__ */ new Set([
      exports2.AuthMechanism.MONGODB_GSSAPI,
      exports2.AuthMechanism.MONGODB_AWS,
      exports2.AuthMechanism.MONGODB_X509
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/mongo_credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoCredentials = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var gssapi_1 = require_gssapi();
    var providers_1 = require_providers();
    function getDefaultAuthMechanism(hello) {
      if (hello) {
        if (Array.isArray(hello.saslSupportedMechs)) {
          return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
        }
        if (hello.maxWireVersion >= 3) {
          return providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
        }
      }
      return providers_1.AuthMechanism.MONGODB_CR;
    }
    var MongoCredentials = class _MongoCredentials {
      constructor(options) {
        this.username = options.username;
        this.password = options.password;
        this.source = options.source;
        if (!this.source && options.db) {
          this.source = options.db;
        }
        this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
        this.mechanismProperties = options.mechanismProperties || {};
        if (this.mechanism.match(/MONGODB-AWS/i)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
            this.mechanismProperties = {
              ...this.mechanismProperties,
              AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
            };
          }
        }
        if ("gssapiCanonicalizeHostName" in this.mechanismProperties) {
          (0, utils_1.emitWarningOnce)("gssapiCanonicalizeHostName is deprecated. Please use CANONICALIZE_HOST_NAME instead.");
          this.mechanismProperties.CANONICALIZE_HOST_NAME = this.mechanismProperties.gssapiCanonicalizeHostName;
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      /** Determines if two MongoCredentials objects are equivalent */
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      /**
       * If the authentication mechanism is set to "default", resolves the authMechanism
       * based on the server version and server supported sasl mechanisms.
       *
       * @param hello - A hello response from the server
       */
      resolveAuthMechanism(hello) {
        if (this.mechanism.match(/DEFAULT/i)) {
          return new _MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(hello),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
      validate() {
        var _a;
        if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_CR || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
          throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
        }
        if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
          if (this.source != null && this.source !== "$external") {
            throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
          }
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
          throw new error_1.MongoAPIError("PLAIN Authentication Mechanism needs an auth source");
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
          if (this.password === "") {
            Reflect.set(this, "password", void 0);
            return;
          }
          throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
        }
        const canonicalization = (_a = this.mechanismProperties.CANONICALIZE_HOST_NAME) !== null && _a !== void 0 ? _a : false;
        if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
          throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
        }
      }
      static merge(creds, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        return new _MongoCredentials({
          username: (_b = (_a = options.username) !== null && _a !== void 0 ? _a : creds === null || creds === void 0 ? void 0 : creds.username) !== null && _b !== void 0 ? _b : "",
          password: (_d = (_c = options.password) !== null && _c !== void 0 ? _c : creds === null || creds === void 0 ? void 0 : creds.password) !== null && _d !== void 0 ? _d : "",
          mechanism: (_f = (_e = options.mechanism) !== null && _e !== void 0 ? _e : creds === null || creds === void 0 ? void 0 : creds.mechanism) !== null && _f !== void 0 ? _f : providers_1.AuthMechanism.MONGODB_DEFAULT,
          mechanismProperties: (_h = (_g = options.mechanismProperties) !== null && _g !== void 0 ? _g : creds === null || creds === void 0 ? void 0 : creds.mechanismProperties) !== null && _h !== void 0 ? _h : {},
          source: (_l = (_k = (_j = options.source) !== null && _j !== void 0 ? _j : options.db) !== null && _k !== void 0 ? _k : creds === null || creds === void 0 ? void 0 : creds.source) !== null && _l !== void 0 ? _l : "admin"
        });
      }
    };
    exports2.MongoCredentials = MongoCredentials;
  }
});

// asset-input/node_modules/mongodb/package.json
var require_package = __commonJS({
  "asset-input/node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      name: "mongodb",
      version: "4.17.2",
      description: "The official MongoDB driver for Node.js",
      main: "lib/index.js",
      files: [
        "lib",
        "src",
        "etc/prepare.js",
        "mongodb.d.ts",
        "tsconfig.json"
      ],
      types: "mongodb.d.ts",
      repository: {
        type: "git",
        url: "git@github.com:mongodb/node-mongodb-native.git"
      },
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      author: {
        name: "The MongoDB NodeJS Team",
        email: "dbx-node@mongodb.com"
      },
      dependencies: {
        bson: "^4.7.2",
        "mongodb-connection-string-url": "^2.6.0",
        socks: "^2.7.1"
      },
      devDependencies: {
        "@iarna/toml": "^2.2.5",
        "@istanbuljs/nyc-config-typescript": "^1.0.2",
        "@microsoft/api-extractor": "^7.34.7",
        "@microsoft/tsdoc-config": "^0.16.2",
        "@mongodb-js/zstd": "^1.1.0",
        "@octokit/core": "^4.2.4",
        "@types/chai": "^4.3.5",
        "@types/chai-subset": "^1.3.3",
        "@types/express": "^4.17.17",
        "@types/kerberos": "^1.1.1",
        "@types/mocha": "^10.0.1",
        "@types/node": "^18.16.3",
        "@types/saslprep": "^1.0.1",
        "@types/semver": "^7.3.13",
        "@types/sinon": "^10.0.14",
        "@types/sinon-chai": "^3.2.9",
        "@types/whatwg-url": "^11.0.0",
        "@typescript-eslint/eslint-plugin": "^5.59.2",
        "@typescript-eslint/parser": "^5.59.2",
        bluebird: "^3.7.2",
        chai: "^4.3.7",
        "chai-subset": "^1.6.0",
        chalk: "^4.1.2",
        eslint: "^8.39.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-import": "^2.27.5",
        "eslint-plugin-prettier": "^4.2.1",
        "eslint-plugin-simple-import-sort": "^8.0.0",
        "eslint-plugin-tsdoc": "^0.2.17",
        express: "^4.18.2",
        "js-yaml": "^4.1.0",
        mocha: "^9.2.2",
        "mocha-sinon": "^2.1.2",
        nyc: "^15.1.0",
        prettier: "^2.8.8",
        semver: "^7.5.0",
        sinon: "^13.0.1",
        "sinon-chai": "^3.7.0",
        "source-map-support": "^0.5.21",
        "standard-version": "^9.5.0",
        "ts-node": "^10.9.1",
        tsd: "^0.27.0",
        typescript: "^4.8.4",
        "typescript-cached-transpile": "^0.0.6",
        "v8-heapsnapshot": "^1.2.0",
        yargs: "^17.7.2"
      },
      license: "Apache-2.0",
      engines: {
        node: ">=12.9.0"
      },
      bugs: {
        url: "https://jira.mongodb.org/projects/NODE/issues/"
      },
      homepage: "https://github.com/mongodb/node-mongodb-native",
      optionalDependencies: {
        "@aws-sdk/credential-providers": "^3.186.0",
        "@mongodb-js/saslprep": "^1.1.0"
      },
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:ts": "node ./node_modules/typescript/bin/tsc",
        "build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs",
        "build:docs": "./etc/docs/build.ts",
        "build:typedoc": "typedoc",
        "check:bench": "node test/benchmarks/driverBench",
        "check:coverage": "nyc npm run test:all",
        "check:integration-coverage": "nyc npm run check:test",
        "check:lambda": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/handler.test.js",
        "check:lambda:aws": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/aws_handler.test.js",
        "check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
        "check:eslint": "eslint -v && eslint --max-warnings=0 --ext '.js,.ts' src test",
        "check:tsd": "tsd --version && tsd",
        "check:dependencies": "mocha test/action/dependency.test.ts",
        "check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
        "check:test": "mocha --config test/mocha_mongodb.json test/integration",
        "check:unit": "mocha test/unit",
        "check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
        "check:atlas": "mocha --config test/manual/mocharc.json test/manual/atlas_connectivity.test.js",
        "check:adl": "mocha --config test/mocha_mongodb.json test/manual/atlas-data-lake-testing",
        "check:aws": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_aws.test.ts",
        "check:ocsp": "mocha --config test/manual/mocharc.json test/manual/ocsp_support.test.js",
        "check:kerberos": "mocha --config test/manual/mocharc.json test/manual/kerberos.test.js",
        "check:tls": "mocha --config test/manual/mocharc.json test/manual/tls_support.test.js",
        "check:ldap": "mocha --config test/manual/mocharc.json test/manual/ldap.test.js",
        "check:socks5": "mocha --config test/manual/mocharc.json test/manual/socks5.test.ts",
        "check:csfle": "mocha --config test/mocha_mongodb.json test/integration/client-side-encryption",
        "check:snappy": "mocha test/unit/assorted/snappy.test.js",
        "fix:eslint": "npm run check:eslint -- --fix",
        prepare: "node etc/prepare.js",
        "preview:docs": "ts-node etc/docs/preview.ts",
        release: "bash etc/check-remote.sh && standard-version -a -i HISTORY.md",
        test: "npm run check:lint && npm run test:all",
        "test:all": "npm run check:unit && npm run check:test",
        "update:docs": "npm run build:docs -- --yes"
      },
      tsd: {
        directory: "test/types",
        compilerOptions: {
          strict: true,
          target: "esnext",
          module: "commonjs",
          moduleResolution: "node"
        }
      }
    };
  }
});

// asset-input/node_modules/mongodb/lib/cmap/handshake/client_metadata.js
var require_client_metadata = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/handshake/client_metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFAASEnv = exports2.makeClientMetadata = exports2.LimitedSizeDocument = void 0;
    var os = require("os");
    var process2 = require("process");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var NODE_DRIVER_VERSION = require_package().version;
    var LimitedSizeDocument = class {
      constructor(maxSize) {
        this.maxSize = maxSize;
        this.document = /* @__PURE__ */ new Map();
        this.documentSize = 5;
      }
      /** Only adds key/value if the bsonByteLength is less than MAX_SIZE */
      ifItFitsItSits(key, value) {
        const newElementSize = bson_1.BSON.serialize((/* @__PURE__ */ new Map()).set(key, value)).byteLength - 5;
        if (newElementSize + this.documentSize > this.maxSize) {
          return false;
        }
        this.documentSize += newElementSize;
        this.document.set(key, value);
        return true;
      }
      toObject() {
        return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
          promoteLongs: false,
          promoteBuffers: false,
          promoteValues: false,
          useBigInt64: false
        });
      }
    };
    exports2.LimitedSizeDocument = LimitedSizeDocument;
    function makeClientMetadata(options) {
      const metadataDocument = new LimitedSizeDocument(512);
      const { appName = "" } = options;
      if (appName.length > 0) {
        const name2 = Buffer.byteLength(appName, "utf8") <= 128 ? options.appName : Buffer.from(appName, "utf8").subarray(0, 128).toString("utf8");
        metadataDocument.ifItFitsItSits("application", { name: name2 });
      }
      const { name = "", version = "", platform = "" } = options.driverInfo;
      const driverInfo = {
        name: name.length > 0 ? `nodejs|${name}` : "nodejs",
        version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
      };
      if (!metadataDocument.ifItFitsItSits("driver", driverInfo)) {
        throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo name and version, metadata cannot exceed 512 bytes");
      }
      let runtimeInfo = getRuntimeInfo();
      if (platform.length > 0) {
        runtimeInfo = `${runtimeInfo}|${platform}`;
      }
      if (!metadataDocument.ifItFitsItSits("platform", runtimeInfo)) {
        throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo platform, metadata cannot exceed 512 bytes");
      }
      const osInfo = (/* @__PURE__ */ new Map()).set("name", process2.platform).set("architecture", process2.arch).set("version", os.release()).set("type", os.type());
      if (!metadataDocument.ifItFitsItSits("os", osInfo)) {
        for (const key of osInfo.keys()) {
          osInfo.delete(key);
          if (osInfo.size === 0)
            break;
          if (metadataDocument.ifItFitsItSits("os", osInfo))
            break;
        }
      }
      const faasEnv = getFAASEnv();
      if (faasEnv != null) {
        if (!metadataDocument.ifItFitsItSits("env", faasEnv)) {
          for (const key of faasEnv.keys()) {
            faasEnv.delete(key);
            if (faasEnv.size === 0)
              break;
            if (metadataDocument.ifItFitsItSits("env", faasEnv))
              break;
          }
        }
      }
      return metadataDocument.toObject();
    }
    exports2.makeClientMetadata = makeClientMetadata;
    function getFAASEnv() {
      const { AWS_EXECUTION_ENV = "", AWS_LAMBDA_RUNTIME_API = "", FUNCTIONS_WORKER_RUNTIME = "", K_SERVICE = "", FUNCTION_NAME = "", VERCEL = "", AWS_LAMBDA_FUNCTION_MEMORY_SIZE = "", AWS_REGION = "", FUNCTION_MEMORY_MB = "", FUNCTION_REGION = "", FUNCTION_TIMEOUT_SEC = "", VERCEL_REGION = "" } = process2.env;
      const isAWSFaaS = AWS_EXECUTION_ENV.startsWith("AWS_Lambda_") || AWS_LAMBDA_RUNTIME_API.length > 0;
      const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
      const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
      const isVercelFaaS = VERCEL.length > 0;
      const faasEnv = /* @__PURE__ */ new Map();
      if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
        if (VERCEL_REGION.length > 0) {
          faasEnv.set("region", VERCEL_REGION);
        }
        faasEnv.set("name", "vercel");
        return faasEnv;
      }
      if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
        if (AWS_REGION.length > 0) {
          faasEnv.set("region", AWS_REGION);
        }
        if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
          faasEnv.set("memory_mb", new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
        }
        faasEnv.set("name", "aws.lambda");
        return faasEnv;
      }
      if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
        faasEnv.set("name", "azure.func");
        return faasEnv;
      }
      if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
        if (FUNCTION_REGION.length > 0) {
          faasEnv.set("region", FUNCTION_REGION);
        }
        if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
          faasEnv.set("memory_mb", new bson_1.Int32(FUNCTION_MEMORY_MB));
        }
        if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
          faasEnv.set("timeout_sec", new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
        }
        faasEnv.set("name", "gcp.func");
        return faasEnv;
      }
      return null;
    }
    exports2.getFAASEnv = getFAASEnv;
    function getRuntimeInfo() {
      var _a, _b;
      if ("Deno" in globalThis) {
        const version = typeof ((_a = Deno === null || Deno === void 0 ? void 0 : Deno.version) === null || _a === void 0 ? void 0 : _a.deno) === "string" ? (_b = Deno === null || Deno === void 0 ? void 0 : Deno.version) === null || _b === void 0 ? void 0 : _b.deno : "0.0.0-unknown";
        return `Deno v${version}, ${os.endianness()}`;
      }
      if ("Bun" in globalThis) {
        const version = typeof (Bun === null || Bun === void 0 ? void 0 : Bun.version) === "string" ? Bun === null || Bun === void 0 ? void 0 : Bun.version : "0.0.0-unknown";
        return `Bun v${version}, ${os.endianness()}`;
      }
      return `Node.js ${process2.version}, ${os.endianness()}`;
    }
  }
});

// asset-input/node_modules/mongodb/lib/cmap/wire_protocol/compression.js
var require_compression = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/wire_protocol/compression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompress = exports2.compress = exports2.uncompressibleCommands = exports2.Compressor = void 0;
    var zlib = require("zlib");
    var constants_1 = require_constants3();
    var deps_1 = require_deps();
    var error_1 = require_error();
    exports2.Compressor = Object.freeze({
      none: 0,
      snappy: 1,
      zlib: 2,
      zstd: 3
    });
    exports2.uncompressibleCommands = /* @__PURE__ */ new Set([
      constants_1.LEGACY_HELLO_COMMAND,
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    var MAX_COMPRESSOR_ID = 3;
    var ZSTD_COMPRESSION_LEVEL = 3;
    function compress(self2, dataToBeCompressed, callback) {
      const zlibOptions = {};
      switch (self2.options.agreedCompressor) {
        case "snappy": {
          if ("kModuleError" in deps_1.Snappy) {
            return callback(deps_1.Snappy["kModuleError"]);
          }
          if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {
            deps_1.Snappy.compress(dataToBeCompressed, callback);
          } else {
            deps_1.Snappy.compress(dataToBeCompressed).then((buffer) => callback(void 0, buffer), (error) => callback(error));
          }
          break;
        }
        case "zlib":
          if (self2.options.zlibCompressionLevel) {
            zlibOptions.level = self2.options.zlibCompressionLevel;
          }
          zlib.deflate(dataToBeCompressed, zlibOptions, callback);
          break;
        case "zstd":
          if ("kModuleError" in deps_1.ZStandard) {
            return callback(deps_1.ZStandard["kModuleError"]);
          }
          deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then((buffer) => callback(void 0, buffer), (error) => callback(error));
          break;
        default:
          throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${self2.options.agreedCompressor} failed to compress`);
      }
    }
    exports2.compress = compress;
    function decompress(compressorID, compressedData, callback) {
      if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {
        throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
      }
      switch (compressorID) {
        case exports2.Compressor.snappy: {
          if ("kModuleError" in deps_1.Snappy) {
            return callback(deps_1.Snappy["kModuleError"]);
          }
          if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {
            deps_1.Snappy.uncompress(compressedData, { asBuffer: true }, callback);
          } else {
            deps_1.Snappy.uncompress(compressedData, { asBuffer: true }).then((buffer) => callback(void 0, buffer), (error) => callback(error));
          }
          break;
        }
        case exports2.Compressor.zstd: {
          if ("kModuleError" in deps_1.ZStandard) {
            return callback(deps_1.ZStandard["kModuleError"]);
          }
          deps_1.ZStandard.decompress(compressedData).then((buffer) => callback(void 0, buffer), (error) => callback(error));
          break;
        }
        case exports2.Compressor.zlib:
          zlib.inflate(compressedData, callback);
          break;
        default:
          callback(void 0, compressedData);
      }
    }
    exports2.decompress = decompress;
  }
});

// asset-input/node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "asset-input/node_modules/mongodb/lib/encrypter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Encrypter = void 0;
    var bson_1 = require_bson2();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var utils_1 = require_utils2();
    var AutoEncrypterClass;
    var kInternalClient = Symbol("internalClient");
    var Encrypter = class {
      constructor(client, uri, options) {
        if (typeof options.autoEncryption !== "object") {
          throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
        }
        this[kInternalClient] = null;
        this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = client;
        } else if (options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
        }
        if (this.bypassAutoEncryption) {
          options.autoEncryption.metadataClient = void 0;
        } else if (options.maxPoolSize === 0) {
          options.autoEncryption.metadataClient = client;
        } else {
          options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
        }
        if (options.proxyHost) {
          options.autoEncryption.proxyOptions = {
            proxyHost: options.proxyHost,
            proxyPort: options.proxyPort,
            proxyUsername: options.proxyUsername,
            proxyPassword: options.proxyPassword
          };
        }
        options.autoEncryption.bson = /* @__PURE__ */ Object.create(null);
        options.autoEncryption.bson.serialize = bson_1.serialize;
        options.autoEncryption.bson.deserialize = bson_1.deserialize;
        this.autoEncrypter = new AutoEncrypterClass(client, options.autoEncryption);
      }
      getInternalClient(client, uri, options) {
        let internalClient = this[kInternalClient];
        if (internalClient == null) {
          const clonedOptions = {};
          for (const key of [
            ...Object.getOwnPropertyNames(options),
            ...Object.getOwnPropertySymbols(options)
          ]) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].includes(key))
              continue;
            Reflect.set(clonedOptions, key, Reflect.get(options, key));
          }
          clonedOptions.minPoolSize = 0;
          internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
          this[kInternalClient] = internalClient;
          for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
            for (const listener of client.listeners(eventName)) {
              internalClient.on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            internalClient === null || internalClient === void 0 ? void 0 : internalClient.on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return internalClient;
      }
      async connectInternalClient() {
        const internalClient = this[kInternalClient];
        if (this.needsConnecting && internalClient != null) {
          this.needsConnecting = false;
          await internalClient.connect();
        }
      }
      close(client, force, callback) {
        this.autoEncrypter.teardown(!!force, (e) => {
          const internalClient = this[kInternalClient];
          if (internalClient != null && client !== internalClient) {
            return internalClient.close(force, callback);
          }
          callback(e);
        });
      }
      static checkForMongoCrypt() {
        const mongodbClientEncryption = (0, utils_1.getMongoDBClientEncryption)();
        if (mongodbClientEncryption == null) {
          throw new error_1.MongoMissingDependencyError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
        }
        AutoEncrypterClass = mongodbClientEncryption.extension(require_lib3()).AutoEncrypter;
      }
    };
    exports2.Encrypter = Encrypter;
  }
});

// asset-input/node_modules/mongodb/lib/mongo_logger.js
var require_mongo_logger = __commonJS({
  "asset-input/node_modules/mongodb/lib/mongo_logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoLogger = exports2.MongoLoggableComponent = exports2.SeverityLevel = void 0;
    var stream_1 = require("stream");
    var utils_1 = require_utils2();
    exports2.SeverityLevel = Object.freeze({
      EMERGENCY: "emergency",
      ALERT: "alert",
      CRITICAL: "critical",
      ERROR: "error",
      WARNING: "warn",
      NOTICE: "notice",
      INFORMATIONAL: "info",
      DEBUG: "debug",
      TRACE: "trace",
      OFF: "off"
    });
    exports2.MongoLoggableComponent = Object.freeze({
      COMMAND: "command",
      TOPOLOGY: "topology",
      SERVER_SELECTION: "serverSelection",
      CONNECTION: "connection"
    });
    function parseSeverityFromString(s) {
      const validSeverities = Object.values(exports2.SeverityLevel);
      const lowerSeverity = s === null || s === void 0 ? void 0 : s.toLowerCase();
      if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
        return lowerSeverity;
      }
      return null;
    }
    function resolveLogPath({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
      const isValidLogDestinationString = (destination) => ["stdout", "stderr"].includes(destination.toLowerCase());
      if (typeof mongodbLogPath === "string" && isValidLogDestinationString(mongodbLogPath)) {
        return mongodbLogPath.toLowerCase() === "stderr" ? process.stderr : process.stdout;
      }
      if (typeof mongodbLogPath === "object" && mongodbLogPath instanceof stream_1.Writable) {
        return mongodbLogPath;
      }
      if (typeof MONGODB_LOG_PATH === "string" && isValidLogDestinationString(MONGODB_LOG_PATH)) {
        return MONGODB_LOG_PATH.toLowerCase() === "stderr" ? process.stderr : process.stdout;
      }
      return process.stderr;
    }
    var MongoLogger = class {
      constructor(options) {
        this.componentSeverities = options.componentSeverities;
        this.maxDocumentLength = options.maxDocumentLength;
        this.logDestination = options.logDestination;
      }
      /* eslint-disable @typescript-eslint/no-unused-vars */
      /* eslint-disable @typescript-eslint/no-empty-function */
      emergency(component, message) {
      }
      alert(component, message) {
      }
      critical(component, message) {
      }
      error(component, message) {
      }
      warn(component, message) {
      }
      notice(component, message) {
      }
      info(component, message) {
      }
      debug(component, message) {
      }
      trace(component, message) {
      }
      /**
       * Merges options set through environment variables and the MongoClient, preferring environment
       * variables when both are set, and substituting defaults for values not set. Options set in
       * constructor take precedence over both environment variables and MongoClient options.
       *
       * @remarks
       * When parsing component severity levels, invalid values are treated as unset and replaced with
       * the default severity.
       *
       * @param envOptions - options set for the logger from the environment
       * @param clientOptions - options set for the logger in the MongoClient options
       * @returns a MongoLoggerOptions object to be used when instantiating a new MongoLogger
       */
      static resolveOptions(envOptions, clientOptions) {
        var _a, _b, _c, _d, _e, _f;
        const combinedOptions = {
          ...envOptions,
          ...clientOptions,
          mongodbLogPath: resolveLogPath(envOptions, clientOptions)
        };
        const defaultSeverity = (_a = parseSeverityFromString(combinedOptions.MONGODB_LOG_ALL)) !== null && _a !== void 0 ? _a : exports2.SeverityLevel.OFF;
        return {
          componentSeverities: {
            command: (_b = parseSeverityFromString(combinedOptions.MONGODB_LOG_COMMAND)) !== null && _b !== void 0 ? _b : defaultSeverity,
            topology: (_c = parseSeverityFromString(combinedOptions.MONGODB_LOG_TOPOLOGY)) !== null && _c !== void 0 ? _c : defaultSeverity,
            serverSelection: (_d = parseSeverityFromString(combinedOptions.MONGODB_LOG_SERVER_SELECTION)) !== null && _d !== void 0 ? _d : defaultSeverity,
            connection: (_e = parseSeverityFromString(combinedOptions.MONGODB_LOG_CONNECTION)) !== null && _e !== void 0 ? _e : defaultSeverity,
            default: defaultSeverity
          },
          maxDocumentLength: (_f = (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH)) !== null && _f !== void 0 ? _f : 1e3,
          logDestination: combinedOptions.mongodbLogPath
        };
      }
    };
    exports2.MongoLogger = MongoLogger;
  }
});

// asset-input/node_modules/mongodb/lib/connection_string.js
var require_connection_string = __commonJS({
  "asset-input/node_modules/mongodb/lib/connection_string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FEATURE_FLAGS = exports2.DEFAULT_OPTIONS = exports2.OPTIONS = exports2.parseOptions = exports2.resolveSRVRecord = void 0;
    var dns = require("dns");
    var fs = require("fs");
    var mongodb_connection_string_url_1 = require_lib2();
    var url_1 = require("url");
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var client_metadata_1 = require_client_metadata();
    var compression_1 = require_compression();
    var encrypter_1 = require_encrypter();
    var error_1 = require_error();
    var logger_1 = require_logger();
    var mongo_client_1 = require_mongo_client();
    var mongo_logger_1 = require_mongo_logger();
    var promise_provider_1 = require_promise_provider();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils2();
    var write_concern_1 = require_write_concern();
    var VALID_TXT_RECORDS = ["authSource", "replicaSet", "loadBalanced"];
    var LB_SINGLE_HOST_ERROR = "loadBalanced option only supported with a single host in the URI";
    var LB_REPLICA_SET_ERROR = "loadBalanced option not supported with a replicaSet option";
    var LB_DIRECT_CONNECTION_ERROR = "loadBalanced option not supported when directConnection is provided";
    async function resolveSRVRecord(options) {
      var _a, _b, _c;
      if (typeof options.srvHost !== "string") {
        throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
      }
      if (options.srvHost.split(".").length < 3) {
        throw new error_1.MongoAPIError("URI must include hostname, domain name, and tld");
      }
      const lookupAddress = options.srvHost;
      const addresses = await dns.promises.resolveSrv(`_${options.srvServiceName}._tcp.${lookupAddress}`);
      if (addresses.length === 0) {
        throw new error_1.MongoAPIError("No addresses found at host");
      }
      for (const { name } of addresses) {
        if (!(0, utils_1.matchesParentDomain)(name, lookupAddress)) {
          throw new error_1.MongoAPIError("Server record does not share hostname with parent URI");
        }
      }
      const hostAddresses = addresses.map((r) => {
        var _a2;
        return utils_1.HostAddress.fromString(`${r.name}:${(_a2 = r.port) !== null && _a2 !== void 0 ? _a2 : 27017}`);
      });
      validateLoadBalancedOptions(hostAddresses, options, true);
      let record;
      try {
        record = await dns.promises.resolveTxt(lookupAddress);
      } catch (error) {
        if (error.code !== "ENODATA" && error.code !== "ENOTFOUND") {
          throw error;
        }
        return hostAddresses;
      }
      if (record.length > 1) {
        throw new error_1.MongoParseError("Multiple text records not allowed");
      }
      const txtRecordOptions = new url_1.URLSearchParams(record[0].join(""));
      const txtRecordOptionKeys = [...txtRecordOptions.keys()];
      if (txtRecordOptionKeys.some((key) => !VALID_TXT_RECORDS.includes(key))) {
        throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(", ")}`);
      }
      if (VALID_TXT_RECORDS.some((option) => txtRecordOptions.get(option) === "")) {
        throw new error_1.MongoParseError("Cannot have empty URI params in DNS TXT Record");
      }
      const source = (_a = txtRecordOptions.get("authSource")) !== null && _a !== void 0 ? _a : void 0;
      const replicaSet = (_b = txtRecordOptions.get("replicaSet")) !== null && _b !== void 0 ? _b : void 0;
      const loadBalanced = (_c = txtRecordOptions.get("loadBalanced")) !== null && _c !== void 0 ? _c : void 0;
      if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
        options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
      }
      if (!options.userSpecifiedReplicaSet && replicaSet) {
        options.replicaSet = replicaSet;
      }
      if (loadBalanced === "true") {
        options.loadBalanced = true;
      }
      if (options.replicaSet && options.srvMaxHosts > 0) {
        throw new error_1.MongoParseError("Cannot combine replicaSet option with srvMaxHosts");
      }
      validateLoadBalancedOptions(hostAddresses, options, true);
      return hostAddresses;
    }
    exports2.resolveSRVRecord = resolveSRVRecord;
    function checkTLSOptions(allOptions) {
      if (!allOptions)
        return;
      const check = (a, b) => {
        if (allOptions.has(a) && allOptions.has(b)) {
          throw new error_1.MongoAPIError(`The '${a}' option cannot be used with the '${b}' option`);
        }
      };
      check("tlsInsecure", "tlsAllowInvalidCertificates");
      check("tlsInsecure", "tlsAllowInvalidHostnames");
      check("tlsInsecure", "tlsDisableCertificateRevocationCheck");
      check("tlsInsecure", "tlsDisableOCSPEndpointCheck");
      check("tlsAllowInvalidCertificates", "tlsDisableCertificateRevocationCheck");
      check("tlsAllowInvalidCertificates", "tlsDisableOCSPEndpointCheck");
      check("tlsDisableCertificateRevocationCheck", "tlsDisableOCSPEndpointCheck");
    }
    var TRUTHS = /* @__PURE__ */ new Set(["true", "t", "1", "y", "yes"]);
    var FALSEHOODS = /* @__PURE__ */ new Set(["false", "f", "0", "n", "no", "-1"]);
    function getBoolean(name, value) {
      if (typeof value === "boolean")
        return value;
      const valueString = String(value).toLowerCase();
      if (TRUTHS.has(valueString)) {
        if (valueString !== "true") {
          (0, utils_1.emitWarningOnce)(`deprecated value for ${name} : ${valueString} - please update to ${name} : true instead`);
        }
        return true;
      }
      if (FALSEHOODS.has(valueString)) {
        if (valueString !== "false") {
          (0, utils_1.emitWarningOnce)(`deprecated value for ${name} : ${valueString} - please update to ${name} : false instead`);
        }
        return false;
      }
      throw new error_1.MongoParseError(`Expected ${name} to be stringified boolean value, got: ${value}`);
    }
    function getIntFromOptions(name, value) {
      const parsedInt = (0, utils_1.parseInteger)(value);
      if (parsedInt != null) {
        return parsedInt;
      }
      throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value}`);
    }
    function getUIntFromOptions(name, value) {
      const parsedValue = getIntFromOptions(name, value);
      if (parsedValue < 0) {
        throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value}`);
      }
      return parsedValue;
    }
    function* entriesFromString(value) {
      const keyValuePairs = value.split(",");
      for (const keyValue of keyValuePairs) {
        const [key, value2] = keyValue.split(":");
        if (value2 == null) {
          throw new error_1.MongoParseError("Cannot have undefined values in key value pairs");
        }
        yield [key, value2];
      }
    }
    var CaseInsensitiveMap = class extends Map {
      constructor(entries = []) {
        super(entries.map(([k, v]) => [k.toLowerCase(), v]));
      }
      has(k) {
        return super.has(k.toLowerCase());
      }
      get(k) {
        return super.get(k.toLowerCase());
      }
      set(k, v) {
        return super.set(k.toLowerCase(), v);
      }
      delete(k) {
        return super.delete(k.toLowerCase());
      }
    };
    function parseOptions(uri, mongoClient = void 0, options = {}) {
      var _a;
      if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
        options = mongoClient;
        mongoClient = void 0;
      }
      const url = new mongodb_connection_string_url_1.default(uri);
      const { hosts, isSRV } = url;
      const mongoOptions = /* @__PURE__ */ Object.create(null);
      for (const flag of Object.getOwnPropertySymbols(options)) {
        if (exports2.FEATURE_FLAGS.has(flag)) {
          mongoOptions[flag] = options[flag];
        }
      }
      mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
      const urlOptions = new CaseInsensitiveMap();
      if (url.pathname !== "/" && url.pathname !== "") {
        const dbName = decodeURIComponent(url.pathname[0] === "/" ? url.pathname.slice(1) : url.pathname);
        if (dbName) {
          urlOptions.set("dbName", [dbName]);
        }
      }
      if (url.username !== "") {
        const auth = {
          username: decodeURIComponent(url.username)
        };
        if (typeof url.password === "string") {
          auth.password = decodeURIComponent(url.password);
        }
        urlOptions.set("auth", [auth]);
      }
      for (const key of url.searchParams.keys()) {
        const values = [...url.searchParams.getAll(key)];
        if (values.includes("")) {
          throw new error_1.MongoAPIError("URI cannot contain options with no value");
        }
        if (!urlOptions.has(key)) {
          urlOptions.set(key, values);
        }
      }
      const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v]) => v != null));
      if (urlOptions.has("serverApi")) {
        throw new error_1.MongoParseError("URI cannot contain `serverApi`, it can only be passed to the client");
      }
      if (objectOptions.has("loadBalanced")) {
        throw new error_1.MongoParseError("loadBalanced is only a valid option in the URI");
      }
      const allOptions = new CaseInsensitiveMap();
      const allKeys = /* @__PURE__ */ new Set([
        ...urlOptions.keys(),
        ...objectOptions.keys(),
        ...exports2.DEFAULT_OPTIONS.keys()
      ]);
      for (const key of allKeys) {
        const values = [];
        const objectOptionValue = objectOptions.get(key);
        if (objectOptionValue != null) {
          values.push(objectOptionValue);
        }
        const urlValue = urlOptions.get(key);
        if (urlValue != null) {
          values.push(...urlValue);
        }
        const defaultOptionsValue = exports2.DEFAULT_OPTIONS.get(key);
        if (defaultOptionsValue != null) {
          values.push(defaultOptionsValue);
        }
        allOptions.set(key, values);
      }
      if (allOptions.has("tlsCertificateKeyFile") && !allOptions.has("tlsCertificateFile")) {
        allOptions.set("tlsCertificateFile", allOptions.get("tlsCertificateKeyFile"));
      }
      if (allOptions.has("tls") || allOptions.has("ssl")) {
        const tlsAndSslOpts = (allOptions.get("tls") || []).concat(allOptions.get("ssl") || []).map(getBoolean.bind(null, "tls/ssl"));
        if (new Set(tlsAndSslOpts).size !== 1) {
          throw new error_1.MongoParseError("All values of tls/ssl must be the same.");
        }
      }
      checkTLSOptions(allOptions);
      const unsupportedOptions = (0, utils_1.setDifference)(allKeys, Array.from(Object.keys(exports2.OPTIONS)).map((s) => s.toLowerCase()));
      if (unsupportedOptions.size !== 0) {
        const optionWord = unsupportedOptions.size > 1 ? "options" : "option";
        const isOrAre = unsupportedOptions.size > 1 ? "are" : "is";
        throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(", ")} ${isOrAre} not supported`);
      }
      for (const [key, descriptor] of Object.entries(exports2.OPTIONS)) {
        const values = allOptions.get(key);
        if (!values || values.length === 0)
          continue;
        setOption(mongoOptions, key, descriptor, values);
      }
      if (mongoOptions.credentials) {
        const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
        const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
        const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
        if ((isGssapi || isX509) && allOptions.has("authSource") && mongoOptions.credentials.source !== "$external") {
          throw new error_1.MongoParseError(`${mongoOptions.credentials} can only have authSource set to '$external'`);
        }
        if (!(isGssapi || isX509 || isAws) && mongoOptions.dbName && !allOptions.has("authSource")) {
          mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
            source: mongoOptions.dbName
          });
        }
        if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
          throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
        }
        mongoOptions.credentials.validate();
        if (mongoOptions.credentials.password === "" && mongoOptions.credentials.username === "" && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
          delete mongoOptions.credentials;
        }
      }
      if (!mongoOptions.dbName) {
        mongoOptions.dbName = "test";
      }
      if (options.promiseLibrary) {
        promise_provider_1.PromiseProvider.set(options.promiseLibrary);
      }
      validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
      if (mongoClient && mongoOptions.autoEncryption) {
        encrypter_1.Encrypter.checkForMongoCrypt();
        mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
        mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
      }
      mongoOptions.userSpecifiedAuthSource = objectOptions.has("authSource") || urlOptions.has("authSource");
      mongoOptions.userSpecifiedReplicaSet = objectOptions.has("replicaSet") || urlOptions.has("replicaSet");
      if (isSRV) {
        mongoOptions.srvHost = hosts[0];
        if (mongoOptions.directConnection) {
          throw new error_1.MongoAPIError("SRV URI does not support directConnection");
        }
        if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === "string") {
          throw new error_1.MongoParseError("Cannot use srvMaxHosts option with replicaSet");
        }
        const noUserSpecifiedTLS = !objectOptions.has("tls") && !urlOptions.has("tls");
        const noUserSpecifiedSSL = !objectOptions.has("ssl") && !urlOptions.has("ssl");
        if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
          mongoOptions.tls = true;
        }
      } else {
        const userSpecifiedSrvOptions = urlOptions.has("srvMaxHosts") || objectOptions.has("srvMaxHosts") || urlOptions.has("srvServiceName") || objectOptions.has("srvServiceName");
        if (userSpecifiedSrvOptions) {
          throw new error_1.MongoParseError("Cannot use srvMaxHosts or srvServiceName with a non-srv connection string");
        }
      }
      if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
        throw new error_1.MongoParseError("directConnection option requires exactly one host");
      }
      if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
        throw new error_1.MongoParseError("Must specify proxyHost if other proxy options are passed");
      }
      if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
        throw new error_1.MongoParseError("Can only specify both of proxy username/password or neither");
      }
      const proxyOptions = ["proxyHost", "proxyPort", "proxyUsername", "proxyPassword"].map((key) => {
        var _a2;
        return (_a2 = urlOptions.get(key)) !== null && _a2 !== void 0 ? _a2 : [];
      });
      if (proxyOptions.some((options2) => options2.length > 1)) {
        throw new error_1.MongoParseError("Proxy options cannot be specified multiple times in the connection string");
      }
      const loggerFeatureFlag = Symbol.for("@@mdb.enableMongoLogger");
      mongoOptions[loggerFeatureFlag] = (_a = mongoOptions[loggerFeatureFlag]) !== null && _a !== void 0 ? _a : false;
      let loggerEnvOptions = {};
      let loggerClientOptions = {};
      if (mongoOptions[loggerFeatureFlag]) {
        loggerEnvOptions = {
          MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
          MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
          MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
          MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
          MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
          MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
          MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH
        };
        loggerClientOptions = {
          mongodbLogPath: mongoOptions.mongodbLogPath
        };
      }
      mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions(loggerEnvOptions, loggerClientOptions);
      mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
      return mongoOptions;
    }
    exports2.parseOptions = parseOptions;
    function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
      if (mongoOptions.loadBalanced) {
        if (hosts.length > 1) {
          throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
        }
        if (mongoOptions.replicaSet) {
          throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
        }
        if (mongoOptions.directConnection) {
          throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
        }
        if (isSrv && mongoOptions.srvMaxHosts > 0) {
          throw new error_1.MongoParseError("Cannot limit srv hosts with loadBalanced enabled");
        }
      }
      return;
    }
    function setOption(mongoOptions, key, descriptor, values) {
      const { target, type, transform, deprecated } = descriptor;
      const name = target !== null && target !== void 0 ? target : key;
      if (deprecated) {
        const deprecatedMsg = typeof deprecated === "string" ? `: ${deprecated}` : "";
        (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
      }
      switch (type) {
        case "boolean":
          mongoOptions[name] = getBoolean(name, values[0]);
          break;
        case "int":
          mongoOptions[name] = getIntFromOptions(name, values[0]);
          break;
        case "uint":
          mongoOptions[name] = getUIntFromOptions(name, values[0]);
          break;
        case "string":
          if (values[0] == null) {
            break;
          }
          mongoOptions[name] = String(values[0]);
          break;
        case "record":
          if (!(0, utils_1.isRecord)(values[0])) {
            throw new error_1.MongoParseError(`${name} must be an object`);
          }
          mongoOptions[name] = values[0];
          break;
        case "any":
          mongoOptions[name] = values[0];
          break;
        default: {
          if (!transform) {
            throw new error_1.MongoParseError("Descriptors missing a type must define a transform");
          }
          const transformValue = transform({ name, options: mongoOptions, values });
          mongoOptions[name] = transformValue;
          break;
        }
      }
    }
    exports2.OPTIONS = {
      appName: {
        type: "string"
      },
      auth: {
        target: "credentials",
        transform({ name, options, values: [value] }) {
          if (!(0, utils_1.isRecord)(value, ["username", "password"])) {
            throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
          }
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
            username: value.username,
            password: value.password
          });
        }
      },
      authMechanism: {
        target: "credentials",
        transform({ options, values: [value] }) {
          var _a, _b;
          const mechanisms = Object.values(providers_1.AuthMechanism);
          const [mechanism] = mechanisms.filter((m) => m.match(RegExp(String.raw`\b${value}\b`, "i")));
          if (!mechanism) {
            throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value}`);
          }
          let source = (_a = options.credentials) === null || _a === void 0 ? void 0 : _a.source;
          if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
            source = "$external";
          }
          let password = (_b = options.credentials) === null || _b === void 0 ? void 0 : _b.password;
          if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === "") {
            password = void 0;
          }
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
            mechanism,
            source,
            password
          });
        }
      },
      authMechanismProperties: {
        target: "credentials",
        transform({ options, values: [optionValue] }) {
          if (typeof optionValue === "string") {
            const mechanismProperties = /* @__PURE__ */ Object.create(null);
            for (const [key, value] of entriesFromString(optionValue)) {
              try {
                mechanismProperties[key] = getBoolean(key, value);
              } catch {
                mechanismProperties[key] = value;
              }
            }
            return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
              mechanismProperties
            });
          }
          if (!(0, utils_1.isRecord)(optionValue)) {
            throw new error_1.MongoParseError("AuthMechanismProperties must be an object");
          }
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, { mechanismProperties: optionValue });
        }
      },
      authSource: {
        target: "credentials",
        transform({ options, values: [value] }) {
          const source = String(value);
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
        }
      },
      autoEncryption: {
        type: "record"
      },
      bsonRegExp: {
        type: "boolean"
      },
      serverApi: {
        target: "serverApi",
        transform({ values: [version] }) {
          const serverApiToValidate = typeof version === "string" ? { version } : version;
          const versionToValidate = serverApiToValidate && serverApiToValidate.version;
          if (!versionToValidate) {
            throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
          }
          if (!Object.values(mongo_client_1.ServerApiVersion).some((v) => v === versionToValidate)) {
            throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
          }
          return serverApiToValidate;
        }
      },
      checkKeys: {
        type: "boolean"
      },
      compressors: {
        default: "none",
        target: "compressors",
        transform({ values }) {
          const compressionList = /* @__PURE__ */ new Set();
          for (const compVal of values) {
            const compValArray = typeof compVal === "string" ? compVal.split(",") : compVal;
            if (!Array.isArray(compValArray)) {
              throw new error_1.MongoInvalidArgumentError("compressors must be an array or a comma-delimited list of strings");
            }
            for (const c of compValArray) {
              if (Object.keys(compression_1.Compressor).includes(String(c))) {
                compressionList.add(String(c));
              } else {
                throw new error_1.MongoInvalidArgumentError(`${c} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
              }
            }
          }
          return [...compressionList];
        }
      },
      connectTimeoutMS: {
        default: 3e4,
        type: "uint"
      },
      dbName: {
        type: "string"
      },
      directConnection: {
        default: false,
        type: "boolean"
      },
      driverInfo: {
        default: {},
        type: "record"
      },
      enableUtf8Validation: { type: "boolean", default: true },
      family: {
        transform({ name, values: [value] }) {
          const transformValue = getIntFromOptions(name, value);
          if (transformValue === 4 || transformValue === 6) {
            return transformValue;
          }
          throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
        }
      },
      fieldsAsRaw: {
        type: "record"
      },
      forceServerObjectId: {
        default: false,
        type: "boolean"
      },
      fsync: {
        deprecated: "Please use journal instead",
        target: "writeConcern",
        transform({ name, options, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              fsync: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value}`);
          return wc;
        }
      },
      heartbeatFrequencyMS: {
        default: 1e4,
        type: "uint"
      },
      ignoreUndefined: {
        type: "boolean"
      },
      j: {
        deprecated: "Please use journal instead",
        target: "writeConcern",
        transform({ name, options, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              journal: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
          return wc;
        }
      },
      journal: {
        target: "writeConcern",
        transform({ name, options, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              journal: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
          return wc;
        }
      },
      keepAlive: {
        default: true,
        type: "boolean"
      },
      keepAliveInitialDelay: {
        default: 12e4,
        type: "uint"
      },
      loadBalanced: {
        default: false,
        type: "boolean"
      },
      localThresholdMS: {
        default: 15,
        type: "uint"
      },
      logger: {
        default: new logger_1.Logger("MongoClient"),
        transform({ values: [value] }) {
          if (value instanceof logger_1.Logger) {
            return value;
          }
          (0, utils_1.emitWarning)("Alternative loggers might not be supported");
          return;
        }
      },
      loggerLevel: {
        target: "logger",
        transform({ values: [value] }) {
          return new logger_1.Logger("MongoClient", { loggerLevel: value });
        }
      },
      maxConnecting: {
        default: 2,
        transform({ name, values: [value] }) {
          const maxConnecting = getUIntFromOptions(name, value);
          if (maxConnecting === 0) {
            throw new error_1.MongoInvalidArgumentError("maxConnecting must be > 0 if specified");
          }
          return maxConnecting;
        }
      },
      maxIdleTimeMS: {
        default: 0,
        type: "uint"
      },
      maxPoolSize: {
        default: 100,
        type: "uint"
      },
      maxStalenessSeconds: {
        target: "readPreference",
        transform({ name, options, values: [value] }) {
          const maxStalenessSeconds = getUIntFromOptions(name, value);
          if (options.readPreference) {
            return read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options.readPreference, maxStalenessSeconds }
            });
          } else {
            return new read_preference_1.ReadPreference("secondary", void 0, { maxStalenessSeconds });
          }
        }
      },
      minInternalBufferSize: {
        type: "uint"
      },
      minPoolSize: {
        default: 0,
        type: "uint"
      },
      minHeartbeatFrequencyMS: {
        default: 500,
        type: "uint"
      },
      monitorCommands: {
        default: false,
        type: "boolean"
      },
      name: {
        target: "driverInfo",
        transform({ values: [value], options }) {
          return { ...options.driverInfo, name: String(value) };
        }
      },
      noDelay: {
        default: true,
        type: "boolean"
      },
      pkFactory: {
        default: utils_1.DEFAULT_PK_FACTORY,
        transform({ values: [value] }) {
          if ((0, utils_1.isRecord)(value, ["createPk"]) && typeof value.createPk === "function") {
            return value;
          }
          throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value}`);
        }
      },
      promiseLibrary: {
        deprecated: true,
        type: "any"
      },
      promoteBuffers: {
        type: "boolean"
      },
      promoteLongs: {
        type: "boolean"
      },
      promoteValues: {
        type: "boolean"
      },
      proxyHost: {
        type: "string"
      },
      proxyPassword: {
        type: "string"
      },
      proxyPort: {
        type: "uint"
      },
      proxyUsername: {
        type: "string"
      },
      raw: {
        default: false,
        type: "boolean"
      },
      readConcern: {
        transform({ values: [value], options }) {
          if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ["level"])) {
            return read_concern_1.ReadConcern.fromOptions({ ...options.readConcern, ...value });
          }
          throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value)}`);
        }
      },
      readConcernLevel: {
        target: "readConcern",
        transform({ values: [level], options }) {
          return read_concern_1.ReadConcern.fromOptions({
            ...options.readConcern,
            level
          });
        }
      },
      readPreference: {
        default: read_preference_1.ReadPreference.primary,
        transform({ values: [value], options }) {
          var _a, _b, _c;
          if (value instanceof read_preference_1.ReadPreference) {
            return read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options.readPreference, ...value },
              ...value
            });
          }
          if ((0, utils_1.isRecord)(value, ["mode"])) {
            const rp = read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options.readPreference, ...value },
              ...value
            });
            if (rp)
              return rp;
            else
              throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value)}`);
          }
          if (typeof value === "string") {
            const rpOpts = {
              hedge: (_a = options.readPreference) === null || _a === void 0 ? void 0 : _a.hedge,
              maxStalenessSeconds: (_b = options.readPreference) === null || _b === void 0 ? void 0 : _b.maxStalenessSeconds
            };
            return new read_preference_1.ReadPreference(value, (_c = options.readPreference) === null || _c === void 0 ? void 0 : _c.tags, rpOpts);
          }
          throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value}`);
        }
      },
      readPreferenceTags: {
        target: "readPreference",
        transform({ values, options }) {
          const tags = Array.isArray(values[0]) ? values[0] : values;
          const readPreferenceTags = [];
          for (const tag of tags) {
            const readPreferenceTag = /* @__PURE__ */ Object.create(null);
            if (typeof tag === "string") {
              for (const [k, v] of entriesFromString(tag)) {
                readPreferenceTag[k] = v;
              }
            }
            if ((0, utils_1.isRecord)(tag)) {
              for (const [k, v] of Object.entries(tag)) {
                readPreferenceTag[k] = v;
              }
            }
            readPreferenceTags.push(readPreferenceTag);
          }
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: options.readPreference,
            readPreferenceTags
          });
        }
      },
      replicaSet: {
        type: "string"
      },
      retryReads: {
        default: true,
        type: "boolean"
      },
      retryWrites: {
        default: true,
        type: "boolean"
      },
      serializeFunctions: {
        type: "boolean"
      },
      serverSelectionTimeoutMS: {
        default: 3e4,
        type: "uint"
      },
      servername: {
        type: "string"
      },
      socketTimeoutMS: {
        default: 0,
        type: "uint"
      },
      srvMaxHosts: {
        type: "uint",
        default: 0
      },
      srvServiceName: {
        type: "string",
        default: "mongodb"
      },
      ssl: {
        target: "tls",
        type: "boolean"
      },
      sslCA: {
        target: "ca",
        transform({ values: [value] }) {
          return fs.readFileSync(String(value), { encoding: "ascii" });
        }
      },
      sslCRL: {
        target: "crl",
        transform({ values: [value] }) {
          return fs.readFileSync(String(value), { encoding: "ascii" });
        }
      },
      sslCert: {
        target: "cert",
        transform({ values: [value] }) {
          return fs.readFileSync(String(value), { encoding: "ascii" });
        }
      },
      sslKey: {
        target: "key",
        transform({ values: [value] }) {
          return fs.readFileSync(String(value), { encoding: "ascii" });
        }
      },
      sslPass: {
        deprecated: true,
        target: "passphrase",
        type: "string"
      },
      sslValidate: {
        target: "rejectUnauthorized",
        type: "boolean"
      },
      tls: {
        type: "boolean"
      },
      tlsAllowInvalidCertificates: {
        target: "rejectUnauthorized",
        transform({ name, values: [value] }) {
          return !getBoolean(name, value);
        }
      },
      tlsAllowInvalidHostnames: {
        target: "checkServerIdentity",
        transform({ name, values: [value] }) {
          return getBoolean(name, value) ? () => void 0 : void 0;
        }
      },
      tlsCAFile: {
        target: "ca",
        transform({ values: [value] }) {
          return fs.readFileSync(String(value), { encoding: "ascii" });
        }
      },
      tlsCertificateFile: {
        target: "cert",
        transform({ values: [value] }) {
          return fs.readFileSync(String(value), { encoding: "ascii" });
        }
      },
      tlsCertificateKeyFile: {
        target: "key",
        transform({ values: [value] }) {
          return fs.readFileSync(String(value), { encoding: "ascii" });
        }
      },
      tlsCertificateKeyFilePassword: {
        target: "passphrase",
        type: "any"
      },
      tlsInsecure: {
        transform({ name, options, values: [value] }) {
          const tlsInsecure = getBoolean(name, value);
          if (tlsInsecure) {
            options.checkServerIdentity = () => void 0;
            options.rejectUnauthorized = false;
          } else {
            options.checkServerIdentity = options.tlsAllowInvalidHostnames ? () => void 0 : void 0;
            options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
          }
          return tlsInsecure;
        }
      },
      w: {
        target: "writeConcern",
        transform({ values: [value], options }) {
          return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options.writeConcern, w: value } });
        }
      },
      waitQueueTimeoutMS: {
        default: 0,
        type: "uint"
      },
      writeConcern: {
        target: "writeConcern",
        transform({ values: [value], options }) {
          if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
            return write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...options.writeConcern,
                ...value
              }
            });
          } else if (value === "majority" || typeof value === "number") {
            return write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...options.writeConcern,
                w: value
              }
            });
          }
          throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value)}`);
        }
      },
      wtimeout: {
        deprecated: "Please use wtimeoutMS instead",
        target: "writeConcern",
        transform({ values: [value], options }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              wtimeout: getUIntFromOptions("wtimeout", value)
            }
          });
          if (wc)
            return wc;
          throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
        }
      },
      wtimeoutMS: {
        target: "writeConcern",
        transform({ values: [value], options }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              wtimeoutMS: getUIntFromOptions("wtimeoutMS", value)
            }
          });
          if (wc)
            return wc;
          throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
        }
      },
      zlibCompressionLevel: {
        default: 0,
        type: "int"
      },
      // Custom types for modifying core behavior
      connectionType: { type: "any" },
      srvPoller: { type: "any" },
      // Accepted NodeJS Options
      minDHSize: { type: "any" },
      pskCallback: { type: "any" },
      secureContext: { type: "any" },
      enableTrace: { type: "any" },
      requestCert: { type: "any" },
      rejectUnauthorized: { type: "any" },
      checkServerIdentity: { type: "any" },
      ALPNProtocols: { type: "any" },
      SNICallback: { type: "any" },
      session: { type: "any" },
      requestOCSP: { type: "any" },
      localAddress: { type: "any" },
      localPort: { type: "any" },
      hints: { type: "any" },
      lookup: { type: "any" },
      ca: { type: "any" },
      cert: { type: "any" },
      ciphers: { type: "any" },
      crl: { type: "any" },
      ecdhCurve: { type: "any" },
      key: { type: "any" },
      passphrase: { type: "any" },
      pfx: { type: "any" },
      secureProtocol: { type: "any" },
      index: { type: "any" },
      // Legacy Options, these are unused but left here to avoid errors with CSFLE lib
      useNewUrlParser: { type: "boolean" },
      useUnifiedTopology: { type: "boolean" }
    };
    exports2.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports2.OPTIONS).filter(([, descriptor]) => descriptor.default != null).map(([k, d]) => [k, d.default]));
    exports2.FEATURE_FLAGS = /* @__PURE__ */ new Set([
      Symbol.for("@@mdb.skipPingOnConnect"),
      Symbol.for("@@mdb.enableMongoLogger")
    ]);
  }
});

// asset-input/node_modules/mongodb/lib/sdam/events.js
var require_events = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerHeartbeatFailedEvent = exports2.ServerHeartbeatSucceededEvent = exports2.ServerHeartbeatStartedEvent = exports2.TopologyClosedEvent = exports2.TopologyOpeningEvent = exports2.TopologyDescriptionChangedEvent = exports2.ServerClosedEvent = exports2.ServerOpeningEvent = exports2.ServerDescriptionChangedEvent = void 0;
    var ServerDescriptionChangedEvent = class {
      /** @internal */
      constructor(topologyId, address, previousDescription, newDescription) {
        this.topologyId = topologyId;
        this.address = address;
        this.previousDescription = previousDescription;
        this.newDescription = newDescription;
      }
    };
    exports2.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;
    var ServerOpeningEvent = class {
      /** @internal */
      constructor(topologyId, address) {
        this.topologyId = topologyId;
        this.address = address;
      }
    };
    exports2.ServerOpeningEvent = ServerOpeningEvent;
    var ServerClosedEvent = class {
      /** @internal */
      constructor(topologyId, address) {
        this.topologyId = topologyId;
        this.address = address;
      }
    };
    exports2.ServerClosedEvent = ServerClosedEvent;
    var TopologyDescriptionChangedEvent = class {
      /** @internal */
      constructor(topologyId, previousDescription, newDescription) {
        this.topologyId = topologyId;
        this.previousDescription = previousDescription;
        this.newDescription = newDescription;
      }
    };
    exports2.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;
    var TopologyOpeningEvent = class {
      /** @internal */
      constructor(topologyId) {
        this.topologyId = topologyId;
      }
    };
    exports2.TopologyOpeningEvent = TopologyOpeningEvent;
    var TopologyClosedEvent = class {
      /** @internal */
      constructor(topologyId) {
        this.topologyId = topologyId;
      }
    };
    exports2.TopologyClosedEvent = TopologyClosedEvent;
    var ServerHeartbeatStartedEvent = class {
      /** @internal */
      constructor(connectionId) {
        this.connectionId = connectionId;
      }
    };
    exports2.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = class {
      /** @internal */
      constructor(connectionId, duration, reply) {
        this.connectionId = connectionId;
        this.duration = duration;
        this.reply = reply !== null && reply !== void 0 ? reply : {};
      }
    };
    exports2.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = class {
      /** @internal */
      constructor(connectionId, duration, failure) {
        this.connectionId = connectionId;
        this.duration = duration;
        this.failure = failure;
      }
    };
    exports2.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/commands.js
var require_commands = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/commands.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinMsg = exports2.Msg = exports2.Response = exports2.Query = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils2();
    var constants_1 = require_constants2();
    var _requestId = 0;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SECONDARY = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query = class _Query {
      constructor(ns, query, options) {
        if (ns == null)
          throw new error_1.MongoRuntimeError("Namespace must be specified for query");
        if (query == null)
          throw new error_1.MongoRuntimeError("A query document must be specified for query");
        if (ns.indexOf("\0") !== -1) {
          throw new error_1.MongoRuntimeError("Namespace cannot contain a null character");
        }
        this.ns = ns;
        this.query = query;
        this.numberToSkip = options.numberToSkip || 0;
        this.numberToReturn = options.numberToReturn || 0;
        this.returnFieldSelector = options.returnFieldSelector || void 0;
        this.requestId = _Query.getRequestId();
        this.pre32Limit = options.pre32Limit;
        this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        this.batchSize = this.numberToReturn;
        this.tailable = false;
        this.secondaryOk = typeof options.secondaryOk === "boolean" ? options.secondaryOk : false;
        this.oplogReplay = false;
        this.noCursorTimeout = false;
        this.awaitData = false;
        this.exhaust = false;
        this.partial = false;
      }
      /** Assign next request Id. */
      incRequestId() {
        this.requestId = _requestId++;
      }
      /** Peek next request Id. */
      nextRequestId() {
        return _requestId + 1;
      }
      /** Increment then return next request Id. */
      static getRequestId() {
        return ++_requestId;
      }
      // Uses a single allocated buffer for the process, avoiding multiple memory allocations
      toBin() {
        const buffers = [];
        let projection = null;
        let flags = 0;
        if (this.tailable) {
          flags |= OPTS_TAILABLE_CURSOR;
        }
        if (this.secondaryOk) {
          flags |= OPTS_SECONDARY;
        }
        if (this.oplogReplay) {
          flags |= OPTS_OPLOG_REPLAY;
        }
        if (this.noCursorTimeout) {
          flags |= OPTS_NO_CURSOR_TIMEOUT;
        }
        if (this.awaitData) {
          flags |= OPTS_AWAIT_DATA;
        }
        if (this.exhaust) {
          flags |= OPTS_EXHAUST;
        }
        if (this.partial) {
          flags |= OPTS_PARTIAL;
        }
        if (this.batchSize !== this.numberToReturn)
          this.numberToReturn = this.batchSize;
        const header = Buffer.alloc(
          4 * 4 + // Header
          4 + // Flags
          Buffer.byteLength(this.ns) + 1 + // namespace
          4 + // numberToSkip
          4
          // numberToReturn
        );
        buffers.push(header);
        const query = BSON.serialize(this.query, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(query);
        if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
          projection = BSON.serialize(this.returnFieldSelector, {
            checkKeys: this.checkKeys,
            serializeFunctions: this.serializeFunctions,
            ignoreUndefined: this.ignoreUndefined
          });
          buffers.push(projection);
        }
        const totalLength = header.length + query.length + (projection ? projection.length : 0);
        let index = 4;
        header[3] = totalLength >> 24 & 255;
        header[2] = totalLength >> 16 & 255;
        header[1] = totalLength >> 8 & 255;
        header[0] = totalLength & 255;
        header[index + 3] = this.requestId >> 24 & 255;
        header[index + 2] = this.requestId >> 16 & 255;
        header[index + 1] = this.requestId >> 8 & 255;
        header[index] = this.requestId & 255;
        index = index + 4;
        header[index + 3] = 0 >> 24 & 255;
        header[index + 2] = 0 >> 16 & 255;
        header[index + 1] = 0 >> 8 & 255;
        header[index] = 0 & 255;
        index = index + 4;
        header[index + 3] = constants_1.OP_QUERY >> 24 & 255;
        header[index + 2] = constants_1.OP_QUERY >> 16 & 255;
        header[index + 1] = constants_1.OP_QUERY >> 8 & 255;
        header[index] = constants_1.OP_QUERY & 255;
        index = index + 4;
        header[index + 3] = flags >> 24 & 255;
        header[index + 2] = flags >> 16 & 255;
        header[index + 1] = flags >> 8 & 255;
        header[index] = flags & 255;
        index = index + 4;
        index = index + header.write(this.ns, index, "utf8") + 1;
        header[index - 1] = 0;
        header[index + 3] = this.numberToSkip >> 24 & 255;
        header[index + 2] = this.numberToSkip >> 16 & 255;
        header[index + 1] = this.numberToSkip >> 8 & 255;
        header[index] = this.numberToSkip & 255;
        index = index + 4;
        header[index + 3] = this.numberToReturn >> 24 & 255;
        header[index + 2] = this.numberToReturn >> 16 & 255;
        header[index + 1] = this.numberToReturn >> 8 & 255;
        header[index] = this.numberToReturn & 255;
        index = index + 4;
        return buffers;
      }
    };
    exports2.Query = Query;
    var Response = class {
      constructor(message, msgHeader, msgBody, opts) {
        this.documents = new Array(0);
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts !== null && opts !== void 0 ? opts : {
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
        this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
        this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
      }
      isParsed() {
        return this.parsed;
      }
      parse(options) {
        var _a, _b, _c, _d;
        if (this.parsed)
          return;
        options = options !== null && options !== void 0 ? options : {};
        const raw = options.raw || false;
        const documentsReturnedIn = options.documentsReturnedIn || null;
        const promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;
        const promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;
        const promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;
        const bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;
        let bsonSize;
        const _options = {
          promoteLongs,
          promoteValues,
          promoteBuffers,
          bsonRegExp
        };
        this.index = 20;
        this.responseFlags = this.data.readInt32LE(0);
        this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
        this.startingFrom = this.data.readInt32LE(12);
        this.numberReturned = this.data.readInt32LE(16);
        this.documents = new Array(this.numberReturned);
        this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
        this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
        this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
        this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
        for (let i = 0; i < this.numberReturned; i++) {
          bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
          if (raw) {
            this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
          } else {
            this.documents[i] = BSON.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
          }
          this.index = this.index + bsonSize;
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          _options.fieldsAsRaw = fieldsAsRaw;
          const doc = BSON.deserialize(this.documents[0], _options);
          this.documents = [doc];
        }
        this.parsed = true;
      }
    };
    exports2.Response = Response;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var Msg = class _Msg {
      constructor(ns, command, options) {
        if (command == null)
          throw new error_1.MongoInvalidArgumentError("Query document must be specified for query");
        this.ns = ns;
        this.command = command;
        this.command.$db = (0, utils_1.databaseNamespace)(ns);
        if (options.readPreference && options.readPreference.mode !== read_preference_1.ReadPreference.PRIMARY) {
          this.command.$readPreference = options.readPreference.toJSON();
        }
        this.options = options !== null && options !== void 0 ? options : {};
        this.requestId = options.requestId ? options.requestId : _Msg.getRequestId();
        this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
        this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options.moreToCome || false;
        this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer.alloc(
          4 * 4 + // Header
          4
          // Flags
        );
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeDocumentSegment(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(constants_1.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      makeDocumentSegment(buffers, document2) {
        const payloadTypeBuffer = Buffer.alloc(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        return payloadTypeBuffer.length + documentBuffer.length;
      }
      serializeBson(document2) {
        return BSON.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
      static getRequestId() {
        _requestId = _requestId + 1 & 2147483647;
        return _requestId;
      }
    };
    exports2.Msg = Msg;
    var BinMsg = class {
      constructor(message, msgHeader, msgBody, opts) {
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts !== null && opts !== void 0 ? opts : {
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
        this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
        this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
        this.documents = [];
      }
      isParsed() {
        return this.parsed;
      }
      parse(options) {
        var _a, _b, _c, _d;
        if (this.parsed)
          return;
        options = options !== null && options !== void 0 ? options : {};
        this.index = 4;
        const raw = options.raw || false;
        const documentsReturnedIn = options.documentsReturnedIn || null;
        const promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;
        const promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;
        const promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;
        const bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;
        const validation = this.parseBsonSerializationOptions(options);
        const bsonOptions = {
          promoteLongs,
          promoteValues,
          promoteBuffers,
          bsonRegExp,
          validation
          // Due to the strictness of the BSON libraries validation option we need this cast
        };
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.slice(this.index, this.index + bsonSize);
            this.documents.push(raw ? bin : BSON.deserialize(bin, bsonOptions));
            this.index += bsonSize;
          } else if (payloadType === 1) {
            throw new error_1.MongoRuntimeError("OP_MSG Payload Type 1 detected unsupported protocol");
          }
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          bsonOptions.fieldsAsRaw = fieldsAsRaw;
          const doc = BSON.deserialize(this.documents[0], bsonOptions);
          this.documents = [doc];
        }
        this.parsed = true;
      }
      parseBsonSerializationOptions({ enableUtf8Validation }) {
        if (enableUtf8Validation === false) {
          return { utf8: false };
        }
        return { utf8: { writeErrors: false } };
      }
    };
    exports2.BinMsg = BinMsg;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/command_monitoring_events.js
var require_command_monitoring_events = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/command_monitoring_events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommandFailedEvent = exports2.CommandSucceededEvent = exports2.CommandStartedEvent = void 0;
    var constants_1 = require_constants3();
    var utils_1 = require_utils2();
    var commands_1 = require_commands();
    var CommandStartedEvent = class {
      /**
       * Create a started event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       */
      constructor(connection, command) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        if (SENSITIVE_COMMANDS.has(commandName)) {
          this.commandObj = {};
          this.commandObj[commandName] = true;
        }
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.databaseName = databaseName(command);
        this.commandName = commandName;
        this.command = maybeRedact(commandName, cmd, cmd);
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports2.CommandStartedEvent = CommandStartedEvent;
    var CommandSucceededEvent = class {
      /**
       * Create a succeeded event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       * @param reply - the reply for this command from the server
       * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(connection, command, reply, started) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = (0, utils_1.calculateDurationInMs)(started);
        this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports2.CommandSucceededEvent = CommandSucceededEvent;
    var CommandFailedEvent = class {
      /**
       * Create a failure event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       * @param error - the generated error or a server error response
       * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(connection, command, error, started) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = (0, utils_1.calculateDurationInMs)(started);
        this.failure = maybeRedact(commandName, cmd, error);
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports2.CommandFailedEvent = CommandFailedEvent;
    var SENSITIVE_COMMANDS = /* @__PURE__ */ new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var HELLO_COMMANDS = /* @__PURE__ */ new Set(["hello", constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
    var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
    var namespace = (command) => command.ns;
    var databaseName = (command) => command.ns.split(".")[0];
    var collectionName = (command) => command.ns.split(".")[1];
    var maybeRedact = (commandName, commandDoc, result) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldSelector: "projection"
    };
    var OP_QUERY_KEYS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "partial",
      "exhaust"
    ];
    function extractCommand(command) {
      var _a;
      if (command instanceof commands_1.Msg) {
        return (0, utils_1.deepCopy)(command.command);
      }
      if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = { find: collectionName(command) };
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (command.query[key] != null) {
              result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);
            }
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          const legacyKey = key;
          if (command[legacyKey] != null) {
            result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);
          }
        });
        OP_QUERY_KEYS.forEach((key) => {
          if (command[key]) {
            result[key] = command[key];
          }
        });
        if (command.pre32Limit != null) {
          result.limit = command.pre32Limit;
        }
        if (command.query.$explain) {
          return { explain: result };
        }
        return result;
      }
      const clonedQuery = {};
      const clonedCommand = {};
      if (command.query) {
        for (const k in command.query) {
          clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);
        }
        clonedCommand.query = clonedQuery;
      }
      for (const k in command) {
        if (k === "query")
          continue;
        clonedCommand[k] = (0, utils_1.deepCopy)(command[k]);
      }
      return command.query ? clonedQuery : clonedCommand;
    }
    function extractReply(command, reply) {
      if (!reply) {
        return reply;
      }
      if (command instanceof commands_1.Msg) {
        return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
      }
      if (command.query && command.query.$query != null) {
        return {
          ok: 1,
          cursor: {
            id: (0, utils_1.deepCopy)(reply.cursorId),
            ns: namespace(command),
            firstBatch: (0, utils_1.deepCopy)(reply.documents)
          }
        };
      }
      return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
    }
    function extractConnectionDetails(connection) {
      let connectionId;
      if ("id" in connection) {
        connectionId = connection.id;
      }
      return {
        address: connection.address,
        serviceId: connection.serviceId,
        connectionId
      };
    }
  }
});

// asset-input/node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/message_stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageStream = void 0;
    var stream_1 = require("stream");
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var commands_1 = require_commands();
    var compression_1 = require_compression();
    var constants_1 = require_constants2();
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
    var kBuffer = Symbol("buffer");
    var MessageStream = class extends stream_1.Duplex {
      constructor(options = {}) {
        super(options);
        this.isMonitoringConnection = false;
        this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
        this[kBuffer] = new utils_1.BufferPool();
      }
      get buffer() {
        return this[kBuffer];
      }
      _write(chunk, _, callback) {
        this[kBuffer].append(chunk);
        processIncomingData(this, callback);
      }
      _read() {
        return;
      }
      writeCommand(command, operationDescription) {
        const compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : "none";
        if (compressorName === "none" || !canCompress(command)) {
          const data = command.toBin();
          this.push(Array.isArray(data) ? Buffer.concat(data) : data);
          return;
        }
        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        (0, compression_1.compress)({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {
          if (err || !compressedMessage) {
            operationDescription.cb(err);
            return;
          }
          const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
          msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
          msgHeader.writeInt32LE(command.requestId, 4);
          msgHeader.writeInt32LE(0, 8);
          msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
          const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
          compressionDetails.writeInt32LE(originalCommandOpCode, 0);
          compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
          compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8);
          this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
        });
      }
    };
    exports2.MessageStream = MessageStream;
    function canCompress(command) {
      const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !compression_1.uncompressibleCommands.has(commandName);
    }
    function processIncomingData(stream, callback) {
      const buffer = stream[kBuffer];
      const sizeOfMessage = buffer.getInt32();
      if (sizeOfMessage == null) {
        return callback();
      }
      if (sizeOfMessage < 0) {
        return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));
      }
      if (sizeOfMessage > stream.maxBsonMessageSize) {
        return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
      }
      if (sizeOfMessage > buffer.length) {
        return callback();
      }
      const message = buffer.read(sizeOfMessage);
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      const monitorHasAnotherHello = () => {
        if (stream.isMonitoringConnection) {
          const sizeOfMessage2 = buffer.getInt32();
          if (sizeOfMessage2 != null && sizeOfMessage2 <= buffer.length) {
            return true;
          }
        }
        return false;
      };
      let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;
      if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {
        const messageBody = message.subarray(MESSAGE_HEADER_SIZE);
        if (monitorHasAnotherHello()) {
          return processIncomingData(stream, callback);
        }
        stream.emit("message", new ResponseType(message, messageHeader, messageBody));
        if (buffer.length >= 4) {
          return processIncomingData(stream, callback);
        }
        return callback();
      }
      messageHeader.fromCompressed = true;
      messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
      messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;
      return (0, compression_1.decompress)(compressorID, compressedBuffer, (err, messageBody) => {
        if (err || !messageBody) {
          return callback(err);
        }
        if (messageBody.length !== messageHeader.length) {
          return callback(new error_1.MongoDecompressionError("Message body and message header must be the same length"));
        }
        if (monitorHasAnotherHello()) {
          return processIncomingData(stream, callback);
        }
        stream.emit("message", new ResponseType(message, messageHeader, messageBody));
        if (buffer.length >= 4) {
          return processIncomingData(stream, callback);
        }
        return callback();
      });
    }
  }
});

// asset-input/node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/stream_description.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamDescription = void 0;
    var common_1 = require_common();
    var server_description_1 = require_server_description();
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "logicalSessionTimeoutMinutes"
    ];
    var StreamDescription = class {
      constructor(address, options) {
        this.address = address;
        this.type = common_1.ServerType.Unknown;
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.logicalSessionTimeoutMinutes = options === null || options === void 0 ? void 0 : options.logicalSessionTimeoutMinutes;
        this.loadBalanced = !!(options === null || options === void 0 ? void 0 : options.loadBalanced);
        this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
      }
      receiveResponse(response) {
        if (response == null) {
          return;
        }
        this.type = (0, server_description_1.parseServerType)(response);
        for (const field of RESPONSE_FIELDS) {
          if (response[field] != null) {
            this[field] = response[field];
          }
          if ("__nodejs_mock_server__" in response) {
            this.__nodejs_mock_server__ = response["__nodejs_mock_server__"];
          }
        }
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => {
            var _a;
            return (_a = response.compression) === null || _a === void 0 ? void 0 : _a.includes(c);
          })[0];
        }
      }
    };
    exports2.StreamDescription = StreamDescription;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/connection.js
var require_connection = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasSessionSupport = exports2.CryptoConnection = exports2.Connection = void 0;
    var timers_1 = require("timers");
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var sessions_1 = require_sessions();
    var utils_1 = require_utils2();
    var command_monitoring_events_1 = require_command_monitoring_events();
    var commands_1 = require_commands();
    var message_stream_1 = require_message_stream();
    var stream_description_1 = require_stream_description();
    var shared_1 = require_shared();
    var kStream = Symbol("stream");
    var kQueue = Symbol("queue");
    var kMessageStream = Symbol("messageStream");
    var kGeneration = Symbol("generation");
    var kLastUseTime = Symbol("lastUseTime");
    var kClusterTime = Symbol("clusterTime");
    var kDescription = Symbol("description");
    var kHello = Symbol("hello");
    var kAutoEncrypter = Symbol("autoEncrypter");
    var kDelayedTimeoutId = Symbol("delayedTimeoutId");
    var INVALID_QUEUE_SIZE = "Connection internal queue contains more than 1 operation description";
    var Connection = class _Connection extends mongo_types_1.TypedEventEmitter {
      constructor(stream, options) {
        var _a, _b;
        super();
        this.id = options.id;
        this.address = streamIdentifier(stream, options);
        this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;
        this.monitorCommands = options.monitorCommands;
        this.serverApi = options.serverApi;
        this.closed = false;
        this.destroyed = false;
        this[kHello] = null;
        this[kClusterTime] = null;
        this[kDescription] = new stream_description_1.StreamDescription(this.address, options);
        this[kGeneration] = options.generation;
        this[kLastUseTime] = (0, utils_1.now)();
        this[kQueue] = /* @__PURE__ */ new Map();
        this[kMessageStream] = new message_stream_1.MessageStream({
          ...options,
          maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize
        });
        this[kStream] = stream;
        this[kDelayedTimeoutId] = null;
        this[kMessageStream].on("message", (message) => this.onMessage(message));
        this[kMessageStream].on("error", (error) => this.onError(error));
        this[kStream].on("close", () => this.onClose());
        this[kStream].on("timeout", () => this.onTimeout());
        this[kStream].on("error", () => {
        });
        this[kStream].pipe(this[kMessageStream]);
        this[kMessageStream].pipe(this[kStream]);
      }
      get description() {
        return this[kDescription];
      }
      get hello() {
        return this[kHello];
      }
      // the `connect` method stores the result of the handshake hello on the connection
      set hello(response) {
        this[kDescription].receiveResponse(response);
        this[kDescription] = Object.freeze(this[kDescription]);
        this[kHello] = response;
      }
      // Set the whether the message stream is for a monitoring connection.
      set isMonitoringConnection(value) {
        this[kMessageStream].isMonitoringConnection = value;
      }
      get isMonitoringConnection() {
        return this[kMessageStream].isMonitoringConnection;
      }
      get serviceId() {
        var _a;
        return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;
      }
      get loadBalanced() {
        return this.description.loadBalanced;
      }
      get generation() {
        return this[kGeneration] || 0;
      }
      set generation(generation) {
        this[kGeneration] = generation;
      }
      get idleTime() {
        return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);
      }
      get clusterTime() {
        return this[kClusterTime];
      }
      get stream() {
        return this[kStream];
      }
      markAvailable() {
        this[kLastUseTime] = (0, utils_1.now)();
      }
      onError(error) {
        if (this.closed) {
          return;
        }
        this[kStream].destroy(error);
        this.closed = true;
        for (const op of this[kQueue].values()) {
          op.cb(error);
        }
        this[kQueue].clear();
        this.emit(_Connection.CLOSE);
      }
      onClose() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        const message = `connection ${this.id} to ${this.address} closed`;
        for (const op of this[kQueue].values()) {
          op.cb(new error_1.MongoNetworkError(message));
        }
        this[kQueue].clear();
        this.emit(_Connection.CLOSE);
      }
      onTimeout() {
        if (this.closed) {
          return;
        }
        this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {
          this[kStream].destroy();
          this.closed = true;
          const message = `connection ${this.id} to ${this.address} timed out`;
          const beforeHandshake = this.hello == null;
          for (const op of this[kQueue].values()) {
            op.cb(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
          }
          this[kQueue].clear();
          this.emit(_Connection.CLOSE);
        }, 1).unref();
      }
      onMessage(message) {
        var _a;
        const delayedTimeoutId = this[kDelayedTimeoutId];
        if (delayedTimeoutId != null) {
          (0, timers_1.clearTimeout)(delayedTimeoutId);
          this[kDelayedTimeoutId] = null;
        }
        const socketTimeoutMS = (_a = this[kStream].timeout) !== null && _a !== void 0 ? _a : 0;
        this[kStream].setTimeout(0);
        this.emit("message", message);
        let operationDescription = this[kQueue].get(message.responseTo);
        if (!operationDescription && this.isMonitoringConnection) {
          if (this[kQueue].size > 1) {
            this.onError(new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));
          } else {
            const entry = this[kQueue].entries().next();
            if (entry.value != null) {
              const [requestId, orphaned] = entry.value;
              operationDescription = orphaned;
              this[kQueue].delete(requestId);
            }
          }
        }
        if (!operationDescription) {
          return;
        }
        const callback = operationDescription.cb;
        this[kQueue].delete(message.responseTo);
        if ("moreToCome" in message && message.moreToCome) {
          this[kQueue].set(message.requestId, operationDescription);
          this[kStream].setTimeout(socketTimeoutMS);
        }
        try {
          message.parse(operationDescription);
        } catch (err) {
          callback(err);
          return;
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = operationDescription.session;
          if (session) {
            (0, sessions_1.updateSessionFromResponse)(session, document2);
          }
          if (document2.$clusterTime) {
            this[kClusterTime] = document2.$clusterTime;
            this.emit(_Connection.CLUSTER_TIME_RECEIVED, document2.$clusterTime);
          }
          if (operationDescription.command) {
            if (document2.writeConcernError) {
              callback(new error_1.MongoWriteConcernError(document2.writeConcernError, document2));
              return;
            }
            if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
              callback(new error_1.MongoServerError(document2));
              return;
            }
          } else {
            if (document2.ok === 0 || document2.$err || document2.errmsg) {
              callback(new error_1.MongoServerError(document2));
              return;
            }
          }
        }
        callback(void 0, message.documents[0]);
      }
      destroy(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = { force: false };
        }
        this.removeAllListeners(_Connection.PINNED);
        this.removeAllListeners(_Connection.UNPINNED);
        options = Object.assign({ force: false }, options);
        if (this[kStream] == null || this.destroyed) {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        if (options.force) {
          this[kStream].destroy();
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        this[kStream].end(() => {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
        });
      }
      command(ns, cmd, options, callback) {
        const readPreference = (0, shared_1.getReadPreference)(cmd, options);
        const shouldUseOpMsg = supportsOpMsg(this);
        const session = options === null || options === void 0 ? void 0 : options.session;
        let clusterTime = this.clusterTime;
        let finalCmd = Object.assign({}, cmd);
        if (this.serverApi) {
          const { version, strict, deprecationErrors } = this.serverApi;
          finalCmd.apiVersion = version;
          if (strict != null)
            finalCmd.apiStrict = strict;
          if (deprecationErrors != null)
            finalCmd.apiDeprecationErrors = deprecationErrors;
        }
        if (hasSessionSupport(this) && session) {
          if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
            clusterTime = session.clusterTime;
          }
          const err = (0, sessions_1.applySession)(session, finalCmd, options);
          if (err) {
            return callback(err);
          }
        }
        if (clusterTime) {
          finalCmd.$clusterTime = clusterTime;
        }
        if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
          finalCmd = {
            $query: finalCmd,
            $readPreference: readPreference.toJSON()
          };
        }
        const commandOptions = Object.assign({
          command: true,
          numberToSkip: 0,
          numberToReturn: -1,
          checkKeys: false,
          // This value is not overridable
          secondaryOk: readPreference.secondaryOk()
        }, options);
        const cmdNs = `${ns.db}.$cmd`;
        const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);
        try {
          write(this, message, commandOptions, callback);
        } catch (err) {
          callback(err);
        }
      }
    };
    exports2.Connection = Connection;
    Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
    Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
    Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
    Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
    Connection.CLOSE = constants_1.CLOSE;
    Connection.MESSAGE = constants_1.MESSAGE;
    Connection.PINNED = constants_1.PINNED;
    Connection.UNPINNED = constants_1.UNPINNED;
    var CryptoConnection = class extends Connection {
      constructor(stream, options) {
        super(stream, options);
        this[kAutoEncrypter] = options.autoEncrypter;
      }
      /** @internal @override */
      command(ns, cmd, options, callback) {
        const autoEncrypter = this[kAutoEncrypter];
        if (!autoEncrypter) {
          return callback(new error_1.MongoMissingDependencyError("No AutoEncrypter available for encryption"));
        }
        const serverWireVersion = (0, utils_1.maxWireVersion)(this);
        if (serverWireVersion === 0) {
          return super.command(ns, cmd, options, callback);
        }
        if (serverWireVersion < 8) {
          callback(new error_1.MongoCompatibilityError("Auto-encryption requires a minimum MongoDB version of 4.2"));
          return;
        }
        const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
        const indexKeys = cmd.createIndexes ? cmd.indexes.map((index) => index.key) : null;
        autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {
          if (err || encrypted == null) {
            callback(err, null);
            return;
          }
          if (sort != null && (cmd.find || cmd.findAndModify)) {
            encrypted.sort = sort;
          }
          if (indexKeys != null && cmd.createIndexes) {
            for (const [offset, index] of indexKeys.entries()) {
              encrypted.indexes[offset].key = index;
            }
          }
          super.command(ns, encrypted, options, (err2, response) => {
            if (err2 || response == null) {
              callback(err2, response);
              return;
            }
            autoEncrypter.decrypt(response, options, callback);
          });
        });
      }
    };
    exports2.CryptoConnection = CryptoConnection;
    function hasSessionSupport(conn) {
      const description = conn.description;
      return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;
    }
    exports2.hasSessionSupport = hasSessionSupport;
    function supportsOpMsg(conn) {
      const description = conn.description;
      if (description == null) {
        return false;
      }
      return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;
    }
    function streamIdentifier(stream, options) {
      if (options.proxyHost) {
        return options.hostAddress.toString();
      }
      const { remoteAddress, remotePort } = stream;
      if (typeof remoteAddress === "string" && typeof remotePort === "number") {
        return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
      }
      return (0, utils_1.uuidV4)().toString("hex");
    }
    function write(conn, command, options, callback) {
      options = options !== null && options !== void 0 ? options : {};
      const operationDescription = {
        requestId: command.requestId,
        cb: callback,
        session: options.session,
        noResponse: typeof options.noResponse === "boolean" ? options.noResponse : false,
        documentsReturnedIn: options.documentsReturnedIn,
        command: !!options.command,
        // for BSON parsing
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
        bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
        enableUtf8Validation: typeof options.enableUtf8Validation === "boolean" ? options.enableUtf8Validation : true,
        raw: typeof options.raw === "boolean" ? options.raw : false,
        started: 0
      };
      if (conn[kDescription] && conn[kDescription].compressor) {
        operationDescription.agreedCompressor = conn[kDescription].compressor;
        if (conn[kDescription].zlibCompressionLevel) {
          operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;
        }
      }
      if (typeof options.socketTimeoutMS === "number") {
        conn[kStream].setTimeout(options.socketTimeoutMS);
      } else if (conn.socketTimeoutMS !== 0) {
        conn[kStream].setTimeout(conn.socketTimeoutMS);
      }
      if (conn.monitorCommands) {
        conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));
        operationDescription.started = (0, utils_1.now)();
        operationDescription.cb = (err, reply) => {
          if (err) {
            conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));
          } else {
            if (reply && (reply.ok === 0 || reply.$err)) {
              conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));
            } else {
              conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));
            }
          }
          if (typeof callback === "function") {
            callback(err, reply);
          }
        };
      }
      if (!operationDescription.noResponse) {
        conn[kQueue].set(operationDescription.requestId, operationDescription);
      }
      try {
        conn[kMessageStream].writeCommand(command, operationDescription);
      } catch (e) {
        if (!operationDescription.noResponse) {
          conn[kQueue].delete(operationDescription.requestId);
          operationDescription.cb(e);
          return;
        }
      }
      if (operationDescription.noResponse) {
        operationDescription.cb();
      }
    }
  }
});

// asset-input/node_modules/smart-buffer/build/utils.js
var require_utils4 = __commonJS({
  "asset-input/node_modules/smart-buffer/build/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports2.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports2.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports2.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports2.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports2.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports2.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports2.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// asset-input/node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "asset-input/node_modules/smart-buffer/build/smartbuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils4();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class _SmartBuffer {
      /**
       * Creates a new SmartBuffer instance.
       *
       * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
       */
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (_SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      /**
       * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
       *
       * @param size { Number } The size of the internal Buffer.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
       *
       * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
       *
       * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
       */
      static fromOptions(options) {
        return new this(options);
      }
      /**
       * Type checking function that determines if an object is a SmartBufferOptions object.
       */
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      // Signed integers
      /**
       * Reads an Int8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      /**
       * Reads an Int16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      /**
       * Reads an Int16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      /**
       * Reads an Int32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      /**
       * Reads an Int32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      /**
       * Reads a BigInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      /**
       * Reads a BigInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      /**
       * Writes an Int8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      /**
       * Inserts an Int8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      /**
       * Writes an Int16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Inserts an Int16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Writes an Int16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Inserts an Int16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Writes an Int32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Inserts an Int32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Writes an Int32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Inserts an Int32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigInt64BE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigInt64BE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigInt64LE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      /**
       * Inserts a Int64LE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      // Unsigned Integers
      /**
       * Reads an UInt8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      /**
       * Reads an UInt16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      /**
       * Reads an UInt16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      /**
       * Reads an UInt32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      /**
       * Reads an UInt32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      /**
       * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      /**
       * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      /**
       * Writes an UInt8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Inserts an UInt8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Writes an UInt16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Inserts an UInt16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Writes an UInt16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Inserts an UInt16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Writes an UInt32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Inserts an UInt32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Writes an UInt32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Inserts an UInt32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigUInt64BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigUInt64LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      // Floating Point
      /**
       * Reads an FloatBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      /**
       * Reads an FloatLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      /**
       * Writes a FloatBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Inserts a FloatBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Writes a FloatLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      /**
       * Inserts a FloatLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      // Double Floating Point
      /**
       * Reads an DoublEBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      /**
       * Reads an DoubleLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      /**
       * Writes a DoubleBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Inserts a DoubleBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Writes a DoubleLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      /**
       * Inserts a DoubleLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      // Strings
      /**
       * Reads a String from the current read position.
       *
       * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
       *             the string (Defaults to instance level encoding).
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      /**
       * Inserts a String
       *
       * @param value { String } The String value to insert.
       * @param offset { Number } The offset to insert the string at.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      /**
       * Writes a String
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      /**
       * Reads a null-terminated String from the current read position.
       *
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      /**
       * Inserts a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      // Buffers
      /**
       * Reads a Buffer from the internal read position.
       *
       * @param length { Number } The length of data to read as a Buffer.
       *
       * @return { Buffer }
       */
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      /**
       * Reads a null-terminated Buffer from the current read poisiton.
       *
       * @return { Buffer }
       */
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      /**
       * Inserts a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      /**
       * Clears the SmartBuffer instance to its original empty state.
       */
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      /**
       * Gets the remaining data left to be read from the SmartBuffer instance.
       *
       * @return { Number }
       */
      remaining() {
        return this.length - this._readOffset;
      }
      /**
       * Gets the current read offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get readOffset() {
        return this._readOffset;
      }
      /**
       * Sets the read offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      /**
       * Gets the current write offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get writeOffset() {
        return this._writeOffset;
      }
      /**
       * Sets the write offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      /**
       * Gets the currently set string encoding of the SmartBuffer instance.
       *
       * @return { BufferEncoding } The string Buffer encoding currently set.
       */
      get encoding() {
        return this._encoding;
      }
      /**
       * Sets the string encoding of the SmartBuffer instance.
       *
       * @param encoding { BufferEncoding } The string Buffer encoding to set.
       */
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      /**
       * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
       *
       * @return { Buffer } The Buffer value.
       */
      get internalBuffer() {
        return this._buff;
      }
      /**
       * Gets the value of the internal managed Buffer (Includes managed data only)
       *
       * @param { Buffer }
       */
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      /**
       * Gets the String value of the internal managed Buffer
       *
       * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
       */
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      /**
       * Destroys the SmartBuffer instance.
       */
      destroy() {
        this.clear();
        return this;
      }
      /**
       * Handles inserting and writing strings.
       *
       * @param value { String } The String value to insert.
       * @param isInsert { Boolean } True if inserting a string, false if writing.
       * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       */
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      /**
       * Handles writing or insert of a Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       */
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      /**
       * Ensures that the internal Buffer is large enough to read data.
       *
       * @param length { Number } The length of the data that needs to be read.
       * @param offset { Number } The offset of the data that needs to be read.
       */
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to insert data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written.
       */
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
       */
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write at least the given amount of data.
       *
       * @param minLength { Number } The minimum length of the data needs to be written.
       */
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      /**
       * Reads a numeric number value using the provided function.
       *
       * @typeparam T { number | bigint } The type of the value to be read
       *
       * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes read.
       * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
       *
       * @returns { T } the number value
       */
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      /**
       * Inserts a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      /**
       * Writes a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports2.SmartBuffer = SmartBuffer;
  }
});

// asset-input/node_modules/socks/build/common/constants.js
var require_constants4 = __commonJS({
  "asset-input/node_modules/socks/build/common/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = exports2.SOCKS5_CUSTOM_AUTH_END = exports2.SOCKS5_CUSTOM_AUTH_START = exports2.SOCKS_INCOMING_PACKET_SIZES = exports2.SocksClientState = exports2.Socks5Response = exports2.Socks5HostType = exports2.Socks5Auth = exports2.Socks4Response = exports2.SocksCommand = exports2.ERRORS = exports2.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports2.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      // Command response + incoming connection (bind)
      Socks5ResponseHeader: 5,
      // We need at least 5 to read the hostname length, then we wait for the address+port information.
      Socks5ResponseIPv4: 10,
      // 4 header + 4 ip + 2 port
      Socks5ResponseIPv6: 22,
      // 4 header + 16 ip + 2 port
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      // 4 header + 1 host length + host + 2 port
      // Command response + incoming connection (bind)
      Socks4Response: 8
      // 2 header + 2 port + 4 ip
    };
    exports2.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (exports2.SocksCommand = SocksCommand = {}));
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (exports2.Socks4Response = Socks4Response = {}));
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (exports2.Socks5Auth = Socks5Auth = {}));
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports2.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports2.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (exports2.Socks5Response = Socks5Response = {}));
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (exports2.Socks5HostType = Socks5HostType = {}));
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (exports2.SocksClientState = SocksClientState = {}));
  }
});

// asset-input/node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "asset-input/node_modules/socks/build/common/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shuffleArray = exports2.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options) {
        super(message);
        this.options = options;
      }
    };
    exports2.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    exports2.shuffleArray = shuffleArray;
  }
});

// asset-input/node_modules/ip-address/dist/common.js
var require_common3 = __commonJS({
  "asset-input/node_modules/ip-address/dist/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCorrect = exports2.isInSubnet = void 0;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    exports2.isInSubnet = isInSubnet;
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    exports2.isCorrect = isCorrect;
  }
});

// asset-input/node_modules/ip-address/dist/v4/constants.js
var require_constants5 = __commonJS({
  "asset-input/node_modules/ip-address/dist/v4/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_SUBNET_STRING = exports2.RE_ADDRESS = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 32;
    exports2.GROUPS = 4;
    exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// asset-input/node_modules/ip-address/dist/address-error.js
var require_address_error = __commonJS({
  "asset-input/node_modules/ip-address/dist/address-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressError = void 0;
    var AddressError = class extends Error {
      constructor(message, parseMessage) {
        super(message);
        this.name = "AddressError";
        if (parseMessage !== null) {
          this.parseMessage = parseMessage;
        }
      }
    };
    exports2.AddressError = AddressError;
  }
});

// asset-input/node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "asset-input/node_modules/jsbn/index.js"(exports2, module2) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a) this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a) this.fromString(a, 256);
          else this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0) this[0] = x;
        else if (x < -1) this[0] = x + this.DV;
        else this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 256) k = 8;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh2 = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-") mi = true;
            continue;
          }
          mi = false;
          if (sh2 == 0)
            this[this.t++] = x;
          else if (sh2 + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh2) - 1) << sh2;
            this[this.t++] = x >> this.DB - sh2;
          } else
            this[this.t - 1] |= x << sh2;
          sh2 += k;
          if (sh2 >= this.DB) sh2 -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh2 > 0) this[this.t - 1] |= (1 << this.DB - sh2) - 1 << sh2;
        }
        this.clamp();
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) --this.t;
      }
      function bnToString(b) {
        if (this.s < 0) return "-" + this.negate().toString(b);
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0) m = true;
            if (m) r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0) return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0) return this.s < 0 ? -r : r;
        while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0) return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i) r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i) r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i) r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1) r[i++] = this.DV + c;
        else if (c > 0) r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null) q.fromInt(0);
          if (r != null) this.copyTo(r);
          return;
        }
        if (r == null) r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys) y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd) r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms) BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) r.rShiftTo(nsh, r);
        if (ts < 0) BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
        else return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1) return 0;
        var x = this[0];
        if ((x & 1) == 0) return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1) return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven()) z2 = new Classic(m);
        else z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1) return this[0] - this.DV;
          else if (this.t == 0) return -1;
        } else if (this.t == 1) return this[0];
        else if (this.t == 0) return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0) return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
        else return 1;
      }
      function bnpToRadix(b) {
        if (b == null) b = 10;
        if (this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2) this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0) x[0] &= (1 << t2) - 1;
          else x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0) d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128)) ++k;
            if (k > 0 || d != this.s) r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0) this.rShiftTo(-n, r);
        else this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0) this.lShiftTo(-n, r);
        else this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0) return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0) ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0) return i * this.DB + lbit(this[i]);
        if (this.s < 0) return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0) r[i++] = c;
        else if (c < -1) r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0) return;
        while (this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t) this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0) r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0) r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
        else if (x.compareTo(this.m) < 0) return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0) return r;
        else if (i < 18) k = 1;
        else if (i < 48) k = 3;
        else if (i < 144) k = 4;
        else if (i < 768) k = 5;
        else k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1) w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0) w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0) z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0) return x;
        if (i < g) g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0) y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0) return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0) r = this[0] % n;
          else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven()) b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven()) d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if (d.compareTo(m) >= 0) return d.subtract(m);
        if (d.signum() < 0) d.addTo(m, d);
        else return d;
        if (d.signum() < 0) return d.add(m);
        else return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i]) return true;
          return false;
        }
        if (x.isEven()) return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j) if (m % lowprimes[i++] == 0) return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length) t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports2 !== "undefined") {
        exports2 = module2.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports2);
  }
});

// asset-input/node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "asset-input/node_modules/sprintf-js/src/sprintf.js"(exports2) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// asset-input/node_modules/ip-address/dist/ipv4.js
var require_ipv4 = __commonJS({
  "asset-input/node_modules/ip-address/dist/ipv4.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address4 = void 0;
    var common = __importStar(require_common3());
    var constants = __importStar(require_constants5());
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    var Address4 = class _Address4 {
      constructor(address) {
        this.groups = constants.GROUPS;
        this.parsedAddress = [];
        this.parsedSubnet = "";
        this.subnet = "/32";
        this.subnetMask = 32;
        this.v4 = true;
        this.isCorrect = common.isCorrect(constants.BITS);
        this.isInSubnet = common.isInSubnet;
        this.address = address;
        const subnet = constants.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants.RE_SUBNET_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(address);
      }
      static isValid(address) {
        try {
          new _Address4(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      /*
       * Parses a v4 address
       */
      parse(address) {
        const groups = address.split(".");
        if (!address.match(constants.RE_ADDRESS)) {
          throw new address_error_1.AddressError("Invalid IPv4 address.");
        }
        return groups;
      }
      /**
       * Returns the correct form of an address
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      correctForm() {
        return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
      }
      /**
       * Converts a hex string to an IPv4 address object
       * @memberof Address4
       * @static
       * @param {string} hex - a hex string to convert
       * @returns {Address4}
       */
      static fromHex(hex) {
        const padded = hex.replace(/:/g, "").padStart(8, "0");
        const groups = [];
        let i;
        for (i = 0; i < 8; i += 2) {
          const h = padded.slice(i, i + 2);
          groups.push(parseInt(h, 16));
        }
        return new _Address4(groups.join("."));
      }
      /**
       * Converts an integer into a IPv4 address object
       * @memberof Address4
       * @static
       * @param {integer} integer - a number to convert
       * @returns {Address4}
       */
      static fromInteger(integer) {
        return _Address4.fromHex(integer.toString(16));
      }
      /**
       * Return an address from in-addr.arpa form
       * @memberof Address4
       * @static
       * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
       * @returns {Adress4}
       * @example
       * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
       * address.correctForm(); // '192.0.2.42'
       */
      static fromArpa(arpaFormAddress) {
        const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
        const address = leader.split(".").reverse().join(".");
        return new _Address4(address);
      }
      /**
       * Converts an IPv4 address object to a hex string
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toHex() {
        return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10))).join(":");
      }
      /**
       * Converts an IPv4 address object to an array of bytes
       * @memberof Address4
       * @instance
       * @returns {Array}
       */
      toArray() {
        return this.parsedAddress.map((part) => parseInt(part, 10));
      }
      /**
       * Converts an IPv4 address object to an IPv6 address group
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toGroup6() {
        const output = [];
        let i;
        for (i = 0; i < constants.GROUPS; i += 2) {
          const hex = (0, sprintf_js_1.sprintf)("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
          output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
        }
        return output.join(":");
      }
      /**
       * Returns the address as a BigInteger
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10))).join(""), 16);
      }
      /**
       * Helper function getting start address.
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
      }
      /**
       * The first address in the range given by this address' subnet.
       * Often referred to as the Network Address.
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddress() {
        return _Address4.fromBigInteger(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address4.fromBigInteger(this._startAddress().add(adjust));
      }
      /**
       * Helper function getting end address.
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddress() {
        return _Address4.fromBigInteger(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address4.fromBigInteger(this._endAddress().subtract(adjust));
      }
      /**
       * Converts a BigInteger to a v4 address object
       * @memberof Address4
       * @static
       * @param {BigInteger} bigInteger - a BigInteger to convert
       * @returns {Address4}
       */
      static fromBigInteger(bigInteger) {
        return _Address4.fromInteger(parseInt(bigInteger.toString(), 10));
      }
      /**
       * Returns the first n bits of the address, defaulting to the
       * subnet mask
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      mask(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      }
      /**
       * Returns the bits in the given range as a base-2 string
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address4
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const reversed = this.correctForm().split(".").reverse().join(".");
        if (options.omitSuffix) {
          return reversed;
        }
        return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
      }
      /**
       * Returns true if the given address is a multicast address
       * @memberof Address4
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.isInSubnet(new _Address4("224.0.0.0/4"));
      }
      /**
       * Returns a zero-padded base-2 string representation of the address
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants.BITS, "0");
      }
      /**
       * Groups an IPv4 address for inclusion at the end of an IPv6 address
       * @returns {String}
       */
      groupForV6() {
        const segments = this.parsedAddress;
        return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
      }
    };
    exports2.Address4 = Address4;
  }
});

// asset-input/node_modules/ip-address/dist/v6/constants.js
var require_constants6 = __commonJS({
  "asset-input/node_modules/ip-address/dist/v6/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_URL_WITH_PORT = exports2.RE_URL = exports2.RE_ZONE_STRING = exports2.RE_SUBNET_STRING = exports2.RE_BAD_ADDRESS = exports2.RE_BAD_CHARACTERS = exports2.TYPES = exports2.SCOPES = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 128;
    exports2.GROUPS = 8;
    exports2.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports2.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports2.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports2.RE_ZONE_STRING = /%.*$/;
    exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// asset-input/node_modules/ip-address/dist/v6/helpers.js
var require_helpers = __commonJS({
  "asset-input/node_modules/ip-address/dist/v6/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simpleGroup = exports2.spanLeadingZeroes = exports2.spanAll = exports2.spanAllZeroes = void 0;
    var sprintf_js_1 = require_sprintf();
    function spanAllZeroes(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    exports2.spanAllZeroes = spanAllZeroes;
    function spanAll(s, offset = 0) {
      const letters = s.split("");
      return letters.map(
        (n, i) => (0, sprintf_js_1.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n))
        // XXX Use #base-2 .value-0 instead?
      ).join("");
    }
    exports2.spanAll = spanAll;
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      const groups = address.split(":");
      return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
    }
    exports2.spanLeadingZeroes = spanLeadingZeroes;
    function simpleGroup(addressString, offset = 0) {
      const groups = addressString.split(":");
      return groups.map((g, i) => {
        if (/group-v4/.test(g)) {
          return g;
        }
        return (0, sprintf_js_1.sprintf)('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
      });
    }
    exports2.simpleGroup = simpleGroup;
  }
});

// asset-input/node_modules/ip-address/dist/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "asset-input/node_modules/ip-address/dist/v6/regular-expressions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.possibleElisions = exports2.simpleRegularExpression = exports2.ADDRESS_BOUNDARY = exports2.padGroup = exports2.groupPossibilities = void 0;
    var v6 = __importStar(require_constants6());
    var sprintf_js_1 = require_sprintf();
    function groupPossibilities(possibilities) {
      return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
    }
    exports2.groupPossibilities = groupPossibilities;
    function padGroup(group) {
      if (group.length < 4) {
        return (0, sprintf_js_1.sprintf)("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    exports2.padGroup = padGroup;
    exports2.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      const zeroIndexes = [];
      groups.forEach((group, i) => {
        const groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i) => {
        if (i === zeroIndex) {
          const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
          return groupPossibilities([padGroup(group), elision]);
        }
        return padGroup(group);
      }).join(":"));
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    exports2.simpleRegularExpression = simpleRegularExpression;
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      const left = moreLeft ? "" : ":";
      const right = moreRight ? "" : ":";
      const possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push((0, sprintf_js_1.sprintf)("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (let groups = 1; groups < elidedGroups - 1; groups++) {
        for (let position = 1; position < elidedGroups - groups; position++) {
          possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports2.possibleElisions = possibleElisions;
  }
});

// asset-input/node_modules/ip-address/dist/ipv6.js
var require_ipv6 = __commonJS({
  "asset-input/node_modules/ip-address/dist/ipv6.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address6 = void 0;
    var common = __importStar(require_common3());
    var constants4 = __importStar(require_constants5());
    var constants6 = __importStar(require_constants6());
    var helpers = __importStar(require_helpers());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      const r = /(\d+)(\d{3})/;
      while (r.test(number)) {
        number = number.replace(r, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice) {
      const s1 = [];
      const s2 = [];
      let i;
      for (i = 0; i < address.length; i++) {
        if (i < slice[0]) {
          s1.push(address[i]);
        } else if (i > slice[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = class _Address6 {
      constructor(address, optionalGroups) {
        this.addressMinusSuffix = "";
        this.parsedSubnet = "";
        this.subnet = "/128";
        this.subnetMask = 128;
        this.v4 = false;
        this.zone = "";
        this.isInSubnet = common.isInSubnet;
        this.isCorrect = common.isCorrect(constants6.BITS);
        if (optionalGroups === void 0) {
          this.groups = constants6.GROUPS;
        } else {
          this.groups = optionalGroups;
        }
        this.address = address;
        const subnet = constants6.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants6.RE_SUBNET_STRING, "");
        } else if (/\//.test(address)) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        const zone = constants6.RE_ZONE_STRING.exec(address);
        if (zone) {
          this.zone = zone[0];
          address = address.replace(constants6.RE_ZONE_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(this.addressMinusSuffix);
      }
      static isValid(address) {
        try {
          new _Address6(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      /**
       * Convert a BigInteger to a v6 address object
       * @memberof Address6
       * @static
       * @param {BigInteger} bigInteger - a BigInteger to convert
       * @returns {Address6}
       * @example
       * var bigInteger = new BigInteger('1000000000000');
       * var address = Address6.fromBigInteger(bigInteger);
       * address.correctForm(); // '::e8:d4a5:1000'
       */
      static fromBigInteger(bigInteger) {
        const hex = bigInteger.toString(16).padStart(32, "0");
        const groups = [];
        let i;
        for (i = 0; i < constants6.GROUPS; i++) {
          groups.push(hex.slice(i * 4, (i + 1) * 4));
        }
        return new _Address6(groups.join(":"));
      }
      /**
       * Convert a URL (with optional port number) to an address object
       * @memberof Address6
       * @static
       * @param {string} url - a URL with optional port number
       * @example
       * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
       * addressAndPort.address.correctForm(); // 'ffff::'
       * addressAndPort.port; // 8080
       */
      static fromURL(url) {
        let host;
        let port = null;
        let result;
        if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
          result = constants6.RE_URL_WITH_PORT.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
          }
          host = result[1];
          port = result[2];
        } else if (url.indexOf("/") !== -1) {
          url = url.replace(/^[a-z0-9]+:\/\//, "");
          result = constants6.RE_URL.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
          }
          host = result[1];
        } else {
          host = url;
        }
        if (port) {
          port = parseInt(port, 10);
          if (port < 0 || port > 65536) {
            port = null;
          }
        } else {
          port = null;
        }
        return {
          address: new _Address6(host),
          port
        };
      }
      /**
       * Create an IPv6-mapped address given an IPv4 address
       * @memberof Address6
       * @static
       * @param {string} address - An IPv4 address string
       * @returns {Address6}
       * @example
       * var address = Address6.fromAddress4('192.168.0.1');
       * address.correctForm(); // '::ffff:c0a8:1'
       * address.to4in6(); // '::ffff:192.168.0.1'
       */
      static fromAddress4(address) {
        const address4 = new ipv4_1.Address4(address);
        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
        return new _Address6(`::ffff:${address4.correctForm()}/${mask6}`);
      }
      /**
       * Return an address from ip6.arpa form
       * @memberof Address6
       * @static
       * @param {string} arpaFormAddress - an 'ip6.arpa' form address
       * @returns {Adress6}
       * @example
       * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
       * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
       */
      static fromArpa(arpaFormAddress) {
        let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
        const semicolonAmount = 7;
        if (address.length !== 63) {
          throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
        }
        const parts = address.split(".").reverse();
        for (let i = semicolonAmount; i > 0; i--) {
          const insertIndex = i * 4;
          parts.splice(insertIndex, 0, ":");
        }
        address = parts.join("");
        return new _Address6(address);
      }
      /**
       * Return the Microsoft UNC transcription of the address
       * @memberof Address6
       * @instance
       * @returns {String} the Microsoft UNC transcription of the address
       */
      microsoftTranscription() {
        return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
      }
      /**
       * Return the first n bits of the address, defaulting to the subnet mask
       * @memberof Address6
       * @instance
       * @param {number} [mask=subnet] - the number of bits to mask
       * @returns {String} the first n bits of the address as a string
       */
      mask(mask = this.subnetMask) {
        return this.getBitsBase2(0, mask);
      }
      /**
       * Return the number of possible subnets of a given size in the address
       * @memberof Address6
       * @instance
       * @param {number} [size=128] - the subnet size
       * @returns {String}
       */
      // TODO: probably useful to have a numeric version of this too
      possibleSubnets(subnetSize = 128) {
        const availableBits = constants6.BITS - this.subnetMask;
        const subnetBits = Math.abs(subnetSize - constants6.BITS);
        const subnetPowers = availableBits - subnetBits;
        if (subnetPowers < 0) {
          return "0";
        }
        return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
      }
      /**
       * Helper function getting start address.
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
      }
      /**
       * The first address in the range given by this address' subnet
       * Often referred to as the Network Address.
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddress() {
        return _Address6.fromBigInteger(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address6.fromBigInteger(this._startAddress().add(adjust));
      }
      /**
       * Helper function getting end address.
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddress() {
        return _Address6.fromBigInteger(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address6.fromBigInteger(this._endAddress().subtract(adjust));
      }
      /**
       * Return the scope of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getScope() {
        let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
        if (this.getType() === "Global unicast" && scope !== "Link local") {
          scope = "Global";
        }
        return scope || "Unknown";
      }
      /**
       * Return the type of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getType() {
        for (const subnet of Object.keys(constants6.TYPES)) {
          if (this.isInSubnet(new _Address6(subnet))) {
            return constants6.TYPES[subnet];
          }
        }
        return "Global unicast";
      }
      /**
       * Return the bits in the given range as a BigInteger
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      getBits(start, end) {
        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
      }
      /**
       * Return the bits in the given range as a base-2 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the bits in the given range as a base-16 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase16(start, end) {
        const length = end - start;
        if (length % 4 !== 0) {
          throw new Error("Length of bits to retrieve must be divisible by four");
        }
        return this.getBits(start, end).toString(16).padStart(length / 4, "0");
      }
      /**
       * Return the bits that are set past the subnet mask length
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsPastSubnet() {
        return this.getBitsBase2(this.subnetMask, constants6.BITS);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address6
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const characters = Math.floor(this.subnetMask / 4);
        const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
        if (characters > 0) {
          if (options.omitSuffix) {
            return reversed;
          }
          return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
        }
        if (options.omitSuffix) {
          return "";
        }
        return "ip6.arpa.";
      }
      /**
       * Return the correct form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      correctForm() {
        let i;
        let groups = [];
        let zeroCounter = 0;
        const zeroes = [];
        for (i = 0; i < this.parsedAddress.length; i++) {
          const value = parseInt(this.parsedAddress[i], 16);
          if (value === 0) {
            zeroCounter++;
          }
          if (value !== 0 && zeroCounter > 0) {
            if (zeroCounter > 1) {
              zeroes.push([i - zeroCounter, i - 1]);
            }
            zeroCounter = 0;
          }
        }
        if (zeroCounter > 1) {
          zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
        }
        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
        if (zeroes.length > 0) {
          const index = zeroLengths.indexOf(Math.max(...zeroLengths));
          groups = compact(this.parsedAddress, zeroes[index]);
        } else {
          groups = this.parsedAddress;
        }
        for (i = 0; i < groups.length; i++) {
          if (groups[i] !== "compact") {
            groups[i] = parseInt(groups[i], 16).toString(16);
          }
        }
        let correct = groups.join(":");
        correct = correct.replace(/^compact$/, "::");
        correct = correct.replace(/^compact|compact$/, ":");
        correct = correct.replace(/compact/, "");
        return correct;
      }
      /**
       * Return a zero-padded base-2 string representation of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       * @example
       * var address = new Address6('2001:4860:4001:803::1011');
       * address.binaryZeroPad();
       * // '0010000000000001010010000110000001000000000000010000100000000011
       * //  0000000000000000000000000000000000000000000000000001000000010001'
       */
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
      }
      // TODO: Improve the semantics of this helper function
      parse4in6(address) {
        const groups = address.split(":");
        const lastGroup = groups.slice(-1)[0];
        const address4 = lastGroup.match(constants4.RE_ADDRESS);
        if (address4) {
          this.parsedAddress4 = address4[0];
          this.address4 = new ipv4_1.Address4(this.parsedAddress4);
          for (let i = 0; i < this.address4.groups; i++) {
            if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
              throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
            }
          }
          this.v4 = true;
          groups[groups.length - 1] = this.address4.toGroup6();
          address = groups.join(":");
        }
        return address;
      }
      // TODO: Make private?
      parse(address) {
        address = this.parse4in6(address);
        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
        if (badCharacters) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
        }
        const badAddress = address.match(constants6.RE_BAD_ADDRESS);
        if (badAddress) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
        }
        let groups = [];
        const halves = address.split("::");
        if (halves.length === 2) {
          let first = halves[0].split(":");
          let last = halves[1].split(":");
          if (first.length === 1 && first[0] === "") {
            first = [];
          }
          if (last.length === 1 && last[0] === "") {
            last = [];
          }
          const remaining = this.groups - (first.length + last.length);
          if (!remaining) {
            throw new address_error_1.AddressError("Error parsing groups");
          }
          this.elidedGroups = remaining;
          this.elisionBegin = first.length;
          this.elisionEnd = first.length + this.elidedGroups;
          groups = groups.concat(first);
          for (let i = 0; i < remaining; i++) {
            groups.push("0");
          }
          groups = groups.concat(last);
        } else if (halves.length === 1) {
          groups = address.split(":");
          this.elidedGroups = 0;
        } else {
          throw new address_error_1.AddressError("Too many :: groups found");
        }
        groups = groups.map((group) => (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)));
        if (groups.length !== this.groups) {
          throw new address_error_1.AddressError("Incorrect number of groups found");
        }
        return groups;
      }
      /**
       * Return the canonical form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      canonicalForm() {
        return this.parsedAddress.map(paddedHex).join(":");
      }
      /**
       * Return the decimal form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      decimal() {
        return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16))).join(":");
      }
      /**
       * Return the address as a BigInteger
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
      }
      /**
       * Return the last two groups of this address as an IPv4 address string
       * @memberof Address6
       * @instance
       * @returns {Address4}
       * @example
       * var address = new Address6('2001:4860:4001::1825:bf11');
       * address.to4().correctForm(); // '24.37.191.17'
       */
      to4() {
        const binary = this.binaryZeroPad().split("");
        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
      }
      /**
       * Return the v4-in-v6 form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      to4in6() {
        const address4 = this.to4();
        const address6 = new _Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
        const correct = address6.correctForm();
        let infix = "";
        if (!/:$/.test(correct)) {
          infix = ":";
        }
        return correct + infix + address4.address;
      }
      /**
       * Return an object containing the Teredo properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspectTeredo() {
        const prefix = this.getBitsBase16(0, 32);
        const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
        const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
        const flags = this.getBits(64, 80);
        const flagsBase2 = this.getBitsBase2(64, 80);
        const coneNat = flags.testBit(15);
        const reserved = flags.testBit(14);
        const groupIndividual = flags.testBit(8);
        const universalLocal = flags.testBit(9);
        const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
          server4: server4.address,
          client4: client4.address,
          flags: flagsBase2,
          coneNat,
          microsoft: {
            reserved,
            universalLocal,
            groupIndividual,
            nonce
          },
          udpPort
        };
      }
      /**
       * Return an object containing the 6to4 properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspect6to4() {
        const prefix = this.getBitsBase16(0, 16);
        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
          gateway: gateway.address
        };
      }
      /**
       * Return a v6 6to4 address from a v6 v4inv6 address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      to6to4() {
        if (!this.is4()) {
          return null;
        }
        const addr6to4 = [
          "2002",
          this.getBitsBase16(96, 112),
          this.getBitsBase16(112, 128),
          "",
          "/16"
        ].join(":");
        return new _Address6(addr6to4);
      }
      /**
       * Return a byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toByteArray() {
        const byteArray = this.bigInteger().toByteArray();
        if (byteArray.length === 17 && byteArray[0] === 0) {
          return byteArray.slice(1);
        }
        return byteArray;
      }
      /**
       * Return an unsigned byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toUnsignedByteArray() {
        return this.toByteArray().map(unsignByte);
      }
      /**
       * Convert a byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromByteArray(bytes) {
        return this.fromUnsignedByteArray(bytes.map(unsignByte));
      }
      /**
       * Convert an unsigned byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromUnsignedByteArray(bytes) {
        const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
        let result = new jsbn_1.BigInteger("0", 10);
        let multiplier = new jsbn_1.BigInteger("1", 10);
        for (let i = bytes.length - 1; i >= 0; i--) {
          result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));
          multiplier = multiplier.multiply(BYTE_MAX);
        }
        return _Address6.fromBigInteger(result);
      }
      /**
       * Returns true if the address is in the canonical form, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isCanonical() {
        return this.addressMinusSuffix === this.canonicalForm();
      }
      /**
       * Returns true if the address is a link local address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLinkLocal() {
        if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
          return true;
        }
        return false;
      }
      /**
       * Returns true if the address is a multicast address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.getType() === "Multicast";
      }
      /**
       * Returns true if the address is a v4-in-v6 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is4() {
        return this.v4;
      }
      /**
       * Returns true if the address is a Teredo address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isTeredo() {
        return this.isInSubnet(new _Address6("2001::/32"));
      }
      /**
       * Returns true if the address is a 6to4 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is6to4() {
        return this.isInSubnet(new _Address6("2002::/16"));
      }
      /**
       * Returns true if the address is a loopback address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLoopback() {
        return this.getType() === "Loopback";
      }
      // #endregion
      // #region HTML
      /**
       * @returns {String} the address in link form with a default port of 80
       */
      href(optionalPort) {
        if (optionalPort === void 0) {
          optionalPort = "";
        } else {
          optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
        }
        return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
      }
      /**
       * @returns {String} a link suitable for conveying the address via a URL hash
       */
      link(options) {
        if (!options) {
          options = {};
        }
        if (options.className === void 0) {
          options.className = "";
        }
        if (options.prefix === void 0) {
          options.prefix = "/#address=";
        }
        if (options.v4 === void 0) {
          options.v4 = false;
        }
        let formFunction = this.correctForm;
        if (options.v4) {
          formFunction = this.to4in6;
        }
        if (options.className) {
          return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
        }
        return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
      }
      /**
       * Groups an address
       * @returns {String}
       */
      group() {
        if (this.elidedGroups === 0) {
          return helpers.simpleGroup(this.address).join(":");
        }
        assert(typeof this.elidedGroups === "number");
        assert(typeof this.elisionBegin === "number");
        const output = [];
        const [left, right] = this.address.split("::");
        if (left.length) {
          output.push(...helpers.simpleGroup(left));
        } else {
          output.push("");
        }
        const classes = ["hover-group"];
        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
          classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
        }
        output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
        if (right.length) {
          output.push(...helpers.simpleGroup(right, this.elisionEnd));
        } else {
          output.push("");
        }
        if (this.is4()) {
          assert(this.address4 instanceof ipv4_1.Address4);
          output.pop();
          output.push(this.address4.groupForV6());
        }
        return output.join(":");
      }
      // #endregion
      // #region Regular expressions
      /**
       * Generate a regular expression string that can be used to find or validate
       * all variations of this address
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {string}
       */
      regularExpressionString(substringSearch = false) {
        let output = [];
        const address6 = new _Address6(this.correctForm());
        if (address6.elidedGroups === 0) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
        } else if (address6.elidedGroups === constants6.GROUPS) {
          output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
        } else {
          const halves = address6.address.split("::");
          if (halves[0].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
          }
          assert(typeof address6.elidedGroups === "number");
          output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
          if (halves[1].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
          }
          output = [output.join(":")];
        }
        if (!substringSearch) {
          output = [
            "(?=^|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|[^\\w\\:])(",
            ...output,
            ")(?=[^\\w\\:]|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|$)"
          ];
        }
        return output.join("");
      }
      /**
       * Generate a regular expression that can be used to find or validate all
       * variations of this address.
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {RegExp}
       */
      regularExpression(substringSearch = false) {
        return new RegExp(this.regularExpressionString(substringSearch), "i");
      }
    };
    exports2.Address6 = Address6;
  }
});

// asset-input/node_modules/ip-address/dist/ip-address.js
var require_ip_address = __commonJS({
  "asset-input/node_modules/ip-address/dist/ip-address.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var address_error_1 = require_address_error();
    Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
      return address_error_1.AddressError;
    } });
    var helpers = __importStar(require_helpers());
    exports2.v6 = { helpers };
  }
});

// asset-input/node_modules/socks/build/common/helpers.js
var require_helpers2 = __commonJS({
  "asset-input/node_modules/socks/build/common/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipToBuffer = exports2.int32ToIpv4 = exports2.ipv4ToInt32 = exports2.validateSocksClientChainOptions = exports2.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants4();
    var stream = require("stream");
    var ip_address_1 = require_ip_address();
    var net = require("net");
    function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
      }
      if (acceptedCommands.indexOf(options.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!isValidSocksProxy(options.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(options.proxy, options);
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
      if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
      }
    }
    exports2.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options) {
      if (options.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
      }
      options.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
        }
        validateCustomProxyAuth(proxy, options);
      });
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
    }
    exports2.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
    function ipv4ToInt32(ip) {
      const address = new ip_address_1.Address4(ip);
      return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
    }
    exports2.ipv4ToInt32 = ipv4ToInt32;
    function int32ToIpv4(int32) {
      const octet1 = int32 >>> 24 & 255;
      const octet2 = int32 >>> 16 & 255;
      const octet3 = int32 >>> 8 & 255;
      const octet4 = int32 & 255;
      return [octet1, octet2, octet3, octet4].join(".");
    }
    exports2.int32ToIpv4 = int32ToIpv4;
    function ipToBuffer(ip) {
      if (net.isIPv4(ip)) {
        const address = new ip_address_1.Address4(ip);
        return Buffer.from(address.toArray());
      } else if (net.isIPv6(ip)) {
        const address = new ip_address_1.Address6(ip);
        return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
      } else {
        throw new Error("Invalid IP address format");
      }
    }
    exports2.ipToBuffer = ipToBuffer;
  }
});

// asset-input/node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "asset-input/node_modules/socks/build/common/receivebuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports2.ReceiveBuffer = ReceiveBuffer;
  }
});

// asset-input/node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "asset-input/node_modules/socks/build/client/socksclient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocksClientError = exports2.SocksClient = void 0;
    var events_1 = require("events");
    var net = require("net");
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants4();
    var helpers_1 = require_helpers2();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports2, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var ip_address_1 = require_ip_address();
    var SocksClient = class _SocksClient extends events_1.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign({}, options);
        (0, helpers_1.validateSocksClientOptions)(options);
        this.setState(constants_1.SocksClientState.Created);
      }
      /**
       * Creates a new SOCKS connection.
       *
       * Note: Supports callbacks and promises. Only supports the connect command.
       * @param options { SocksClientOptions } Options.
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnection(options, callback) {
        return new Promise((resolve, reject) => {
          try {
            (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new _SocksClient(options);
          client.connect(options.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve(info);
            } else {
              resolve(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      /**
       * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
       *
       * Note: Supports callbacks and promises. Only supports the connect method.
       * Note: Implemented via createConnection() factory function.
       * @param options { SocksClientChainOptions } Options
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnectionChain(options, callback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            (0, helpers_1.validateSocksClientChainOptions)(options);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          if (options.randomizeChain) {
            (0, util_1.shuffleArray)(options.proxies);
          }
          try {
            let sock;
            for (let i = 0; i < options.proxies.length; i++) {
              const nextProxy = options.proxies[i];
              const nextDestination = i === options.proxies.length - 1 ? options.destination : {
                host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
                port: options.proxies[i + 1].port
              };
              const result = yield _SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination,
                existing_socket: sock
              });
              sock = sock || result.socket;
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      /**
       * Creates a SOCKS UDP Frame.
       * @param options
       */
      static createUDPFrame(options) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options.frameNumber || 0);
        if (net.isIPv4(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
        } else if (net.isIPv6(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
          buff.writeString(options.remoteHost.host);
        }
        buff.writeUInt16BE(options.remoteHost.port);
        buff.writeBuffer(options.data);
        return buff.toBuffer();
      }
      /**
       * Parses a SOCKS UDP frame.
       * @param data
       */
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      /**
       * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
       */
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      /**
       * Starts the connection establishment to the proxy and destination.
       * @param existingSocket Connected socket to use instead of creating a new one (internal use).
       */
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      /**
       * Handles internal Socks timeout callback.
       * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
       */
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      /**
       * Handles Socket connect event.
       */
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles Socket data event.
       * @param data
       */
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      /**
       * Handles processing of the data we have received.
       */
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      /**
       * Handles Socket close event.
       * @param had_error
       */
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      /**
       * Handles Socket error event.
       * @param err
       */
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      /**
       * Removes internal event listeners on the underlying Socket.
       */
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      /**
       * Closes and destroys the underlying Socket. Emits an error event.
       * @param err { String } An error string to include in error event.
       */
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      /**
       * Sends initial Socks v4 handshake request.
       */
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      /**
       * Handles Socks v4 handshake response.
       * @param data
       */
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      /**
       * Handles Socks v4 incoming connection request (BIND)
       * @param data
       */
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      /**
       * Sends initial Socks v5 handshake request.
       */
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles initial Socks v5 handshake response.
       * @param data
       */
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      /**
       * Sends Socks v5 user & password auth handshake.
       *
       * Note: No auth and user/pass are currently supported.
       */
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      /**
       * Handles Socks v5 auth handshake response.
       * @param data
       */
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      /**
       * Sends Socks v5 final handshake request.
       */
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      /**
       * Handles Socks v5 final handshake response.
       * @param data
       */
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      /**
       * Handles Socks v5 incoming connection request (BIND).
       */
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports2.SocksClient = SocksClient;
  }
});

// asset-input/node_modules/socks/build/index.js
var require_build = __commonJS({
  "asset-input/node_modules/socks/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports2);
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/mongocr.js
var require_mongocr = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/mongocr.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoCR = void 0;
    var crypto = require("crypto");
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var auth_provider_1 = require_auth_provider();
    var MongoCR = class extends auth_provider_1.AuthProvider {
      auth(authContext, callback) {
        const { connection, credentials } = authContext;
        if (!credentials) {
          return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
        }
        const username = credentials.username;
        const password = credentials.password;
        const source = credentials.source;
        connection.command((0, utils_1.ns)(`${source}.$cmd`), { getnonce: 1 }, void 0, (err, r) => {
          let nonce = null;
          let key = null;
          if (err == null) {
            nonce = r.nonce;
            let md5 = crypto.createHash("md5");
            md5.update(`${username}:mongo:${password}`, "utf8");
            const hash_password = md5.digest("hex");
            md5 = crypto.createHash("md5");
            md5.update(nonce + username + hash_password, "utf8");
            key = md5.digest("hex");
          }
          const authenticateCommand = {
            authenticate: 1,
            user: username,
            nonce,
            key
          };
          connection.command((0, utils_1.ns)(`${source}.$cmd`), authenticateCommand, void 0, callback);
        });
      }
    };
    exports2.MongoCR = MongoCR;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/mongodb_aws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoDBAWS = void 0;
    var crypto = require("crypto");
    var http = require("http");
    var url = require("url");
    var BSON = require_bson2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var auth_provider_1 = require_auth_provider();
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var ASCII_N = 110;
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var bsonOptions = {
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      bsonRegExp: false
    };
    var MongoDBAWS = class extends auth_provider_1.AuthProvider {
      auth(authContext, callback) {
        const { connection, credentials } = authContext;
        if (!credentials) {
          return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
        }
        if ("kModuleError" in deps_1.aws4) {
          return callback(deps_1.aws4["kModuleError"]);
        }
        const { sign } = deps_1.aws4;
        if ((0, utils_1.maxWireVersion)(connection) < 9) {
          callback(new error_1.MongoCompatibilityError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
          return;
        }
        if (!credentials.username) {
          makeTempCredentials(credentials, (err, tempCredentials) => {
            if (err || !tempCredentials)
              return callback(err);
            authContext.credentials = tempCredentials;
            this.auth(authContext, callback);
          });
          return;
        }
        const accessKeyId = credentials.username;
        const secretAccessKey = credentials.password;
        const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : void 0;
        const db = credentials.source;
        crypto.randomBytes(32, (err, nonce) => {
          if (err) {
            callback(err);
            return;
          }
          const saslStart = {
            saslStart: 1,
            mechanism: "MONGODB-AWS",
            payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
          };
          connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, void 0, (err2, res) => {
            if (err2)
              return callback(err2);
            const serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions);
            const host = serverResponse.h;
            const serverNonce = serverResponse.s.buffer;
            if (serverNonce.length !== 64) {
              callback(
                // TODO(NODE-3483)
                new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`)
              );
              return;
            }
            if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
              callback(new error_1.MongoRuntimeError("Server nonce does not begin with client nonce"));
              return;
            }
            if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
              callback(new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`));
              return;
            }
            const body = "Action=GetCallerIdentity&Version=2011-06-15";
            const options = sign({
              method: "POST",
              host,
              region: deriveRegion(serverResponse.h),
              service: "sts",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": body.length,
                "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
                "X-MongoDB-GS2-CB-Flag": "n"
              },
              path: "/",
              body
            }, awsCredentials);
            const payload = {
              a: options.headers.Authorization,
              d: options.headers["X-Amz-Date"]
            };
            if (sessionToken) {
              payload.t = sessionToken;
            }
            const saslContinue = {
              saslContinue: 1,
              conversationId: 1,
              payload: BSON.serialize(payload, bsonOptions)
            };
            connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, void 0, callback);
          });
        });
      }
    };
    exports2.MongoDBAWS = MongoDBAWS;
    function makeTempCredentials(credentials, callback) {
      function done(creds) {
        if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {
          callback(new error_1.MongoMissingCredentialsError("Could not obtain temporary MONGODB-AWS credentials"));
          return;
        }
        callback(void 0, new mongo_credentials_1.MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: providers_1.AuthMechanism.MONGODB_AWS,
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        }));
      }
      const credentialProvider = (0, deps_1.getAwsCredentialProvider)();
      if ("kModuleError" in credentialProvider) {
        if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
          request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, void 0, (err, res) => {
            if (err)
              return callback(err);
            done(res);
          });
          return;
        }
        request(`${AWS_EC2_URI}/latest/api/token`, { method: "PUT", json: false, headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 } }, (err, token) => {
          if (err)
            return callback(err);
          request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, { json: false, headers: { "X-aws-ec2-metadata-token": token } }, (err2, roleName) => {
            if (err2)
              return callback(err2);
            request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, { headers: { "X-aws-ec2-metadata-token": token } }, (err3, creds) => {
              if (err3)
                return callback(err3);
              done(creds);
            });
          });
        });
      } else {
        const { fromNodeProviderChain } = credentialProvider;
        const provider = fromNodeProviderChain();
        provider().then((creds) => {
          done({
            AccessKeyId: creds.accessKeyId,
            SecretAccessKey: creds.secretAccessKey,
            Token: creds.sessionToken,
            Expiration: creds.expiration
          });
        }).catch((error) => {
          callback(new error_1.MongoAWSError(error.message));
        });
      }
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
    function request(uri, _options, callback) {
      const options = Object.assign({
        method: "GET",
        timeout: 1e4,
        json: true
      }, url.parse(uri), _options);
      const req = http.request(options, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => data += d);
        res.on("end", () => {
          if (options.json === false) {
            callback(void 0, data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            callback(void 0, parsed);
          } catch (err) {
            callback(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.on("timeout", () => {
        req.destroy(new error_1.MongoAWSError(`AWS request to ${uri} timed out after ${options.timeout} ms`));
      });
      req.on("error", (err) => callback(err));
      req.end();
    }
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/plain.js
var require_plain = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/plain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Plain = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var auth_provider_1 = require_auth_provider();
    var Plain = class extends auth_provider_1.AuthProvider {
      auth(authContext, callback) {
        const { connection, credentials } = authContext;
        if (!credentials) {
          return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
        }
        const username = credentials.username;
        const password = credentials.password;
        const payload = new bson_1.Binary(Buffer.from(`\0${username}\0${password}`));
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        connection.command((0, utils_1.ns)("$external.$cmd"), command, void 0, callback);
      }
    };
    exports2.Plain = Plain;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/scram.js
var require_scram = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/scram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ScramSHA256 = exports2.ScramSHA1 = void 0;
    var crypto = require("crypto");
    var bson_1 = require_bson2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var auth_provider_1 = require_auth_provider();
    var providers_1 = require_providers();
    var ScramSHA = class extends auth_provider_1.AuthProvider {
      constructor(cryptoMethod) {
        super();
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      prepare(handshakeDoc, authContext, callback) {
        const cryptoMethod = this.cryptoMethod;
        const credentials = authContext.credentials;
        if (!credentials) {
          return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
        }
        if (cryptoMethod === "sha256" && ("kModuleError" in deps_1.saslprep || typeof deps_1.saslprep !== "function")) {
          (0, utils_1.emitWarning)("Warning: no saslprep library specified. Passwords will not be sanitized");
        }
        crypto.randomBytes(24, (err, nonce) => {
          if (err) {
            return callback(err);
          }
          Object.assign(authContext, { nonce });
          const request = Object.assign({}, handshakeDoc, {
            speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
              db: credentials.source
            })
          });
          callback(void 0, request);
        });
      }
      auth(authContext, callback) {
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
          return;
        }
        executeScram(this.cryptoMethod, authContext, callback);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer.concat([
        Buffer.from("n=", "utf8"),
        Buffer.from(username, "utf8"),
        Buffer.from(",r=", "utf8"),
        Buffer.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
      return {
        saslStart: 1,
        mechanism,
        payload: new bson_1.Binary(Buffer.concat([Buffer.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: { skipEmptyExchange: true }
      };
    }
    function executeScram(cryptoMethod, authContext, callback) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
      }
      if (!authContext.nonce) {
        return callback(new error_1.MongoInvalidArgumentError("AuthContext must contain a valid nonce property"));
      }
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, void 0, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        continueScramConversation(cryptoMethod, result, authContext, callback);
      });
    }
    function continueScramConversation(cryptoMethod, response, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
      }
      if (!authContext.nonce) {
        return callback(new error_1.MongoInvalidArgumentError("Unable to continue SCRAM without valid nonce"));
      }
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      let processedPassword;
      if (cryptoMethod === "sha256") {
        processedPassword = "kModuleError" in deps_1.saslprep || typeof deps_1.saslprep !== "function" ? password : (0, deps_1.saslprep)(password);
      } else {
        try {
          processedPassword = passwordDigest(username, password);
        } catch (e) {
          return callback(e);
        }
      }
      const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
      const dict = parsePayload(payload.value());
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        callback(
          // TODO(NODE-3483)
          new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`),
          false
        );
        return;
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);
        return;
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new bson_1.Binary(Buffer.from(clientFinal))
      };
      connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, void 0, (_err, r) => {
        const err = resolveError(_err, r);
        if (err) {
          return callback(err);
        }
        const parsedResponse = parsePayload(r.payload.value());
        if (!compareDigest(Buffer.from(parsedResponse.v, "base64"), serverSignature)) {
          callback(new error_1.MongoRuntimeError("Server returned an invalid signature"));
          return;
        }
        if (!r || r.done !== false) {
          return callback(err, r);
        }
        const retrySaslContinueCmd = {
          saslContinue: 1,
          conversationId: r.conversationId,
          payload: Buffer.alloc(0)
        };
        connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, void 0, callback);
      });
    }
    function parsePayload(payload) {
      const dict = {};
      const parts = payload.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = parts[i].split("=");
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new error_1.MongoInvalidArgumentError("Username must be a string");
      }
      if (typeof password !== "string") {
        throw new error_1.MongoInvalidArgumentError("Password must be a string");
      }
      if (password.length === 0) {
        throw new error_1.MongoInvalidArgumentError("Password cannot be empty");
      }
      let md5;
      try {
        md5 = crypto.createHash("md5");
      } catch (err) {
        if (crypto.getFips()) {
          throw new Error("Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode");
        }
        throw err;
      }
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer.isBuffer(a)) {
        a = Buffer.from(a);
      }
      if (!Buffer.isBuffer(b)) {
        b = Buffer.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] != null) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    function resolveError(err, result) {
      if (err)
        return err;
      if (result) {
        if (result.$err || result.errmsg)
          return new error_1.MongoServerError(result);
      }
      return;
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor() {
        super("sha1");
      }
    };
    exports2.ScramSHA1 = ScramSHA1;
    var ScramSHA256 = class extends ScramSHA {
      constructor() {
        super("sha256");
      }
    };
    exports2.ScramSHA256 = ScramSHA256;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/auth/x509.js
var require_x509 = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/auth/x509.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.X509 = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var auth_provider_1 = require_auth_provider();
    var X509 = class extends auth_provider_1.AuthProvider {
      prepare(handshakeDoc, authContext, callback) {
        const { credentials } = authContext;
        if (!credentials) {
          return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
        }
        Object.assign(handshakeDoc, {
          speculativeAuthenticate: x509AuthenticateCommand(credentials)
        });
        callback(void 0, handshakeDoc);
      }
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (!credentials) {
          return callback(new error_1.MongoMissingCredentialsError("AuthContext must provide credentials."));
        }
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          return callback();
        }
        connection.command((0, utils_1.ns)("$external.$cmd"), x509AuthenticateCommand(credentials), void 0, callback);
      }
    };
    exports2.X509 = X509;
    function x509AuthenticateCommand(credentials) {
      const command = { authenticate: 1, mechanism: "MONGODB-X509" };
      if (credentials.username) {
        command.user = credentials.username;
      }
      return command;
    }
  }
});

// asset-input/node_modules/mongodb/lib/cmap/connect.js
var require_connect = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/connect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LEGAL_TCP_SOCKET_OPTIONS = exports2.LEGAL_TLS_SOCKET_OPTIONS = exports2.prepareHandshakeDocument = exports2.connect = void 0;
    var net = require("net");
    var socks_1 = require_build();
    var tls = require("tls");
    var bson_1 = require_bson2();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var auth_provider_1 = require_auth_provider();
    var gssapi_1 = require_gssapi();
    var mongocr_1 = require_mongocr();
    var mongodb_aws_1 = require_mongodb_aws();
    var plain_1 = require_plain();
    var providers_1 = require_providers();
    var scram_1 = require_scram();
    var x509_1 = require_x509();
    var connection_1 = require_connection();
    var constants_2 = require_constants2();
    var AUTH_PROVIDERS = /* @__PURE__ */ new Map([
      [providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()],
      [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()],
      [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()],
      [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()],
      [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()],
      [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()],
      [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]
    ]);
    function connect(options, callback) {
      makeConnection({ ...options, existingSocket: void 0 }, (err, socket) => {
        var _a;
        if (err || !socket) {
          return callback(err);
        }
        let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;
        if (options.autoEncrypter) {
          ConnectionType = connection_1.CryptoConnection;
        }
        performInitialHandshake(new ConnectionType(socket, options), options, callback);
      });
    }
    exports2.connect = connect;
    function checkSupportedServer(hello, options) {
      var _a;
      const serverVersionHighEnough = hello && (typeof hello.maxWireVersion === "number" || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = hello && (typeof hello.minWireVersion === "number" || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
        return new error_1.MongoCompatibilityError(message2);
      }
      const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
      return new error_1.MongoCompatibilityError(message);
    }
    function performInitialHandshake(conn, options, _callback) {
      const callback = function(err, ret) {
        if (err && conn) {
          conn.destroy();
        }
        _callback(err, ret);
      };
      const credentials = options.credentials;
      if (credentials) {
        if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !AUTH_PROVIDERS.get(credentials.mechanism)) {
          callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));
          return;
        }
      }
      const authContext = new auth_provider_1.AuthContext(conn, credentials, options);
      prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
        if (err || !handshakeDoc) {
          return callback(err);
        }
        const handshakeOptions = Object.assign({}, options);
        if (typeof options.connectTimeoutMS === "number") {
          handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
        }
        const start = (/* @__PURE__ */ new Date()).getTime();
        conn.command((0, utils_1.ns)("admin.$cmd"), handshakeDoc, handshakeOptions, (err2, response) => {
          if (err2) {
            callback(err2);
            return;
          }
          if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {
            callback(new error_1.MongoServerError(response));
            return;
          }
          if (!("isWritablePrimary" in response)) {
            response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
          }
          if (response.helloOk) {
            conn.helloOk = true;
          }
          const supportedServerErr = checkSupportedServer(response, options);
          if (supportedServerErr) {
            callback(supportedServerErr);
            return;
          }
          if (options.loadBalanced) {
            if (!response.serviceId) {
              return callback(new error_1.MongoCompatibilityError("Driver attempted to initialize in load balancing mode, but the server does not support this mode."));
            }
          }
          conn.hello = response;
          conn.lastHelloMS = (/* @__PURE__ */ new Date()).getTime() - start;
          if (!response.arbiterOnly && credentials) {
            authContext.response = response;
            const resolvedCredentials = credentials.resolveAuthMechanism(response);
            const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);
            if (!provider) {
              return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));
            }
            provider.auth(authContext, (err3) => {
              if (err3) {
                if (err3 instanceof error_1.MongoError) {
                  err3.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
                  if ((0, error_1.needsRetryableWriteLabel)(err3, response.maxWireVersion)) {
                    err3.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
                  }
                }
                return callback(err3);
              }
              callback(void 0, conn);
            });
            return;
          }
          callback(void 0, conn);
        });
      });
    }
    function prepareHandshakeDocument(authContext, callback) {
      const options = authContext.options;
      const compressors = options.compressors ? options.compressors : [];
      const { serverApi } = authContext.connection;
      const handshakeDoc = {
        [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: true,
        helloOk: true,
        client: options.metadata,
        compression: compressors
      };
      if (options.loadBalanced === true) {
        handshakeDoc.loadBalanced = true;
      }
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
          handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
          const provider2 = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);
          if (!provider2) {
            return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));
          }
          return provider2.prepare(handshakeDoc, authContext, callback);
        }
        const provider = AUTH_PROVIDERS.get(credentials.mechanism);
        if (!provider) {
          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));
        }
        return provider.prepare(handshakeDoc, authContext, callback);
      }
      callback(void 0, handshakeDoc);
    }
    exports2.prepareHandshakeDocument = prepareHandshakeDocument;
    exports2.LEGAL_TLS_SOCKET_OPTIONS = [
      "ALPNProtocols",
      "ca",
      "cert",
      "checkServerIdentity",
      "ciphers",
      "crl",
      "ecdhCurve",
      "key",
      "minDHSize",
      "passphrase",
      "pfx",
      "rejectUnauthorized",
      "secureContext",
      "secureProtocol",
      "servername",
      "session"
    ];
    exports2.LEGAL_TCP_SOCKET_OPTIONS = [
      "family",
      "hints",
      "localAddress",
      "localPort",
      "lookup"
    ];
    function parseConnectOptions(options) {
      const hostAddress = options.hostAddress;
      if (!hostAddress)
        throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
      const result = {};
      for (const name of exports2.LEGAL_TCP_SOCKET_OPTIONS) {
        if (options[name] != null) {
          result[name] = options[name];
        }
      }
      if (typeof hostAddress.socketPath === "string") {
        result.path = hostAddress.socketPath;
        return result;
      } else if (typeof hostAddress.host === "string") {
        result.host = hostAddress.host;
        result.port = hostAddress.port;
        return result;
      } else {
        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
      }
    }
    function parseSslOptions(options) {
      const result = parseConnectOptions(options);
      for (const name of exports2.LEGAL_TLS_SOCKET_OPTIONS) {
        if (options[name] != null) {
          result[name] = options[name];
        }
      }
      if (options.existingSocket) {
        result.socket = options.existingSocket;
      }
      if (result.servername == null && result.host && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    var SOCKET_ERROR_EVENT_LIST = ["error", "close", "timeout", "parseError"];
    var SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);
    function makeConnection(options, _callback) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;
      const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;
      const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, "socketTimeout")) !== null && _d !== void 0 ? _d : 0;
      const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;
      const connectTimeoutMS = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 3e4;
      const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;
      const keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 12e4) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 12e4;
      const existingSocket = options.existingSocket;
      let socket;
      const callback = function(err, ret) {
        if (err && socket) {
          socket.destroy();
        }
        _callback(err, ret);
      };
      if (options.proxyHost != null) {
        return makeSocks5Connection({
          ...options,
          connectTimeoutMS
          // Should always be present for Socks5
        }, callback);
      }
      if (useTLS) {
        const tlsSocket = tls.connect(parseSslOptions(options));
        if (typeof tlsSocket.disableRenegotiation === "function") {
          tlsSocket.disableRenegotiation();
        }
        socket = tlsSocket;
      } else if (existingSocket) {
        socket = existingSocket;
      } else {
        socket = net.createConnection(parseConnectOptions(options));
      }
      socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
      socket.setTimeout(connectTimeoutMS);
      socket.setNoDelay(noDelay);
      const connectEvent = useTLS ? "secureConnect" : "connect";
      let cancellationHandler;
      function errorHandler(eventName) {
        return (err) => {
          SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
          if (cancellationHandler && options.cancellationToken) {
            options.cancellationToken.removeListener("cancel", cancellationHandler);
          }
          socket.removeListener(connectEvent, connectHandler);
          callback(connectionFailureError(eventName, err));
        };
      }
      function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler && options.cancellationToken) {
          options.cancellationToken.removeListener("cancel", cancellationHandler);
        }
        if ("authorizationError" in socket) {
          if (socket.authorizationError && rejectUnauthorized) {
            return callback(socket.authorizationError);
          }
        }
        socket.setTimeout(0);
        callback(void 0, socket);
      }
      SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
      if (options.cancellationToken) {
        cancellationHandler = errorHandler("cancel");
        options.cancellationToken.once("cancel", cancellationHandler);
      }
      if (existingSocket) {
        process.nextTick(connectHandler);
      } else {
        socket.once(connectEvent, connectHandler);
      }
    }
    function makeSocks5Connection(options, callback) {
      var _a, _b;
      const hostAddress = utils_1.HostAddress.fromHostPort(
        (_a = options.proxyHost) !== null && _a !== void 0 ? _a : "",
        // proxyHost is guaranteed to set here
        (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080
      );
      makeConnection({
        ...options,
        hostAddress,
        tls: false,
        proxyHost: void 0
      }, (err, rawSocket) => {
        if (err) {
          return callback(err);
        }
        const destination = parseConnectOptions(options);
        if (typeof destination.host !== "string" || typeof destination.port !== "number") {
          return callback(new error_1.MongoInvalidArgumentError("Can only make Socks5 connections to TCP hosts"));
        }
        socks_1.SocksClient.createConnection({
          existing_socket: rawSocket,
          timeout: options.connectTimeoutMS,
          command: "connect",
          destination: {
            host: destination.host,
            port: destination.port
          },
          proxy: {
            // host and port are ignored because we pass existing_socket
            host: "iLoveJavaScript",
            port: 0,
            type: 5,
            userId: options.proxyUsername || void 0,
            password: options.proxyPassword || void 0
          }
        }).then(({ socket }) => {
          makeConnection({
            ...options,
            existingSocket: socket,
            proxyHost: void 0
          }, callback);
        }, (error) => callback(connectionFailureError("error", error)));
      });
    }
    function connectionFailureError(type, err) {
      switch (type) {
        case "error":
          return new error_1.MongoNetworkError(err);
        case "timeout":
          return new error_1.MongoNetworkTimeoutError("connection timed out");
        case "close":
          return new error_1.MongoNetworkError("connection closed");
        case "cancel":
          return new error_1.MongoNetworkError("connection establishment was cancelled");
        default:
          return new error_1.MongoNetworkError("unknown network error");
      }
    }
  }
});

// asset-input/node_modules/mongodb/lib/cmap/connection_pool_events.js
var require_connection_pool_events = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/connection_pool_events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionPoolClearedEvent = exports2.ConnectionCheckedInEvent = exports2.ConnectionCheckedOutEvent = exports2.ConnectionCheckOutFailedEvent = exports2.ConnectionCheckOutStartedEvent = exports2.ConnectionClosedEvent = exports2.ConnectionReadyEvent = exports2.ConnectionCreatedEvent = exports2.ConnectionPoolClosedEvent = exports2.ConnectionPoolReadyEvent = exports2.ConnectionPoolCreatedEvent = exports2.ConnectionPoolMonitoringEvent = void 0;
    var ConnectionPoolMonitoringEvent = class {
      /** @internal */
      constructor(pool) {
        this.time = /* @__PURE__ */ new Date();
        this.address = pool.address;
      }
    };
    exports2.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        if (pool.options.credentials != null) {
          this.options = { ...pool.options, credentials: {} };
        } else {
          this.options = pool.options;
        }
      }
    };
    exports2.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;
    var ConnectionPoolReadyEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
      }
    };
    exports2.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
      }
    };
    exports2.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionCreatedEvent = ConnectionCreatedEvent;
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionReadyEvent = ConnectionReadyEvent;
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection, reason) {
        super(pool);
        this.connectionId = connection.id;
        this.reason = reason || "unknown";
        this.serviceId = connection.serviceId;
      }
    };
    exports2.ConnectionClosedEvent = ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
      }
    };
    exports2.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, reason) {
        super(pool);
        this.reason = reason;
      }
    };
    exports2.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionCheckedInEvent = ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, options = {}) {
        super(pool);
        this.serviceId = options.serviceId;
        this.interruptInUseConnections = options.interruptInUseConnections;
      }
    };
    exports2.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WaitQueueTimeoutError = exports2.PoolClearedOnNetworkError = exports2.PoolClearedError = exports2.PoolClosedError = void 0;
    var error_1 = require_error();
    var PoolClosedError = class extends error_1.MongoDriverError {
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.address = pool.address;
      }
      get name() {
        return "MongoPoolClosedError";
      }
    };
    exports2.PoolClosedError = PoolClosedError;
    var PoolClearedError = class extends error_1.MongoNetworkError {
      constructor(pool, message) {
        var _a;
        const errorMessage = message ? message : `Connection pool for ${pool.address} was cleared because another operation failed with: "${(_a = pool.serverError) === null || _a === void 0 ? void 0 : _a.message}"`;
        super(errorMessage);
        this.address = pool.address;
        this.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
      }
      get name() {
        return "MongoPoolClearedError";
      }
    };
    exports2.PoolClearedError = PoolClearedError;
    var PoolClearedOnNetworkError = class extends PoolClearedError {
      constructor(pool) {
        super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
      }
      get name() {
        return "PoolClearedOnNetworkError";
      }
    };
    exports2.PoolClearedOnNetworkError = PoolClearedOnNetworkError;
    var WaitQueueTimeoutError = class extends error_1.MongoDriverError {
      constructor(message, address) {
        super(message);
        this.address = address;
      }
      get name() {
        return "MongoWaitQueueTimeoutError";
      }
    };
    exports2.WaitQueueTimeoutError = WaitQueueTimeoutError;
  }
});

// asset-input/node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "asset-input/node_modules/mongodb/lib/cmap/connection_pool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionPool = exports2.PoolState = void 0;
    var timers_1 = require("timers");
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var logger_1 = require_logger();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils2();
    var connect_1 = require_connect();
    var connection_1 = require_connection();
    var connection_pool_events_1 = require_connection_pool_events();
    var errors_1 = require_errors();
    var metrics_1 = require_metrics();
    var kServer = Symbol("server");
    var kLogger = Symbol("logger");
    var kConnections = Symbol("connections");
    var kPending = Symbol("pending");
    var kCheckedOut = Symbol("checkedOut");
    var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
    var kGeneration = Symbol("generation");
    var kServiceGenerations = Symbol("serviceGenerations");
    var kConnectionCounter = Symbol("connectionCounter");
    var kCancellationToken = Symbol("cancellationToken");
    var kWaitQueue = Symbol("waitQueue");
    var kCancelled = Symbol("cancelled");
    var kMetrics = Symbol("metrics");
    var kProcessingWaitQueue = Symbol("processingWaitQueue");
    var kPoolState = Symbol("poolState");
    exports2.PoolState = Object.freeze({
      paused: "paused",
      ready: "ready",
      closed: "closed"
    });
    var ConnectionPool = class _ConnectionPool extends mongo_types_1.TypedEventEmitter {
      constructor(server, options) {
        var _a, _b, _c, _d, _e, _f;
        super();
        this.options = Object.freeze({
          ...options,
          connectionType: connection_1.Connection,
          maxPoolSize: (_a = options.maxPoolSize) !== null && _a !== void 0 ? _a : 100,
          minPoolSize: (_b = options.minPoolSize) !== null && _b !== void 0 ? _b : 0,
          maxConnecting: (_c = options.maxConnecting) !== null && _c !== void 0 ? _c : 2,
          maxIdleTimeMS: (_d = options.maxIdleTimeMS) !== null && _d !== void 0 ? _d : 0,
          waitQueueTimeoutMS: (_e = options.waitQueueTimeoutMS) !== null && _e !== void 0 ? _e : 0,
          minPoolSizeCheckFrequencyMS: (_f = options.minPoolSizeCheckFrequencyMS) !== null && _f !== void 0 ? _f : 100,
          autoEncrypter: options.autoEncrypter,
          metadata: options.metadata
        });
        if (this.options.minPoolSize > this.options.maxPoolSize) {
          throw new error_1.MongoInvalidArgumentError("Connection pool minimum size must not be greater than maximum pool size");
        }
        this[kPoolState] = exports2.PoolState.paused;
        this[kServer] = server;
        this[kLogger] = new logger_1.Logger("ConnectionPool");
        this[kConnections] = new utils_1.List();
        this[kPending] = 0;
        this[kCheckedOut] = /* @__PURE__ */ new Set();
        this[kMinPoolSizeTimer] = void 0;
        this[kGeneration] = 0;
        this[kServiceGenerations] = /* @__PURE__ */ new Map();
        this[kConnectionCounter] = (0, utils_1.makeCounter)(1);
        this[kCancellationToken] = new mongo_types_1.CancellationToken();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kWaitQueue] = new utils_1.List();
        this[kMetrics] = new metrics_1.ConnectionPoolMetrics();
        this[kProcessingWaitQueue] = false;
        process.nextTick(() => {
          this.emit(_ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
        });
      }
      /** The address of the endpoint the pool is connected to */
      get address() {
        return this.options.hostAddress.toString();
      }
      /**
       * Check if the pool has been closed
       *
       * TODO(NODE-3263): We can remove this property once shell no longer needs it
       */
      get closed() {
        return this[kPoolState] === exports2.PoolState.closed;
      }
      /** An integer representing the SDAM generation of the pool */
      get generation() {
        return this[kGeneration];
      }
      /** An integer expressing how many total connections (available + pending + in use) the pool currently has */
      get totalConnectionCount() {
        return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
      }
      /** An integer expressing how many connections are currently available in the pool. */
      get availableConnectionCount() {
        return this[kConnections].length;
      }
      get pendingConnectionCount() {
        return this[kPending];
      }
      get currentCheckedOutCount() {
        return this[kCheckedOut].size;
      }
      get waitQueueSize() {
        return this[kWaitQueue].length;
      }
      get loadBalanced() {
        return this.options.loadBalanced;
      }
      get serviceGenerations() {
        return this[kServiceGenerations];
      }
      get serverError() {
        return this[kServer].description.error;
      }
      /**
       * This is exposed ONLY for use in mongosh, to enable
       * killing all connections if a user quits the shell with
       * operations in progress.
       *
       * This property may be removed as a part of NODE-3263.
       */
      get checkedOutConnections() {
        return this[kCheckedOut];
      }
      /**
       * Get the metrics information for the pool when a wait queue timeout occurs.
       */
      waitQueueErrorMetrics() {
        return this[kMetrics].info(this.options.maxPoolSize);
      }
      /**
       * Set the pool state to "ready"
       */
      ready() {
        if (this[kPoolState] !== exports2.PoolState.paused) {
          return;
        }
        this[kPoolState] = exports2.PoolState.ready;
        this.emit(_ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
        (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
        this.ensureMinPoolSize();
      }
      /**
       * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
       * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
       * explicitly destroyed by the new owner.
       */
      checkOut(callback) {
        this.emit(_ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
        const waitQueueMember = { callback };
        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
        if (waitQueueTimeoutMS) {
          waitQueueMember.timer = (0, timers_1.setTimeout)(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            this.emit(_ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "timeout"));
            waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : "Timed out while checking out a connection from connection pool", this.address));
          }, waitQueueTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        process.nextTick(() => this.processWaitQueue());
      }
      /**
       * Check a connection into the pool.
       *
       * @param connection - The connection to check in
       */
      checkIn(connection) {
        if (!this[kCheckedOut].has(connection)) {
          return;
        }
        const poolClosed = this.closed;
        const stale = this.connectionIsStale(connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this[kConnections].unshift(connection);
        }
        this[kCheckedOut].delete(connection);
        this.emit(_ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          this.destroyConnection(connection, reason);
        }
        process.nextTick(() => this.processWaitQueue());
      }
      /**
       * Clear the pool
       *
       * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
       * previous generation will eventually be pruned during subsequent checkouts.
       */
      clear(options = {}) {
        var _a;
        if (this.closed) {
          return;
        }
        if (this.loadBalanced) {
          const { serviceId } = options;
          if (!serviceId) {
            throw new error_1.MongoRuntimeError("ConnectionPool.clear() called in load balanced mode with no serviceId.");
          }
          const sid = serviceId.toHexString();
          const generation = this.serviceGenerations.get(sid);
          if (generation == null) {
            throw new error_1.MongoRuntimeError("Service generations are required in load balancer mode.");
          } else {
            this.serviceGenerations.set(sid, generation + 1);
          }
          this.emit(_ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
          return;
        }
        const interruptInUseConnections = (_a = options.interruptInUseConnections) !== null && _a !== void 0 ? _a : false;
        const oldGeneration = this[kGeneration];
        this[kGeneration] += 1;
        const alreadyPaused = this[kPoolState] === exports2.PoolState.paused;
        this[kPoolState] = exports2.PoolState.paused;
        this.clearMinPoolSizeTimer();
        if (!alreadyPaused) {
          this.emit(_ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { interruptInUseConnections }));
        }
        if (interruptInUseConnections) {
          process.nextTick(() => this.interruptInUseConnections(oldGeneration));
        }
        this.processWaitQueue();
      }
      /**
       * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.
       *
       * Only connections where `connection.generation <= minGeneration` are killed.
       */
      interruptInUseConnections(minGeneration) {
        for (const connection of this[kCheckedOut]) {
          if (connection.generation <= minGeneration) {
            this.checkIn(connection);
            connection.onError(new errors_1.PoolClearedOnNetworkError(this));
          }
        }
      }
      close(_options, _cb) {
        let options = _options;
        const callback = _cb !== null && _cb !== void 0 ? _cb : _options;
        if (typeof options === "function") {
          options = {};
        }
        options = Object.assign({ force: false }, options);
        if (this.closed) {
          return callback();
        }
        this[kCancellationToken].emit("cancel");
        if (typeof this[kConnectionCounter].return === "function") {
          this[kConnectionCounter].return(void 0);
        }
        this[kPoolState] = exports2.PoolState.closed;
        this.clearMinPoolSizeTimer();
        this.processWaitQueue();
        (0, utils_1.eachAsync)(this[kConnections].toArray(), (conn, cb) => {
          this.emit(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy(options, cb);
        }, (err) => {
          this[kConnections].clear();
          this.emit(_ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
          callback(err);
        });
      }
      /**
       * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda
       * has completed by calling back.
       *
       * NOTE: please note the required signature of `fn`
       *
       * @remarks When in load balancer mode, connections can be pinned to cursors or transactions.
       *   In these cases we pass the connection in to this method to ensure it is used and a new
       *   connection is not checked out.
       *
       * @param conn - A pinned connection for use in load balancing mode.
       * @param fn - A function which operates on a managed connection
       * @param callback - The original callback
       */
      withConnection(conn, fn, callback) {
        if (conn) {
          fn(void 0, conn, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
          });
          return;
        }
        this.checkOut((err, conn2) => {
          fn(err, conn2, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
            if (conn2) {
              this.checkIn(conn2);
            }
          });
        });
      }
      /** Clear the min pool size timer */
      clearMinPoolSizeTimer() {
        const minPoolSizeTimer = this[kMinPoolSizeTimer];
        if (minPoolSizeTimer) {
          (0, timers_1.clearTimeout)(minPoolSizeTimer);
        }
      }
      destroyConnection(connection, reason) {
        this.emit(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
        process.nextTick(() => connection.destroy());
      }
      connectionIsStale(connection) {
        const serviceId = connection.serviceId;
        if (this.loadBalanced && serviceId) {
          const sid = serviceId.toHexString();
          const generation = this.serviceGenerations.get(sid);
          return connection.generation !== generation;
        }
        return connection.generation !== this[kGeneration];
      }
      connectionIsIdle(connection) {
        return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
      }
      /**
       * Destroys a connection if the connection is perished.
       *
       * @returns `true` if the connection was destroyed, `false` otherwise.
       */
      destroyConnectionIfPerished(connection) {
        const isStale = this.connectionIsStale(connection);
        const isIdle = this.connectionIsIdle(connection);
        if (!isStale && !isIdle && !connection.closed) {
          return false;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        this.destroyConnection(connection, reason);
        return true;
      }
      createConnection(callback) {
        const connectOptions = {
          ...this.options,
          id: this[kConnectionCounter].next().value,
          generation: this[kGeneration],
          cancellationToken: this[kCancellationToken]
        };
        this[kPending]++;
        this.emit(_ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
        (0, connect_1.connect)(connectOptions, (err, connection) => {
          if (err || !connection) {
            this[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
            this[kPending]--;
            this.emit(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, { id: connectOptions.id, serviceId: void 0 }, "error"));
            if (err instanceof error_1.MongoNetworkError || err instanceof error_1.MongoServerError) {
              err.connectionGeneration = connectOptions.generation;
            }
            callback(err !== null && err !== void 0 ? err : new error_1.MongoRuntimeError("Connection creation failed without error"));
            return;
          }
          if (this[kPoolState] !== exports2.PoolState.ready) {
            this[kPending]--;
            connection.destroy({ force: true });
            callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
            return;
          }
          for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
            connection.on(event, (e) => this.emit(event, e));
          }
          if (this.loadBalanced) {
            connection.on(connection_1.Connection.PINNED, (pinType) => this[kMetrics].markPinned(pinType));
            connection.on(connection_1.Connection.UNPINNED, (pinType) => this[kMetrics].markUnpinned(pinType));
            const serviceId = connection.serviceId;
            if (serviceId) {
              let generation;
              const sid = serviceId.toHexString();
              if (generation = this.serviceGenerations.get(sid)) {
                connection.generation = generation;
              } else {
                this.serviceGenerations.set(sid, 0);
                connection.generation = 0;
              }
            }
          }
          connection.markAvailable();
          this.emit(_ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection));
          this[kPending]--;
          callback(void 0, connection);
          return;
        });
      }
      ensureMinPoolSize() {
        const minPoolSize = this.options.minPoolSize;
        if (this[kPoolState] !== exports2.PoolState.ready || minPoolSize === 0) {
          return;
        }
        this[kConnections].prune((connection) => this.destroyConnectionIfPerished(connection));
        if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
          this.createConnection((err, connection) => {
            if (err) {
              this[kServer].handleError(err);
            }
            if (!err && connection) {
              this[kConnections].push(connection);
              process.nextTick(() => this.processWaitQueue());
            }
            if (this[kPoolState] === exports2.PoolState.ready) {
              (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
              this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
            }
          });
        } else {
          (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
          this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
        }
      }
      processWaitQueue() {
        if (this[kProcessingWaitQueue]) {
          return;
        }
        this[kProcessingWaitQueue] = true;
        while (this.waitQueueSize) {
          const waitQueueMember = this[kWaitQueue].first();
          if (!waitQueueMember) {
            this[kWaitQueue].shift();
            continue;
          }
          if (waitQueueMember[kCancelled]) {
            this[kWaitQueue].shift();
            continue;
          }
          if (this[kPoolState] !== exports2.PoolState.ready) {
            const reason = this.closed ? "poolClosed" : "connectionError";
            const error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
            this.emit(_ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason));
            if (waitQueueMember.timer) {
              (0, timers_1.clearTimeout)(waitQueueMember.timer);
            }
            this[kWaitQueue].shift();
            waitQueueMember.callback(error);
            continue;
          }
          if (!this.availableConnectionCount) {
            break;
          }
          const connection = this[kConnections].shift();
          if (!connection) {
            break;
          }
          if (!this.destroyConnectionIfPerished(connection)) {
            this[kCheckedOut].add(connection);
            this.emit(_ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));
            if (waitQueueMember.timer) {
              (0, timers_1.clearTimeout)(waitQueueMember.timer);
            }
            this[kWaitQueue].shift();
            waitQueueMember.callback(void 0, connection);
          }
        }
        const { maxPoolSize, maxConnecting } = this.options;
        while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
          const waitQueueMember = this[kWaitQueue].shift();
          if (!waitQueueMember || waitQueueMember[kCancelled]) {
            continue;
          }
          this.createConnection((err, connection) => {
            if (waitQueueMember[kCancelled]) {
              if (!err && connection) {
                this[kConnections].push(connection);
              }
            } else {
              if (err) {
                this.emit(_ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "connectionError"));
              } else if (connection) {
                this[kCheckedOut].add(connection);
                this.emit(_ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));
              }
              if (waitQueueMember.timer) {
                (0, timers_1.clearTimeout)(waitQueueMember.timer);
              }
              waitQueueMember.callback(err, connection);
            }
            process.nextTick(() => this.processWaitQueue());
          });
        }
        this[kProcessingWaitQueue] = false;
      }
    };
    exports2.ConnectionPool = ConnectionPool;
    ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
    ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
    ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
    ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
    ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
    ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
    ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
    ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
    ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
    ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
    ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
  }
});

// asset-input/node_modules/mongodb/lib/sdam/monitor.js
var require_monitor = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/monitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonitorInterval = exports2.RTTPinger = exports2.Monitor = void 0;
    var timers_1 = require("timers");
    var bson_1 = require_bson2();
    var connect_1 = require_connect();
    var connection_1 = require_connection();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils2();
    var common_1 = require_common();
    var events_1 = require_events();
    var server_1 = require_server();
    var kServer = Symbol("server");
    var kMonitorId = Symbol("monitorId");
    var kConnection = Symbol("connection");
    var kCancellationToken = Symbol("cancellationToken");
    var kRoundTripTime = Symbol("roundTripTime");
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = /* @__PURE__ */ new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
    }
    var Monitor = class extends mongo_types_1.TypedEventEmitter {
      get connection() {
        return this[kConnection];
      }
      constructor(server, options) {
        var _a, _b, _c;
        super();
        this[kServer] = server;
        this[kConnection] = void 0;
        this[kCancellationToken] = new mongo_types_1.CancellationToken();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kMonitorId] = void 0;
        this.s = {
          state: common_1.STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 1e4,
          heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 1e4,
          minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500
        });
        const cancellationToken = this[kCancellationToken];
        const connectOptions = Object.assign(
          {
            id: "<monitor>",
            generation: server.s.pool.generation,
            connectionType: connection_1.Connection,
            cancellationToken,
            hostAddress: server.description.hostAddress
          },
          options,
          // force BSON serialization options
          {
            raw: false,
            promoteLongs: true,
            promoteValues: true,
            promoteBuffers: true
          }
        );
        delete connectOptions.credentials;
        if (connectOptions.autoEncrypter) {
          delete connectOptions.autoEncrypter;
        }
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== common_1.STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = new MonitorInterval(monitorServer(this), {
          heartbeatFrequencyMS,
          minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        var _a;
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();
      }
      reset() {
        const topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = new MonitorInterval(monitorServer(this), {
          heartbeatFrequencyMS,
          minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, common_1.STATE_CLOSED);
      }
    };
    exports2.Monitor = Monitor;
    function resetMonitorState(monitor) {
      var _a, _b, _c;
      (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();
      monitor[kMonitorId] = void 0;
      (_b = monitor.rttPinger) === null || _b === void 0 ? void 0 : _b.close();
      monitor.rttPinger = void 0;
      monitor[kCancellationToken].emit("cancel");
      (_c = monitor[kConnection]) === null || _c === void 0 ? void 0 : _c.destroy({ force: true });
      monitor[kConnection] = void 0;
    }
    function checkServer(monitor, callback) {
      let start = (0, utils_1.now)();
      monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));
      function failureHandler(err) {
        var _a;
        (_a = monitor[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({ force: true });
        monitor[kConnection] = void 0;
        monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));
        const error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(err) : err;
        error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
        if (error instanceof error_1.MongoNetworkTimeoutError) {
          error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
        }
        monitor.emit("resetServer", error);
        callback(err);
      }
      const connection = monitor[kConnection];
      if (connection && !connection.closed) {
        const { serverApi, helloOk } = connection;
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const topologyVersion = monitor[kServer].description.topologyVersion;
        const isAwaitable = topologyVersion != null;
        const cmd = {
          [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: true,
          ...isAwaitable && topologyVersion ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) } : {}
        };
        const options = isAwaitable ? {
          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
          exhaustAllowed: true
        } : { socketTimeoutMS: connectTimeoutMS };
        if (isAwaitable && monitor.rttPinger == null) {
          monitor.rttPinger = new RTTPinger(monitor[kCancellationToken], Object.assign({ heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS }, monitor.connectOptions));
        }
        connection.command((0, utils_1.ns)("admin.$cmd"), cmd, options, (err, hello) => {
          var _a;
          if (err) {
            return failureHandler(err);
          }
          if (!("isWritablePrimary" in hello)) {
            hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
          }
          const duration = isAwaitable && monitor.rttPinger ? monitor.rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);
          monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello));
          if (isAwaitable && hello.topologyVersion) {
            monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));
            start = (0, utils_1.now)();
          } else {
            (_a = monitor.rttPinger) === null || _a === void 0 ? void 0 : _a.close();
            monitor.rttPinger = void 0;
            callback(void 0, hello);
          }
        });
        return;
      }
      (0, connect_1.connect)(monitor.connectOptions, (err, conn) => {
        if (err) {
          monitor[kConnection] = void 0;
          failureHandler(err);
          return;
        }
        if (conn) {
          conn.isMonitoringConnection = true;
          if (isInCloseState(monitor)) {
            conn.destroy({ force: true });
            return;
          }
          monitor[kConnection] = conn;
          monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));
          callback(void 0, conn.hello);
        }
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        if (monitor.s.state === STATE_MONITORING) {
          process.nextTick(callback);
          return;
        }
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        checkServer(monitor, (err, hello) => {
          if (err) {
            if (monitor[kServer].description.type === common_1.ServerType.Unknown) {
              return done();
            }
          }
          if (hello && hello.topologyVersion) {
            (0, timers_1.setTimeout)(() => {
              var _a;
              if (!isInCloseState(monitor)) {
                (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();
              }
            }, 0);
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        // tests mock counter as just number, but in a real situation counter should always be a Long
        // TODO(NODE-2674): Preserve int64 sent from MongoDB
        counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(cancellationToken, options) {
        this.connection = void 0;
        this[kCancellationToken] = cancellationToken;
        this[kRoundTripTime] = 0;
        this.closed = false;
        const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
        this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this[kRoundTripTime];
      }
      close() {
        var _a;
        this.closed = true;
        (0, timers_1.clearTimeout)(this[kMonitorId]);
        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.destroy({ force: true });
        this.connection = void 0;
      }
    };
    exports2.RTTPinger = RTTPinger;
    function measureRoundTripTime(rttPinger, options) {
      var _a;
      const start = (0, utils_1.now)();
      options.cancellationToken = rttPinger[kCancellationToken];
      const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
      if (rttPinger.closed) {
        return;
      }
      function measureAndReschedule(conn) {
        if (rttPinger.closed) {
          conn === null || conn === void 0 ? void 0 : conn.destroy({ force: true });
          return;
        }
        if (rttPinger.connection == null) {
          rttPinger.connection = conn;
        }
        rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);
        rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);
      }
      const connection = rttPinger.connection;
      if (connection == null) {
        (0, connect_1.connect)(options, (err, conn) => {
          if (err) {
            rttPinger.connection = void 0;
            rttPinger[kRoundTripTime] = 0;
            return;
          }
          measureAndReschedule(conn);
        });
        return;
      }
      const commandName = ((_a = connection.serverApi) === null || _a === void 0 ? void 0 : _a.version) || connection.helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND;
      connection.command((0, utils_1.ns)("admin.$cmd"), { [commandName]: 1 }, void 0, (err) => {
        var _a2;
        if (err) {
          (_a2 = rttPinger.connection) === null || _a2 === void 0 ? void 0 : _a2.destroy({ force: true });
          rttPinger.connection = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule();
      });
    }
    var MonitorInterval = class {
      constructor(fn, options = {}) {
        var _a, _b;
        this.isExpeditedCallToFnScheduled = false;
        this.stopped = false;
        this.isExecutionInProgress = false;
        this.hasExecutedOnce = false;
        this._executeAndReschedule = () => {
          if (this.stopped)
            return;
          if (this.timerId) {
            (0, timers_1.clearTimeout)(this.timerId);
          }
          this.isExpeditedCallToFnScheduled = false;
          this.isExecutionInProgress = true;
          this.fn(() => {
            this.lastExecutionEnded = (0, utils_1.now)();
            this.isExecutionInProgress = false;
            this._reschedule(this.heartbeatFrequencyMS);
          });
        };
        this.fn = fn;
        this.lastExecutionEnded = -Infinity;
        this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 1e3;
        this.minHeartbeatFrequencyMS = (_b = options.minHeartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 500;
        if (options.immediate) {
          this._executeAndReschedule();
        } else {
          this._reschedule(void 0);
        }
      }
      wake() {
        const currentTime = (0, utils_1.now)();
        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
        if (timeSinceLastCall < 0) {
          return this._executeAndReschedule();
        }
        if (this.isExecutionInProgress) {
          return;
        }
        if (this.isExpeditedCallToFnScheduled) {
          return;
        }
        if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
          this.isExpeditedCallToFnScheduled = true;
          this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
          return;
        }
        this._executeAndReschedule();
      }
      stop() {
        this.stopped = true;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
          this.timerId = void 0;
        }
        this.lastExecutionEnded = -Infinity;
        this.isExpeditedCallToFnScheduled = false;
      }
      toString() {
        return JSON.stringify(this);
      }
      toJSON() {
        const currentTime = (0, utils_1.now)();
        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
        return {
          timerId: this.timerId != null ? "set" : "cleared",
          lastCallTime: this.lastExecutionEnded,
          isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
          stopped: this.stopped,
          heartbeatFrequencyMS: this.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
          currentTime,
          timeSinceLastCall
        };
      }
      _reschedule(ms) {
        if (this.stopped)
          return;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
        }
        this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
      }
    };
    exports2.MonitorInterval = MonitorInterval;
  }
});

// asset-input/node_modules/mongodb/lib/sdam/server.js
var require_server = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = void 0;
    var connection_1 = require_connection();
    var connection_pool_1 = require_connection_pool();
    var errors_1 = require_errors();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var logger_1 = require_logger();
    var mongo_types_1 = require_mongo_types();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils2();
    var common_1 = require_common();
    var monitor_1 = require_monitor();
    var server_description_1 = require_server_description();
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
      [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
      [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
    });
    var Server = class _Server extends mongo_types_1.TypedEventEmitter {
      /**
       * Create a server
       */
      constructor(topology, description, options) {
        super();
        this.serverApi = options.serverApi;
        const poolOptions = { hostAddress: description.hostAddress, ...options };
        this.s = {
          description,
          options,
          logger: new logger_1.Logger("Server"),
          state: common_1.STATE_CLOSED,
          topology,
          pool: new connection_pool_1.ConnectionPool(this, poolOptions),
          operationCount: 0
        };
        for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
          this.s.pool.on(event, (e) => this.emit(event, e));
        }
        this.s.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        if (this.loadBalanced) {
          this.monitor = null;
          return;
        }
        this.monitor = new monitor_1.Monitor(this, this.s.options);
        for (const event of constants_1.HEARTBEAT_EVENTS) {
          this.monitor.on(event, (e) => this.emit(event, e));
        }
        this.monitor.on("resetServer", (error) => markServerUnknown(this, error));
        this.monitor.on(_Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
          this.emit(_Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
            roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
          }));
          if (this.s.state === common_1.STATE_CONNECTING) {
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(_Server.CONNECT, this);
          }
        });
      }
      get clusterTime() {
        return this.s.topology.clusterTime;
      }
      set clusterTime(clusterTime) {
        this.s.topology.clusterTime = clusterTime;
      }
      get description() {
        return this.s.description;
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return;
      }
      get loadBalanced() {
        return this.s.topology.description.type === common_1.TopologyType.LoadBalanced;
      }
      /**
       * Initiate server connect
       */
      connect() {
        var _a;
        if (this.s.state !== common_1.STATE_CLOSED) {
          return;
        }
        stateTransition(this, common_1.STATE_CONNECTING);
        if (!this.loadBalanced) {
          (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.connect();
        } else {
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(_Server.CONNECT, this);
        }
      }
      /** Destroy the server connection */
      destroy(options, callback) {
        var _a;
        if (typeof options === "function")
          callback = options, options = {};
        options = Object.assign({}, { force: false }, options);
        if (this.s.state === common_1.STATE_CLOSED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        if (!this.loadBalanced) {
          (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.close();
        }
        this.s.pool.close(options, (err) => {
          stateTransition(this, common_1.STATE_CLOSED);
          this.emit("closed");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      /**
       * Immediately schedule monitoring of this server. If there already an attempt being made
       * this will be a no-op.
       */
      requestCheck() {
        var _a;
        if (!this.loadBalanced) {
          (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.requestCheck();
        }
      }
      /**
       * Execute a command
       * @internal
       */
      command(ns, cmd, options, callback) {
        if (callback == null) {
          throw new error_1.MongoInvalidArgumentError("Callback must be provided");
        }
        if (ns.db == null || typeof ns === "string") {
          throw new error_1.MongoInvalidArgumentError("Namespace must not be a string");
        }
        if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
          callback(new error_1.MongoServerClosedError());
          return;
        }
        const finalOptions = Object.assign({}, options, { wireProtocolCommand: false });
        if (finalOptions.omitReadPreference) {
          delete finalOptions.readPreference;
        }
        const session = finalOptions.session;
        const conn = session === null || session === void 0 ? void 0 : session.pinnedConnection;
        if (this.loadBalanced && session && conn == null && isPinnableCommand(cmd, session)) {
          this.s.pool.checkOut((err, checkedOut) => {
            if (err || checkedOut == null) {
              if (callback)
                return callback(err);
              return;
            }
            session.pin(checkedOut);
            this.command(ns, cmd, finalOptions, callback);
          });
          return;
        }
        this.s.operationCount += 1;
        this.s.pool.withConnection(conn, (err, conn2, cb) => {
          if (err || !conn2) {
            this.s.operationCount -= 1;
            if (!err) {
              return cb(new error_1.MongoRuntimeError("Failed to create connection without error"));
            }
            if (!(err instanceof errors_1.PoolClearedError)) {
              this.handleError(err);
            }
            return cb(err);
          }
          conn2.command(ns, cmd, finalOptions, makeOperationHandler(this, conn2, cmd, finalOptions, (error, response) => {
            this.s.operationCount -= 1;
            cb(error, response);
          }));
        }, callback);
      }
      /**
       * Handle SDAM error
       * @internal
       */
      handleError(error, connection) {
        if (!(error instanceof error_1.MongoError)) {
          return;
        }
        const isStaleError = error.connectionGeneration && error.connectionGeneration < this.s.pool.generation;
        if (isStaleError) {
          return;
        }
        const isNetworkNonTimeoutError = error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError);
        const isNetworkTimeoutBeforeHandshakeError = (0, error_1.isNetworkErrorBeforeHandshake)(error);
        const isAuthHandshakeError = error.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
        if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
          if (!this.loadBalanced) {
            error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
            markServerUnknown(this, error);
          } else if (connection) {
            this.s.pool.clear({ serviceId: connection.serviceId });
          }
        } else {
          if ((0, error_1.isSDAMUnrecoverableError)(error)) {
            if (shouldHandleStateChangeError(this, error)) {
              const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error);
              if (this.loadBalanced && connection && shouldClearPool) {
                this.s.pool.clear({ serviceId: connection.serviceId });
              }
              if (!this.loadBalanced) {
                if (shouldClearPool) {
                  error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
                }
                markServerUnknown(this, error);
                process.nextTick(() => this.requestCheck());
              }
            }
          }
        }
      }
    };
    exports2.Server = Server;
    Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
    Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
    Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
    Server.CONNECT = constants_1.CONNECT;
    Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
    Server.CLOSED = constants_1.CLOSED;
    Server.ENDED = constants_1.ENDED;
    function calculateRoundTripTime(oldRtt, duration) {
      if (oldRtt === -1) {
        return duration;
      }
      const alpha = 0.2;
      return alpha * duration + (1 - alpha) * oldRtt;
    }
    function markServerUnknown(server, error) {
      var _a;
      if (server.loadBalanced) {
        return;
      }
      if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {
        (_a = server.monitor) === null || _a === void 0 ? void 0 : _a.reset();
      }
      server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, void 0, { error }));
    }
    function isPinnableCommand(cmd, session) {
      if (session) {
        return session.inTransaction() || "aggregate" in cmd || "find" in cmd || "getMore" in cmd || "listCollections" in cmd || "listIndexes" in cmd;
      }
      return false;
    }
    function connectionIsStale(pool, connection) {
      if (connection.serviceId) {
        return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
      }
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
    }
    function isRetryableWritesEnabled(topology) {
      return topology.s.options.retryWrites !== false;
    }
    function makeOperationHandler(server, connection, cmd, options, callback) {
      const session = options === null || options === void 0 ? void 0 : options.session;
      return function handleOperationResult(error, result) {
        if (result != null) {
          return callback(void 0, result);
        }
        if ((options === null || options === void 0 ? void 0 : options.noResponse) === true) {
          return callback(void 0, null);
        }
        if (!error) {
          return callback(new error_1.MongoUnexpectedServerResponseError("Empty response with no error"));
        }
        if (!(error instanceof error_1.MongoError)) {
          return callback(error);
        }
        if (connectionIsStale(server.s.pool, connection)) {
          return callback(error);
        }
        if (error instanceof error_1.MongoNetworkError) {
          if (session && !session.hasEnded && session.serverSession) {
            session.serverSession.isDirty = true;
          }
          if (inActiveTransaction(session, cmd) && !error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
            error.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
          }
          if ((isRetryableWritesEnabled(server.s.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(server) && !inActiveTransaction(session, cmd)) {
            error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        } else {
          if ((isRetryableWritesEnabled(server.s.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error, (0, utils_1.maxWireVersion)(server)) && !inActiveTransaction(session, cmd)) {
            error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        }
        if (session && session.isPinned && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          session.unpin({ force: true });
        }
        server.handleError(error, connection);
        return callback(error);
      };
    }
  }
});

// asset-input/node_modules/mongodb/lib/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/srv_polling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SrvPoller = exports2.SrvPollingEvent = void 0;
    var dns = require("dns");
    var timers_1 = require("timers");
    var error_1 = require_error();
    var logger_1 = require_logger();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils2();
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      hostnames() {
        return new Set(this.srvRecords.map((r) => utils_1.HostAddress.fromSrvRecord(r).toString()));
      }
    };
    exports2.SrvPollingEvent = SrvPollingEvent;
    var SrvPoller = class _SrvPoller extends mongo_types_1.TypedEventEmitter {
      constructor(options) {
        var _a, _b, _c;
        super();
        if (!options || !options.srvHost) {
          throw new error_1.MongoRuntimeError("Options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options.srvHost;
        this.srvMaxHosts = (_a = options.srvMaxHosts) !== null && _a !== void 0 ? _a : 0;
        this.srvServiceName = (_b = options.srvServiceName) !== null && _b !== void 0 ? _b : "mongodb";
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = (_c = options.heartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 1e4;
        this.logger = new logger_1.Logger("srvPoller", options);
        this.haMode = false;
        this.generation = 0;
        this._timeout = void 0;
      }
      get srvAddress() {
        return `_${this.srvServiceName}._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          (0, timers_1.clearTimeout)(this._timeout);
          this.generation += 1;
          this._timeout = void 0;
        }
      }
      schedule() {
        if (this._timeout) {
          (0, timers_1.clearTimeout)(this._timeout);
        }
        this._timeout = (0, timers_1.setTimeout)(() => {
          this._poll().catch((unexpectedRuntimeError) => {
            this.logger.error(`Unexpected ${new error_1.MongoRuntimeError(unexpectedRuntimeError).stack}`);
          });
        }, this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit(_SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
      }
      failure(message, obj) {
        this.logger.warn(message, obj);
        this.haMode = true;
        this.schedule();
      }
      parentDomainMismatch(srvRecord) {
        this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
      }
      async _poll() {
        const generation = this.generation;
        let srvRecords;
        try {
          srvRecords = await dns.promises.resolveSrv(this.srvAddress);
        } catch (dnsError) {
          this.failure("DNS error", dnsError);
          return;
        }
        if (generation !== this.generation) {
          return;
        }
        const finalAddresses = [];
        for (const record of srvRecords) {
          if ((0, utils_1.matchesParentDomain)(record.name, this.srvHost)) {
            finalAddresses.push(record);
          } else {
            this.parentDomainMismatch(record);
          }
        }
        if (!finalAddresses.length) {
          this.failure("No valid addresses found at host");
          return;
        }
        this.success(finalAddresses);
      }
    };
    exports2.SrvPoller = SrvPoller;
    SrvPoller.SRV_RECORD_DISCOVERY = "srvRecordDiscovery";
  }
});

// asset-input/node_modules/mongodb/lib/sdam/topology.js
var require_topology = __commonJS({
  "asset-input/node_modules/mongodb/lib/sdam/topology.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerCapabilities = exports2.Topology = void 0;
    var timers_1 = require("timers");
    var util_1 = require("util");
    var bson_1 = require_bson2();
    var connection_string_1 = require_connection_string();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils2();
    var common_1 = require_common();
    var events_1 = require_events();
    var server_1 = require_server();
    var server_description_1 = require_server_description();
    var server_selection_1 = require_server_selection();
    var srv_polling_1 = require_srv_polling();
    var topology_description_1 = require_topology_description();
    var globalTopologyCounter = 0;
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
      [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
      [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
    });
    var kCancelled = Symbol("cancelled");
    var kWaitQueue = Symbol("waitQueue");
    var Topology = class _Topology extends mongo_types_1.TypedEventEmitter {
      /**
       * @param seedlist - a list of HostAddress instances to connect to
       */
      constructor(seeds, options) {
        var _a;
        super();
        this.selectServerAsync = (0, util_1.promisify)((selector, options2, callback) => this.selectServer(selector, options2, callback));
        this.bson = /* @__PURE__ */ Object.create(null);
        this.bson.serialize = bson_1.serialize;
        this.bson.deserialize = bson_1.deserialize;
        options = options !== null && options !== void 0 ? options : {
          hosts: [utils_1.HostAddress.fromString("localhost:27017")],
          ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries()),
          ...Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries())
        };
        if (typeof seeds === "string") {
          seeds = [utils_1.HostAddress.fromString(seeds)];
        } else if (!Array.isArray(seeds)) {
          seeds = [seeds];
        }
        const seedlist = [];
        for (const seed of seeds) {
          if (typeof seed === "string") {
            seedlist.push(utils_1.HostAddress.fromString(seed));
          } else if (seed instanceof utils_1.HostAddress) {
            seedlist.push(seed);
          } else {
            throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
          }
        }
        const topologyType = topologyTypeFromOptions(options);
        const topologyId = globalTopologyCounter++;
        const selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
        const serverDescriptions = /* @__PURE__ */ new Map();
        for (const hostAddress of selectedHosts) {
          serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
        }
        this[kWaitQueue] = new utils_1.List();
        this.s = {
          // the id of this topology
          id: topologyId,
          // passed in options
          options,
          // initial seedlist of servers to connect to
          seedlist,
          // initial state
          state: common_1.STATE_CLOSED,
          // the topology description
          description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, void 0, void 0, void 0, options),
          serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
          // a map of server instances to normalized addresses
          servers: /* @__PURE__ */ new Map(),
          credentials: options === null || options === void 0 ? void 0 : options.credentials,
          clusterTime: void 0,
          // timer management
          connectionTimers: /* @__PURE__ */ new Set(),
          detectShardedTopology: (ev) => this.detectShardedTopology(ev),
          detectSrvRecords: (ev) => this.detectSrvRecords(ev)
        };
        if (options.srvHost && !options.loadBalanced) {
          this.s.srvPoller = (_a = options.srvPoller) !== null && _a !== void 0 ? _a : new srv_polling_1.SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options.srvHost,
            srvMaxHosts: options.srvMaxHosts,
            srvServiceName: options.srvServiceName
          });
          this.on(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        }
      }
      detectShardedTopology(event) {
        var _a, _b, _c;
        const previousType = event.previousDescription.type;
        const newType = event.newDescription.type;
        const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
        const srvListeners = (_a = this.s.srvPoller) === null || _a === void 0 ? void 0 : _a.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
        const listeningToSrvPolling = !!(srvListeners === null || srvListeners === void 0 ? void 0 : srvListeners.includes(this.s.detectSrvRecords));
        if (transitionToSharded && !listeningToSrvPolling) {
          (_b = this.s.srvPoller) === null || _b === void 0 ? void 0 : _b.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
          (_c = this.s.srvPoller) === null || _c === void 0 ? void 0 : _c.start();
        }
      }
      detectSrvRecords(ev) {
        const previousTopologyDescription = this.s.description;
        this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
        if (this.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(this);
        this.emit(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
      /**
       * @returns A `TopologyDescription` for this topology
       */
      get description() {
        return this.s.description;
      }
      get loadBalanced() {
        return this.s.options.loadBalanced;
      }
      get capabilities() {
        return new ServerCapabilities(this.lastHello());
      }
      connect(options, callback) {
        var _a;
        if (typeof options === "function")
          callback = options, options = {};
        options = options !== null && options !== void 0 ? options : {};
        if (this.s.state === common_1.STATE_CONNECTED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, common_1.STATE_CONNECTING);
        this.emit(_Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
        this.emit(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(
          this.s.id,
          new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown),
          // initial is always Unknown
          this.s.description
        ));
        const serverDescriptions = Array.from(this.s.description.servers.values());
        this.s.servers = new Map(serverDescriptions.map((serverDescription) => [
          serverDescription.address,
          createAndConnectServer(this, serverDescription)
        ]));
        if (this.s.options.loadBalanced) {
          for (const description of serverDescriptions) {
            const newDescription = new server_description_1.ServerDescription(description.hostAddress, void 0, {
              loadBalanced: this.s.options.loadBalanced
            });
            this.serverUpdateHandler(newDescription);
          }
        }
        const exitWithError = (error) => callback ? callback(error) : this.emit(_Topology.ERROR, error);
        const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;
        this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, (err, server) => {
          if (err) {
            return this.close({ force: false }, () => exitWithError(err));
          }
          const skipPingOnConnect = this.s.options[Symbol.for("@@mdb.skipPingOnConnect")] === true;
          if (!skipPingOnConnect && server && this.s.credentials) {
            server.command((0, utils_1.ns)("admin.$cmd"), { ping: 1 }, {}, (err2) => {
              if (err2) {
                return exitWithError(err2);
              }
              stateTransition(this, common_1.STATE_CONNECTED);
              this.emit(_Topology.OPEN, this);
              this.emit(_Topology.CONNECT, this);
              callback === null || callback === void 0 ? void 0 : callback(void 0, this);
            });
            return;
          }
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(_Topology.OPEN, this);
          this.emit(_Topology.CONNECT, this);
          callback === null || callback === void 0 ? void 0 : callback(void 0, this);
        });
      }
      close(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (typeof options === "boolean") {
          options = { force: options };
        }
        options = options !== null && options !== void 0 ? options : {};
        if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
          return callback === null || callback === void 0 ? void 0 : callback();
        }
        const destroyedServers = Array.from(this.s.servers.values(), (server) => {
          return (0, util_1.promisify)(destroyServer)(server, this, options);
        });
        Promise.all(destroyedServers).then(() => {
          this.s.servers.clear();
          stateTransition(this, common_1.STATE_CLOSING);
          drainWaitQueue(this[kWaitQueue], new error_1.MongoTopologyClosedError());
          (0, common_1.drainTimerQueue)(this.s.connectionTimers);
          if (this.s.srvPoller) {
            this.s.srvPoller.stop();
            this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
          }
          this.removeListener(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
          stateTransition(this, common_1.STATE_CLOSED);
          this.emit(_Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
        }).finally(() => callback === null || callback === void 0 ? void 0 : callback());
      }
      /**
       * Selects a server according to the selection predicate provided
       *
       * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
       * @param options - Optional settings related to server selection
       * @param callback - The callback used to indicate success or failure
       * @returns An instance of a `Server` meeting the criteria of the predicate provided
       */
      selectServer(selector, options, callback) {
        let serverSelector;
        if (typeof selector !== "function") {
          if (typeof selector === "string") {
            serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
          } else {
            let readPreference;
            if (selector instanceof read_preference_1.ReadPreference) {
              readPreference = selector;
            } else {
              read_preference_1.ReadPreference.translate(options);
              readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
            }
            serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
          }
        } else {
          serverSelector = selector;
        }
        options = Object.assign({}, { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options);
        const isSharded = this.description.type === common_1.TopologyType.Sharded;
        const session = options.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          callback(void 0, transaction.server);
          return;
        }
        const waitQueueMember = {
          serverSelector,
          transaction,
          callback
        };
        const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
          waitQueueMember.timer = (0, timers_1.setTimeout)(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
            waitQueueMember.callback(timeoutError);
          }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
      }
      // Sessions related methods
      /**
       * @returns Whether the topology should initiate selection to determine session support
       */
      shouldCheckForSessionSupport() {
        if (this.description.type === common_1.TopologyType.Single) {
          return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
      }
      /**
       * @returns Whether sessions are supported on the current topology
       */
      hasSessionSupport() {
        return this.loadBalanced || this.description.logicalSessionTimeoutMinutes != null;
      }
      /**
       * Update the internal TopologyDescription with a ServerDescription
       *
       * @param serverDescription - The server to update in the internal list of server descriptions
       */
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        if (!previousServerDescription) {
          return;
        }
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          (0, common_1._advanceClusterTime)(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit(_Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          const newDescription = this.s.description.servers.get(serverDescription.address);
          if (newDescription) {
            this.emit(_Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
          }
        }
        updateServers(this, serverDescription);
        if (this[kWaitQueue].length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emit(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = void 0;
        if (typeof callback === "function")
          callback(void 0, true);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === common_1.STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === common_1.STATE_CLOSED;
      }
      /**
       * @deprecated This function is deprecated and will be removed in the next major version.
       */
      unref() {
        (0, utils_1.emitWarning)("`unref` is a noop and will be removed in the next major version");
      }
      // NOTE: There are many places in code where we explicitly check the last hello
      //       to do feature support detection. This should be done any other way, but for
      //       now we will just return the first hello seen, which should suffice.
      lastHello() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== common_1.ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
      }
      get commonWireVersion() {
        return this.description.commonWireVersion;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get clusterTime() {
        return this.s.clusterTime;
      }
      set clusterTime(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    };
    exports2.Topology = Topology;
    Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
    Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
    Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
    Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
    Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
    Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
    Topology.ERROR = constants_1.ERROR;
    Topology.OPEN = constants_1.OPEN;
    Topology.CONNECT = constants_1.CONNECT;
    Topology.CLOSE = constants_1.CLOSE;
    Topology.TIMEOUT = constants_1.TIMEOUT;
    function destroyServer(server, topology, options, callback) {
      options = options !== null && options !== void 0 ? options : {};
      for (const event of constants_1.LOCAL_SERVER_EVENTS) {
        server.removeAllListeners(event);
      }
      server.destroy(options, () => {
        topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
        for (const event of constants_1.SERVER_RELAY_EVENTS) {
          server.removeAllListeners(event);
        }
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    function topologyTypeFromOptions(options) {
      if (options === null || options === void 0 ? void 0 : options.directConnection) {
        return common_1.TopologyType.Single;
      }
      if (options === null || options === void 0 ? void 0 : options.replicaSet) {
        return common_1.TopologyType.ReplicaSetNoPrimary;
      }
      if (options === null || options === void 0 ? void 0 : options.loadBalanced) {
        return common_1.TopologyType.LoadBalanced;
      }
      return common_1.TopologyType.Unknown;
    }
    function createAndConnectServer(topology, serverDescription) {
      topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server = new server_1.Server(topology, serverDescription, topology.s.options);
      for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server.on(event, (e) => topology.emit(event, e));
      }
      server.on(server_1.Server.DESCRIPTION_RECEIVED, (description) => topology.serverUpdateHandler(description));
      server.connect();
      return server;
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        if (server) {
          server.s.description = incomingServerDescription;
          if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
            const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
            server.s.pool.clear({ interruptInUseConnections });
          } else if (incomingServerDescription.error == null) {
            const newTopologyType = topology.s.description.type;
            const shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;
            if (shouldMarkPoolReady) {
              server.s.pool.ready();
            }
          }
        }
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        if (!topology.s.servers.has(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        if (server) {
          destroyServer(server, topology);
        }
      }
    }
    function drainWaitQueue(queue, err) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        if (!waitQueueMember) {
          continue;
        }
        if (waitQueueMember.timer) {
          (0, timers_1.clearTimeout)(waitQueueMember.timer);
        }
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(err);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === common_1.STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());
        return;
      }
      const isSharded = topology.description.type === common_1.TopologyType.Sharded;
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology[kWaitQueue].length;
      for (let i = 0; i < membersToProcess; ++i) {
        const waitQueueMember = topology[kWaitQueue].shift();
        if (!waitQueueMember) {
          continue;
        }
        if (waitQueueMember[kCancelled]) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
        } catch (e) {
          if (waitQueueMember.timer) {
            (0, timers_1.clearTimeout)(waitQueueMember.timer);
          }
          waitQueueMember.callback(e);
          continue;
        }
        let selectedServer;
        if (selectedDescriptions.length === 0) {
          topology[kWaitQueue].push(waitQueueMember);
          continue;
        } else if (selectedDescriptions.length === 1) {
          selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
        } else {
          const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
          const server1 = topology.s.servers.get(descriptions[0].address);
          const server2 = topology.s.servers.get(descriptions[1].address);
          selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
        }
        if (!selectedServer) {
          waitQueueMember.callback(new error_1.MongoServerSelectionError("server selection returned a server description but the server was not found in the topology", topology.description));
          return;
        }
        const transaction = waitQueueMember.transaction;
        if (isSharded && transaction && transaction.isActive && selectedServer) {
          transaction.pinServer(selectedServer);
        }
        if (waitQueueMember.timer) {
          (0, timers_1.clearTimeout)(waitQueueMember.timer);
        }
        waitQueueMember.callback(void 0, selectedServer);
      }
      if (topology[kWaitQueue].length > 0) {
        for (const [, server] of topology.s.servers) {
          process.nextTick(function scheduleServerCheck() {
            return server.requestCheck();
          });
        }
      }
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription === null || currentServerDescription === void 0 ? void 0 : currentServerDescription.topologyVersion;
      return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    var ServerCapabilities = class {
      constructor(hello) {
        this.minWireVersion = hello.minWireVersion || 0;
        this.maxWireVersion = hello.maxWireVersion || 0;
      }
      get hasAggregationCursor() {
        return this.maxWireVersion >= 1;
      }
      get hasWriteCommands() {
        return this.maxWireVersion >= 2;
      }
      get hasTextSearch() {
        return this.minWireVersion >= 0;
      }
      get hasAuthCommands() {
        return this.maxWireVersion >= 1;
      }
      get hasListCollectionsCommand() {
        return this.maxWireVersion >= 3;
      }
      get hasListIndexesCommand() {
        return this.maxWireVersion >= 3;
      }
      get supportsSnapshotReads() {
        return this.maxWireVersion >= 13;
      }
      get commandsTakeWriteConcern() {
        return this.maxWireVersion >= 5;
      }
      get commandsTakeCollation() {
        return this.maxWireVersion >= 5;
      }
    };
    exports2.ServerCapabilities = ServerCapabilities;
  }
});

// asset-input/node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "asset-input/node_modules/mongodb/lib/mongo_client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoClient = exports2.ServerApiVersion = void 0;
    var util_1 = require("util");
    var bson_1 = require_bson2();
    var change_stream_1 = require_change_stream();
    var connection_string_1 = require_connection_string();
    var constants_1 = require_constants3();
    var db_1 = require_db();
    var error_1 = require_error();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var read_preference_1 = require_read_preference();
    var server_selection_1 = require_server_selection();
    var topology_1 = require_topology();
    var sessions_1 = require_sessions();
    var utils_1 = require_utils2();
    exports2.ServerApiVersion = Object.freeze({
      v1: "1"
    });
    var kOptions = Symbol("options");
    var MongoClient = class extends mongo_types_1.TypedEventEmitter {
      constructor(url, options) {
        super();
        this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);
        this.mongoLogger = new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions);
        const client = this;
        this.s = {
          url,
          bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),
          namespace: (0, utils_1.ns)("admin"),
          hasBeenClosed: false,
          sessionPool: new sessions_1.ServerSessionPool(this),
          activeSessions: /* @__PURE__ */ new Set(),
          get options() {
            return client[kOptions];
          },
          get readConcern() {
            return client[kOptions].readConcern;
          },
          get writeConcern() {
            return client[kOptions].writeConcern;
          },
          get readPreference() {
            return client[kOptions].readPreference;
          },
          get logger() {
            return client[kOptions].logger;
          },
          get isMongoClient() {
            return true;
          }
        };
      }
      /** @see MongoOptions */
      get options() {
        return Object.freeze({ ...this[kOptions] });
      }
      get serverApi() {
        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });
      }
      /**
       * Intended for APM use only
       * @internal
       */
      get monitorCommands() {
        return this[kOptions].monitorCommands;
      }
      set monitorCommands(value) {
        this[kOptions].monitorCommands = value;
      }
      get autoEncrypter() {
        return this[kOptions].autoEncrypter;
      }
      get readConcern() {
        return this.s.readConcern;
      }
      get writeConcern() {
        return this.s.writeConcern;
      }
      get readPreference() {
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      /** @deprecated The Legacy Logger is deprecated and will be removed in the next major version. */
      get logger() {
        return this.s.logger;
      }
      connect(callback) {
        if (callback && typeof callback !== "function") {
          throw new error_1.MongoInvalidArgumentError("Method `connect` only accepts a callback");
        }
        return (0, utils_1.maybeCallback)(async () => {
          if (this.connectionLock) {
            return this.connectionLock;
          }
          try {
            this.connectionLock = this._connect();
            await this.connectionLock;
            return this;
          } finally {
            this.connectionLock = void 0;
          }
        }, callback);
      }
      async _connect() {
        if (this.topology && this.topology.isConnected()) {
          return this;
        }
        const options = this[kOptions];
        if (typeof options.srvHost === "string") {
          const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
          for (const [index, host] of hosts.entries()) {
            options.hosts[index] = host;
          }
        }
        const topology = new topology_1.Topology(options.hosts, options);
        this.topology = topology;
        topology.client = this;
        topology.once(topology_1.Topology.OPEN, () => this.emit("open", this));
        for (const event of constants_1.MONGO_CLIENT_EVENTS) {
          topology.on(event, (...args) => this.emit(event, ...args));
        }
        const topologyConnect = async () => {
          try {
            await (0, util_1.promisify)((callback) => topology.connect(options, callback))();
          } catch (error) {
            topology.close({ force: true });
            throw error;
          }
        };
        if (this.autoEncrypter) {
          const initAutoEncrypter = (0, util_1.promisify)((callback) => {
            var _a;
            return (_a = this.autoEncrypter) === null || _a === void 0 ? void 0 : _a.init(callback);
          });
          await initAutoEncrypter();
          await topologyConnect();
          await options.encrypter.connectInternalClient();
        } else {
          await topologyConnect();
        }
        return this;
      }
      close(forceOrCallback, callback) {
        Object.defineProperty(this.s, "hasBeenClosed", {
          value: true,
          enumerable: true,
          configurable: false,
          writable: false
        });
        if (typeof forceOrCallback === "function") {
          callback = forceOrCallback;
        }
        const force = typeof forceOrCallback === "boolean" ? forceOrCallback : false;
        return (0, utils_1.maybeCallback)(async () => {
          const activeSessionEnds = Array.from(this.s.activeSessions, (session) => session.endSession());
          this.s.activeSessions.clear();
          await Promise.all(activeSessionEnds);
          if (this.topology == null) {
            return;
          }
          const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
          const topologyDescription = this.topology.description;
          const serverDescriptions = Array.from(topologyDescription.servers.values());
          const servers = selector(topologyDescription, serverDescriptions);
          if (servers.length !== 0) {
            const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
            if (endSessions.length !== 0) {
              await this.db("admin").command({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true }).catch(() => null);
            }
          }
          const topology = this.topology;
          this.topology = void 0;
          await new Promise((resolve, reject) => {
            topology.close({ force }, (error) => {
              if (error)
                return reject(error);
              const { encrypter } = this[kOptions];
              if (encrypter) {
                return encrypter.close(this, force, (error2) => {
                  if (error2)
                    return reject(error2);
                  resolve();
                });
              }
              resolve();
            });
          });
        }, callback);
      }
      /**
       * Create a new Db instance sharing the current socket connections.
       *
       * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.
       * @param options - Optional settings for Db construction
       */
      db(dbName, options) {
        options = options !== null && options !== void 0 ? options : {};
        if (!dbName) {
          dbName = this.options.dbName;
        }
        const finalOptions = Object.assign({}, this[kOptions], options);
        const db = new db_1.Db(this, dbName, finalOptions);
        return db;
      }
      static connect(url, options, callback) {
        callback = typeof callback === "function" ? callback : typeof options === "function" ? options : void 0;
        return (0, utils_1.maybeCallback)(async () => {
          options = typeof options !== "function" ? options : void 0;
          const client = new this(url, options);
          return client.connect();
        }, callback);
      }
      startSession(options) {
        const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this[kOptions]);
        this.s.activeSessions.add(session);
        session.once("ended", () => {
          this.s.activeSessions.delete(session);
        });
        return session;
      }
      withSession(optionsOrOperation, callback) {
        const options = {
          // Always define an owner
          owner: Symbol(),
          // If it's an object inherit the options
          ...typeof optionsOrOperation === "object" ? optionsOrOperation : {}
        };
        const withSessionCallback = typeof optionsOrOperation === "function" ? optionsOrOperation : callback;
        if (withSessionCallback == null) {
          throw new error_1.MongoInvalidArgumentError("Missing required callback parameter");
        }
        const session = this.startSession(options);
        return (0, utils_1.maybeCallback)(async () => {
          try {
            await withSessionCallback(session);
          } finally {
            try {
              await session.endSession();
            } catch {
            }
          }
        }, null);
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates,
       * replacements, deletions, and invalidations) in this cluster. Will ignore all
       * changes to system collections, as well as the local, admin, and config databases.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to provide the schema that may be defined for all the data within the current cluster
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       *
       * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TSchema - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline2 = [], options = {}) {
        if (!Array.isArray(pipeline2)) {
          options = pipeline2;
          pipeline2 = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline2, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Return the mongo client logger
       * @deprecated The Legacy Logger is deprecated and will be removed in the next major version.
       */
      getLogger() {
        return this.s.logger;
      }
    };
    exports2.MongoClient = MongoClient;
  }
});

// asset-input/node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "asset-input/node_modules/mongodb/lib/change_stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChangeStream = void 0;
    var collection_1 = require_collection();
    var constants_1 = require_constants3();
    var change_stream_cursor_1 = require_change_stream_cursor();
    var db_1 = require_db();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils2();
    var kCursorStream = Symbol("cursorStream");
    var kClosed = Symbol("closed");
    var kMode = Symbol("mode");
    var CHANGE_STREAM_OPTIONS = [
      "resumeAfter",
      "startAfter",
      "startAtOperationTime",
      "fullDocument",
      "fullDocumentBeforeChange",
      "showExpandedEvents"
    ];
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
    var NO_RESUME_TOKEN_ERROR = "A change stream document has been received that lacks a resume token (_id).";
    var CHANGESTREAM_CLOSED_ERROR = "ChangeStream is closed";
    var ChangeStream = class _ChangeStream extends mongo_types_1.TypedEventEmitter {
      /**
       * @internal
       *
       * @param parent - The parent object that created this change stream
       * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
       */
      constructor(parent, pipeline2 = [], options = {}) {
        super();
        this.pipeline = pipeline2;
        this.options = { ...options };
        delete this.options.writeConcern;
        if (parent instanceof collection_1.Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
        } else if (parent instanceof db_1.Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
        } else if (parent instanceof mongo_client_1.MongoClient) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
        } else {
          throw new error_1.MongoChangeStreamError("Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient");
        }
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (!this.options.readPreference && parent.readPreference) {
          this.options.readPreference = parent.readPreference;
        }
        this.cursor = this._createChangeStreamCursor(options);
        this[kClosed] = false;
        this[kMode] = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this._streamEvents(this.cursor);
          }
        });
        this.on("removeListener", (eventName) => {
          var _a;
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            (_a = this[kCursorStream]) === null || _a === void 0 ? void 0 : _a.removeAllListeners("data");
          }
        });
      }
      /** @internal */
      get cursorStream() {
        return this[kCursorStream];
      }
      /** The cached resume token that is used to resume after the most recently returned change. */
      get resumeToken() {
        var _a;
        return (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.resumeToken;
      }
      hasNext(callback) {
        this._setIsIterator();
        return (0, utils_1.maybeCallback)(async () => {
          while (true) {
            try {
              const hasNext = await this.cursor.hasNext();
              return hasNext;
            } catch (error) {
              try {
                await this._processErrorIteratorMode(error);
              } catch (error2) {
                try {
                  await this.close();
                } catch {
                }
                throw error2;
              }
            }
          }
        }, callback);
      }
      next(callback) {
        this._setIsIterator();
        return (0, utils_1.maybeCallback)(async () => {
          while (true) {
            try {
              const change = await this.cursor.next();
              const processedChange = this._processChange(change !== null && change !== void 0 ? change : null);
              return processedChange;
            } catch (error) {
              try {
                await this._processErrorIteratorMode(error);
              } catch (error2) {
                try {
                  await this.close();
                } catch {
                }
                throw error2;
              }
            }
          }
        }, callback);
      }
      tryNext(callback) {
        this._setIsIterator();
        return (0, utils_1.maybeCallback)(async () => {
          while (true) {
            try {
              const change = await this.cursor.tryNext();
              return change !== null && change !== void 0 ? change : null;
            } catch (error) {
              try {
                await this._processErrorIteratorMode(error);
              } catch (error2) {
                try {
                  await this.close();
                } catch {
                }
                throw error2;
              }
            }
          }
        }, callback);
      }
      async *[Symbol.asyncIterator]() {
        if (this.closed) {
          return;
        }
        try {
          while (true) {
            yield await this.next();
          }
        } finally {
          try {
            await this.close();
          } catch {
          }
        }
      }
      /** Is the cursor closed */
      get closed() {
        return this[kClosed] || this.cursor.closed;
      }
      close(callback) {
        this[kClosed] = true;
        return (0, utils_1.maybeCallback)(async () => {
          const cursor = this.cursor;
          try {
            await cursor.close();
          } finally {
            this._endStream();
          }
        }, callback);
      }
      /**
       * Return a modified Readable stream including a possible transform method.
       *
       * NOTE: When using a Stream to process change stream events, the stream will
       * NOT automatically resume in the case a resumable error is encountered.
       *
       * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed
       */
      stream(options) {
        if (this.closed) {
          throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
        }
        this.streamOptions = options;
        return this.cursor.stream(options);
      }
      /** @internal */
      _setIsEmitter() {
        if (this[kMode] === "iterator") {
          throw new error_1.MongoAPIError("ChangeStream cannot be used as an EventEmitter after being used as an iterator");
        }
        this[kMode] = "emitter";
      }
      /** @internal */
      _setIsIterator() {
        if (this[kMode] === "emitter") {
          throw new error_1.MongoAPIError("ChangeStream cannot be used as an iterator after being used as an EventEmitter");
        }
        this[kMode] = "iterator";
      }
      /**
       * Create a new change stream cursor based on self's configuration
       * @internal
       */
      _createChangeStreamCursor(options) {
        const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);
        if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
          changeStreamStageOptions.allChangesForCluster = true;
        }
        const pipeline2 = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
        const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.s.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.s.db.s.client : null;
        if (client == null) {
          throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
        }
        const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline2, options);
        for (const event of CHANGE_STREAM_EVENTS) {
          changeStreamCursor.on(event, (e) => this.emit(event, e));
        }
        if (this.listenerCount(_ChangeStream.CHANGE) > 0) {
          this._streamEvents(changeStreamCursor);
        }
        return changeStreamCursor;
      }
      /** @internal */
      _closeEmitterModeWithError(error) {
        this.emit(_ChangeStream.ERROR, error);
        this.close(() => {
        });
      }
      /** @internal */
      _streamEvents(cursor) {
        var _a;
        this._setIsEmitter();
        const stream = (_a = this[kCursorStream]) !== null && _a !== void 0 ? _a : cursor.stream();
        this[kCursorStream] = stream;
        stream.on("data", (change) => {
          try {
            const processedChange = this._processChange(change);
            this.emit(_ChangeStream.CHANGE, processedChange);
          } catch (error) {
            this.emit(_ChangeStream.ERROR, error);
          }
        });
        stream.on("error", (error) => this._processErrorStreamMode(error));
      }
      /** @internal */
      _endStream() {
        const cursorStream = this[kCursorStream];
        if (cursorStream) {
          ["data", "close", "end", "error"].forEach((event) => cursorStream.removeAllListeners(event));
          cursorStream.destroy();
        }
        this[kCursorStream] = void 0;
      }
      /** @internal */
      _processChange(change) {
        if (this[kClosed]) {
          throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (change == null) {
          throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (change && !change._id) {
          throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
        }
        this.cursor.cacheResumeToken(change._id);
        this.options.startAtOperationTime = void 0;
        return change;
      }
      /** @internal */
      _processErrorStreamMode(changeStreamError) {
        if (this[kClosed])
          return;
        if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
          this._endStream();
          this.cursor.close().catch(() => null);
          const topology = (0, utils_1.getTopology)(this.parent);
          topology.selectServer(this.cursor.readPreference, {}, (serverSelectionError) => {
            if (serverSelectionError)
              return this._closeEmitterModeWithError(changeStreamError);
            this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
          });
        } else {
          this._closeEmitterModeWithError(changeStreamError);
        }
      }
      /** @internal */
      async _processErrorIteratorMode(changeStreamError) {
        if (this[kClosed]) {
          throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (!(0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
          try {
            await this.close();
          } catch {
          }
          throw changeStreamError;
        }
        await this.cursor.close().catch(() => null);
        const topology = (0, utils_1.getTopology)(this.parent);
        try {
          await topology.selectServerAsync(this.cursor.readPreference, {});
          this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
        } catch {
          await this.close();
          throw changeStreamError;
        }
      }
    };
    exports2.ChangeStream = ChangeStream;
    ChangeStream.RESPONSE = constants_1.RESPONSE;
    ChangeStream.MORE = constants_1.MORE;
    ChangeStream.INIT = constants_1.INIT;
    ChangeStream.CLOSE = constants_1.CLOSE;
    ChangeStream.CHANGE = constants_1.CHANGE;
    ChangeStream.END = constants_1.END;
    ChangeStream.ERROR = constants_1.ERROR;
    ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
  }
});

// asset-input/node_modules/mongodb/lib/gridfs/download.js
var require_download = __commonJS({
  "asset-input/node_modules/mongodb/lib/gridfs/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GridFSBucketReadStream = void 0;
    var stream_1 = require("stream");
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var GridFSBucketReadStream = class _GridFSBucketReadStream extends stream_1.Readable {
      /**
       * @param chunks - Handle for chunks collection
       * @param files - Handle for files collection
       * @param readPreference - The read preference to use
       * @param filter - The filter to use to find the file document
       * @internal
       */
      constructor(chunks, files, readPreference, filter, options) {
        super();
        this.s = {
          bytesToTrim: 0,
          bytesToSkip: 0,
          bytesRead: 0,
          chunks,
          expected: 0,
          files,
          filter,
          init: false,
          expectedEnd: 0,
          options: {
            start: 0,
            end: 0,
            ...options
          },
          readPreference
        };
      }
      /**
       * Reads from the cursor and pushes to the stream.
       * Private Impl, do not call directly
       * @internal
       */
      _read() {
        if (this.destroyed)
          return;
        waitForFile(this, () => doRead(this));
      }
      /**
       * Sets the 0-based offset in bytes to start streaming from. Throws
       * an error if this stream has entered flowing mode
       * (e.g. if you've already called `on('data')`)
       *
       * @param start - 0-based offset in bytes to start streaming from
       */
      start(start = 0) {
        throwIfInitialized(this);
        this.s.options.start = start;
        return this;
      }
      /**
       * Sets the 0-based offset in bytes to start streaming from. Throws
       * an error if this stream has entered flowing mode
       * (e.g. if you've already called `on('data')`)
       *
       * @param end - Offset in bytes to stop reading at
       */
      end(end = 0) {
        throwIfInitialized(this);
        this.s.options.end = end;
        return this;
      }
      abort(callback) {
        return (0, utils_1.maybeCallback)(async () => {
          this.push(null);
          this.destroyed = true;
          if (this.s.cursor) {
            await this.s.cursor.close().catch((error) => {
              this.emit(_GridFSBucketReadStream.CLOSE);
              throw error;
            });
          } else {
            if (!this.s.init) {
              this.emit(_GridFSBucketReadStream.CLOSE);
            }
          }
        }, callback);
      }
    };
    exports2.GridFSBucketReadStream = GridFSBucketReadStream;
    GridFSBucketReadStream.ERROR = "error";
    GridFSBucketReadStream.FILE = "file";
    GridFSBucketReadStream.DATA = "data";
    GridFSBucketReadStream.END = "end";
    GridFSBucketReadStream.CLOSE = "close";
    function throwIfInitialized(stream) {
      if (stream.s.init) {
        throw new error_1.MongoGridFSStreamError("Options cannot be changed after the stream is initialized");
      }
    }
    function doRead(stream) {
      if (stream.destroyed)
        return;
      if (!stream.s.cursor)
        return;
      if (!stream.s.file)
        return;
      stream.s.cursor.next((error, doc) => {
        if (stream.destroyed) {
          return;
        }
        if (error) {
          stream.emit(GridFSBucketReadStream.ERROR, error);
          return;
        }
        if (!doc) {
          stream.push(null);
          if (!stream.s.cursor)
            return;
          stream.s.cursor.close((error2) => {
            if (error2) {
              stream.emit(GridFSBucketReadStream.ERROR, error2);
              return;
            }
            stream.emit(GridFSBucketReadStream.CLOSE);
          });
          return;
        }
        if (!stream.s.file)
          return;
        const bytesRemaining = stream.s.file.length - stream.s.bytesRead;
        const expectedN = stream.s.expected++;
        const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
        }
        if (doc.n < expectedN) {
          return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
        }
        let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.byteLength !== expectedLength) {
          if (bytesRemaining <= 0) {
            return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream.s.file.length} bytes but already read ${stream.s.bytesRead} bytes`));
          }
          return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
        }
        stream.s.bytesRead += buf.byteLength;
        if (buf.byteLength === 0) {
          return stream.push(null);
        }
        let sliceStart = null;
        let sliceEnd = null;
        if (stream.s.bytesToSkip != null) {
          sliceStart = stream.s.bytesToSkip;
          stream.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === stream.s.expectedEnd - 1;
        const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;
        if (atEndOfStream && stream.s.bytesToTrim != null) {
          sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
        } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
        }
        stream.push(buf);
        return;
      });
    }
    function init(stream) {
      const findOneOptions = {};
      if (stream.s.readPreference) {
        findOneOptions.readPreference = stream.s.readPreference;
      }
      if (stream.s.options && stream.s.options.sort) {
        findOneOptions.sort = stream.s.options.sort;
      }
      if (stream.s.options && stream.s.options.skip) {
        findOneOptions.skip = stream.s.options.skip;
      }
      stream.s.files.findOne(stream.s.filter, findOneOptions, (error, doc) => {
        if (error) {
          return stream.emit(GridFSBucketReadStream.ERROR, error);
        }
        if (!doc) {
          const identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
          const errmsg = `FileNotFound: file ${identifier} was not found`;
          const err = new error_1.MongoRuntimeError(errmsg);
          err.code = "ENOENT";
          return stream.emit(GridFSBucketReadStream.ERROR, err);
        }
        if (doc.length <= 0) {
          stream.push(null);
          return;
        }
        if (stream.destroyed) {
          stream.emit(GridFSBucketReadStream.CLOSE);
          return;
        }
        try {
          stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
        } catch (error2) {
          return stream.emit(GridFSBucketReadStream.ERROR, error2);
        }
        const filter = { files_id: doc._id };
        if (stream.s.options && stream.s.options.start != null) {
          const skip = Math.floor(stream.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter["n"] = { $gte: skip };
          }
        }
        stream.s.cursor = stream.s.chunks.find(filter).sort({ n: 1 });
        if (stream.s.readPreference) {
          stream.s.cursor.withReadPreference(stream.s.readPreference);
        }
        stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        stream.s.file = doc;
        try {
          stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
        } catch (error2) {
          return stream.emit(GridFSBucketReadStream.ERROR, error2);
        }
        stream.emit(GridFSBucketReadStream.FILE, doc);
        return;
      });
    }
    function waitForFile(stream, callback) {
      if (stream.s.file) {
        return callback();
      }
      if (!stream.s.init) {
        init(stream);
        stream.s.init = true;
      }
      stream.once("file", () => {
        callback();
      });
    }
    function handleStartOption(stream, doc, options) {
      if (options && options.start != null) {
        if (options.start > doc.length) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);
        }
        if (options.start < 0) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);
        }
        if (options.end != null && options.end < options.start) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);
        }
        stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
        stream.s.expected = Math.floor(options.start / doc.chunkSize);
        return options.start - stream.s.bytesRead;
      }
      throw new error_1.MongoInvalidArgumentError("Start option must be defined");
    }
    function handleEndOption(stream, doc, cursor, options) {
      if (options && options.end != null) {
        if (options.end > doc.length) {
          throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);
        }
        if (options.start == null || options.start < 0) {
          throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);
        }
        const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
        stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
        return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
      }
      throw new error_1.MongoInvalidArgumentError("End option must be defined");
    }
  }
});

// asset-input/node_modules/mongodb/lib/gridfs/upload.js
var require_upload = __commonJS({
  "asset-input/node_modules/mongodb/lib/gridfs/upload.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GridFSBucketWriteStream = void 0;
    var stream_1 = require("stream");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils2();
    var write_concern_1 = require_write_concern();
    var GridFSBucketWriteStream = class _GridFSBucketWriteStream extends stream_1.Writable {
      /**
       * @param bucket - Handle for this stream's corresponding bucket
       * @param filename - The value of the 'filename' key in the files doc
       * @param options - Optional settings.
       * @internal
       */
      constructor(bucket, filename, options) {
        super();
        options = options !== null && options !== void 0 ? options : {};
        this.bucket = bucket;
        this.chunks = bucket.s._chunksCollection;
        this.filename = filename;
        this.files = bucket.s._filesCollection;
        this.options = options;
        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;
        this.done = false;
        this.id = options.id ? options.id : new bson_1.ObjectId();
        this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
        this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
        this.length = 0;
        this.n = 0;
        this.pos = 0;
        this.state = {
          streamEnd: false,
          outstandingRequests: 0,
          errored: false,
          aborted: false
        };
        if (!this.bucket.s.calledOpenUploadStream) {
          this.bucket.s.calledOpenUploadStream = true;
          checkIndexes(this, () => {
            this.bucket.s.checkedIndexes = true;
            this.bucket.emit("index");
          });
        }
      }
      write(chunk, encodingOrCallback, callback) {
        const encoding = typeof encodingOrCallback === "function" ? void 0 : encodingOrCallback;
        callback = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
        return waitForIndexes(this, () => doWrite(this, chunk, encoding, callback));
      }
      abort(callback) {
        return (0, utils_1.maybeCallback)(async () => {
          if (this.state.streamEnd) {
            throw new error_1.MongoAPIError("Cannot abort a stream that has already completed");
          }
          if (this.state.aborted) {
            throw new error_1.MongoAPIError("Cannot call abort() on a stream twice");
          }
          this.state.aborted = true;
          await this.chunks.deleteMany({ files_id: this.id });
        }, callback);
      }
      end(chunkOrCallback, encodingOrCallback, callback) {
        const chunk = typeof chunkOrCallback === "function" ? void 0 : chunkOrCallback;
        const encoding = typeof encodingOrCallback === "function" ? void 0 : encodingOrCallback;
        callback = typeof chunkOrCallback === "function" ? chunkOrCallback : typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
        if (this.state.streamEnd || checkAborted(this, callback))
          return this;
        this.state.streamEnd = true;
        if (callback) {
          this.once(_GridFSBucketWriteStream.FINISH, (result) => {
            if (callback)
              callback(void 0, result);
          });
        }
        if (!chunk) {
          waitForIndexes(this, () => !!writeRemnant(this));
          return this;
        }
        this.write(chunk, encoding, () => {
          writeRemnant(this);
        });
        return this;
      }
    };
    exports2.GridFSBucketWriteStream = GridFSBucketWriteStream;
    GridFSBucketWriteStream.CLOSE = "close";
    GridFSBucketWriteStream.ERROR = "error";
    GridFSBucketWriteStream.FINISH = "finish";
    function __handleError(stream, error, callback) {
      if (stream.state.errored) {
        return;
      }
      stream.state.errored = true;
      if (callback) {
        return callback(error);
      }
      stream.emit(GridFSBucketWriteStream.ERROR, error);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: new bson_1.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    function checkChunksIndex(stream, callback) {
      stream.chunks.listIndexes().toArray((error, indexes) => {
        let index;
        if (error) {
          if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
            index = { files_id: 1, n: 1 };
            stream.chunks.createIndex(index, { background: false, unique: true }, (error2) => {
              if (error2) {
                return callback(error2);
              }
              callback();
            });
            return;
          }
          return callback(error);
        }
        let hasChunksIndex = false;
        if (indexes) {
          indexes.forEach((index2) => {
            if (index2.key) {
              const keys = Object.keys(index2.key);
              if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
                hasChunksIndex = true;
              }
            }
          });
        }
        if (hasChunksIndex) {
          callback();
        } else {
          index = { files_id: 1, n: 1 };
          const writeConcernOptions = getWriteOptions(stream);
          stream.chunks.createIndex(index, {
            ...writeConcernOptions,
            background: true,
            unique: true
          }, callback);
        }
      });
    }
    function checkDone(stream, callback) {
      if (stream.done)
        return true;
      if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
        stream.done = true;
        const filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);
        if (checkAborted(stream, callback)) {
          return false;
        }
        stream.files.insertOne(filesDoc, getWriteOptions(stream), (error) => {
          if (error) {
            return __handleError(stream, error, callback);
          }
          stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);
          stream.emit(GridFSBucketWriteStream.CLOSE);
        });
        return true;
      }
      return false;
    }
    function checkIndexes(stream, callback) {
      stream.files.findOne({}, { projection: { _id: 1 } }, (error, doc) => {
        if (error) {
          return callback(error);
        }
        if (doc) {
          return callback();
        }
        stream.files.listIndexes().toArray((error2, indexes) => {
          let index;
          if (error2) {
            if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
              index = { filename: 1, uploadDate: 1 };
              stream.files.createIndex(index, { background: false }, (error3) => {
                if (error3) {
                  return callback(error3);
                }
                checkChunksIndex(stream, callback);
              });
              return;
            }
            return callback(error2);
          }
          let hasFileIndex = false;
          if (indexes) {
            indexes.forEach((index2) => {
              const keys = Object.keys(index2.key);
              if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
                hasFileIndex = true;
              }
            });
          }
          if (hasFileIndex) {
            checkChunksIndex(stream, callback);
          } else {
            index = { filename: 1, uploadDate: 1 };
            const writeConcernOptions = getWriteOptions(stream);
            stream.files.createIndex(index, {
              ...writeConcernOptions,
              background: false
            }, (error3) => {
              if (error3) {
                return callback(error3);
              }
              checkChunksIndex(stream, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
      const ret = {
        _id,
        length,
        chunkSize,
        uploadDate: /* @__PURE__ */ new Date(),
        filename
      };
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(stream, chunk, encoding, callback) {
      if (checkAborted(stream, callback)) {
        return false;
      }
      const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
      stream.length += inputBuf.length;
      if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
        inputBuf.copy(stream.bufToStore, stream.pos);
        stream.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      let inputBufRemaining = inputBuf.length;
      let spaceRemaining = stream.chunkSizeBytes - stream.pos;
      let numToCopy = Math.min(spaceRemaining, inputBuf.length);
      let outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        const inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
        stream.pos += numToCopy;
        spaceRemaining -= numToCopy;
        let doc;
        if (spaceRemaining === 0) {
          doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
          ++stream.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(stream, callback)) {
            return false;
          }
          stream.chunks.insertOne(doc, getWriteOptions(stream), (error) => {
            if (error) {
              return __handleError(stream, error);
            }
            --stream.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              stream.emit("drain", doc);
              callback && callback();
              checkDone(stream);
            }
          });
          spaceRemaining = stream.chunkSizeBytes;
          stream.pos = 0;
          ++stream.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(stream) {
      const obj = {};
      if (stream.writeConcern) {
        obj.writeConcern = {
          w: stream.writeConcern.w,
          wtimeout: stream.writeConcern.wtimeout,
          j: stream.writeConcern.j
        };
      }
      return obj;
    }
    function waitForIndexes(stream, callback) {
      if (stream.bucket.s.checkedIndexes) {
        return callback(false);
      }
      stream.bucket.once("index", () => {
        callback(true);
      });
      return true;
    }
    function writeRemnant(stream, callback) {
      if (stream.pos === 0) {
        return checkDone(stream, callback);
      }
      ++stream.state.outstandingRequests;
      const remnant = Buffer.alloc(stream.pos);
      stream.bufToStore.copy(remnant, 0, 0, stream.pos);
      const doc = createChunkDoc(stream.id, stream.n, remnant);
      if (checkAborted(stream, callback)) {
        return false;
      }
      stream.chunks.insertOne(doc, getWriteOptions(stream), (error) => {
        if (error) {
          return __handleError(stream, error);
        }
        --stream.state.outstandingRequests;
        checkDone(stream);
      });
      return true;
    }
    function checkAborted(stream, callback) {
      if (stream.state.aborted) {
        if (typeof callback === "function") {
          callback(new error_1.MongoAPIError("Stream has been aborted"));
        }
        return true;
      }
      return false;
    }
  }
});

// asset-input/node_modules/mongodb/lib/gridfs/index.js
var require_gridfs = __commonJS({
  "asset-input/node_modules/mongodb/lib/gridfs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GridFSBucket = void 0;
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils2();
    var write_concern_1 = require_write_concern();
    var download_1 = require_download();
    var upload_1 = require_upload();
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    var GridFSBucket = class extends mongo_types_1.TypedEventEmitter {
      constructor(db, options) {
        super();
        this.setMaxListeners(0);
        const privateOptions = {
          ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
          ...options,
          writeConcern: write_concern_1.WriteConcern.fromOptions(options)
        };
        this.s = {
          db,
          options: privateOptions,
          _chunksCollection: db.collection(privateOptions.bucketName + ".chunks"),
          _filesCollection: db.collection(privateOptions.bucketName + ".files"),
          checkedIndexes: false,
          calledOpenUploadStream: false
        };
      }
      /**
       * Returns a writable stream (GridFSBucketWriteStream) for writing
       * buffers to GridFS. The stream's 'id' property contains the resulting
       * file's id.
       *
       * @param filename - The value of the 'filename' key in the files doc
       * @param options - Optional settings.
       */
      openUploadStream(filename, options) {
        return new upload_1.GridFSBucketWriteStream(this, filename, options);
      }
      /**
       * Returns a writable stream (GridFSBucketWriteStream) for writing
       * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
       * file's id.
       */
      openUploadStreamWithId(id, filename, options) {
        return new upload_1.GridFSBucketWriteStream(this, filename, { ...options, id });
      }
      /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */
      openDownloadStream(id, options) {
        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, options);
      }
      delete(id, callback) {
        return (0, utils_1.maybeCallback)(async () => {
          const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id });
          await this.s._chunksCollection.deleteMany({ files_id: id });
          if (deletedCount === 0) {
            throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
          }
        }, callback);
      }
      /** Convenience wrapper around find on the files collection */
      find(filter, options) {
        filter !== null && filter !== void 0 ? filter : filter = {};
        options = options !== null && options !== void 0 ? options : {};
        return this.s._filesCollection.find(filter, options);
      }
      /**
       * Returns a readable stream (GridFSBucketReadStream) for streaming the
       * file with the given name from GridFS. If there are multiple files with
       * the same name, this will stream the most recent file with the given name
       * (as determined by the `uploadDate` field). You can set the `revision`
       * option to change this behavior.
       */
      openDownloadStreamByName(filename, options) {
        let sort = { uploadDate: -1 };
        let skip = void 0;
        if (options && options.revision != null) {
          if (options.revision >= 0) {
            sort = { uploadDate: 1 };
            skip = options.revision;
          } else {
            skip = -options.revision - 1;
          }
        }
        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { ...options, sort, skip });
      }
      rename(id, filename, callback) {
        return (0, utils_1.maybeCallback)(async () => {
          const filter = { _id: id };
          const update = { $set: { filename } };
          const { matchedCount } = await this.s._filesCollection.updateOne(filter, update);
          if (matchedCount === 0) {
            throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
          }
        }, callback);
      }
      drop(callback) {
        return (0, utils_1.maybeCallback)(async () => {
          await this.s._filesCollection.drop();
          await this.s._chunksCollection.drop();
        }, callback);
      }
      /**
       * Get the Db scoped logger.
       *
       * @deprecated Legacy Logger is deprecated and will be removed in the next major version.
       */
      getLogger() {
        return this.s.db.s.logger;
      }
    };
    exports2.GridFSBucket = GridFSBucket;
    GridFSBucket.INDEX = "index";
  }
});

// asset-input/node_modules/mongodb/lib/index.js
var require_lib3 = __commonJS({
  "asset-input/node_modules/mongodb/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractCursor = exports2.MongoWriteConcernError = exports2.MongoUnexpectedServerResponseError = exports2.MongoTransactionError = exports2.MongoTopologyClosedError = exports2.MongoTailableCursorError = exports2.MongoSystemError = exports2.MongoServerSelectionError = exports2.MongoServerError = exports2.MongoServerClosedError = exports2.MongoRuntimeError = exports2.MongoParseError = exports2.MongoNotConnectedError = exports2.MongoNetworkTimeoutError = exports2.MongoNetworkError = exports2.MongoMissingDependencyError = exports2.MongoMissingCredentialsError = exports2.MongoKerberosError = exports2.MongoInvalidArgumentError = exports2.MongoGridFSStreamError = exports2.MongoGridFSChunkError = exports2.MongoExpiredSessionError = exports2.MongoError = exports2.MongoDriverError = exports2.MongoDecompressionError = exports2.MongoCursorInUseError = exports2.MongoCursorExhaustedError = exports2.MongoCompatibilityError = exports2.MongoChangeStreamError = exports2.MongoBatchReExecutionError = exports2.MongoAWSError = exports2.MongoAPIError = exports2.MongoBulkWriteError = exports2.ObjectID = exports2.ChangeStreamCursor = exports2.Timestamp = exports2.ObjectId = exports2.MinKey = exports2.MaxKey = exports2.Map = exports2.Long = exports2.Int32 = exports2.Double = exports2.Decimal128 = exports2.DBRef = exports2.Code = exports2.BSONSymbol = exports2.BSONRegExp = exports2.Binary = exports2.BSON = void 0;
    exports2.ConnectionPoolCreatedEvent = exports2.ConnectionPoolClosedEvent = exports2.ConnectionPoolClearedEvent = exports2.ConnectionCreatedEvent = exports2.ConnectionClosedEvent = exports2.ConnectionCheckOutStartedEvent = exports2.ConnectionCheckOutFailedEvent = exports2.ConnectionCheckedOutEvent = exports2.ConnectionCheckedInEvent = exports2.CommandSucceededEvent = exports2.CommandStartedEvent = exports2.CommandFailedEvent = exports2.WriteConcern = exports2.ReadPreference = exports2.ReadConcern = exports2.TopologyType = exports2.ServerType = exports2.ReadPreferenceMode = exports2.ReadConcernLevel = exports2.ProfilingLevel = exports2.ReturnDocument = exports2.BSONType = exports2.ServerApiVersion = exports2.LoggerLevel = exports2.ExplainVerbosity = exports2.MongoErrorLabel = exports2.AutoEncryptionLoggerLevel = exports2.CURSOR_FLAGS = exports2.Compressor = exports2.AuthMechanism = exports2.GSSAPICanonicalizationValue = exports2.BatchType = exports2.Promise = exports2.UnorderedBulkOperation = exports2.OrderedBulkOperation = exports2.MongoClient = exports2.Logger = exports2.ListIndexesCursor = exports2.ListCollectionsCursor = exports2.GridFSBucketWriteStream = exports2.GridFSBucketReadStream = exports2.GridFSBucket = exports2.FindCursor = exports2.Db = exports2.Collection = exports2.ClientSession = exports2.ChangeStream = exports2.CancellationToken = exports2.AggregationCursor = exports2.Admin = void 0;
    exports2.SrvPollingEvent = exports2.TopologyOpeningEvent = exports2.TopologyDescriptionChangedEvent = exports2.TopologyClosedEvent = exports2.ServerOpeningEvent = exports2.ServerHeartbeatSucceededEvent = exports2.ServerHeartbeatStartedEvent = exports2.ServerHeartbeatFailedEvent = exports2.ServerDescriptionChangedEvent = exports2.ServerClosedEvent = exports2.ConnectionReadyEvent = exports2.ConnectionPoolReadyEvent = exports2.ConnectionPoolMonitoringEvent = void 0;
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "Admin", { enumerable: true, get: function() {
      return admin_1.Admin;
    } });
    var bson_1 = require_bson2();
    var ordered_1 = require_ordered();
    Object.defineProperty(exports2, "OrderedBulkOperation", { enumerable: true, get: function() {
      return ordered_1.OrderedBulkOperation;
    } });
    var unordered_1 = require_unordered();
    Object.defineProperty(exports2, "UnorderedBulkOperation", { enumerable: true, get: function() {
      return unordered_1.UnorderedBulkOperation;
    } });
    var change_stream_1 = require_change_stream();
    Object.defineProperty(exports2, "ChangeStream", { enumerable: true, get: function() {
      return change_stream_1.ChangeStream;
    } });
    var collection_1 = require_collection();
    Object.defineProperty(exports2, "Collection", { enumerable: true, get: function() {
      return collection_1.Collection;
    } });
    var abstract_cursor_1 = require_abstract_cursor();
    Object.defineProperty(exports2, "AbstractCursor", { enumerable: true, get: function() {
      return abstract_cursor_1.AbstractCursor;
    } });
    var aggregation_cursor_1 = require_aggregation_cursor();
    Object.defineProperty(exports2, "AggregationCursor", { enumerable: true, get: function() {
      return aggregation_cursor_1.AggregationCursor;
    } });
    var find_cursor_1 = require_find_cursor();
    Object.defineProperty(exports2, "FindCursor", { enumerable: true, get: function() {
      return find_cursor_1.FindCursor;
    } });
    var list_collections_cursor_1 = require_list_collections_cursor();
    Object.defineProperty(exports2, "ListCollectionsCursor", { enumerable: true, get: function() {
      return list_collections_cursor_1.ListCollectionsCursor;
    } });
    var list_indexes_cursor_1 = require_list_indexes_cursor();
    Object.defineProperty(exports2, "ListIndexesCursor", { enumerable: true, get: function() {
      return list_indexes_cursor_1.ListIndexesCursor;
    } });
    var db_1 = require_db();
    Object.defineProperty(exports2, "Db", { enumerable: true, get: function() {
      return db_1.Db;
    } });
    var gridfs_1 = require_gridfs();
    Object.defineProperty(exports2, "GridFSBucket", { enumerable: true, get: function() {
      return gridfs_1.GridFSBucket;
    } });
    var download_1 = require_download();
    Object.defineProperty(exports2, "GridFSBucketReadStream", { enumerable: true, get: function() {
      return download_1.GridFSBucketReadStream;
    } });
    var upload_1 = require_upload();
    Object.defineProperty(exports2, "GridFSBucketWriteStream", { enumerable: true, get: function() {
      return upload_1.GridFSBucketWriteStream;
    } });
    var logger_1 = require_logger();
    Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var mongo_client_1 = require_mongo_client();
    Object.defineProperty(exports2, "MongoClient", { enumerable: true, get: function() {
      return mongo_client_1.MongoClient;
    } });
    var mongo_types_1 = require_mongo_types();
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return mongo_types_1.CancellationToken;
    } });
    var promise_provider_1 = require_promise_provider();
    Object.defineProperty(exports2, "Promise", { enumerable: true, get: function() {
      return promise_provider_1.PromiseProvider;
    } });
    var sessions_1 = require_sessions();
    Object.defineProperty(exports2, "ClientSession", { enumerable: true, get: function() {
      return sessions_1.ClientSession;
    } });
    var bson_2 = require_bson2();
    Object.defineProperty(exports2, "BSON", { enumerable: true, get: function() {
      return bson_2.BSON;
    } });
    var bson_3 = require_bson2();
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return bson_3.Binary;
    } });
    Object.defineProperty(exports2, "BSONRegExp", { enumerable: true, get: function() {
      return bson_3.BSONRegExp;
    } });
    Object.defineProperty(exports2, "BSONSymbol", { enumerable: true, get: function() {
      return bson_3.BSONSymbol;
    } });
    Object.defineProperty(exports2, "Code", { enumerable: true, get: function() {
      return bson_3.Code;
    } });
    Object.defineProperty(exports2, "DBRef", { enumerable: true, get: function() {
      return bson_3.DBRef;
    } });
    Object.defineProperty(exports2, "Decimal128", { enumerable: true, get: function() {
      return bson_3.Decimal128;
    } });
    Object.defineProperty(exports2, "Double", { enumerable: true, get: function() {
      return bson_3.Double;
    } });
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return bson_3.Int32;
    } });
    Object.defineProperty(exports2, "Long", { enumerable: true, get: function() {
      return bson_3.Long;
    } });
    Object.defineProperty(exports2, "Map", { enumerable: true, get: function() {
      return bson_3.Map;
    } });
    Object.defineProperty(exports2, "MaxKey", { enumerable: true, get: function() {
      return bson_3.MaxKey;
    } });
    Object.defineProperty(exports2, "MinKey", { enumerable: true, get: function() {
      return bson_3.MinKey;
    } });
    Object.defineProperty(exports2, "ObjectId", { enumerable: true, get: function() {
      return bson_3.ObjectId;
    } });
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return bson_3.Timestamp;
    } });
    var change_stream_cursor_1 = require_change_stream_cursor();
    Object.defineProperty(exports2, "ChangeStreamCursor", { enumerable: true, get: function() {
      return change_stream_cursor_1.ChangeStreamCursor;
    } });
    exports2.ObjectID = bson_1.ObjectId;
    var common_1 = require_common2();
    Object.defineProperty(exports2, "MongoBulkWriteError", { enumerable: true, get: function() {
      return common_1.MongoBulkWriteError;
    } });
    var error_1 = require_error();
    Object.defineProperty(exports2, "MongoAPIError", { enumerable: true, get: function() {
      return error_1.MongoAPIError;
    } });
    Object.defineProperty(exports2, "MongoAWSError", { enumerable: true, get: function() {
      return error_1.MongoAWSError;
    } });
    Object.defineProperty(exports2, "MongoBatchReExecutionError", { enumerable: true, get: function() {
      return error_1.MongoBatchReExecutionError;
    } });
    Object.defineProperty(exports2, "MongoChangeStreamError", { enumerable: true, get: function() {
      return error_1.MongoChangeStreamError;
    } });
    Object.defineProperty(exports2, "MongoCompatibilityError", { enumerable: true, get: function() {
      return error_1.MongoCompatibilityError;
    } });
    Object.defineProperty(exports2, "MongoCursorExhaustedError", { enumerable: true, get: function() {
      return error_1.MongoCursorExhaustedError;
    } });
    Object.defineProperty(exports2, "MongoCursorInUseError", { enumerable: true, get: function() {
      return error_1.MongoCursorInUseError;
    } });
    Object.defineProperty(exports2, "MongoDecompressionError", { enumerable: true, get: function() {
      return error_1.MongoDecompressionError;
    } });
    Object.defineProperty(exports2, "MongoDriverError", { enumerable: true, get: function() {
      return error_1.MongoDriverError;
    } });
    Object.defineProperty(exports2, "MongoError", { enumerable: true, get: function() {
      return error_1.MongoError;
    } });
    Object.defineProperty(exports2, "MongoExpiredSessionError", { enumerable: true, get: function() {
      return error_1.MongoExpiredSessionError;
    } });
    Object.defineProperty(exports2, "MongoGridFSChunkError", { enumerable: true, get: function() {
      return error_1.MongoGridFSChunkError;
    } });
    Object.defineProperty(exports2, "MongoGridFSStreamError", { enumerable: true, get: function() {
      return error_1.MongoGridFSStreamError;
    } });
    Object.defineProperty(exports2, "MongoInvalidArgumentError", { enumerable: true, get: function() {
      return error_1.MongoInvalidArgumentError;
    } });
    Object.defineProperty(exports2, "MongoKerberosError", { enumerable: true, get: function() {
      return error_1.MongoKerberosError;
    } });
    Object.defineProperty(exports2, "MongoMissingCredentialsError", { enumerable: true, get: function() {
      return error_1.MongoMissingCredentialsError;
    } });
    Object.defineProperty(exports2, "MongoMissingDependencyError", { enumerable: true, get: function() {
      return error_1.MongoMissingDependencyError;
    } });
    Object.defineProperty(exports2, "MongoNetworkError", { enumerable: true, get: function() {
      return error_1.MongoNetworkError;
    } });
    Object.defineProperty(exports2, "MongoNetworkTimeoutError", { enumerable: true, get: function() {
      return error_1.MongoNetworkTimeoutError;
    } });
    Object.defineProperty(exports2, "MongoNotConnectedError", { enumerable: true, get: function() {
      return error_1.MongoNotConnectedError;
    } });
    Object.defineProperty(exports2, "MongoParseError", { enumerable: true, get: function() {
      return error_1.MongoParseError;
    } });
    Object.defineProperty(exports2, "MongoRuntimeError", { enumerable: true, get: function() {
      return error_1.MongoRuntimeError;
    } });
    Object.defineProperty(exports2, "MongoServerClosedError", { enumerable: true, get: function() {
      return error_1.MongoServerClosedError;
    } });
    Object.defineProperty(exports2, "MongoServerError", { enumerable: true, get: function() {
      return error_1.MongoServerError;
    } });
    Object.defineProperty(exports2, "MongoServerSelectionError", { enumerable: true, get: function() {
      return error_1.MongoServerSelectionError;
    } });
    Object.defineProperty(exports2, "MongoSystemError", { enumerable: true, get: function() {
      return error_1.MongoSystemError;
    } });
    Object.defineProperty(exports2, "MongoTailableCursorError", { enumerable: true, get: function() {
      return error_1.MongoTailableCursorError;
    } });
    Object.defineProperty(exports2, "MongoTopologyClosedError", { enumerable: true, get: function() {
      return error_1.MongoTopologyClosedError;
    } });
    Object.defineProperty(exports2, "MongoTransactionError", { enumerable: true, get: function() {
      return error_1.MongoTransactionError;
    } });
    Object.defineProperty(exports2, "MongoUnexpectedServerResponseError", { enumerable: true, get: function() {
      return error_1.MongoUnexpectedServerResponseError;
    } });
    Object.defineProperty(exports2, "MongoWriteConcernError", { enumerable: true, get: function() {
      return error_1.MongoWriteConcernError;
    } });
    var common_2 = require_common2();
    Object.defineProperty(exports2, "BatchType", { enumerable: true, get: function() {
      return common_2.BatchType;
    } });
    var gssapi_1 = require_gssapi();
    Object.defineProperty(exports2, "GSSAPICanonicalizationValue", { enumerable: true, get: function() {
      return gssapi_1.GSSAPICanonicalizationValue;
    } });
    var providers_1 = require_providers();
    Object.defineProperty(exports2, "AuthMechanism", { enumerable: true, get: function() {
      return providers_1.AuthMechanism;
    } });
    var compression_1 = require_compression();
    Object.defineProperty(exports2, "Compressor", { enumerable: true, get: function() {
      return compression_1.Compressor;
    } });
    var abstract_cursor_2 = require_abstract_cursor();
    Object.defineProperty(exports2, "CURSOR_FLAGS", { enumerable: true, get: function() {
      return abstract_cursor_2.CURSOR_FLAGS;
    } });
    var deps_1 = require_deps();
    Object.defineProperty(exports2, "AutoEncryptionLoggerLevel", { enumerable: true, get: function() {
      return deps_1.AutoEncryptionLoggerLevel;
    } });
    var error_2 = require_error();
    Object.defineProperty(exports2, "MongoErrorLabel", { enumerable: true, get: function() {
      return error_2.MongoErrorLabel;
    } });
    var explain_1 = require_explain();
    Object.defineProperty(exports2, "ExplainVerbosity", { enumerable: true, get: function() {
      return explain_1.ExplainVerbosity;
    } });
    var logger_2 = require_logger();
    Object.defineProperty(exports2, "LoggerLevel", { enumerable: true, get: function() {
      return logger_2.LoggerLevel;
    } });
    var mongo_client_2 = require_mongo_client();
    Object.defineProperty(exports2, "ServerApiVersion", { enumerable: true, get: function() {
      return mongo_client_2.ServerApiVersion;
    } });
    var mongo_types_2 = require_mongo_types();
    Object.defineProperty(exports2, "BSONType", { enumerable: true, get: function() {
      return mongo_types_2.BSONType;
    } });
    var find_and_modify_1 = require_find_and_modify();
    Object.defineProperty(exports2, "ReturnDocument", { enumerable: true, get: function() {
      return find_and_modify_1.ReturnDocument;
    } });
    var set_profiling_level_1 = require_set_profiling_level();
    Object.defineProperty(exports2, "ProfilingLevel", { enumerable: true, get: function() {
      return set_profiling_level_1.ProfilingLevel;
    } });
    var read_concern_1 = require_read_concern();
    Object.defineProperty(exports2, "ReadConcernLevel", { enumerable: true, get: function() {
      return read_concern_1.ReadConcernLevel;
    } });
    var read_preference_1 = require_read_preference();
    Object.defineProperty(exports2, "ReadPreferenceMode", { enumerable: true, get: function() {
      return read_preference_1.ReadPreferenceMode;
    } });
    var common_3 = require_common();
    Object.defineProperty(exports2, "ServerType", { enumerable: true, get: function() {
      return common_3.ServerType;
    } });
    Object.defineProperty(exports2, "TopologyType", { enumerable: true, get: function() {
      return common_3.TopologyType;
    } });
    var read_concern_2 = require_read_concern();
    Object.defineProperty(exports2, "ReadConcern", { enumerable: true, get: function() {
      return read_concern_2.ReadConcern;
    } });
    var read_preference_2 = require_read_preference();
    Object.defineProperty(exports2, "ReadPreference", { enumerable: true, get: function() {
      return read_preference_2.ReadPreference;
    } });
    var write_concern_1 = require_write_concern();
    Object.defineProperty(exports2, "WriteConcern", { enumerable: true, get: function() {
      return write_concern_1.WriteConcern;
    } });
    var command_monitoring_events_1 = require_command_monitoring_events();
    Object.defineProperty(exports2, "CommandFailedEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandFailedEvent;
    } });
    Object.defineProperty(exports2, "CommandStartedEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandStartedEvent;
    } });
    Object.defineProperty(exports2, "CommandSucceededEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandSucceededEvent;
    } });
    var connection_pool_events_1 = require_connection_pool_events();
    Object.defineProperty(exports2, "ConnectionCheckedInEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckedInEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCheckedOutEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckedOutEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckOutFailedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckOutStartedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionClosedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionClosedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCreatedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCreatedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolClearedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolClearedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolClosedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolClosedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolCreatedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolCreatedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolMonitoringEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolReadyEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolReadyEvent;
    } });
    Object.defineProperty(exports2, "ConnectionReadyEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionReadyEvent;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "ServerClosedEvent", { enumerable: true, get: function() {
      return events_1.ServerClosedEvent;
    } });
    Object.defineProperty(exports2, "ServerDescriptionChangedEvent", { enumerable: true, get: function() {
      return events_1.ServerDescriptionChangedEvent;
    } });
    Object.defineProperty(exports2, "ServerHeartbeatFailedEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatFailedEvent;
    } });
    Object.defineProperty(exports2, "ServerHeartbeatStartedEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatStartedEvent;
    } });
    Object.defineProperty(exports2, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatSucceededEvent;
    } });
    Object.defineProperty(exports2, "ServerOpeningEvent", { enumerable: true, get: function() {
      return events_1.ServerOpeningEvent;
    } });
    Object.defineProperty(exports2, "TopologyClosedEvent", { enumerable: true, get: function() {
      return events_1.TopologyClosedEvent;
    } });
    Object.defineProperty(exports2, "TopologyDescriptionChangedEvent", { enumerable: true, get: function() {
      return events_1.TopologyDescriptionChangedEvent;
    } });
    Object.defineProperty(exports2, "TopologyOpeningEvent", { enumerable: true, get: function() {
      return events_1.TopologyOpeningEvent;
    } });
    var srv_polling_1 = require_srv_polling();
    Object.defineProperty(exports2, "SrvPollingEvent", { enumerable: true, get: function() {
      return srv_polling_1.SrvPollingEvent;
    } });
  }
});

// asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js
var require_binary2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js"(exports2, module2) {
    "use strict";
    var Binary = require_lib3().Binary;
    module2.exports = exports2 = Binary;
  }
});

// asset-input/node_modules/mongoose/lib/connectionstate.js
var require_connectionstate = __commonJS({
  "asset-input/node_modules/mongoose/lib/connectionstate.js"(exports2, module2) {
    "use strict";
    var STATES = module2.exports = exports2 = /* @__PURE__ */ Object.create(null);
    var disconnected = "disconnected";
    var connected = "connected";
    var connecting = "connecting";
    var disconnecting = "disconnecting";
    var uninitialized = "uninitialized";
    STATES[0] = disconnected;
    STATES[1] = connected;
    STATES[2] = connecting;
    STATES[3] = disconnecting;
    STATES[99] = uninitialized;
    STATES[disconnected] = 0;
    STATES[connected] = 1;
    STATES[connecting] = 2;
    STATES[disconnecting] = 3;
    STATES[uninitialized] = 99;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/immediate.js
var require_immediate = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/immediate.js"(exports2, module2) {
    "use strict";
    var nextTick = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : (cb) => setTimeout(cb, 0);
    module2.exports = function immediate(cb) {
      return nextTick(cb);
    };
  }
});

// asset-input/node_modules/mongoose/lib/collection.js
var require_collection2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/collection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    function Collection(name, conn, opts) {
      if (opts === void 0) {
        opts = {};
      }
      this.opts = opts;
      this.name = name;
      this.collectionName = name;
      this.conn = conn;
      this.queue = [];
      this.buffer = true;
      this.emitter = new EventEmitter();
      if (STATES.connected === this.conn.readyState) {
        this.onOpen();
      }
    }
    Collection.prototype.name;
    Collection.prototype.collectionName;
    Collection.prototype.conn;
    Collection.prototype.onOpen = function() {
      this.buffer = false;
      immediate(() => this.doQueue());
    };
    Collection.prototype.onClose = function() {
    };
    Collection.prototype.addQueue = function(name, args) {
      this.queue.push([name, args]);
      return this;
    };
    Collection.prototype.removeQueue = function(name, args) {
      const index = this.queue.findIndex((v) => v[0] === name && v[1] === args);
      if (index === -1) {
        return false;
      }
      this.queue.splice(index, 1);
      return true;
    };
    Collection.prototype.doQueue = function() {
      for (const method of this.queue) {
        if (typeof method[0] === "function") {
          method[0].apply(this, method[1]);
        } else {
          this[method[0]].apply(this, method[1]);
        }
      }
      this.queue = [];
      const _this = this;
      immediate(function() {
        _this.emitter.emit("queue");
      });
      return this;
    };
    Collection.prototype.ensureIndex = function() {
      throw new Error("Collection#ensureIndex unimplemented by driver");
    };
    Collection.prototype.createIndex = function() {
      throw new Error("Collection#createIndex unimplemented by driver");
    };
    Collection.prototype.findAndModify = function() {
      throw new Error("Collection#findAndModify unimplemented by driver");
    };
    Collection.prototype.findOneAndUpdate = function() {
      throw new Error("Collection#findOneAndUpdate unimplemented by driver");
    };
    Collection.prototype.findOneAndDelete = function() {
      throw new Error("Collection#findOneAndDelete unimplemented by driver");
    };
    Collection.prototype.findOneAndReplace = function() {
      throw new Error("Collection#findOneAndReplace unimplemented by driver");
    };
    Collection.prototype.findOne = function() {
      throw new Error("Collection#findOne unimplemented by driver");
    };
    Collection.prototype.find = function() {
      throw new Error("Collection#find unimplemented by driver");
    };
    Collection.prototype.insert = function() {
      throw new Error("Collection#insert unimplemented by driver");
    };
    Collection.prototype.insertOne = function() {
      throw new Error("Collection#insertOne unimplemented by driver");
    };
    Collection.prototype.insertMany = function() {
      throw new Error("Collection#insertMany unimplemented by driver");
    };
    Collection.prototype.save = function() {
      throw new Error("Collection#save unimplemented by driver");
    };
    Collection.prototype.update = function() {
      throw new Error("Collection#update unimplemented by driver");
    };
    Collection.prototype.getIndexes = function() {
      throw new Error("Collection#getIndexes unimplemented by driver");
    };
    Collection.prototype.mapReduce = function() {
      throw new Error("Collection#mapReduce unimplemented by driver");
    };
    Collection.prototype.watch = function() {
      throw new Error("Collection#watch unimplemented by driver");
    };
    Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      const opts = this.opts;
      if (opts.bufferCommands != null) {
        return opts.bufferCommands;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
        return opts.schemaUserProvidedOptions.bufferCommands;
      }
      return this.conn._shouldBufferCommands();
    };
    Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
      const conn = this.conn;
      const opts = this.opts;
      if (opts.bufferTimeoutMS != null) {
        return opts.bufferTimeoutMS;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
        return opts.schemaUserProvidedOptions.bufferTimeoutMS;
      }
      if (conn.config.bufferTimeoutMS != null) {
        return conn.config.bufferTimeoutMS;
      }
      if (conn.base != null && conn.base.get("bufferTimeoutMS") != null) {
        return conn.base.get("bufferTimeoutMS");
      }
      return 1e4;
    };
    module2.exports = Collection;
  }
});

// asset-input/node_modules/mongoose/lib/error/mongooseError.js
var require_mongooseError = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/mongooseError.js"(exports2, module2) {
    "use strict";
    var MongooseError = class extends Error {
    };
    Object.defineProperty(MongooseError.prototype, "name", {
      value: "MongooseError"
    });
    module2.exports = MongooseError;
  }
});

// asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js
var require_objectid2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js"(exports2, module2) {
    "use strict";
    var ObjectId2 = require_lib3().ObjectId;
    module2.exports = exports2 = ObjectId2;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/getConstructorName.js
var require_getConstructorName = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/getConstructorName.js"(exports2, module2) {
    "use strict";
    module2.exports = function getConstructorName(val) {
      if (val == null) {
        return void 0;
      }
      if (typeof val.constructor !== "function") {
        return void 0;
      }
      return val.constructor.name;
    };
  }
});

// asset-input/node_modules/mongoose/lib/types/decimal128.js
var require_decimal1282 = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/decimal128.js"(exports2, module2) {
    "use strict";
    module2.exports = require_driver().get().Decimal128;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/symbols.js
var require_symbols = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/symbols.js"(exports2) {
    "use strict";
    exports2.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup");
    exports2.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
    exports2.arrayParentSymbol = Symbol("mongoose#Array#_parent");
    exports2.arrayPathSymbol = Symbol("mongoose#Array#_path");
    exports2.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
    exports2.documentArrayParent = Symbol("mongoose:documentArrayParent");
    exports2.documentIsSelected = Symbol("mongoose#Document#isSelected");
    exports2.documentIsModified = Symbol("mongoose#Document#isModified");
    exports2.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
    exports2.documentSchemaSymbol = Symbol("mongoose#Document#schema");
    exports2.getSymbol = Symbol("mongoose#Document#get");
    exports2.modelSymbol = Symbol("mongoose#Model");
    exports2.objectIdSymbol = Symbol("mongoose#ObjectId");
    exports2.populateModelSymbol = Symbol("mongoose.PopulateOptions#Model");
    exports2.schemaTypeSymbol = Symbol("mongoose#schemaType");
    exports2.sessionNewDocuments = Symbol("mongoose:ClientSession#newDocuments");
    exports2.scopeSymbol = Symbol("mongoose#Document#scope");
    exports2.validatorErrorSymbol = Symbol("mongoose:validatorError");
  }
});

// asset-input/node_modules/mongoose/lib/types/objectid.js
var require_objectid3 = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/objectid.js"(exports2, module2) {
    "use strict";
    var ObjectId2 = require_driver().get().ObjectId;
    var objectIdSymbol = require_symbols().objectIdSymbol;
    Object.defineProperty(ObjectId2.prototype, "_id", {
      enumerable: false,
      configurable: true,
      get: function() {
        return this;
      }
    });
    if (!ObjectId2.prototype.hasOwnProperty("valueOf")) {
      ObjectId2.prototype.valueOf = function objectIdValueOf() {
        return this.toString();
      };
    }
    ObjectId2.prototype[objectIdSymbol] = true;
    module2.exports = ObjectId2;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/specialProperties.js
var require_specialProperties = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/specialProperties.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
  }
});

// asset-input/node_modules/mongoose/lib/types/array/isMongooseArray.js
var require_isMongooseArray = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/array/isMongooseArray.js"(exports2) {
    "use strict";
    exports2.isMongooseArray = function(mongooseArray) {
      return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/isMongooseObject.js
var require_isMongooseObject = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/isMongooseObject.js"(exports2, module2) {
    "use strict";
    var isMongooseArray = require_isMongooseArray().isMongooseArray;
    module2.exports = function(v) {
      return v != null && (isMongooseArray(v) || // Array or Document Array
      v.$__ != null || // Document
      v.isMongooseBuffer || // Buffer
      v.$isMongooseMap);
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/getFunctionName.js"(exports2, module2) {
    "use strict";
    var functionNameRE = /^function\s*([^\s(]+)/;
    module2.exports = function(fn) {
      return fn.name || (fn.toString().trim().match(functionNameRE) || [])[1];
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/isBsonType.js
var require_isBsonType = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/isBsonType.js"(exports2, module2) {
    "use strict";
    function isBsonType(obj, typename) {
      return typeof obj === "object" && obj !== null && obj._bsontype === typename;
    }
    module2.exports = isBsonType;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/isObject.js
var require_isObject = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/isObject.js"(exports2, module2) {
    "use strict";
    module2.exports = function(arg) {
      return Buffer.isBuffer(arg) || Object.prototype.toString.call(arg) === "[object Object]";
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/trusted.js
var require_trusted = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/trusted.js"(exports2) {
    "use strict";
    var trustedSymbol = Symbol("mongoose#trustedSymbol");
    exports2.trustedSymbol = trustedSymbol;
    exports2.trusted = function trusted(obj) {
      if (obj == null || typeof obj !== "object") {
        return obj;
      }
      obj[trustedSymbol] = true;
      return obj;
    };
  }
});

// asset-input/node_modules/ms/index.js
var require_ms = __commonJS({
  "asset-input/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// asset-input/node_modules/mpath/lib/stringToParts.js
var require_stringToParts = __commonJS({
  "asset-input/node_modules/mpath/lib/stringToParts.js"(exports2, module2) {
    "use strict";
    module2.exports = function stringToParts(str) {
      const result = [];
      let curPropertyName = "";
      let state = "DEFAULT";
      for (let i = 0; i < str.length; ++i) {
        if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
          state = "DEFAULT";
          curPropertyName = result[result.length - 1] + "[" + curPropertyName;
          result.splice(result.length - 1, 1);
        }
        if (str[i] === "[") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "IN_SQUARE_BRACKETS";
        } else if (str[i] === "]") {
          if (state === "IN_SQUARE_BRACKETS") {
            state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
            result.push(curPropertyName);
            curPropertyName = "";
          } else {
            state = "DEFAULT";
            curPropertyName += str[i];
          }
        } else if (str[i] === ".") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "DEFAULT";
        } else {
          curPropertyName += str[i];
        }
      }
      if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
        result.push(curPropertyName);
      }
      return result;
    };
  }
});

// asset-input/node_modules/mpath/lib/index.js
var require_lib4 = __commonJS({
  "asset-input/node_modules/mpath/lib/index.js"(exports2) {
    var stringToParts = require_stringToParts();
    var ignoreProperties = ["__proto__", "constructor", "prototype"];
    exports2.get = function(path, o, special, map) {
      var lookup;
      if ("function" == typeof special) {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = "string" == typeof path ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var obj = o, part;
      for (var i = 0; i < parts.length; ++i) {
        part = parts[i];
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `get()` must be a string or number, got " + typeof parts[i]);
        }
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          return [].concat(obj).map(function(item) {
            return item ? exports2.get(paths, item, special || lookup, map) : map(void 0);
          });
        }
        if (lookup) {
          obj = lookup(obj, part);
        } else {
          var _from = special && obj[special] ? obj[special] : obj;
          obj = _from instanceof Map ? _from.get(part) : _from[part];
        }
        if (!obj) return map(obj);
      }
      return map(obj);
    };
    exports2.has = function(path, o) {
      var parts = typeof path === "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `has()` must be a string or number, got " + typeof parts[i]);
        }
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        cur = cur[parts[i]];
      }
      return true;
    };
    exports2.unset = function(path, o) {
      var parts = typeof path === "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + typeof parts[i]);
        }
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return false;
        }
        if (i === len - 1) {
          delete cur[parts[i]];
          return true;
        }
        cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
      }
      return true;
    };
    exports2.set = function(path, val, o, special, map, _copying) {
      var lookup;
      if ("function" == typeof special) {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = "string" == typeof path ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      if (null == o) return;
      for (var i = 0; i < parts.length; ++i) {
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `set()` must be a string or number, got " + typeof parts[i]);
        }
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return;
        }
      }
      var copy = _copying || /\$/.test(path) && _copying !== false, obj = o, part;
      for (var i = 0, len = parts.length - 1; i < len; ++i) {
        part = parts[i];
        if ("$" == part) {
          if (i == len - 1) {
            break;
          } else {
            continue;
          }
        }
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          if (!copy && Array.isArray(val)) {
            for (var j = 0; j < obj.length && j < val.length; ++j) {
              exports2.set(paths, val[j], obj[j], special || lookup, map, copy);
            }
          } else {
            for (var j = 0; j < obj.length; ++j) {
              exports2.set(paths, val, obj[j], special || lookup, map, copy);
            }
          }
          return;
        }
        if (lookup) {
          obj = lookup(obj, part);
        } else {
          var _to = special && obj[special] ? obj[special] : obj;
          obj = _to instanceof Map ? _to.get(part) : _to[part];
        }
        if (!obj) return;
      }
      part = parts[len];
      if (special && obj[special]) {
        obj = obj[special];
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        if (!copy && Array.isArray(val)) {
          _setArray(obj, val, part, lookup, special, map);
        } else {
          for (var j = 0; j < obj.length; ++j) {
            var item = obj[j];
            if (item) {
              if (lookup) {
                lookup(item, part, map(val));
              } else {
                if (item[special]) item = item[special];
                item[part] = map(val);
              }
            }
          }
        }
      } else {
        if (lookup) {
          lookup(obj, part, map(val));
        } else if (obj instanceof Map) {
          obj.set(part, map(val));
        } else {
          obj[part] = map(val);
        }
      }
    };
    exports2.stringToParts = stringToParts;
    function _setArray(obj, val, part, lookup, special, map) {
      for (var item, j = 0; j < obj.length && j < val.length; ++j) {
        item = obj[j];
        if (Array.isArray(item) && Array.isArray(val[j])) {
          _setArray(item, val[j], part, lookup, special, map);
        } else if (item) {
          if (lookup) {
            lookup(item, part, map(val[j]));
          } else {
            if (item[special]) item = item[special];
            item[part] = map(val[j]);
          }
        }
      }
    }
    function K(v) {
      return v;
    }
  }
});

// asset-input/node_modules/mpath/index.js
var require_mpath = __commonJS({
  "asset-input/node_modules/mpath/index.js"(exports2, module2) {
    "use strict";
    module2.exports = exports2 = require_lib4();
  }
});

// asset-input/node_modules/mongoose/lib/options/PopulateOptions.js
var require_PopulateOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/PopulateOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var PopulateOptions = class {
      constructor(obj) {
        this._docs = {};
        this._childDocs = [];
        if (obj == null) {
          return;
        }
        obj = clone(obj);
        Object.assign(this, obj);
        if (typeof obj.subPopulate === "object") {
          this.populate = obj.subPopulate;
        }
        if (obj.perDocumentLimit != null && obj.limit != null) {
          throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj.path + "`.");
        }
      }
    };
    module2.exports = PopulateOptions;
  }
});

// asset-input/node_modules/mongoose/lib/types/DocumentArray/isMongooseDocumentArray.js
var require_isMongooseDocumentArray = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/DocumentArray/isMongooseDocumentArray.js"(exports2) {
    "use strict";
    exports2.isMongooseDocumentArray = function(mongooseDocumentArray) {
      return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;
    };
  }
});

// asset-input/node_modules/mquery/lib/utils.js
var require_utils5 = __commonJS({
  "asset-input/node_modules/mquery/lib/utils.js"(exports2) {
    "use strict";
    var specialProperties = ["__proto__", "constructor", "prototype"];
    var clone = exports2.clone = function clone2(obj, options) {
      if (obj === void 0 || obj === null)
        return obj;
      if (Array.isArray(obj))
        return exports2.cloneArray(obj, options);
      if (obj.constructor) {
        if (/ObjectI[dD]$/.test(obj.constructor.name)) {
          return "function" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.id);
        }
        if (obj.constructor.name === "ReadPreference") {
          return new obj.constructor(obj.mode, clone2(obj.tags, options));
        }
        if ("Binary" == obj._bsontype && obj.buffer && obj.value) {
          return "function" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);
        }
        if ("Date" === obj.constructor.name || "Function" === obj.constructor.name)
          return new obj.constructor(+obj);
        if ("RegExp" === obj.constructor.name)
          return new RegExp(obj);
        if ("Buffer" === obj.constructor.name)
          return Buffer.from(obj);
      }
      if (isObject(obj))
        return exports2.cloneObject(obj, options);
      if (obj.valueOf)
        return obj.valueOf();
    };
    exports2.cloneObject = function cloneObject(obj, options) {
      const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;
      let hasKeys = false, val, k = "", i = 0;
      for (i = 0; i < len; ++i) {
        k = keys[i];
        if (specialProperties.indexOf(k) !== -1) {
          continue;
        }
        val = clone(obj[k], options);
        if (!minimize || "undefined" !== typeof val) {
          hasKeys || (hasKeys = true);
          ret[k] = val;
        }
      }
      return minimize ? hasKeys && ret : ret;
    };
    exports2.cloneArray = function cloneArray(arr, options) {
      const ret = [], l = arr.length;
      let i = 0;
      for (; i < l; i++)
        ret.push(clone(arr[i], options));
      return ret;
    };
    exports2.tick = function tick(callback) {
      if ("function" !== typeof callback) return;
      return function() {
        const args = arguments;
        soon(function() {
          callback.apply(this, args);
        });
      };
    };
    exports2.merge = function merge(to, from) {
      const keys = Object.keys(from);
      for (const key of keys) {
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if ("undefined" === typeof to[key]) {
          to[key] = from[key];
        } else {
          if (exports2.isObject(from[key])) {
            merge(to[key], from[key]);
          } else {
            to[key] = from[key];
          }
        }
      }
    };
    exports2.mergeClone = function mergeClone(to, from) {
      const keys = Object.keys(from);
      for (const key of keys) {
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if ("undefined" === typeof to[key]) {
          to[key] = clone(from[key]);
        } else {
          if (exports2.isObject(from[key])) {
            mergeClone(to[key], from[key]);
          } else {
            to[key] = clone(from[key]);
          }
        }
      }
    };
    exports2.readPref = function readPref(pref) {
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return pref;
    };
    exports2.readConcern = function readConcern(concern) {
      if ("string" === typeof concern) {
        switch (concern) {
          case "l":
            concern = "local";
            break;
          case "a":
            concern = "available";
            break;
          case "m":
            concern = "majority";
            break;
          case "lz":
            concern = "linearizable";
            break;
          case "s":
            concern = "snapshot";
            break;
        }
        concern = { level: concern };
      }
      return concern;
    };
    var _toString = Object.prototype.toString;
    exports2.toString = function(arg) {
      return _toString.call(arg);
    };
    var isObject = exports2.isObject = function(arg) {
      return "[object Object]" == exports2.toString(arg);
    };
    exports2.keys = Object.keys;
    exports2.create = "function" == typeof Object.create ? Object.create : create;
    function create(proto) {
      if (arguments.length > 1) {
        throw new Error("Adding properties is not supported");
      }
      function F() {
      }
      F.prototype = proto;
      return new F();
    }
    exports2.inherits = function(ctor, superCtor) {
      ctor.prototype = exports2.create(superCtor.prototype);
      ctor.prototype.constructor = ctor;
    };
    var soon = exports2.soon = "function" == typeof setImmediate ? setImmediate : process.nextTick;
    exports2.isArgumentsObject = function(v) {
      return Object.prototype.toString.call(v) === "[object Arguments]";
    };
  }
});

// asset-input/node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "asset-input/node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// asset-input/node_modules/debug/src/common.js
var require_common4 = __commonJS({
  "asset-input/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// asset-input/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "asset-input/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// asset-input/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "asset-input/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// asset-input/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "asset-input/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// asset-input/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "asset-input/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// asset-input/node_modules/debug/src/index.js
var require_src = __commonJS({
  "asset-input/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// asset-input/node_modules/mquery/lib/permissions.js
var require_permissions = __commonJS({
  "asset-input/node_modules/mquery/lib/permissions.js"(exports2) {
    "use strict";
    var denied = exports2;
    denied.distinct = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      const keys = Object.keys(denied.distinct);
      let err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.maxScan = denied.distinct.snapshot = denied.distinct.hint = denied.distinct.tailable = true;
    denied.findOneAndUpdate = denied.findOneAndRemove = function(self2) {
      const keys = Object.keys(denied.findOneAndUpdate);
      let err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.maxScan = denied.findOneAndUpdate.snapshot = denied.findOneAndUpdate.tailable = true;
    denied.count = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      const keys = Object.keys(denied.count);
      let err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.count.slice = denied.count.batchSize = denied.count.maxScan = denied.count.snapshot = denied.count.tailable = true;
  }
});

// asset-input/node_modules/mquery/lib/env.js
var require_env = __commonJS({
  "asset-input/node_modules/mquery/lib/env.js"(exports2, module2) {
    "use strict";
    exports2.isNode = "undefined" != typeof process && "object" == typeof module2 && "object" == typeof global && "function" == typeof Buffer && process.argv;
    exports2.isMongo = !exports2.isNode && "function" == typeof printjson && "function" == typeof ObjectId && "function" == typeof rs && "function" == typeof sh;
    exports2.isBrowser = !exports2.isNode && !exports2.isMongo && "undefined" != typeof window;
    exports2.type = exports2.isNode ? "node" : exports2.isMongo ? "mongo" : exports2.isBrowser ? "browser" : "unknown";
  }
});

// asset-input/node_modules/mquery/lib/collection/collection.js
var require_collection3 = __commonJS({
  "asset-input/node_modules/mquery/lib/collection/collection.js"(exports2, module2) {
    "use strict";
    var methods = [
      "find",
      "findOne",
      "update",
      "updateMany",
      "updateOne",
      "replaceOne",
      "remove",
      "count",
      "distinct",
      "findOneAndDelete",
      "findOneAndUpdate",
      "aggregate",
      "findCursor",
      "deleteOne",
      "deleteMany"
    ];
    function Collection() {
    }
    for (let i = 0, len = methods.length; i < len; ++i) {
      const method = methods[i];
      Collection.prototype[method] = notImplemented(method);
    }
    module2.exports = exports2 = Collection;
    Collection.methods = methods;
    function notImplemented(method) {
      return function() {
        throw new Error("collection." + method + " not implemented");
      };
    }
  }
});

// asset-input/node_modules/mquery/lib/collection/node.js
var require_node3 = __commonJS({
  "asset-input/node_modules/mquery/lib/collection/node.js"(exports2, module2) {
    "use strict";
    var Collection = require_collection3();
    var NodeCollection = class extends Collection {
      constructor(col) {
        super();
        this.collection = col;
        this.collectionName = col.collectionName;
      }
      /**
       * find(match, options, function(err, docs))
       */
      find(match, options, cb) {
        const cursor = this.collection.find(match, options);
        try {
          cursor.toArray(cb);
        } catch (error) {
          cb(error);
        }
      }
      /**
       * findOne(match, options, function(err, doc))
       */
      findOne(match, options, cb) {
        this.collection.findOne(match, options, cb);
      }
      /**
       * count(match, options, function(err, count))
       */
      count(match, options, cb) {
        this.collection.count(match, options, cb);
      }
      /**
       * distinct(prop, match, options, function(err, count))
       */
      distinct(prop, match, options, cb) {
        this.collection.distinct(prop, match, options, cb);
      }
      /**
       * update(match, update, options, function(err[, result]))
       */
      update(match, update, options, cb) {
        this.collection.update(match, update, options, cb);
      }
      /**
       * update(match, update, options, function(err[, result]))
       */
      updateMany(match, update, options, cb) {
        this.collection.updateMany(match, update, options, cb);
      }
      /**
       * update(match, update, options, function(err[, result]))
       */
      updateOne(match, update, options, cb) {
        this.collection.updateOne(match, update, options, cb);
      }
      /**
       * replaceOne(match, update, options, function(err[, result]))
       */
      replaceOne(match, update, options, cb) {
        this.collection.replaceOne(match, update, options, cb);
      }
      /**
       * deleteOne(match, options, function(err[, result])
       */
      deleteOne(match, options, cb) {
        this.collection.deleteOne(match, options, cb);
      }
      /**
       * deleteMany(match, options, function(err[, result])
       */
      deleteMany(match, options, cb) {
        this.collection.deleteMany(match, options, cb);
      }
      /**
       * remove(match, options, function(err[, result])
       */
      remove(match, options, cb) {
        this.collection.remove(match, options, cb);
      }
      /**
       * findOneAndDelete(match, options, function(err[, result])
       */
      findOneAndDelete(match, options, cb) {
        this.collection.findOneAndDelete(match, options, cb);
      }
      /**
       * findOneAndUpdate(match, update, options, function(err[, result])
       */
      findOneAndUpdate(match, update, options, cb) {
        this.collection.findOneAndUpdate(match, update, options, cb);
      }
      /**
       * var cursor = findCursor(match, options)
       */
      findCursor(match, options) {
        return this.collection.find(match, options);
      }
      /**
       * aggregation(operators..., function(err, doc))
       * TODO
       */
    };
    module2.exports = exports2 = NodeCollection;
  }
});

// asset-input/node_modules/mquery/lib/collection/index.js
var require_collection4 = __commonJS({
  "asset-input/node_modules/mquery/lib/collection/index.js"(exports2, module2) {
    "use strict";
    var env = require_env();
    if ("unknown" == env.type) {
      throw new Error("Unknown environment");
    }
    module2.exports = env.isNode ? require_node3() : env.isMongo ? require_collection3() : require_collection3();
  }
});

// asset-input/node_modules/mquery/lib/mquery.js
var require_mquery = __commonJS({
  "asset-input/node_modules/mquery/lib/mquery.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var util2 = require("util");
    var utils = require_utils5();
    var debug = require_src()("mquery");
    function Query(criteria, options) {
      if (!(this instanceof Query))
        return new Query(criteria, options);
      const proto = this.constructor.prototype;
      this.op = proto.op || void 0;
      this.options = Object.assign({}, proto.options);
      this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};
      this._fields = proto._fields ? utils.clone(proto._fields) : void 0;
      this._update = proto._update ? utils.clone(proto._update) : void 0;
      this._path = proto._path || void 0;
      this._distinct = proto._distinct || void 0;
      this._collection = proto._collection || void 0;
      this._traceFunction = proto._traceFunction || void 0;
      if (options) {
        this.setOptions(options);
      }
      if (criteria) {
        if (criteria.find && criteria.remove && criteria.update) {
          this.collection(criteria);
        } else {
          this.find(criteria);
        }
      }
    }
    var $withinCmd = "$geoWithin";
    Object.defineProperty(Query, "use$geoWithin", {
      get: function() {
        return $withinCmd == "$geoWithin";
      },
      set: function(v) {
        if (true === v) {
          $withinCmd = "$geoWithin";
        } else {
          $withinCmd = "$within";
        }
      }
    });
    Query.prototype.toConstructor = function toConstructor() {
      function CustomQuery(criteria, options) {
        if (!(this instanceof CustomQuery))
          return new CustomQuery(criteria, options);
        Query.call(this, criteria, options);
      }
      utils.inherits(CustomQuery, Query);
      const p = CustomQuery.prototype;
      p.options = {};
      p.setOptions(this.options);
      p.op = this.op;
      p._conditions = utils.clone(this._conditions);
      p._fields = utils.clone(this._fields);
      p._update = utils.clone(this._update);
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._traceFunction = this._traceFunction;
      return CustomQuery;
    };
    Query.prototype.setOptions = function(options) {
      if (!(options && utils.isObject(options)))
        return this;
      const methods = utils.keys(options);
      let method;
      for (let i = 0; i < methods.length; ++i) {
        method = methods[i];
        if ("function" == typeof this[method]) {
          const args = Array.isArray(options[method]) ? options[method] : [options[method]];
          this[method].apply(this, args);
        } else {
          this.options[method] = options[method];
        }
      }
      return this;
    };
    Query.prototype.collection = function collection(coll) {
      this._collection = new Query.Collection(coll);
      return this;
    };
    Query.prototype.collation = function(value) {
      this.options.collation = value;
      return this;
    };
    Query.prototype.$where = function(js) {
      this._conditions.$where = js;
      return this;
    };
    Query.prototype.where = function() {
      if (!arguments.length) return this;
      if (!this.op) this.op = "find";
      const type = typeof arguments[0];
      if ("string" == type) {
        this._path = arguments[0];
        if (2 === arguments.length) {
          this._conditions[this._path] = arguments[1];
        }
        return this;
      }
      if ("object" == type && !Array.isArray(arguments[0])) {
        return this.merge(arguments[0]);
      }
      throw new TypeError("path must be a string or object");
    };
    Query.prototype.equals = function equals(val) {
      this._ensurePath("equals");
      const path = this._path;
      this._conditions[path] = val;
      return this;
    };
    Query.prototype.eq = function eq(val) {
      this._ensurePath("eq");
      const path = this._path;
      this._conditions[path] = val;
      return this;
    };
    Query.prototype.or = function or(array) {
      const or2 = this._conditions.$or || (this._conditions.$or = []);
      if (!Array.isArray(array)) array = [array];
      or2.push.apply(or2, array);
      return this;
    };
    Query.prototype.nor = function nor(array) {
      const nor2 = this._conditions.$nor || (this._conditions.$nor = []);
      if (!Array.isArray(array)) array = [array];
      nor2.push.apply(nor2, array);
      return this;
    };
    Query.prototype.and = function and(array) {
      const and2 = this._conditions.$and || (this._conditions.$and = []);
      if (!Array.isArray(array)) array = [array];
      and2.push.apply(and2, array);
      return this;
    };
    "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
      Query.prototype[$conditional] = function() {
        let path, val;
        if (1 === arguments.length) {
          this._ensurePath($conditional);
          val = arguments[0];
          path = this._path;
        } else {
          val = arguments[1];
          path = arguments[0];
        }
        const conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
        conds["$" + $conditional] = val;
        return this;
      };
    });
    Query.prototype.mod = function() {
      let val, path;
      if (1 === arguments.length) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
      } else if (2 === arguments.length && !Array.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = [arguments[0], arguments[1]];
        path = this._path;
      } else if (3 === arguments.length) {
        val = [arguments[1], arguments[2]];
        path = arguments[0];
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.exists = function() {
      let path, val;
      if (0 === arguments.length) {
        this._ensurePath("exists");
        path = this._path;
        val = true;
      } else if (1 === arguments.length) {
        if ("boolean" === typeof arguments[0]) {
          this._ensurePath("exists");
          path = this._path;
          val = arguments[0];
        } else {
          path = arguments[0];
          val = true;
        }
      } else if (2 === arguments.length) {
        path = arguments[0];
        val = arguments[1];
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$exists = val;
      return this;
    };
    Query.prototype.elemMatch = function() {
      if (null == arguments[0])
        throw new TypeError("Invalid argument");
      let fn, path, criteria;
      if ("function" === typeof arguments[0]) {
        this._ensurePath("elemMatch");
        path = this._path;
        fn = arguments[0];
      } else if (utils.isObject(arguments[0])) {
        this._ensurePath("elemMatch");
        path = this._path;
        criteria = arguments[0];
      } else if ("function" === typeof arguments[1]) {
        path = arguments[0];
        fn = arguments[1];
      } else if (arguments[1] && utils.isObject(arguments[1])) {
        path = arguments[0];
        criteria = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (fn) {
        criteria = new Query();
        fn(criteria);
        criteria = criteria._conditions;
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$elemMatch = criteria;
      return this;
    };
    Query.prototype.within = function within() {
      this._ensurePath("within");
      this._geoComparison = $withinCmd;
      if (0 === arguments.length) {
        return this;
      }
      if (2 === arguments.length) {
        return this.box.apply(this, arguments);
      } else if (2 < arguments.length) {
        return this.polygon.apply(this, arguments);
      }
      const area = arguments[0];
      if (!area)
        throw new TypeError("Invalid argument");
      if (area.center)
        return this.circle(area);
      if (area.box)
        return this.box.apply(this, area.box);
      if (area.polygon)
        return this.polygon.apply(this, area.polygon);
      if (area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.box = function() {
      let path, box;
      if (3 === arguments.length) {
        path = arguments[0];
        box = [arguments[1], arguments[2]];
      } else if (2 === arguments.length) {
        this._ensurePath("box");
        path = this._path;
        box = [arguments[0], arguments[1]];
      } else {
        throw new TypeError("Invalid argument");
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison || $withinCmd] = { $box: box };
      return this;
    };
    Query.prototype.polygon = function() {
      let val, path;
      if ("string" == typeof arguments[0]) {
        val = Array.from(arguments);
        path = val.shift();
      } else {
        this._ensurePath("polygon");
        path = this._path;
        val = Array.from(arguments);
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison || $withinCmd] = { $polygon: val };
      return this;
    };
    Query.prototype.circle = function() {
      let path, val;
      if (1 === arguments.length) {
        this._ensurePath("circle");
        path = this._path;
        val = arguments[0];
      } else if (2 === arguments.length) {
        path = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!("radius" in val && val.center))
        throw new Error("center and radius are required");
      const conds = this._conditions[path] || (this._conditions[path] = {});
      const type = val.spherical ? "$centerSphere" : "$center";
      const wKey = this._geoComparison || $withinCmd;
      conds[wKey] = {};
      conds[wKey][type] = [val.center, val.radius];
      if ("unique" in val)
        conds[wKey].$uniqueDocs = !!val.unique;
      return this;
    };
    Query.prototype.near = function near() {
      let path, val;
      this._geoComparison = "$near";
      if (0 === arguments.length) {
        return this;
      } else if (1 === arguments.length) {
        this._ensurePath("near");
        path = this._path;
        val = arguments[0];
      } else if (2 === arguments.length) {
        path = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!val.center) {
        throw new Error("center is required");
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      const type = val.spherical ? "$nearSphere" : "$near";
      if (Array.isArray(val.center)) {
        conds[type] = val.center;
        const radius = "maxDistance" in val ? val.maxDistance : null;
        if (null != radius) {
          conds.$maxDistance = radius;
        }
        if (null != val.minDistance) {
          conds.$minDistance = val.minDistance;
        }
      } else {
        if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
          throw new Error(util2.format("Invalid GeoJSON specified for %s", type));
        }
        conds[type] = { $geometry: val.center };
        if ("maxDistance" in val) {
          conds[type]["$maxDistance"] = val.maxDistance;
        }
        if ("minDistance" in val) {
          conds[type]["$minDistance"] = val.minDistance;
        }
      }
      return this;
    };
    Query.prototype.intersects = function intersects() {
      this._ensurePath("intersects");
      this._geoComparison = "$geoIntersects";
      if (0 === arguments.length) {
        return this;
      }
      const area = arguments[0];
      if (null != area && area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.geometry = function geometry() {
      if (!("$within" == this._geoComparison || "$geoWithin" == this._geoComparison || "$near" == this._geoComparison || "$geoIntersects" == this._geoComparison)) {
        throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
      }
      let val, path;
      if (1 === arguments.length) {
        this._ensurePath("geometry");
        path = this._path;
        val = arguments[0];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!(val.type && Array.isArray(val.coordinates))) {
        throw new TypeError("Invalid argument");
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison] = { $geometry: val };
      return this;
    };
    Query.prototype.select = function select() {
      let arg = arguments[0];
      if (!arg) return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      const fields = this._fields || (this._fields = {});
      const type = typeof arg;
      let i, len;
      if (("string" == type || utils.isArgumentsObject(arg)) && "number" == typeof arg.length || Array.isArray(arg)) {
        if ("string" == type)
          arg = arg.split(/\s+/);
        for (i = 0, len = arg.length; i < len; ++i) {
          let field = arg[i];
          if (!field) continue;
          const include = "-" == field[0] ? 0 : 1;
          if (include === 0) field = field.substring(1);
          fields[field] = include;
        }
        return this;
      }
      if (utils.isObject(arg)) {
        const keys = utils.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          fields[keys[i]] = arg[keys[i]];
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.slice = function() {
      if (0 === arguments.length)
        return this;
      this._validate("slice");
      let path, val;
      if (1 === arguments.length) {
        const arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          const keys = Object.keys(arg);
          const numKeys = keys.length;
          for (let i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
      } else if (2 === arguments.length) {
        if ("number" === typeof arguments[0]) {
          this._ensurePath("slice");
          path = this._path;
          val = [arguments[0], arguments[1]];
        } else {
          path = arguments[0];
          val = arguments[1];
        }
      } else if (3 === arguments.length) {
        path = arguments[0];
        val = [arguments[1], arguments[2]];
      }
      const myFields = this._fields || (this._fields = {});
      myFields[path] = { $slice: val };
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (!arg) return this;
      let i, len, field;
      this._validate("sort");
      const type = typeof arg;
      if (Array.isArray(arg)) {
        len = arg.length;
        for (i = 0; i < arg.length; ++i) {
          if (!Array.isArray(arg[i])) {
            throw new Error("Invalid sort() argument, must be array of arrays");
          }
          _pushArr(this.options, arg[i][0], arg[i][1]);
        }
        return this;
      }
      if (1 === arguments.length && "string" == type) {
        arg = arg.split(/\s+/);
        len = arg.length;
        for (i = 0; i < len; ++i) {
          field = arg[i];
          if (!field) continue;
          const ascend = "-" == field[0] ? -1 : 1;
          if (ascend === -1) field = field.substring(1);
          push(this.options, field, ascend);
        }
        return this;
      }
      if (utils.isObject(arg)) {
        const keys = utils.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          field = keys[i];
          push(this.options, field, arg[field]);
        }
        return this;
      }
      if (typeof Map !== "undefined" && arg instanceof Map) {
        _pushMap(this.options, arg);
        return this;
      }
      throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
    };
    var _validSortValue = {
      1: 1,
      "-1": -1,
      asc: 1,
      ascending: 1,
      desc: -1,
      descending: -1
    };
    function push(opts, field, value) {
      if (Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      let s;
      if (value && value.$meta) {
        s = opts.sort || (opts.sort = {});
        s[field] = { $meta: value.$meta };
        return;
      }
      s = opts.sort || (opts.sort = {});
      let val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val) throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
      s[field] = val;
    }
    function _pushArr(opts, field, value) {
      opts.sort = opts.sort || [];
      if (!Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      let val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val) throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
      opts.sort.push([field, val]);
    }
    function _pushMap(opts, map) {
      opts.sort = opts.sort || /* @__PURE__ */ new Map();
      if (!(opts.sort instanceof Map)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object or map consistently");
      }
      map.forEach(function(value, key) {
        let val = String(value || 1).toLowerCase();
        val = _validSortValue[val];
        if (!val) throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
        opts.sort.set(key, val);
      });
    }
    ["limit", "skip", "maxScan", "batchSize", "comment"].forEach(function(method) {
      Query.prototype[method] = function(v) {
        this._validate(method);
        this.options[method] = v;
        return this;
      };
    });
    Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
      this._validate("maxTime");
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.snapshot = function() {
      this._validate("snapshot");
      this.options.snapshot = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.hint = function() {
      if (0 === arguments.length) return this;
      this._validate("hint");
      const arg = arguments[0];
      if (utils.isObject(arg)) {
        const hint = this.options.hint || (this.options.hint = {});
        for (const k in arg) {
          hint[k] = arg[k];
        }
        return this;
      }
      if (typeof arg === "string") {
        this.options.hint = arg;
        return this;
      }
      throw new TypeError("Invalid hint. " + arg);
    };
    Query.prototype.j = function j(val) {
      this.options.j = val;
      return this;
    };
    Query.prototype.slaveOk = function(v) {
      this.options.slaveOk = arguments.length ? !!v : true;
      return this;
    };
    Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
      if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
        console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
        Query.prototype.read.deprecationWarningIssued = true;
      }
      this.options.readPreference = utils.readPref(pref);
      return this;
    };
    Query.prototype.readConcern = Query.prototype.r = function(level) {
      this.options.readConcern = utils.readConcern(level);
      return this;
    };
    Query.prototype.tailable = function() {
      this._validate("tailable");
      this.options.tailable = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
      if ("object" === typeof concern) {
        if ("undefined" !== typeof concern.j) this.options.j = concern.j;
        if ("undefined" !== typeof concern.w) this.options.w = concern.w;
        if ("undefined" !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;
      } else {
        this.options.w = "m" === concern ? "majority" : concern;
      }
      return this;
    };
    Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
      this.options.wtimeout = ms;
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source)
        return this;
      if (!Query.canMerge(source))
        throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
      if (source instanceof Query) {
        if (source._conditions) {
          utils.merge(this._conditions, source._conditions);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils.merge(this._fields, source._fields);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils.merge(this.options, source.options);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        return this;
      }
      utils.merge(this._conditions, source);
      return this;
    };
    Query.prototype.find = function(criteria, callback) {
      this.op = "find";
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback) return this;
      const conds = this._conditions;
      const options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("find", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("find", callback, {
        conditions: conds,
        options
      });
      this._collection.find(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.cursor = function cursor(criteria) {
      if (this.op) {
        if (this.op !== "find") {
          throw new TypeError(".cursor only support .find method");
        }
      } else {
        this.find(criteria);
      }
      const conds = this._conditions;
      const options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("findCursor", this._collection.collectionName, conds, options);
      return this._collection.findCursor(conds, options);
    };
    Query.prototype.findOne = function(criteria, callback) {
      this.op = "findOne";
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback) return this;
      const conds = this._conditions;
      const options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("findOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("findOne", callback, {
        conditions: conds,
        options
      });
      this._collection.findOne(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.count = function(criteria, callback) {
      this.op = "count";
      this._validate();
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback) return this;
      const conds = this._conditions, options = this._optionsForExec();
      debug("count", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("count", callback, {
        conditions: conds,
        options
      });
      this._collection.count(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.distinct = function(criteria, field, callback) {
      this.op = "distinct";
      this._validate();
      if (!callback) {
        switch (typeof field) {
          case "function":
            callback = field;
            if ("string" == typeof criteria) {
              field = criteria;
              criteria = void 0;
            }
            break;
          case "undefined":
          case "string":
            break;
          default:
            throw new TypeError("Invalid `field` argument. Must be string or function");
        }
        switch (typeof criteria) {
          case "function":
            callback = criteria;
            criteria = field = void 0;
            break;
          case "string":
            field = criteria;
            criteria = void 0;
            break;
        }
      }
      if ("string" == typeof field) {
        this._distinct = field;
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback) {
        return this;
      }
      if (!this._distinct) {
        throw new Error("No value for `distinct` has been declared");
      }
      const conds = this._conditions, options = this._optionsForExec();
      debug("distinct", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("distinct", callback, {
        conditions: conds,
        options
      });
      this._collection.distinct(this._distinct, conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.update = function update(criteria, doc, options, callback) {
      let force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "update", criteria, doc, options, force, callback);
    };
    Query.prototype.updateMany = function updateMany(criteria, doc, options, callback) {
      let force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "updateMany", criteria, doc, options, force, callback);
    };
    Query.prototype.updateOne = function updateOne(criteria, doc, options, callback) {
      let force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "updateOne", criteria, doc, options, force, callback);
    };
    Query.prototype.replaceOne = function replaceOne(criteria, doc, options, callback) {
      let force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", criteria, doc, options, force, callback);
    };
    function _update(query, op, criteria, doc, options, force, callback) {
      query.op = op;
      if (Query.canMerge(criteria)) {
        query.merge(criteria);
      }
      if (doc) {
        query._mergeUpdate(doc);
      }
      if (utils.isObject(options)) {
        query.setOptions(options);
      }
      if (!(force || callback)) {
        return query;
      }
      if (!query._update || !query.options.overwrite && 0 === utils.keys(query._update).length) {
        callback && utils.soon(callback.bind(null, null, 0));
        return query;
      }
      options = query._optionsForExec();
      if (!callback) options.safe = false;
      criteria = query._conditions;
      doc = query._updateForExec();
      debug("update", query._collection.collectionName, criteria, doc, options);
      callback = query._wrapCallback(op, callback, {
        conditions: criteria,
        doc,
        options
      });
      query._collection[op](criteria, doc, options, utils.tick(callback));
      return query;
    }
    Query.prototype.remove = function(criteria, callback) {
      this.op = "remove";
      let force;
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (true === criteria) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      const options = this._optionsForExec();
      if (!callback) options.safe = false;
      const conds = this._conditions;
      debug("remove", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("remove", callback, {
        conditions: conds,
        options
      });
      this._collection.remove(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.deleteOne = function(criteria, callback) {
      this.op = "deleteOne";
      let force;
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (true === criteria) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      const options = this._optionsForExec();
      if (!callback) options.safe = false;
      delete options.justOne;
      const conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options
      });
      this._collection.deleteOne(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.deleteMany = function(criteria, callback) {
      this.op = "deleteMany";
      let force;
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (true === criteria) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      const options = this._optionsForExec();
      if (!callback) options.safe = false;
      delete options.justOne;
      const conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options
      });
      this._collection.deleteMany(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
      this.op = "findOneAndUpdate";
      this._validate();
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = {};
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          options = void 0;
          break;
        case 1:
          if ("function" == typeof criteria) {
            callback = criteria;
            criteria = options = doc = void 0;
          } else {
            doc = criteria;
            criteria = options = void 0;
          }
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options && this.setOptions(options);
      if (!callback) return this;
      const conds = this._conditions;
      const update = this._updateForExec();
      options = this._optionsForExec();
      return this._collection.findOneAndUpdate(conds, update, options, utils.tick(callback));
    };
    Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options, callback) {
      this.op = "findOneAndRemove";
      this._validate();
      if ("function" == typeof options) {
        callback = options;
        options = void 0;
      } else if ("function" == typeof conditions) {
        callback = conditions;
        conditions = void 0;
      }
      if (Query.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback) return this;
      options = this._optionsForExec();
      const conds = this._conditions;
      return this._collection.findOneAndDelete(conds, options, utils.tick(callback));
    };
    Query.prototype._wrapCallback = function(method, callback, queryInfo) {
      const traceFunction = this._traceFunction || Query.traceFunction;
      if (traceFunction) {
        queryInfo.collectionName = this._collection.collectionName;
        const traceCallback = traceFunction && traceFunction.call(null, method, queryInfo, this);
        const startTime = (/* @__PURE__ */ new Date()).getTime();
        return function wrapperCallback(err, result) {
          if (traceCallback) {
            const millis = (/* @__PURE__ */ new Date()).getTime() - startTime;
            traceCallback.call(null, err, result, millis);
          }
          if (callback) {
            callback.apply(null, arguments);
          }
        };
      }
      return callback;
    };
    Query.prototype.setTraceFunction = function(traceFunction) {
      this._traceFunction = traceFunction;
      return this;
    };
    Query.prototype.exec = function exec(op, callback) {
      switch (typeof op) {
        case "function":
          callback = op;
          op = null;
          break;
        case "string":
          this.op = op;
          break;
      }
      assert.ok(this.op, "Missing query type: (find, update, etc)");
      if ("update" == this.op || "remove" == this.op) {
        callback || (callback = true);
      }
      const _this = this;
      if ("function" == typeof callback) {
        this[this.op](callback);
      } else {
        return new Query.Promise(function(success, error) {
          _this[_this.op](function(err, val) {
            if (err) error(err);
            else success(val);
            success = error = null;
          });
        });
      }
    };
    Query.prototype.thunk = function() {
      const _this = this;
      return function(cb) {
        _this.exec(cb);
      };
    };
    Query.prototype.then = function(resolve, reject) {
      const _this = this;
      const promise = new Query.Promise(function(success, error) {
        _this.exec(function(err, val) {
          if (err) error(err);
          else success(val);
          success = error = null;
        });
      });
      return promise.then(resolve, reject);
    };
    Query.prototype.cursor = function() {
      if ("find" != this.op)
        throw new Error("cursor() is only available for find");
      const conds = this._conditions;
      const options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("cursor", this._collection.collectionName, conds, options);
      return this._collection.findCursor(conds, options);
    };
    Query.prototype.selected = function selected() {
      return !!(this._fields && Object.keys(this._fields).length > 0);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      if (!this._fields) return false;
      const keys = Object.keys(this._fields);
      if (0 === keys.length) return false;
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (0 === this._fields[key]) return false;
        if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
          return false;
        }
      }
      return true;
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      if (!this._fields) return false;
      const keys = Object.keys(this._fields);
      if (0 === keys.length) return false;
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (0 === this._fields[key]) return true;
      }
      return false;
    };
    Query.prototype._mergeUpdate = function(doc) {
      if (!this._update) this._update = {};
      if (doc instanceof Query) {
        if (doc._update) {
          utils.mergeClone(this._update, doc._update);
        }
      } else {
        utils.mergeClone(this._update, doc);
      }
    };
    Query.prototype._optionsForExec = function() {
      const options = utils.clone(this.options);
      return options;
    };
    Query.prototype._fieldsForExec = function() {
      return utils.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      const update = utils.clone(this._update);
      const ops = utils.keys(update);
      const ret = {};
      for (const op of ops) {
        if (this.options.overwrite) {
          ret[op] = update[op];
          continue;
        }
        if ("$" !== op[0]) {
          if (!ret.$set) {
            if (update.$set) {
              ret.$set = update.$set;
            } else {
              ret.$set = {};
            }
          }
          ret.$set[op] = update[op];
          if (!~ops.indexOf("$set")) ops.push("$set");
        } else if ("$set" === op) {
          if (!ret.$set) {
            ret[op] = update[op];
          }
        } else {
          ret[op] = update[op];
        }
      }
      this._compiledUpdate = ret;
      return ret;
    };
    Query.prototype._ensurePath = function(method) {
      if (!this._path) {
        const msg = method + "() must be used after where() when called with these arguments";
        throw new Error(msg);
      }
    };
    Query.permissions = require_permissions();
    Query._isPermitted = function(a, b) {
      const denied = Query.permissions[b];
      if (!denied) return true;
      return true !== denied[a];
    };
    Query.prototype._validate = function(action) {
      let fail;
      let validator;
      if (void 0 === action) {
        validator = Query.permissions[this.op];
        if ("function" != typeof validator) return true;
        fail = validator(this);
      } else if (!Query._isPermitted(action, this.op)) {
        fail = action;
      }
      if (fail) {
        throw new Error(fail + " cannot be used with " + this.op);
      }
    };
    Query.canMerge = function(conds) {
      return conds instanceof Query || utils.isObject(conds);
    };
    Query.setGlobalTraceFunction = function(traceFunction) {
      Query.traceFunction = traceFunction;
    };
    Query.utils = utils;
    Query.env = require_env();
    Query.Collection = require_collection4();
    Query.BaseCollection = require_collection3();
    Query.Promise = Promise;
    module2.exports = exports2 = Query;
  }
});

// asset-input/node_modules/mongoose/lib/promise_provider.js
var require_promise_provider2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/promise_provider.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var mquery = require_mquery();
    var store = {
      _promise: null
    };
    store.get = function() {
      return store._promise;
    };
    store.set = function(lib) {
      assert.ok(
        typeof lib === "function",
        `mongoose.Promise must be a function, got ${lib}`
      );
      store._promise = lib;
      mquery.Promise = lib;
    };
    store.set(global.Promise);
    module2.exports = store;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/promiseOrCallback.js
var require_promiseOrCallback = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/promiseOrCallback.js"(exports2, module2) {
    "use strict";
    var PromiseProvider = require_promise_provider2();
    var immediate = require_immediate();
    var emittedSymbol = Symbol("mongoose:emitted");
    module2.exports = function promiseOrCallback(callback, fn, ee, Promise2) {
      if (typeof callback === "function") {
        try {
          return fn(function(error) {
            if (error != null) {
              if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
                error[emittedSymbol] = true;
                ee.emit("error", error);
              }
              try {
                callback(error);
              } catch (error2) {
                return immediate(() => {
                  throw error2;
                });
              }
              return;
            }
            callback.apply(this, arguments);
          });
        } catch (error) {
          if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
            error[emittedSymbol] = true;
            ee.emit("error", error);
          }
          return callback(error);
        }
      }
      Promise2 = Promise2 || PromiseProvider.get();
      return new Promise2((resolve, reject) => {
        fn(function(error, res) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            return reject(error);
          }
          if (arguments.length > 2) {
            return resolve(Array.prototype.slice.call(arguments, 1));
          }
          resolve(res);
        });
      });
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/merge.js
var require_merge = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/merge.js"(exports2, module2) {
    "use strict";
    module2.exports = function merge(s1, s2, skipConflictingPaths) {
      const paths = Object.keys(s2.tree);
      const pathsToAdd = {};
      for (const key of paths) {
        if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
          continue;
        }
        pathsToAdd[key] = s2.tree[key];
      }
      s1.add(pathsToAdd);
      s1.callQueue = s1.callQueue.concat(s2.callQueue);
      s1.method(s2.methods);
      s1.static(s2.statics);
      for (const query in s2.query) {
        s1.query[query] = s2.query[query];
      }
      for (const virtual in s2.virtuals) {
        s1.virtuals[virtual] = s2.virtuals[virtual].clone();
      }
      s1._indexes = s1._indexes.concat(s2._indexes || []);
      s1.s.hooks.merge(s2.s.hooks, false);
    };
  }
});

// asset-input/node_modules/mongoose/lib/statemachine.js
var require_statemachine = __commonJS({
  "asset-input/node_modules/mongoose/lib/statemachine.js"(exports2, module2) {
    "use strict";
    var utils = require_utils6();
    var StateMachine = module2.exports = exports2 = function StateMachine2() {
    };
    StateMachine.ctor = function() {
      const states = [...arguments];
      const ctor = function() {
        StateMachine.apply(this, arguments);
        this.paths = {};
        this.states = {};
      };
      ctor.prototype = new StateMachine();
      ctor.prototype.stateNames = states;
      states.forEach(function(state) {
        ctor.prototype[state] = function(path) {
          this._changeState(path, state);
        };
      });
      return ctor;
    };
    StateMachine.prototype._changeState = function _changeState(path, nextState) {
      const prevBucket = this.states[this.paths[path]];
      if (prevBucket) delete prevBucket[path];
      this.paths[path] = nextState;
      this.states[nextState] = this.states[nextState] || {};
      this.states[nextState][path] = true;
    };
    StateMachine.prototype.clear = function clear(state) {
      if (this.states[state] == null) {
        return;
      }
      const keys = Object.keys(this.states[state]);
      let i = keys.length;
      let path;
      while (i--) {
        path = keys[i];
        delete this.states[state][path];
        delete this.paths[path];
      }
    };
    StateMachine.prototype.clearPath = function clearPath(path) {
      const state = this.paths[path];
      if (!state) {
        return;
      }
      delete this.paths[path];
      delete this.states[state][path];
    };
    StateMachine.prototype.getStatePaths = function getStatePaths(state) {
      if (this.states[state] != null) {
        return this.states[state];
      }
      return {};
    };
    StateMachine.prototype.some = function some() {
      const _this = this;
      const what = arguments.length ? arguments : this.stateNames;
      return Array.prototype.some.call(what, function(state) {
        if (_this.states[state] == null) {
          return false;
        }
        return Object.keys(_this.states[state]).length;
      });
    };
    StateMachine.prototype._iter = function _iter(iterMethod) {
      return function() {
        let states = [...arguments];
        const callback = states.pop();
        if (!states.length) states = this.stateNames;
        const _this = this;
        const paths = states.reduce(function(paths2, state) {
          if (_this.states[state] == null) {
            return paths2;
          }
          return paths2.concat(Object.keys(_this.states[state]));
        }, []);
        return paths[iterMethod](function(path, i, paths2) {
          return callback(path, i, paths2);
        });
      };
    };
    StateMachine.prototype.forEach = function forEach() {
      this.forEach = this._iter("forEach");
      return this.forEach.apply(this, arguments);
    };
    StateMachine.prototype.map = function map() {
      this.map = this._iter("map");
      return this.map.apply(this, arguments);
    };
  }
});

// asset-input/node_modules/mongoose/lib/internal.js
var require_internal = __commonJS({
  "asset-input/node_modules/mongoose/lib/internal.js"(exports2, module2) {
    "use strict";
    var StateMachine = require_statemachine();
    var ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
    module2.exports = exports2 = InternalCache;
    function InternalCache() {
      this.activePaths = new ActiveRoster();
    }
    InternalCache.prototype.strictMode = true;
    InternalCache.prototype.fullPath = void 0;
    InternalCache.prototype.selected = void 0;
    InternalCache.prototype.shardval = void 0;
    InternalCache.prototype.saveError = void 0;
    InternalCache.prototype.validationError = void 0;
    InternalCache.prototype.adhocPaths = void 0;
    InternalCache.prototype.removing = void 0;
    InternalCache.prototype.inserting = void 0;
    InternalCache.prototype.saving = void 0;
    InternalCache.prototype.version = void 0;
    InternalCache.prototype._id = void 0;
    InternalCache.prototype.ownerDocument = void 0;
    InternalCache.prototype.populate = void 0;
    InternalCache.prototype.populated = void 0;
    InternalCache.prototype.primitiveAtomics = void 0;
    InternalCache.prototype.wasPopulated = false;
    InternalCache.prototype.scope = void 0;
    InternalCache.prototype.session = null;
    InternalCache.prototype.pathsToScopes = null;
    InternalCache.prototype.cachedRequired = null;
  }
});

// asset-input/node_modules/mongoose/lib/error/messages.js
var require_messages = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/messages.js"(exports2, module2) {
    "use strict";
    var msg = module2.exports = exports2 = {};
    msg.DocumentNotFoundError = null;
    msg.general = {};
    msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
    msg.general.required = "Path `{PATH}` is required.";
    msg.Number = {};
    msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
    msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
    msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.Date = {};
    msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
    msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
    msg.String = {};
    msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
    msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
    msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
  }
});

// asset-input/node_modules/mongoose/lib/error/notFound.js
var require_notFound = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/notFound.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var util2 = require("util");
    var DocumentNotFoundError = class extends MongooseError {
      /**
       * OverwriteModel Error constructor.
       * @api private
       */
      constructor(filter, model, numAffected, result) {
        let msg;
        const messages = MongooseError.messages;
        if (messages.DocumentNotFoundError != null) {
          msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model) : messages.DocumentNotFoundError;
        } else {
          msg = 'No document found for query "' + util2.inspect(filter) + '" on model "' + model + '"';
        }
        super(msg);
        this.result = result;
        this.numAffected = numAffected;
        this.filter = filter;
        this.query = filter;
      }
    };
    Object.defineProperty(DocumentNotFoundError.prototype, "name", {
      value: "DocumentNotFoundError"
    });
    module2.exports = DocumentNotFoundError;
  }
});

// asset-input/node_modules/mongoose/lib/error/cast.js
var require_cast = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/cast.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var util2 = require("util");
    var CastError = class extends MongooseError {
      constructor(type, value, path, reason, schemaType) {
        if (arguments.length > 0) {
          const stringValue = getStringValue(value);
          const valueType = getValueType(value);
          const messageFormat = getMessageFormat(schemaType);
          const msg = formatMessage(null, type, stringValue, path, messageFormat, valueType, reason);
          super(msg);
          this.init(type, value, path, reason, schemaType);
        } else {
          super(formatMessage());
        }
      }
      toJSON() {
        return {
          stringValue: this.stringValue,
          valueType: this.valueType,
          kind: this.kind,
          value: this.value,
          path: this.path,
          reason: this.reason,
          name: this.name,
          message: this.message
        };
      }
      /*!
       * ignore
       */
      init(type, value, path, reason, schemaType) {
        this.stringValue = getStringValue(value);
        this.messageFormat = getMessageFormat(schemaType);
        this.kind = type;
        this.value = value;
        this.path = path;
        this.reason = reason;
        this.valueType = getValueType(value);
      }
      /**
       * ignore
       * @param {Readonly<CastError>} other
       * @api private
       */
      copy(other) {
        this.messageFormat = other.messageFormat;
        this.stringValue = other.stringValue;
        this.kind = other.kind;
        this.value = other.value;
        this.path = other.path;
        this.reason = other.reason;
        this.message = other.message;
        this.valueType = other.valueType;
      }
      /*!
       * ignore
       */
      setModel(model) {
        this.model = model;
        this.message = formatMessage(
          model,
          this.kind,
          this.stringValue,
          this.path,
          this.messageFormat,
          this.valueType
        );
      }
    };
    Object.defineProperty(CastError.prototype, "name", {
      value: "CastError"
    });
    function getStringValue(value) {
      let stringValue = util2.inspect(value);
      stringValue = stringValue.replace(/^'|'$/g, '"');
      if (!stringValue.startsWith('"')) {
        stringValue = '"' + stringValue + '"';
      }
      return stringValue;
    }
    function getValueType(value) {
      if (value == null) {
        return "" + value;
      }
      const t = typeof value;
      if (t !== "object") {
        return t;
      }
      if (typeof value.constructor !== "function") {
        return t;
      }
      return value.constructor.name;
    }
    function getMessageFormat(schemaType) {
      const messageFormat = schemaType && schemaType.options && schemaType.options.cast || null;
      if (typeof messageFormat === "string") {
        return messageFormat;
      }
    }
    function formatMessage(model, kind, stringValue, path, messageFormat, valueType, reason) {
      if (messageFormat != null) {
        let ret = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path);
        if (model != null) {
          ret = ret.replace("{MODEL}", model.modelName);
        }
        return ret;
      } else {
        const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
        let ret = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path + '"';
        if (model != null) {
          ret += ' for model "' + model.modelName + '"';
        }
        if (reason != null && typeof reason.constructor === "function" && reason.constructor.name !== "AssertionError" && reason.constructor.name !== "Error") {
          ret += ' because of "' + reason.constructor.name + '"';
        }
        return ret;
      }
    }
    module2.exports = CastError;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/error/combinePathErrors.js
var require_combinePathErrors = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/error/combinePathErrors.js"(exports2, module2) {
    "use strict";
    module2.exports = function combinePathErrors(err) {
      const keys = Object.keys(err.errors || {});
      const len = keys.length;
      const msgs = [];
      let key;
      for (let i = 0; i < len; ++i) {
        key = keys[i];
        if (err === err.errors[key]) {
          continue;
        }
        msgs.push(key + ": " + err.errors[key].message);
      }
      return msgs.join(", ");
    };
  }
});

// asset-input/node_modules/mongoose/lib/error/validation.js
var require_validation = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/validation.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var getConstructorName = require_getConstructorName();
    var util2 = require("util");
    var combinePathErrors = require_combinePathErrors();
    var ValidationError2 = class _ValidationError extends MongooseError {
      /**
       * Document Validation Error
       *
       * @api private
       * @param {Document} [instance]
       * @inherits MongooseError
       */
      constructor(instance) {
        let _message;
        if (getConstructorName(instance) === "model") {
          _message = instance.constructor.modelName + " validation failed";
        } else {
          _message = "Validation failed";
        }
        super(_message);
        this.errors = {};
        this._message = _message;
        if (instance) {
          instance.$errors = this.errors;
        }
      }
      /**
       * Console.log helper
       */
      toString() {
        return this.name + ": " + combinePathErrors(this);
      }
      /**
       * inspect helper
       * @api private
       */
      inspect() {
        return Object.assign(new Error(this.message), this);
      }
      /**
      * add message
      * @param {String} path
      * @param {String|Error} error
      * @api private
      */
      addError(path, error) {
        if (error instanceof _ValidationError) {
          const { errors } = error;
          for (const errorPath of Object.keys(errors)) {
            this.addError(`${path}.${errorPath}`, errors[errorPath]);
          }
          return;
        }
        this.errors[path] = error;
        this.message = this._message + ": " + combinePathErrors(this);
      }
    };
    if (util2.inspect.custom) {
      ValidationError2.prototype[util2.inspect.custom] = ValidationError2.prototype.inspect;
    }
    Object.defineProperty(ValidationError2.prototype, "toJSON", {
      enumerable: false,
      writable: false,
      configurable: true,
      value: function() {
        return Object.assign({}, this, { name: this.name, message: this.message });
      }
    });
    Object.defineProperty(ValidationError2.prototype, "name", {
      value: "ValidationError"
    });
    module2.exports = ValidationError2;
  }
});

// asset-input/node_modules/mongoose/lib/error/validator.js
var require_validator = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/validator.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ValidatorError = class extends MongooseError {
      /**
       * Schema validator error
       *
       * @param {Object} properties
       * @param {Document} doc
       * @api private
       */
      constructor(properties, doc) {
        let msg = properties.message;
        if (!msg) {
          msg = MongooseError.messages.general.default;
        }
        const message = formatMessage(msg, properties, doc);
        super(message);
        properties = Object.assign({}, properties, { message });
        this.properties = properties;
        this.kind = properties.type;
        this.path = properties.path;
        this.value = properties.value;
        this.reason = properties.reason;
      }
      /**
       * toString helper
       * TODO remove? This defaults to `${this.name}: ${this.message}`
       * @api private
       */
      toString() {
        return this.message;
      }
      /**
       * Ensure `name` and `message` show up in toJSON output re: gh-9296
       * @api private
       */
      toJSON() {
        return Object.assign({ name: this.name, message: this.message }, this);
      }
    };
    Object.defineProperty(ValidatorError.prototype, "name", {
      value: "ValidatorError"
    });
    Object.defineProperty(ValidatorError.prototype, "properties", {
      enumerable: false,
      writable: true,
      value: null
    });
    ValidatorError.prototype.formatMessage = formatMessage;
    function formatMessage(msg, properties, doc) {
      if (typeof msg === "function") {
        return msg(properties, doc);
      }
      const propertyNames = Object.keys(properties);
      for (const propertyName of propertyNames) {
        if (propertyName === "message") {
          continue;
        }
        msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
      }
      return msg;
    }
    module2.exports = ValidatorError;
  }
});

// asset-input/node_modules/mongoose/lib/error/version.js
var require_version = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/version.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var VersionError = class extends MongooseError {
      /**
       * Version Error constructor.
       *
       * @param {Document} doc
       * @param {Number} currentVersion
       * @param {Array<String>} modifiedPaths
       * @api private
       */
      constructor(doc, currentVersion, modifiedPaths) {
        const modifiedPathsStr = modifiedPaths.join(", ");
        super('No matching document found for id "' + doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
        this.version = currentVersion;
        this.modifiedPaths = modifiedPaths;
      }
    };
    Object.defineProperty(VersionError.prototype, "name", {
      value: "VersionError"
    });
    module2.exports = VersionError;
  }
});

// asset-input/node_modules/mongoose/lib/error/parallelSave.js
var require_parallelSave = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/parallelSave.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ParallelSaveError = class extends MongooseError {
      /**
       * ParallelSave Error constructor.
       *
       * @param {Document} doc
       * @api private
       */
      constructor(doc) {
        const msg = "Can't save() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelSaveError.prototype, "name", {
      value: "ParallelSaveError"
    });
    module2.exports = ParallelSaveError;
  }
});

// asset-input/node_modules/mongoose/lib/error/overwriteModel.js
var require_overwriteModel = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/overwriteModel.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var OverwriteModelError = class extends MongooseError {
      /**
       * OverwriteModel Error constructor.
       * @param {String} name
       * @api private
       */
      constructor(name) {
        super("Cannot overwrite `" + name + "` model once compiled.");
      }
    };
    Object.defineProperty(OverwriteModelError.prototype, "name", {
      value: "OverwriteModelError"
    });
    module2.exports = OverwriteModelError;
  }
});

// asset-input/node_modules/mongoose/lib/error/missingSchema.js
var require_missingSchema = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/missingSchema.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var MissingSchemaError = class extends MongooseError {
      /**
       * MissingSchema Error constructor.
       * @param {String} name
       * @api private
       */
      constructor(name) {
        const msg = `Schema hasn't been registered for model "` + name + '".\nUse mongoose.model(name, schema)';
        super(msg);
      }
    };
    Object.defineProperty(MissingSchemaError.prototype, "name", {
      value: "MissingSchemaError"
    });
    module2.exports = MissingSchemaError;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js
var require_allServersUnknown = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js"(exports2, module2) {
    "use strict";
    var getConstructorName = require_getConstructorName();
    module2.exports = function allServersUnknown(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const servers = Array.from(topologyDescription.servers.values());
      return servers.length > 0 && servers.every((server) => server.type === "Unknown");
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/topology/isAtlas.js
var require_isAtlas = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/topology/isAtlas.js"(exports2, module2) {
    "use strict";
    var getConstructorName = require_getConstructorName();
    module2.exports = function isAtlas(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      if (topologyDescription.servers.size === 0) {
        return false;
      }
      for (const server of topologyDescription.servers.values()) {
        if (server.host.endsWith(".mongodb.net") === false || server.port !== 27017) {
          return false;
        }
      }
      return true;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/topology/isSSLError.js
var require_isSSLError = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/topology/isSSLError.js"(exports2, module2) {
    "use strict";
    var getConstructorName = require_getConstructorName();
    var nonSSLMessage = "Client network socket disconnected before secure TLS connection was established";
    module2.exports = function isSSLError(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const descriptions = Array.from(topologyDescription.servers.values());
      return descriptions.length > 0 && descriptions.every((descr) => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
    };
  }
});

// asset-input/node_modules/mongoose/lib/error/serverSelection.js
var require_serverSelection = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/serverSelection.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var allServersUnknown = require_allServersUnknown();
    var isAtlas = require_isAtlas();
    var isSSLError = require_isSSLError();
    var atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/";
    var sslMessage = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html";
    var MongooseServerSelectionError = class extends MongooseError {
      /**
       * MongooseServerSelectionError constructor
       *
       * @api private
       */
      assimilateError(err) {
        const reason = err.reason;
        const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err.message.indexOf("bad auth") === -1 && err.message.indexOf("Authentication failed") === -1;
        if (isAtlasWhitelistError) {
          this.message = atlasMessage;
        } else if (isSSLError(reason)) {
          this.message = sslMessage;
        } else {
          this.message = err.message;
        }
        for (const key in err) {
          if (key !== "name") {
            this[key] = err[key];
          }
        }
        return this;
      }
    };
    Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
      value: "MongooseServerSelectionError"
    });
    module2.exports = MongooseServerSelectionError;
  }
});

// asset-input/node_modules/mongoose/lib/error/divergentArray.js
var require_divergentArray = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/divergentArray.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var DivergentArrayError = class extends MongooseError {
      /**
       * DivergentArrayError constructor.
       * @param {Array<String>} paths
       * @api private
       */
      constructor(paths) {
        const msg = "For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + paths.join("\n  ") + "\nUse Model.update() to update these arrays instead.";
        super(msg);
      }
    };
    Object.defineProperty(DivergentArrayError.prototype, "name", {
      value: "DivergentArrayError"
    });
    module2.exports = DivergentArrayError;
  }
});

// asset-input/node_modules/mongoose/lib/error/strict.js
var require_strict = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/strict.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var StrictModeError = class extends MongooseError {
      /**
       * Strict mode error constructor
       *
       * @param {String} path
       * @param {String} [msg]
       * @param {Boolean} [immutable]
       * @inherits MongooseError
       * @api private
       */
      constructor(path, msg, immutable) {
        msg = msg || "Field `" + path + "` is not in schema and strict mode is set to throw.";
        super(msg);
        this.isImmutableError = !!immutable;
        this.path = path;
      }
    };
    Object.defineProperty(StrictModeError.prototype, "name", {
      value: "StrictModeError"
    });
    module2.exports = StrictModeError;
  }
});

// asset-input/node_modules/mongoose/lib/error/strictPopulate.js
var require_strictPopulate = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/strictPopulate.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var StrictPopulateError = class extends MongooseError {
      /**
       * Strict mode error constructor
       *
       * @param {String} path
       * @param {String} [msg]
       * @inherits MongooseError
       * @api private
       */
      constructor(path, msg) {
        msg = msg || "Cannot populate path `" + path + "` because it is not in your schema. Set the `strictPopulate` option to false to override.";
        super(msg);
        this.path = path;
      }
    };
    Object.defineProperty(StrictPopulateError.prototype, "name", {
      value: "StrictPopulateError"
    });
    module2.exports = StrictPopulateError;
  }
});

// asset-input/node_modules/mongoose/lib/error/index.js
var require_error3 = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/index.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    module2.exports = exports2 = MongooseError;
    MongooseError.messages = require_messages();
    MongooseError.Messages = MongooseError.messages;
    MongooseError.DocumentNotFoundError = require_notFound();
    MongooseError.CastError = require_cast();
    MongooseError.ValidationError = require_validation();
    MongooseError.ValidatorError = require_validator();
    MongooseError.VersionError = require_version();
    MongooseError.ParallelSaveError = require_parallelSave();
    MongooseError.OverwriteModelError = require_overwriteModel();
    MongooseError.MissingSchemaError = require_missingSchema();
    MongooseError.MongooseServerSelectionError = require_serverSelection();
    MongooseError.DivergentArrayError = require_divergentArray();
    MongooseError.StrictModeError = require_strict();
    MongooseError.StrictPopulateError = require_strictPopulate();
  }
});

// asset-input/node_modules/mongoose/lib/options/propertyOptions.js
var require_propertyOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/propertyOptions.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.freeze({
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaTypeOptions.js
var require_SchemaTypeOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaTypeOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var SchemaTypeOptions = class {
      constructor(obj) {
        if (obj == null) {
          return this;
        }
        Object.assign(this, clone(obj));
      }
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "refPath", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
    module2.exports = SchemaTypeOptions;
  }
});

// asset-input/node_modules/mongoose/lib/cast/boolean.js
var require_boolean = __commonJS({
  "asset-input/node_modules/mongoose/lib/cast/boolean.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    module2.exports = function castBoolean(value, path) {
      if (module2.exports.convertToTrue.has(value)) {
        return true;
      }
      if (module2.exports.convertToFalse.has(value)) {
        return false;
      }
      if (value == null) {
        return value;
      }
      throw new CastError("boolean", value, path);
    };
    module2.exports.convertToTrue = /* @__PURE__ */ new Set([true, "true", 1, "1", "yes"]);
    module2.exports.convertToFalse = /* @__PURE__ */ new Set([false, "false", 0, "0", "no"]);
  }
});

// asset-input/node_modules/mongoose/lib/schema/operators/exists.js
var require_exists = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/operators/exists.js"(exports2, module2) {
    "use strict";
    var castBoolean = require_boolean();
    module2.exports = function(val) {
      const path = this != null ? this.path : null;
      return castBoolean(val, path);
    };
  }
});

// asset-input/node_modules/mongoose/lib/schema/operators/type.js
var require_type = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/operators/type.js"(exports2, module2) {
    "use strict";
    module2.exports = function(val) {
      if (Array.isArray(val)) {
        if (!val.every((v) => typeof v === "number" || typeof v === "string")) {
          throw new Error("$type array values must be strings or numbers");
        }
        return val;
      }
      if (typeof val !== "number" && typeof val !== "string") {
        throw new Error("$type parameter must be number, string, or array of numbers and strings");
      }
      return val;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js
var require_handleImmutable = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js"(exports2, module2) {
    "use strict";
    var StrictModeError = require_strict();
    module2.exports = function(schematype) {
      if (schematype.$immutable) {
        schematype.$immutableSetter = createImmutableSetter(
          schematype.path,
          schematype.options.immutable
        );
        schematype.set(schematype.$immutableSetter);
      } else if (schematype.$immutableSetter) {
        schematype.setters = schematype.setters.filter((fn) => fn !== schematype.$immutableSetter);
        delete schematype.$immutableSetter;
      }
    };
    function createImmutableSetter(path, immutable) {
      return function immutableSetter(v, _priorVal, _doc, options) {
        if (this == null || this.$__ == null) {
          return v;
        }
        if (this.isNew) {
          return v;
        }
        if (options && options.overwriteImmutable) {
          return v;
        }
        const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
        if (!_immutable) {
          return v;
        }
        const _value = this.$__.priorDoc != null ? this.$__.priorDoc.$__getValue(path) : this.$__getValue(path);
        if (this.$__.strictMode === "throw" && v !== _value) {
          throw new StrictModeError(path, "Path `" + path + "` is immutable and strict mode is set to throw.", true);
        }
        return _value;
      };
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/isAsyncFunction.js
var require_isAsyncFunction = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/isAsyncFunction.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAsyncFunction(v) {
      return typeof v === "function" && v.constructor && v.constructor.name === "AsyncFunction";
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/isSimpleValidator.js
var require_isSimpleValidator = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/isSimpleValidator.js"(exports2, module2) {
    "use strict";
    module2.exports = function isSimpleValidator(obj) {
      const keys = Object.keys(obj);
      let result = true;
      for (let i = 0, len = keys.length; i < len; ++i) {
        if (typeof obj[keys[i]] === "object" && obj[keys[i]] !== null) {
          result = false;
          break;
        }
      }
      return result;
    };
  }
});

// asset-input/node_modules/mongoose/lib/schematype.js
var require_schematype = __commonJS({
  "asset-input/node_modules/mongoose/lib/schematype.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var $exists = require_exists();
    var $type = require_type();
    var handleImmutable = require_handleImmutable();
    var isAsyncFunction = require_isAsyncFunction();
    var isSimpleValidator = require_isSimpleValidator();
    var immediate = require_immediate();
    var schemaTypeSymbol = require_symbols().schemaTypeSymbol;
    var utils = require_utils6();
    var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
    var documentIsModified = require_symbols().documentIsModified;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var CastError = MongooseError.CastError;
    var ValidatorError = MongooseError.ValidatorError;
    var setOptionsForDefaults = { _skipMarkModified: true };
    function SchemaType(path, options, instance) {
      this[schemaTypeSymbol] = true;
      this.path = path;
      this.instance = instance;
      this.validators = [];
      this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
      this.setters = [];
      this.splitPath();
      options = options || {};
      const defaultOptions = this.constructor.defaultOptions || {};
      const defaultOptionsKeys = Object.keys(defaultOptions);
      for (const option of defaultOptionsKeys) {
        if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {
          options[option] = defaultOptions[option];
        }
      }
      if (options.select == null) {
        delete options.select;
      }
      const Options = this.OptionsConstructor || SchemaTypeOptions;
      this.options = new Options(options);
      this._index = null;
      if (utils.hasUserDefinedProperty(this.options, "immutable")) {
        this.$immutable = this.options.immutable;
        handleImmutable(this);
      }
      const keys = Object.keys(this.options);
      for (const prop of keys) {
        if (prop === "cast") {
          this.castFunction(this.options[prop]);
          continue;
        }
        if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
          if (prop === "index" && this._index) {
            if (options.index === false) {
              const index = this._index;
              if (typeof index === "object" && index != null) {
                if (index.unique) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                }
                if (index.sparse) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                }
              }
              this._index = false;
            }
            continue;
          }
          const val = options[prop];
          if (prop === "default") {
            this.default(val);
            continue;
          }
          const opts = Array.isArray(val) ? val : [val];
          this[prop].apply(this, opts);
        }
      }
      Object.defineProperty(this, "$$context", {
        enumerable: false,
        configurable: false,
        writable: true,
        value: null
      });
    }
    SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
    SchemaType.prototype.path;
    SchemaType.prototype.validators;
    SchemaType.prototype.isRequired;
    SchemaType.prototype.splitPath = function() {
      if (this._presplitPath != null) {
        return this._presplitPath;
      }
      if (this.path == null) {
        return void 0;
      }
      this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split(".");
      return this._presplitPath;
    };
    SchemaType.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = (v) => v;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaType.prototype.castFunction = function castFunction(caster) {
      if (arguments.length === 0) {
        return this._castFunction;
      }
      if (caster === false) {
        caster = this.constructor._defaultCaster || ((v) => v);
      }
      this._castFunction = caster;
      return this._castFunction;
    };
    SchemaType.prototype.cast = function cast() {
      throw new Error("Base SchemaType class does not implement a `cast()` function");
    };
    SchemaType.set = function set(option, value) {
      if (!this.hasOwnProperty("defaultOptions")) {
        this.defaultOptions = Object.assign({}, this.defaultOptions);
      }
      this.defaultOptions[option] = value;
    };
    SchemaType.get = function(getter) {
      this.getters = this.hasOwnProperty("getters") ? this.getters : [];
      this.getters.push(getter);
    };
    SchemaType.prototype.default = function(val) {
      if (arguments.length === 1) {
        if (val === void 0) {
          this.defaultValue = void 0;
          return void 0;
        }
        if (val != null && val.instanceOfSchema) {
          throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
        }
        this.defaultValue = val;
        return this.defaultValue;
      } else if (arguments.length > 1) {
        this.defaultValue = [...arguments];
      }
      return this.defaultValue;
    };
    SchemaType.prototype.index = function(options) {
      this._index = options;
      utils.expires(this._index);
      return this;
    };
    SchemaType.prototype.unique = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
      }
      if (!this.options.hasOwnProperty("index") && bool === false) {
        return this;
      }
      if (this._index == null || this._index === true) {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.unique = bool;
      return this;
    };
    SchemaType.prototype.text = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return this;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
      }
      if (!this.options.hasOwnProperty("index") && bool === false) {
        return this;
      }
      if (this._index === null || this._index === void 0 || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.text = bool;
      return this;
    };
    SchemaType.prototype.sparse = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return this;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
      }
      if (!this.options.hasOwnProperty("index") && bool === false) {
        return this;
      }
      if (this._index == null || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.sparse = bool;
      return this;
    };
    SchemaType.prototype.immutable = function(bool) {
      this.$immutable = bool;
      handleImmutable(this);
      return this;
    };
    SchemaType.prototype.transform = function(fn) {
      this.options.transform = fn;
      return this;
    };
    SchemaType.prototype.set = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A setter must be a function.");
      }
      this.setters.push(fn);
      return this;
    };
    SchemaType.prototype.get = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A getter must be a function.");
      }
      this.getters.push(fn);
      return this;
    };
    SchemaType.prototype.validate = function(obj, message, type) {
      if (typeof obj === "function" || obj && utils.getFunctionName(obj.constructor) === "RegExp") {
        let properties;
        if (typeof message === "function") {
          properties = { validator: obj, message };
          properties.type = type || "user defined";
        } else if (message instanceof Object && !type) {
          properties = isSimpleValidator(message) ? Object.assign({}, message) : utils.clone(message);
          if (!properties.message) {
            properties.message = properties.msg;
          }
          properties.validator = obj;
          properties.type = properties.type || "user defined";
        } else {
          if (message == null) {
            message = MongooseError.messages.general.default;
          }
          if (!type) {
            type = "user defined";
          }
          properties = { message, type, validator: obj };
        }
        this.validators.push(properties);
        return this;
      }
      let i;
      let length;
      let arg;
      for (i = 0, length = arguments.length; i < length; i++) {
        arg = arguments[i];
        if (!utils.isPOJO(arg)) {
          const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See https://mongoosejs.com/docs/api/schematype.html#schematype_SchemaType-validate";
          throw new Error(msg);
        }
        this.validate(arg.validator, arg);
      }
      return this;
    };
    SchemaType.prototype.required = function(required, message) {
      let customOptions = {};
      if (arguments.length > 0 && required == null) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      if (typeof required === "object") {
        customOptions = required;
        message = customOptions.message || message;
        required = required.isRequired;
      }
      if (required === false) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      const _this = this;
      this.isRequired = true;
      this.requiredValidator = function(v) {
        const cachedRequired = this && this.$__ && this.$__.cachedRequired;
        if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
          return true;
        }
        if (cachedRequired != null && _this.path in cachedRequired) {
          const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
          delete cachedRequired[_this.path];
          return res;
        } else if (typeof required === "function") {
          return required.apply(this) ? _this.checkRequired(v, this) : true;
        }
        return _this.checkRequired(v, this);
      };
      this.originalRequiredValue = required;
      if (typeof required === "string") {
        message = required;
        required = void 0;
      }
      const msg = message || MongooseError.messages.general.required;
      this.validators.unshift(Object.assign({}, customOptions, {
        validator: this.requiredValidator,
        message: msg,
        type: "required"
      }));
      return this;
    };
    SchemaType.prototype.ref = function(ref) {
      this.options.ref = ref;
      return this;
    };
    SchemaType.prototype.getDefault = function(scope, init, options) {
      let ret;
      if (typeof this.defaultValue === "function") {
        if (this.defaultValue === Date.now || this.defaultValue === Array || this.defaultValue.name.toLowerCase() === "objectid") {
          ret = this.defaultValue.call(scope);
        } else {
          ret = this.defaultValue.call(scope, scope);
        }
      } else {
        ret = this.defaultValue;
      }
      if (ret !== null && ret !== void 0) {
        if (typeof ret === "object" && (!this.options || !this.options.shared)) {
          ret = utils.clone(ret);
        }
        if (options && options.skipCast) {
          return this._applySetters(ret, scope);
        }
        const casted = this.applySetters(ret, scope, init, void 0, setOptionsForDefaults);
        if (casted && !Array.isArray(casted) && casted.$isSingleNested) {
          casted.$__parent = scope;
        }
        return casted;
      }
      return ret;
    };
    SchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {
      let v = value;
      if (init) {
        return v;
      }
      const setters = this.setters;
      for (let i = setters.length - 1; i >= 0; i--) {
        v = setters[i].call(scope, v, priorVal, this, options);
      }
      return v;
    };
    SchemaType.prototype._castNullish = function _castNullish(v) {
      return v;
    };
    SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
      let v = this._applySetters(value, scope, init, priorVal, options);
      if (v == null) {
        return this._castNullish(v);
      }
      v = this.cast(v, scope, init, priorVal, options);
      return v;
    };
    SchemaType.prototype.applyGetters = function(value, scope) {
      let v = value;
      const getters = this.getters;
      const len = getters.length;
      if (len === 0) {
        return v;
      }
      for (let i = 0; i < len; ++i) {
        v = getters[i].call(scope, v, this);
      }
      return v;
    };
    SchemaType.prototype.select = function select(val) {
      this.selected = !!val;
      return this;
    };
    SchemaType.prototype.doValidate = function(value, fn, scope, options) {
      let err = false;
      const path = this.path;
      const validators = this.validators.filter((v) => typeof v === "object" && v !== null);
      let count = validators.length;
      if (!count) {
        return fn(null);
      }
      for (let i = 0, len = validators.length; i < len; ++i) {
        if (err) {
          break;
        }
        const v = validators[i];
        const validator = v.validator;
        let ok;
        const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : utils.clone(v);
        validatorProperties.path = options && options.path ? options.path : path;
        validatorProperties.fullPath = this.$fullPath;
        validatorProperties.value = value;
        if (validator instanceof RegExp) {
          validate2(validator.test(value), validatorProperties, scope);
          continue;
        }
        if (typeof validator !== "function") {
          continue;
        }
        if (value === void 0 && validator !== this.requiredValidator) {
          validate2(true, validatorProperties, scope);
          continue;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
          if (error.message) {
            validatorProperties.message = error.message;
          }
        }
        if (ok != null && typeof ok.then === "function") {
          ok.then(
            function(ok2) {
              validate2(ok2, validatorProperties, scope);
            },
            function(error) {
              validatorProperties.reason = error;
              validatorProperties.message = error.message;
              ok = false;
              validate2(ok, validatorProperties, scope);
            }
          );
        } else {
          validate2(ok, validatorProperties, scope);
        }
      }
      function validate2(ok, validatorProperties, scope2) {
        if (err) {
          return;
        }
        if (ok === void 0 || ok) {
          if (--count <= 0) {
            immediate(function() {
              fn(null);
            });
          }
        } else {
          const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
          err = new ErrorConstructor(validatorProperties, scope2);
          err[validatorErrorSymbol] = true;
          immediate(function() {
            fn(err);
          });
        }
      }
    };
    function _validate(ok, validatorProperties) {
      if (ok !== void 0 && !ok) {
        const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
        const err = new ErrorConstructor(validatorProperties);
        err[validatorErrorSymbol] = true;
        return err;
      }
    }
    SchemaType.prototype.doValidateSync = function(value, scope, options) {
      const path = this.path;
      const count = this.validators.length;
      if (!count) {
        return null;
      }
      let validators = this.validators;
      if (value === void 0) {
        if (this.validators.length !== 0 && this.validators[0].type === "required") {
          validators = [this.validators[0]];
        } else {
          return null;
        }
      }
      let err = null;
      let i = 0;
      const len = validators.length;
      for (i = 0; i < len; ++i) {
        const v = validators[i];
        if (v === null || typeof v !== "object") {
          continue;
        }
        const validator = v.validator;
        const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : utils.clone(v);
        validatorProperties.path = options && options.path ? options.path : path;
        validatorProperties.fullPath = this.$fullPath;
        validatorProperties.value = value;
        let ok = false;
        if (isAsyncFunction(validator)) {
          continue;
        }
        if (validator instanceof RegExp) {
          err = _validate(validator.test(value), validatorProperties);
          continue;
        }
        if (typeof validator !== "function") {
          continue;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
        }
        if (ok != null && typeof ok.then === "function") {
          continue;
        }
        err = _validate(ok, validatorProperties);
        if (err) {
          break;
        }
      }
      return err;
    };
    SchemaType._isRef = function(self2, value, doc, init) {
      let ref = init && self2.options && (self2.options.ref || self2.options.refPath);
      if (!ref && doc && doc.$__ != null) {
        const path = doc.$__fullPath(self2.path, true);
        const owner = doc.ownerDocument();
        ref = path != null && owner.$populated(path) || doc.$populated(self2.path);
      }
      if (ref) {
        if (value == null) {
          return true;
        }
        if (!Buffer.isBuffer(value) && // buffers are objects too
        value._bsontype !== "Binary" && utils.isObject(value)) {
          return true;
        }
        return init;
      }
      return false;
    };
    SchemaType.prototype._castRef = function _castRef(value, doc, init) {
      if (value == null) {
        return value;
      }
      if (value.$__ != null) {
        value.$__.wasPopulated = value.$__.wasPopulated || { value: value._id };
        return value;
      }
      if (Buffer.isBuffer(value) || !utils.isObject(value)) {
        if (init) {
          return value;
        }
        throw new CastError(this.instance, value, this.path, null, this);
      }
      const path = doc.$__fullPath(this.path, true);
      const owner = doc.ownerDocument();
      const pop = owner.$populated(path, true);
      let ret = value;
      if (!doc.$__.populated || !doc.$__.populated[path] || !doc.$__.populated[path].options || !doc.$__.populated[path].options.options || !doc.$__.populated[path].options.options.lean) {
        ret = new pop.options[populateModelSymbol](value);
        ret.$__.wasPopulated = { value: ret._id };
      }
      return ret;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    function handle$in(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        if (Array.isArray(m) && m.length === 0) {
          return m;
        }
        return _this.castForQuery(m);
      });
    }
    SchemaType.prototype.$conditionalHandlers = {
      $all: handleArray,
      $eq: handleSingle,
      $in: handle$in,
      $ne: handleSingle,
      $nin: handle$in,
      $exists,
      $type
    };
    SchemaType.prototype.castForQueryWrapper = function(params) {
      this.$$context = params.context;
      if ("$conditional" in params) {
        const ret2 = this.castForQuery(params.$conditional, params.val);
        this.$$context = null;
        return ret2;
      }
      if (params.$skipQueryCastForUpdate || params.$applySetters) {
        const ret2 = this._castForQuery(params.val);
        this.$$context = null;
        return ret2;
      }
      const ret = this.castForQuery(params.val);
      this.$$context = null;
      return ret;
    };
    SchemaType.prototype.castForQuery = function($conditional, val) {
      let handler2;
      if (arguments.length === 2) {
        handler2 = this.$conditionalHandlers[$conditional];
        if (!handler2) {
          throw new Error("Can't use " + $conditional);
        }
        return handler2.call(this, val);
      }
      val = $conditional;
      return this._castForQuery(val);
    };
    SchemaType.prototype._castForQuery = function(val) {
      return this.applySetters(val, this.$$context);
    };
    SchemaType.checkRequired = function(fn) {
      if (arguments.length !== 0) {
        this._checkRequired = fn;
      }
      return this._checkRequired;
    };
    SchemaType.prototype.checkRequired = function(val) {
      return val != null;
    };
    SchemaType.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, options, this.instance);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) schematype.requiredValidator = this.requiredValidator;
      if (this.defaultValue !== void 0) schematype.defaultValue = this.defaultValue;
      if (this.$immutable !== void 0 && this.options.immutable === void 0) {
        schematype.$immutable = this.$immutable;
        handleImmutable(schematype);
      }
      if (this._index !== void 0) schematype._index = this._index;
      if (this.selected !== void 0) schematype.selected = this.selected;
      if (this.isRequired !== void 0) schematype.isRequired = this.isRequired;
      if (this.originalRequiredValue !== void 0) schematype.originalRequiredValue = this.originalRequiredValue;
      schematype.getters = this.getters.slice();
      schematype.setters = this.setters.slice();
      return schematype;
    };
    module2.exports = exports2 = SchemaType;
    exports2.CastError = CastError;
    exports2.ValidatorError = ValidatorError;
  }
});

// asset-input/node_modules/mongoose/lib/schema/symbols.js
var require_symbols2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/symbols.js"(exports2) {
    "use strict";
    exports2.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
    exports2.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
  }
});

// asset-input/node_modules/mongoose/lib/schema/mixed.js
var require_mixed = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/mixed.js"(exports2, module2) {
    "use strict";
    var SchemaType = require_schematype();
    var symbols = require_symbols2();
    var isObject = require_isObject();
    var utils = require_utils6();
    function Mixed(path, options) {
      if (options && options.default) {
        const def = options.default;
        if (Array.isArray(def) && def.length === 0) {
          options.default = Array;
        } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {
          options.default = function() {
            return {};
          };
        }
      }
      SchemaType.call(this, path, options, "Mixed");
      this[symbols.schemaMixedSymbol] = true;
    }
    Mixed.schemaName = "Mixed";
    Mixed.defaultOptions = {};
    Mixed.prototype = Object.create(SchemaType.prototype);
    Mixed.prototype.constructor = Mixed;
    Mixed.get = SchemaType.get;
    Mixed.set = SchemaType.set;
    Mixed.prototype.cast = function(val) {
      if (val instanceof Error) {
        return utils.errorToPOJO(val);
      }
      return val;
    };
    Mixed.prototype.castForQuery = function($cond, val) {
      if (arguments.length === 2) {
        return val;
      }
      return $cond;
    };
    module2.exports = Mixed;
  }
});

// asset-input/node_modules/mongoose/lib/error/objectExpected.js
var require_objectExpected = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/objectExpected.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ObjectExpectedError = class extends MongooseError {
      /**
       * Strict mode error constructor
       *
       * @param {string} type
       * @param {string} value
       * @api private
       */
      constructor(path, val) {
        const typeDescription = Array.isArray(val) ? "array" : "primitive value";
        super("Tried to set nested object field `" + path + `\` to ${typeDescription} \`` + val + "`");
        this.path = path;
      }
    };
    Object.defineProperty(ObjectExpectedError.prototype, "name", {
      value: "ObjectExpectedError"
    });
    module2.exports = ObjectExpectedError;
  }
});

// asset-input/node_modules/mongoose/lib/error/objectParameter.js
var require_objectParameter = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/objectParameter.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ObjectParameterError = class extends MongooseError {
      /**
       * Constructor for errors that happen when a parameter that's expected to be
       * an object isn't an object
       *
       * @param {Any} value
       * @param {String} paramName
       * @param {String} fnName
       * @api private
       */
      constructor(value, paramName, fnName) {
        super('Parameter "' + paramName + '" to ' + fnName + '() must be an object, got "' + value.toString() + '" (type ' + typeof value + ")");
      }
    };
    Object.defineProperty(ObjectParameterError.prototype, "name", {
      value: "ObjectParameterError"
    });
    module2.exports = ObjectParameterError;
  }
});

// asset-input/node_modules/mongoose/lib/error/parallelValidate.js
var require_parallelValidate = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/parallelValidate.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var ParallelValidateError = class extends MongooseError {
      /**
       * ParallelValidate Error constructor.
       *
       * @param {Document} doc
       * @api private
       */
      constructor(doc) {
        const msg = "Can't validate() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelValidateError.prototype, "name", {
      value: "ParallelValidateError"
    });
    module2.exports = ParallelValidateError;
  }
});

// asset-input/node_modules/kareem/index.js
var require_kareem = __commonJS({
  "asset-input/node_modules/kareem/index.js"(exports2, module2) {
    "use strict";
    function Kareem() {
      this._pres = /* @__PURE__ */ new Map();
      this._posts = /* @__PURE__ */ new Map();
    }
    Kareem.skipWrappedFunction = function skipWrappedFunction() {
      if (!(this instanceof Kareem.skipWrappedFunction)) {
        return new Kareem.skipWrappedFunction(...arguments);
      }
      this.args = [...arguments];
    };
    Kareem.overwriteResult = function overwriteResult() {
      if (!(this instanceof Kareem.overwriteResult)) {
        return new Kareem.overwriteResult(...arguments);
      }
      this.args = [...arguments];
    };
    Kareem.prototype.execPre = function(name, context, args, callback) {
      if (arguments.length === 3) {
        callback = args;
        args = [];
      }
      const pres = this._pres.get(name) || [];
      const numPres = pres.length;
      const numAsyncPres = pres.numAsync || 0;
      let currentPre = 0;
      let asyncPresLeft = numAsyncPres;
      let done = false;
      const $args = args;
      let shouldSkipWrappedFunction = null;
      if (!numPres) {
        return nextTick(function() {
          callback(null);
        });
      }
      function next() {
        if (currentPre >= numPres) {
          return;
        }
        const pre = pres[currentPre];
        if (pre.isAsync) {
          const args2 = [
            decorateNextFn(_next),
            decorateNextFn(function(error) {
              if (error) {
                if (done) {
                  return;
                }
                if (error instanceof Kareem.skipWrappedFunction) {
                  shouldSkipWrappedFunction = error;
                } else {
                  done = true;
                  return callback(error);
                }
              }
              if (--asyncPresLeft === 0 && currentPre >= numPres) {
                return callback(shouldSkipWrappedFunction);
              }
            })
          ];
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else if (pre.fn.length > 0) {
          const args2 = [decorateNextFn(_next)];
          const _args = arguments.length >= 2 ? arguments : [null].concat($args);
          for (let i = 1; i < _args.length; ++i) {
            if (i === _args.length - 1 && typeof _args[i] === "function") {
              continue;
            }
            args2.push(_args[i]);
          }
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else {
          let maybePromiseLike = null;
          try {
            maybePromiseLike = pre.fn.call(context);
          } catch (err) {
            if (err != null) {
              return callback(err);
            }
          }
          if (isPromiseLike(maybePromiseLike)) {
            maybePromiseLike.then(() => _next(), (err) => _next(err));
          } else {
            if (++currentPre >= numPres) {
              if (asyncPresLeft > 0) {
                return;
              } else {
                return nextTick(function() {
                  callback(shouldSkipWrappedFunction);
                });
              }
            }
            next();
          }
        }
      }
      next.apply(null, [null].concat(args));
      function _next(error) {
        if (error) {
          if (done) {
            return;
          }
          if (error instanceof Kareem.skipWrappedFunction) {
            shouldSkipWrappedFunction = error;
          } else {
            done = true;
            return callback(error);
          }
        }
        if (++currentPre >= numPres) {
          if (asyncPresLeft > 0) {
            return;
          } else {
            return callback(shouldSkipWrappedFunction);
          }
        }
        next.apply(context, arguments);
      }
    };
    Kareem.prototype.execPreSync = function(name, context, args) {
      const pres = this._pres.get(name) || [];
      const numPres = pres.length;
      for (let i = 0; i < numPres; ++i) {
        pres[i].fn.apply(context, args || []);
      }
    };
    Kareem.prototype.execPost = function(name, context, args, options, callback) {
      if (arguments.length < 5) {
        callback = options;
        options = null;
      }
      const posts = this._posts.get(name) || [];
      const numPosts = posts.length;
      let currentPost = 0;
      let firstError = null;
      if (options && options.error) {
        firstError = options.error;
      }
      if (!numPosts) {
        return nextTick(function() {
          callback.apply(null, [firstError].concat(args));
        });
      }
      function next() {
        const post = posts[currentPost].fn;
        let numArgs = 0;
        const argLength = args.length;
        const newArgs = [];
        for (let i = 0; i < argLength; ++i) {
          numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
          if (!args[i] || !args[i]._kareemIgnore) {
            newArgs.push(args[i]);
          }
        }
        if (firstError) {
          if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
            const _cb = decorateNextFn(function(error) {
              if (error) {
                if (error instanceof Kareem.overwriteResult) {
                  args = error.args;
                  if (++currentPost >= numPosts) {
                    return callback.call(null, firstError);
                  }
                  return next();
                }
                firstError = error;
              }
              if (++currentPost >= numPosts) {
                return callback.call(null, firstError);
              }
              next();
            });
            callMiddlewareFunction(
              post,
              context,
              [firstError].concat(newArgs).concat([_cb]),
              _cb
            );
          } else {
            if (++currentPost >= numPosts) {
              return callback.call(null, firstError);
            }
            next();
          }
        } else {
          const _cb = decorateNextFn(function(error) {
            if (error) {
              if (error instanceof Kareem.overwriteResult) {
                args = error.args;
                if (++currentPost >= numPosts) {
                  return callback.apply(null, [null].concat(args));
                }
                return next();
              }
              firstError = error;
              return next();
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            next();
          });
          if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            return next();
          }
          if (post.length === numArgs + 1) {
            callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);
          } else {
            let error;
            let maybePromiseLike;
            try {
              maybePromiseLike = post.apply(context, newArgs);
            } catch (err) {
              error = err;
              firstError = err;
            }
            if (isPromiseLike(maybePromiseLike)) {
              return maybePromiseLike.then(
                (res) => {
                  _cb(res instanceof Kareem.overwriteResult ? res : null);
                },
                (err) => _cb(err)
              );
            }
            if (maybePromiseLike instanceof Kareem.overwriteResult) {
              args = maybePromiseLike.args;
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [error].concat(args));
            }
            next();
          }
        }
      }
      next();
    };
    Kareem.prototype.execPostSync = function(name, context, args) {
      const posts = this._posts.get(name) || [];
      const numPosts = posts.length;
      for (let i = 0; i < numPosts; ++i) {
        const res = posts[i].fn.apply(context, args || []);
        if (res instanceof Kareem.overwriteResult) {
          args = res.args;
        }
      }
      return args;
    };
    Kareem.prototype.createWrapperSync = function(name, fn) {
      const _this = this;
      return function syncWrapper() {
        _this.execPreSync(name, this, arguments);
        const toReturn = fn.apply(this, arguments);
        const result = _this.execPostSync(name, this, [toReturn]);
        return result[0];
      };
    };
    function _handleWrapError(instance, error, name, context, args, options, callback) {
      if (options.useErrorHandlers) {
        return instance.execPost(name, context, args, { error }, function(error2) {
          return typeof callback === "function" && callback(error2);
        });
      } else {
        return typeof callback === "function" && callback(error);
      }
    }
    Kareem.prototype.wrap = function(name, fn, context, args, options) {
      const lastArg = args.length > 0 ? args[args.length - 1] : null;
      const argsWithoutCb = Array.from(args);
      typeof lastArg === "function" && argsWithoutCb.pop();
      const _this = this;
      options = options || {};
      const checkForPromise = options.checkForPromise;
      this.execPre(name, context, args, function(error) {
        if (error && !(error instanceof Kareem.skipWrappedFunction)) {
          const numCallbackParams = options.numCallbackParams || 0;
          const errorArgs = options.contextParameter ? [context] : [];
          for (let i = errorArgs.length; i < numCallbackParams; ++i) {
            errorArgs.push(null);
          }
          return _handleWrapError(
            _this,
            error,
            name,
            context,
            errorArgs,
            options,
            lastArg
          );
        }
        const numParameters = fn.length;
        let ret;
        if (error instanceof Kareem.skipWrappedFunction) {
          ret = error.args[0];
          return _cb(null, ...error.args);
        } else {
          try {
            ret = fn.apply(context, argsWithoutCb.concat(_cb));
          } catch (err) {
            return _cb(err);
          }
        }
        if (checkForPromise) {
          if (isPromiseLike(ret)) {
            return ret.then(
              (res) => _cb(null, res),
              (err) => _cb(err)
            );
          }
          if (numParameters < argsWithoutCb.length + 1) {
            return _cb(null, ret);
          }
        }
        function _cb() {
          const argsWithoutError = Array.from(arguments);
          argsWithoutError.shift();
          if (options.nullResultByDefault && argsWithoutError.length === 0) {
            argsWithoutError.push(null);
          }
          if (arguments[0]) {
            return _handleWrapError(
              _this,
              arguments[0],
              name,
              context,
              argsWithoutError,
              options,
              lastArg
            );
          } else {
            _this.execPost(name, context, argsWithoutError, function() {
              if (lastArg === null) {
                return;
              }
              arguments[0] ? lastArg(arguments[0]) : lastArg.apply(context, arguments);
            });
          }
        }
      });
    };
    Kareem.prototype.filter = function(fn) {
      const clone = this.clone();
      const pres = Array.from(clone._pres.keys());
      for (const name of pres) {
        const hooks = this._pres.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone._pres.delete(name);
          continue;
        }
        hooks.numAsync = hooks.filter((h) => h.isAsync).length;
        clone._pres.set(name, hooks);
      }
      const posts = Array.from(clone._posts.keys());
      for (const name of posts) {
        const hooks = this._posts.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone._posts.delete(name);
          continue;
        }
        clone._posts.set(name, hooks);
      }
      return clone;
    };
    Kareem.prototype.hasHooks = function(name) {
      return this._pres.has(name) || this._posts.has(name);
    };
    Kareem.prototype.createWrapper = function(name, fn, context, options) {
      const _this = this;
      if (!this.hasHooks(name)) {
        return function() {
          nextTick(() => fn.apply(this, arguments));
        };
      }
      return function() {
        const _context = context || this;
        _this.wrap(name, fn, _context, Array.from(arguments), options);
      };
    };
    Kareem.prototype.pre = function(name, isAsync, fn, error, unshift) {
      let options = {};
      if (typeof isAsync === "object" && isAsync !== null) {
        options = isAsync;
        isAsync = options.isAsync;
      } else if (typeof arguments[1] !== "boolean") {
        fn = isAsync;
        isAsync = false;
      }
      const pres = this._pres.get(name) || [];
      this._pres.set(name, pres);
      if (isAsync) {
        pres.numAsync = pres.numAsync || 0;
        ++pres.numAsync;
      }
      if (typeof fn !== "function") {
        throw new Error('pre() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        pres.unshift(Object.assign({}, options, { fn, isAsync }));
      } else {
        pres.push(Object.assign({}, options, { fn, isAsync }));
      }
      return this;
    };
    Kareem.prototype.post = function(name, options, fn, unshift) {
      const posts = this._posts.get(name) || [];
      if (typeof options === "function") {
        unshift = !!fn;
        fn = options;
        options = {};
      }
      if (typeof fn !== "function") {
        throw new Error('post() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        posts.unshift(Object.assign({}, options, { fn }));
      } else {
        posts.push(Object.assign({}, options, { fn }));
      }
      this._posts.set(name, posts);
      return this;
    };
    Kareem.prototype.clone = function() {
      const n = new Kareem();
      for (const key of this._pres.keys()) {
        const clone = this._pres.get(key).slice();
        clone.numAsync = this._pres.get(key).numAsync;
        n._pres.set(key, clone);
      }
      for (const key of this._posts.keys()) {
        n._posts.set(key, this._posts.get(key).slice());
      }
      return n;
    };
    Kareem.prototype.merge = function(other, clone) {
      clone = arguments.length === 1 ? true : clone;
      const ret = clone ? this.clone() : this;
      for (const key of other._pres.keys()) {
        const sourcePres = ret._pres.get(key) || [];
        const deduplicated = other._pres.get(key).filter((p) => sourcePres.map((_p) => _p.fn).indexOf(p.fn) === -1);
        const combined = sourcePres.concat(deduplicated);
        combined.numAsync = sourcePres.numAsync || 0;
        combined.numAsync += deduplicated.filter((p) => p.isAsync).length;
        ret._pres.set(key, combined);
      }
      for (const key of other._posts.keys()) {
        const sourcePosts = ret._posts.get(key) || [];
        const deduplicated = other._posts.get(key).filter((p) => sourcePosts.indexOf(p) === -1);
        ret._posts.set(key, sourcePosts.concat(deduplicated));
      }
      return ret;
    };
    function callMiddlewareFunction(fn, context, args, next) {
      let maybePromiseLike;
      try {
        maybePromiseLike = fn.apply(context, args);
      } catch (error) {
        return next(error);
      }
      if (isPromiseLike(maybePromiseLike)) {
        maybePromiseLike.then(() => next(), (err) => next(err));
      }
    }
    function isPromiseLike(v) {
      return typeof v === "object" && v !== null && typeof v.then === "function";
    }
    function decorateNextFn(fn) {
      let called = false;
      const _this = this;
      return function() {
        if (called) {
          return;
        }
        called = true;
        return nextTick(() => fn.apply(_this, arguments));
      };
    }
    var nextTick = typeof process === "object" && process !== null && process.nextTick || function nextTick2(cb) {
      setTimeout(cb, 0);
    };
    function isErrorHandlingMiddleware(post, numArgs) {
      if (post.errorHandler) {
        return true;
      }
      return post.fn.length === numArgs + 2;
    }
    module2.exports = Kareem;
  }
});

// asset-input/node_modules/mongoose/lib/options/VirtualOptions.js
var require_VirtualOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/VirtualOptions.js"(exports2, module2) {
    "use strict";
    var opts = require_propertyOptions();
    var VirtualOptions = class {
      constructor(obj) {
        Object.assign(this, obj);
        if (obj != null && obj.options != null) {
          this.options = Object.assign({}, obj.options);
        }
      }
    };
    Object.defineProperty(VirtualOptions.prototype, "ref", opts);
    Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
    Object.defineProperty(VirtualOptions.prototype, "localField", opts);
    Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
    Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
    Object.defineProperty(VirtualOptions.prototype, "count", opts);
    Object.defineProperty(VirtualOptions.prototype, "match", opts);
    Object.defineProperty(VirtualOptions.prototype, "options", opts);
    Object.defineProperty(VirtualOptions.prototype, "skip", opts);
    Object.defineProperty(VirtualOptions.prototype, "limit", opts);
    Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
    module2.exports = VirtualOptions;
  }
});

// asset-input/node_modules/mongoose/lib/virtualtype.js
var require_virtualtype = __commonJS({
  "asset-input/node_modules/mongoose/lib/virtualtype.js"(exports2, module2) {
    "use strict";
    var utils = require_utils6();
    function VirtualType(options, name) {
      this.path = name;
      this.getters = [];
      this.setters = [];
      this.options = Object.assign({}, options);
    }
    VirtualType.prototype._applyDefaultGetters = function() {
      if (this.getters.length > 0 || this.setters.length > 0) {
        return;
      }
      const path = this.path;
      const internalProperty = "$" + path;
      this.getters.push(function() {
        return this.$locals[internalProperty];
      });
      this.setters.push(function(v) {
        this.$locals[internalProperty] = v;
      });
    };
    VirtualType.prototype.clone = function() {
      const clone = new VirtualType(this.options, this.path);
      clone.getters = [].concat(this.getters);
      clone.setters = [].concat(this.setters);
      return clone;
    };
    VirtualType.prototype.get = function(fn) {
      this.getters.push(fn);
      return this;
    };
    VirtualType.prototype.set = function(fn) {
      this.setters.push(fn);
      return this;
    };
    VirtualType.prototype.applyGetters = function(value, doc) {
      if (utils.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
        value = doc.$$populatedVirtuals[this.path];
      }
      let v = value;
      for (const getter of this.getters) {
        v = getter.call(doc, v, this, doc);
      }
      return v;
    };
    VirtualType.prototype.applySetters = function(value, doc) {
      let v = value;
      for (const setter of this.setters) {
        v = setter.call(doc, v, this, doc);
      }
      return v;
    };
    module2.exports = VirtualType;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/addAutoId.js
var require_addAutoId = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/addAutoId.js"(exports2, module2) {
    "use strict";
    module2.exports = function addAutoId(schema) {
      const _obj = { _id: { auto: true } };
      _obj._id[schema.options.typeKey] = "ObjectId";
      schema.add(_obj);
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/get.js
var require_get = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/get.js"(exports2, module2) {
    "use strict";
    module2.exports = function get(obj, path, def) {
      let parts;
      let isPathArray = false;
      if (typeof path === "string") {
        if (path.indexOf(".") === -1) {
          const _v = getProperty(obj, path);
          if (_v == null) {
            return def;
          }
          return _v;
        }
        parts = path.split(".");
      } else {
        isPathArray = true;
        parts = path;
        if (parts.length === 1) {
          const _v = getProperty(obj, parts[0]);
          if (_v == null) {
            return def;
          }
          return _v;
        }
      }
      let rest = path;
      let cur = obj;
      for (const part of parts) {
        if (cur == null) {
          return def;
        }
        if (!isPathArray && cur[rest] != null) {
          return cur[rest];
        }
        cur = getProperty(cur, part);
        if (!isPathArray) {
          rest = rest.substr(part.length + 1);
        }
      }
      return cur == null ? def : cur;
    };
    function getProperty(obj, prop) {
      if (obj == null) {
        return obj;
      }
      if (obj instanceof Map) {
        return obj.get(prop);
      }
      return obj[prop];
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js
var require_decorateDiscriminatorIndexOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js"(exports2, module2) {
    "use strict";
    module2.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {
      const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;
      if (discriminatorName && !("sparse" in indexOptions)) {
        const discriminatorKey = schema.options.discriminatorKey;
        indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};
        indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;
      }
      return indexOptions;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/getIndexes.js
var require_getIndexes = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/getIndexes.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var helperIsObject = require_isObject();
    var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
    module2.exports = function getIndexes(schema) {
      let indexes = [];
      const schemaStack = /* @__PURE__ */ new WeakMap();
      const indexTypes = schema.constructor.indexTypes;
      const indexByName = /* @__PURE__ */ new Map();
      collectIndexes(schema);
      return indexes;
      function collectIndexes(schema2, prefix, baseSchema) {
        if (schemaStack.has(schema2)) {
          return;
        }
        schemaStack.set(schema2, true);
        prefix = prefix || "";
        const keys = Object.keys(schema2.paths);
        for (const key of keys) {
          const path = schema2.paths[key];
          if (baseSchema != null && baseSchema.paths[key]) {
            continue;
          }
          if (path.$isMongooseDocumentArray || path.$isSingleNested) {
            if (get(path, "options.excludeIndexes") !== true && get(path, "schemaOptions.excludeIndexes") !== true && get(path, "schema.options.excludeIndexes") !== true) {
              collectIndexes(path.schema, prefix + key + ".");
            }
            if (path.schema.discriminators != null) {
              const discriminators = path.schema.discriminators;
              const discriminatorKeys = Object.keys(discriminators);
              for (const discriminatorKey of discriminatorKeys) {
                collectIndexes(
                  discriminators[discriminatorKey],
                  prefix + key + ".",
                  path.schema
                );
              }
            }
            if (path.$isMongooseDocumentArray) {
              continue;
            }
          }
          const index = path._index || path.caster && path.caster._index;
          if (index !== false && index !== null && index !== void 0) {
            const field = {};
            const isObject = helperIsObject(index);
            const options = isObject ? index : {};
            const type = typeof index === "string" ? index : isObject ? index.type : false;
            if (type && indexTypes.indexOf(type) !== -1) {
              field[prefix + key] = type;
            } else if (options.text) {
              field[prefix + key] = "text";
              delete options.text;
            } else {
              const isDescendingIndex = Number(index) === -1;
              field[prefix + key] = isDescendingIndex ? -1 : 1;
            }
            delete options.type;
            if (!("background" in options)) {
              options.background = true;
            }
            if (schema2.options.autoIndex != null) {
              options._autoIndex = schema2.options.autoIndex;
            }
            const indexName = options && options.name;
            if (typeof indexName === "string") {
              if (indexByName.has(indexName)) {
                Object.assign(indexByName.get(indexName), field);
              } else {
                indexes.push([field, options]);
                indexByName.set(indexName, field);
              }
            } else {
              indexes.push([field, options]);
              indexByName.set(indexName, field);
            }
          }
        }
        schemaStack.delete(schema2);
        if (prefix) {
          fixSubIndexPaths(schema2, prefix);
        } else {
          schema2._indexes.forEach(function(index) {
            const options = index[1];
            if (!("background" in options)) {
              options.background = true;
            }
            decorateDiscriminatorIndexOptions(schema2, options);
          });
          indexes = indexes.concat(schema2._indexes);
        }
      }
      function fixSubIndexPaths(schema2, prefix) {
        const subindexes = schema2._indexes;
        const len = subindexes.length;
        for (let i = 0; i < len; ++i) {
          const indexObj = subindexes[i][0];
          const indexOptions = subindexes[i][1];
          const keys = Object.keys(indexObj);
          const klen = keys.length;
          const newindex = {};
          for (let j = 0; j < klen; ++j) {
            const key = keys[j];
            newindex[prefix + key] = indexObj[key];
          }
          const newIndexOptions = Object.assign({}, indexOptions);
          if (indexOptions != null && indexOptions.partialFilterExpression != null) {
            newIndexOptions.partialFilterExpression = {};
            const partialFilterExpression = indexOptions.partialFilterExpression;
            for (const key of Object.keys(partialFilterExpression)) {
              newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
            }
          }
          indexes.push([newindex, newIndexOptions]);
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/idGetter.js
var require_idGetter = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/idGetter.js"(exports2, module2) {
    "use strict";
    module2.exports = function addIdGetter(schema) {
      const autoIdGetter = !schema.paths["id"] && schema.paths["_id"] && schema.options.id;
      if (!autoIdGetter) {
        return schema;
      }
      schema.virtual("id").get(idGetter);
      return schema;
    };
    function idGetter() {
      if (this._id != null) {
        return String(this._id);
      }
      return null;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js
var require_cleanPositionalOperators = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js"(exports2, module2) {
    "use strict";
    module2.exports = function cleanPositionalOperators(path) {
      return path.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js
var require_handleTimestampOption = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js"(exports2, module2) {
    "use strict";
    module2.exports = handleTimestampOption;
    function handleTimestampOption(arg, prop) {
      if (arg == null) {
        return null;
      }
      if (typeof arg === "boolean") {
        return prop;
      }
      if (typeof arg[prop] === "boolean") {
        return arg[prop] ? prop : null;
      }
      if (!(prop in arg)) {
        return prop;
      }
      return arg[prop];
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js
var require_applyTimestampsToChildren = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js"(exports2, module2) {
    "use strict";
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var handleTimestampOption = require_handleTimestampOption();
    module2.exports = applyTimestampsToChildren;
    function applyTimestampsToChildren(now, update, schema) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      const hasDollarKey = keys.some((key) => key[0] === "$");
      if (hasDollarKey) {
        if (update.$push) {
          _applyTimestampToUpdateOperator(update.$push);
        }
        if (update.$addToSet) {
          _applyTimestampToUpdateOperator(update.$addToSet);
        }
        if (update.$set != null) {
          const keys2 = Object.keys(update.$set);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$set, now);
          }
        }
        if (update.$setOnInsert != null) {
          const keys2 = Object.keys(update.$setOnInsert);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
          }
        }
      }
      const updateKeys = Object.keys(update).filter((key) => key[0] !== "$");
      for (const key of updateKeys) {
        applyTimestampsToUpdateKey(schema, key, update, now);
      }
      function _applyTimestampToUpdateOperator(op) {
        for (const key of Object.keys(op)) {
          const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
          if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
            const timestamps = $path.schema.options.timestamps;
            const createdAt = handleTimestampOption(timestamps, "createdAt");
            const updatedAt = handleTimestampOption(timestamps, "updatedAt");
            if (op[key].$each) {
              op[key].$each.forEach(function(subdoc) {
                if (updatedAt != null) {
                  subdoc[updatedAt] = now;
                }
                if (createdAt != null) {
                  subdoc[createdAt] = now;
                }
                applyTimestampsToChildren(now, subdoc, $path.schema);
              });
            } else {
              if (updatedAt != null) {
                op[key][updatedAt] = now;
              }
              if (createdAt != null) {
                op[key][createdAt] = now;
              }
              applyTimestampsToChildren(now, op[key], $path.schema);
            }
          }
        }
      }
    }
    function applyTimestampsToDocumentArray(arr, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      const len = arr.length;
      if (!timestamps) {
        for (let i = 0; i < len; ++i) {
          applyTimestampsToChildren(now, arr[i], schematype.schema);
        }
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      for (let i = 0; i < len; ++i) {
        if (updatedAt != null) {
          arr[i][updatedAt] = now;
        }
        if (createdAt != null) {
          arr[i][createdAt] = now;
        }
        applyTimestampsToChildren(now, arr[i], schematype.schema);
      }
    }
    function applyTimestampsToSingleNested(subdoc, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      if (!timestamps) {
        applyTimestampsToChildren(now, subdoc, schematype.schema);
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      if (updatedAt != null) {
        subdoc[updatedAt] = now;
      }
      if (createdAt != null) {
        subdoc[createdAt] = now;
      }
      applyTimestampsToChildren(now, subdoc, schematype.schema);
    }
    function applyTimestampsToUpdateKey(schema, key, update, now) {
      const keyToSearch = cleanPositionalOperators(key);
      const path = schema.path(keyToSearch);
      if (!path) {
        return;
      }
      const parentSchemaTypes = [];
      const pieces = keyToSearch.split(".");
      for (let i = pieces.length - 1; i > 0; --i) {
        const s = schema.path(pieces.slice(0, i).join("."));
        if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
          parentSchemaTypes.push({ parentPath: key.split(".").slice(0, i).join("."), parentSchemaType: s });
        }
      }
      if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
        applyTimestampsToDocumentArray(update[key], path, now);
      } else if (update[key] && path.$isSingleNested) {
        applyTimestampsToSingleNested(update[key], path, now);
      } else if (parentSchemaTypes.length > 0) {
        for (const item of parentSchemaTypes) {
          const parentPath = item.parentPath;
          const parentSchemaType = item.parentSchemaType;
          const timestamps = parentSchemaType.schema.options.timestamps;
          const updatedAt = handleTimestampOption(timestamps, "updatedAt");
          if (!timestamps || updatedAt == null) {
            continue;
          }
          if (parentSchemaType.$isSingleNested) {
            update[parentPath + "." + updatedAt] = now;
          } else if (parentSchemaType.$isMongooseDocumentArray) {
            let childPath = key.substring(parentPath.length + 1);
            if (/^\d+$/.test(childPath)) {
              update[parentPath + "." + childPath][updatedAt] = now;
              continue;
            }
            const firstDot = childPath.indexOf(".");
            childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;
            update[parentPath + "." + childPath + "." + updatedAt] = now;
          }
        }
      } else if (path.schema != null && path.schema != schema && update[key]) {
        const timestamps = path.schema.options.timestamps;
        const createdAt = handleTimestampOption(timestamps, "createdAt");
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps) {
          return;
        }
        if (updatedAt != null) {
          update[key][updatedAt] = now;
        }
        if (createdAt != null) {
          update[key][createdAt] = now;
        }
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js
var require_applyTimestampsToUpdate = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = applyTimestampsToUpdate;
    function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options) {
      const updates = currentUpdate;
      let _updates = updates;
      const overwrite = get(options, "overwrite", false);
      const timestamps = get(options, "timestamps", true);
      if (!timestamps || updates == null) {
        return currentUpdate;
      }
      const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
      const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
      if (overwrite) {
        if (currentUpdate && currentUpdate.$set) {
          currentUpdate = currentUpdate.$set;
          updates.$set = {};
          _updates = updates.$set;
        }
        if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
          _updates[updatedAt] = now;
        }
        if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
          _updates[createdAt] = now;
        }
        return updates;
      }
      currentUpdate = currentUpdate || {};
      if (Array.isArray(updates)) {
        updates.push({ $set: { [updatedAt]: now } });
        return updates;
      }
      updates.$set = updates.$set || {};
      if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
        let timestampSet = false;
        if (updatedAt.indexOf(".") !== -1) {
          const pieces = updatedAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$set[updatedAt] = now;
        }
        if (updates.hasOwnProperty(updatedAt)) {
          delete updates[updatedAt];
        }
      }
      if (!skipCreatedAt && createdAt) {
        if (currentUpdate[createdAt]) {
          delete currentUpdate[createdAt];
        }
        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
          delete currentUpdate.$set[createdAt];
        }
        let timestampSet = false;
        if (createdAt.indexOf(".") !== -1) {
          const pieces = createdAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$setOnInsert = updates.$setOnInsert || {};
          updates.$setOnInsert[createdAt] = now;
        }
      }
      if (Object.keys(updates.$set).length === 0) {
        delete updates.$set;
      }
      return updates;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js
var require_setDocumentTimestamps = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js"(exports2, module2) {
    "use strict";
    module2.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {
      const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
      const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
      const defaultTimestamp = currentTime != null ? currentTime() : doc.ownerDocument().constructor.base.now();
      if (!skipCreatedAt && (doc.isNew || doc.$isSubdocument) && createdAt && !doc.$__getValue(createdAt) && doc.$__isSelected(createdAt)) {
        doc.$set(createdAt, defaultTimestamp, void 0, { overwriteImmutable: true });
      }
      if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {
        let ts = defaultTimestamp;
        if (doc.isNew && createdAt != null) {
          ts = doc.$__getValue(createdAt);
        }
        doc.$set(updatedAt, ts);
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js
var require_setupTimestamps = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js"(exports2, module2) {
    "use strict";
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var get = require_get();
    var handleTimestampOption = require_handleTimestampOption();
    var setDocumentTimestamps = require_setDocumentTimestamps();
    var symbols = require_symbols2();
    module2.exports = function setupTimestamps(schema, timestamps) {
      const childHasTimestamp = schema.childSchemas.find(withTimestamp);
      function withTimestamp(s) {
        const ts = s.schema.options.timestamps;
        return !!ts;
      }
      if (!timestamps && !childHasTimestamp) {
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
      const schemaAdditions = {};
      schema.$timestamps = { createdAt, updatedAt };
      if (createdAt && !schema.paths[createdAt]) {
        const baseImmutableCreatedAt = schema.base != null ? schema.base.get("timestamps.createdAt.immutable") : null;
        const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;
        schemaAdditions[createdAt] = { [schema.options.typeKey || "type"]: Date, immutable };
      }
      if (updatedAt && !schema.paths[updatedAt]) {
        schemaAdditions[updatedAt] = Date;
      }
      schema.add(schemaAdditions);
      schema.pre("save", function timestampsPreSave(next) {
        const timestampOption = get(this, "$__.saveOptions.timestamps");
        if (timestampOption === false) {
          return next();
        }
        setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);
        next();
      });
      schema.methods.initializeTimestamps = function() {
        const ts = currentTime != null ? currentTime() : this.constructor.base.now();
        if (createdAt && !this.get(createdAt)) {
          this.$set(createdAt, ts);
        }
        if (updatedAt && !this.get(updatedAt)) {
          this.$set(updatedAt, ts);
        }
        if (this.$isSubdocument) {
          return this;
        }
        const subdocs = this.$getAllSubdocs();
        for (const subdoc of subdocs) {
          if (subdoc.initializeTimestamps) {
            subdoc.initializeTimestamps();
          }
        }
        return this;
      };
      _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
      const opts = { query: true, model: false };
      schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
      schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
      schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
      schema.pre("update", opts, _setTimestampsOnUpdate);
      schema.pre("updateOne", opts, _setTimestampsOnUpdate);
      schema.pre("updateMany", opts, _setTimestampsOnUpdate);
      function _setTimestampsOnUpdate(next) {
        const now = currentTime != null ? currentTime() : this.model.base.now();
        if (this.op === "findOneAndReplace" && this.getUpdate() == null) {
          this.setUpdate({});
        }
        applyTimestampsToUpdate(
          now,
          createdAt,
          updatedAt,
          this.getUpdate(),
          this.options,
          this.schema
        );
        applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
        next();
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/validateRef.js
var require_validateRef = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/validateRef.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var util2 = require("util");
    module2.exports = validateRef;
    function validateRef(ref, path) {
      if (typeof ref === "string") {
        return;
      }
      if (typeof ref === "function") {
        return;
      }
      throw new MongooseError('Invalid ref at path "' + path + '". Got ' + util2.inspect(ref, { depth: 0 }));
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/validOps.js
var require_validOps = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/validOps.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.freeze([
      // Read
      "count",
      "countDocuments",
      "distinct",
      "estimatedDocumentCount",
      "find",
      "findOne",
      // Update
      "findOneAndReplace",
      "findOneAndUpdate",
      "replaceOne",
      "update",
      "updateMany",
      "updateOne",
      // Delete
      "deleteMany",
      "deleteOne",
      "findOneAndDelete",
      "findOneAndRemove",
      "remove"
    ]);
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js
var require_applyQueryMiddleware = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js"(exports2, module2) {
    "use strict";
    module2.exports = applyQueryMiddleware;
    var validOps = require_validOps();
    applyQueryMiddleware.middlewareFunctions = validOps.concat([
      "validate"
    ]);
    function applyQueryMiddleware(Query, model) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true
      };
      const middleware = model.hooks.filter((hook) => {
        const contexts = _getContexts(hook);
        if (hook.name === "updateOne") {
          return contexts.query == null || !!contexts.query;
        }
        if (hook.name === "deleteOne") {
          return !!contexts.query || Object.keys(contexts).length === 0;
        }
        if (hook.name === "validate" || hook.name === "remove") {
          return !!contexts.query;
        }
        if (hook.query != null || hook.document != null) {
          return !!hook.query;
        }
        return true;
      });
      Query.prototype._execUpdate = middleware.createWrapper(
        "update",
        Query.prototype._execUpdate,
        null,
        kareemOptions
      );
      Query.prototype.__distinct = middleware.createWrapper(
        "distinct",
        Query.prototype.__distinct,
        null,
        kareemOptions
      );
      Query.prototype.validate = middleware.createWrapper(
        "validate",
        Query.prototype.validate,
        null,
        kareemOptions
      );
      applyQueryMiddleware.middlewareFunctions.filter((v) => v !== "update" && v !== "distinct" && v !== "validate").forEach((fn) => {
        Query.prototype[`_${fn}`] = middleware.createWrapper(
          fn,
          Query.prototype[`_${fn}`],
          null,
          kareemOptions
        );
      });
    }
    function _getContexts(hook) {
      const ret = {};
      if (hook.hasOwnProperty("query")) {
        ret.query = hook.query;
      }
      if (hook.hasOwnProperty("document")) {
        ret.document = hook.document;
      }
      return ret;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/applyHooks.js
var require_applyHooks = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/applyHooks.js"(exports2, module2) {
    "use strict";
    var symbols = require_symbols2();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = applyHooks;
    applyHooks.middlewareFunctions = [
      "deleteOne",
      "save",
      "validate",
      "remove",
      "updateOne",
      "init"
    ];
    var alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap((fn) => [fn, `$__${fn}`]));
    function applyHooks(model, schema, options) {
      options = options || {};
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true,
        contextParameter: true
      };
      const objToDecorate = options.decorateDoc ? model : model.prototype;
      model.$appliedHooks = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        let childModel = null;
        if (type.$isSingleNested) {
          childModel = type.caster;
        } else if (type.$isMongooseDocumentArray) {
          childModel = type.Constructor;
        } else {
          continue;
        }
        if (childModel.$appliedHooks) {
          continue;
        }
        applyHooks(childModel, type.schema, options);
        if (childModel.discriminators != null) {
          const keys = Object.keys(childModel.discriminators);
          for (const key2 of keys) {
            applyHooks(
              childModel.discriminators[key2],
              childModel.discriminators[key2].schema,
              options
            );
          }
        }
      }
      const middleware = schema.s.hooks.filter((hook) => {
        if (hook.name === "updateOne" || hook.name === "deleteOne") {
          return !!hook["document"];
        }
        if (hook.name === "remove" || hook.name === "init") {
          return hook["document"] == null || !!hook["document"];
        }
        if (hook.query != null || hook.document != null) {
          return hook.document !== false;
        }
        return true;
      }).filter((hook) => {
        if (schema.methods[hook.name]) {
          return !hook.fn[symbols.builtInMiddleware];
        }
        return true;
      });
      model._middleware = middleware;
      objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
      for (const method of ["save", "validate", "remove", "deleteOne"]) {
        const toWrap = method === "validate" ? "$__originalValidate" : `$__${method}`;
        const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
        objToDecorate[`$__${method}`] = wrapped;
      }
      objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
      const customMethods = Object.keys(schema.methods);
      const customMethodOptions = Object.assign({}, kareemOptions, {
        // Only use `checkForPromise` for custom methods, because mongoose
        // query thunks are not as consistent as I would like about returning
        // a nullish value rather than the query. If a query thunk returns
        // a query, `checkForPromise` causes infinite recursion
        checkForPromise: true
      });
      for (const method of customMethods) {
        if (alreadyHookedFunctions.has(method)) {
          continue;
        }
        if (!middleware.hasHooks(method)) {
          continue;
        }
        const originalMethod = objToDecorate[method];
        objToDecorate[method] = function() {
          const args = Array.prototype.slice.call(arguments);
          const cb = args.slice(-1).pop();
          const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
          return promiseOrCallback(cb, (callback) => {
            return this[`$__${method}`].apply(
              this,
              argsWithoutCallback.concat([callback])
            );
          }, model.events);
        };
        objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/options.js
var require_options = __commonJS({
  "asset-input/node_modules/mongoose/lib/options.js"(exports2) {
    "use strict";
    exports2.internalToObjectOptions = {
      transform: false,
      virtuals: false,
      getters: false,
      _skipDepopulateTopLevel: true,
      depopulate: true,
      flattenDecimals: false,
      useProjection: false
    };
  }
});

// asset-input/node_modules/mongoose/lib/types/subdocument.js
var require_subdocument = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/subdocument.js"(exports2, module2) {
    "use strict";
    var Document = require_document();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var promiseOrCallback = require_promiseOrCallback();
    var util2 = require("util");
    var utils = require_utils6();
    module2.exports = Subdocument;
    function Subdocument(value, fields, parent, skipId, options) {
      if (parent != null) {
        const parentOptions = { isNew: parent.isNew };
        if ("defaults" in parent.$__) {
          parentOptions.defaults = parent.$__.defaults;
        }
        options = Object.assign(parentOptions, options);
      }
      if (options != null && options.path != null) {
        this.$basePath = options.path;
      }
      Document.call(this, value, fields, skipId, options);
      delete this.$__.priorDoc;
    }
    Subdocument.prototype = Object.create(Document.prototype);
    Object.defineProperty(Subdocument.prototype, "$isSubdocument", {
      configurable: false,
      writable: false,
      value: true
    });
    Object.defineProperty(Subdocument.prototype, "$isSingleNested", {
      configurable: false,
      writable: false,
      value: true
    });
    Subdocument.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Subdocument.prototype.save = function(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      options = options || {};
      if (!options.suppressWarning) {
        utils.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app.");
      }
      return promiseOrCallback(fn, (cb) => {
        this.$__save(cb);
      });
    };
    Subdocument.prototype.$__fullPath = function(path) {
      if (!this.$__.fullPath) {
        this.ownerDocument();
      }
      return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
    };
    Subdocument.prototype.$__pathRelativeToParent = function(p) {
      if (p == null) {
        return this.$basePath;
      }
      return [this.$basePath, p].join(".");
    };
    Subdocument.prototype.$__save = function(fn) {
      return immediate(() => fn(null, this));
    };
    Subdocument.prototype.$isValid = function(path) {
      const parent = this.$parent();
      const fullPath = this.$__pathRelativeToParent(path);
      if (parent != null && fullPath != null) {
        return parent.$isValid(fullPath);
      }
      return Document.prototype.$isValid.call(this, path);
    };
    Subdocument.prototype.markModified = function(path) {
      Document.prototype.markModified.call(this, path);
      const parent = this.$parent();
      const fullPath = this.$__pathRelativeToParent(path);
      if (parent == null || fullPath == null) {
        return;
      }
      const myPath = this.$__pathRelativeToParent().replace(/\.$/, "");
      if (parent.isDirectModified(myPath) || this.isNew) {
        return;
      }
      this.$__parent.markModified(fullPath, this);
    };
    Subdocument.prototype.isModified = function(paths, options, modifiedPaths) {
      const parent = this.$parent();
      if (parent != null) {
        if (Array.isArray(paths) || typeof paths === "string") {
          paths = Array.isArray(paths) ? paths : paths.split(" ");
          paths = paths.map((p) => this.$__pathRelativeToParent(p)).filter((p) => p != null);
        } else if (!paths) {
          paths = this.$__pathRelativeToParent();
        }
        return parent.$isModified(paths, options, modifiedPaths);
      }
      return Document.prototype.isModified.call(this, paths, options, modifiedPaths);
    };
    Subdocument.prototype.$markValid = function(path) {
      Document.prototype.$markValid.call(this, path);
      const parent = this.$parent();
      const fullPath = this.$__pathRelativeToParent(path);
      if (parent != null && fullPath != null) {
        parent.$markValid(fullPath);
      }
    };
    Subdocument.prototype.invalidate = function(path, err, val) {
      Document.prototype.invalidate.call(this, path, err, val);
      const parent = this.$parent();
      const fullPath = this.$__pathRelativeToParent(path);
      if (parent != null && fullPath != null) {
        parent.invalidate(fullPath, err, val);
      } else if (err.kind === "cast" || err.name === "CastError" || fullPath == null) {
        throw err;
      }
      return this.ownerDocument().$__.validationError;
    };
    Subdocument.prototype.$ignore = function(path) {
      Document.prototype.$ignore.call(this, path);
      const parent = this.$parent();
      const fullPath = this.$__pathRelativeToParent(path);
      if (parent != null && fullPath != null) {
        parent.$ignore(fullPath);
      }
    };
    Subdocument.prototype.ownerDocument = function() {
      if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
      }
      let parent = this;
      const paths = [];
      const seenDocs = /* @__PURE__ */ new Set([parent]);
      while (true) {
        if (typeof parent.$__pathRelativeToParent !== "function") {
          break;
        }
        paths.unshift(parent.$__pathRelativeToParent(void 0, true));
        const _parent = parent.$parent();
        if (_parent == null) {
          break;
        }
        parent = _parent;
        if (seenDocs.has(parent)) {
          throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
        }
        seenDocs.add(parent);
      }
      this.$__.fullPath = paths.join(".");
      this.$__.ownerDocument = parent;
      return this.$__.ownerDocument;
    };
    Subdocument.prototype.$__fullPathWithIndexes = function() {
      let parent = this;
      const paths = [];
      const seenDocs = /* @__PURE__ */ new Set([parent]);
      while (true) {
        if (typeof parent.$__pathRelativeToParent !== "function") {
          break;
        }
        paths.unshift(parent.$__pathRelativeToParent(void 0, false));
        const _parent = parent.$parent();
        if (_parent == null) {
          break;
        }
        parent = _parent;
        if (seenDocs.has(parent)) {
          throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
        }
        seenDocs.add(parent);
      }
      return paths.join(".");
    };
    Subdocument.prototype.parent = function() {
      return this.$__parent;
    };
    Subdocument.prototype.$parent = Subdocument.prototype.parent;
    Subdocument.prototype.$__remove = function(cb) {
      if (cb == null) {
        return;
      }
      return cb(null, this);
    };
    Subdocument.prototype.$__removeFromParent = function() {
      this.$__parent.set(this.$basePath, null);
    };
    Subdocument.prototype.remove = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      registerRemoveListener(this);
      if (!options || !options.noop) {
        this.$__removeFromParent();
      }
      return this.$__remove(callback);
    };
    Subdocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
    };
    Subdocument.prototype.inspect = function() {
      return this.toObject({
        transform: false,
        virtuals: false,
        flattenDecimals: false
      });
    };
    if (util2.inspect.custom) {
      Subdocument.prototype[util2.inspect.custom] = Subdocument.prototype.inspect;
    }
    function registerRemoveListener(sub) {
      let owner = sub.ownerDocument();
      function emitRemove() {
        owner.$removeListener("save", emitRemove);
        owner.$removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
      }
      owner.$on("save", emitRemove);
      owner.$on("remove", emitRemove);
    }
  }
});

// asset-input/node_modules/mongoose/lib/types/ArraySubdocument.js
var require_ArraySubdocument = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/ArraySubdocument.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Subdocument = require_subdocument();
    var utils = require_utils6();
    var documentArrayParent = require_symbols().documentArrayParent;
    function ArraySubdocument(obj, parentArr, skipId, fields, index) {
      if (utils.isMongooseDocumentArray(parentArr)) {
        this.__parentArray = parentArr;
        this[documentArrayParent] = parentArr.$parent();
      } else {
        this.__parentArray = void 0;
        this[documentArrayParent] = void 0;
      }
      this.$setIndex(index);
      this.$__parent = this[documentArrayParent];
      Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, { isNew: true });
    }
    ArraySubdocument.prototype = Object.create(Subdocument.prototype);
    ArraySubdocument.prototype.constructor = ArraySubdocument;
    Object.defineProperty(ArraySubdocument.prototype, "$isSingleNested", {
      configurable: false,
      writable: false,
      value: false
    });
    Object.defineProperty(ArraySubdocument.prototype, "$isDocumentArrayElement", {
      configurable: false,
      writable: false,
      value: true
    });
    for (const i in EventEmitter.prototype) {
      ArraySubdocument[i] = EventEmitter.prototype[i];
    }
    ArraySubdocument.prototype.$setIndex = function(index) {
      this.__index = index;
      if (this.$__ != null && this.$__.validationError != null) {
        const keys = Object.keys(this.$__.validationError.errors);
        for (const key of keys) {
          this.invalidate(key, this.$__.validationError.errors[key]);
        }
      }
    };
    ArraySubdocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
    };
    ArraySubdocument.prototype.$__removeFromParent = function() {
      const _id = this._doc._id;
      if (!_id) {
        throw new Error("For your own good, Mongoose does not know how to remove an ArraySubdocument that has no _id");
      }
      this.__parentArray.pull({ _id });
    };
    ArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {
      if (this.__index == null) {
        return null;
      }
      if (!this.$__.fullPath) {
        this.ownerDocument();
      }
      if (skipIndex) {
        return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
      }
      return path ? this.$__.fullPath + "." + this.__index + "." + path : this.$__.fullPath + "." + this.__index;
    };
    ArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {
      if (this.__index == null || (!this.__parentArray || !this.__parentArray.$path)) {
        return null;
      }
      if (skipIndex) {
        return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + "." + path;
      }
      if (path == null) {
        return this.__parentArray.$path() + "." + this.__index;
      }
      return this.__parentArray.$path() + "." + this.__index + "." + path;
    };
    ArraySubdocument.prototype.$parent = function() {
      return this[documentArrayParent];
    };
    ArraySubdocument.prototype.parentArray = function() {
      return this.__parentArray;
    };
    module2.exports = ArraySubdocument;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js
var require_cleanModifiedSubpaths = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js"(exports2, module2) {
    "use strict";
    module2.exports = function cleanModifiedSubpaths(doc, path, options) {
      options = options || {};
      const skipDocArrays = options.skipDocArrays;
      let deleted = 0;
      if (!doc) {
        return deleted;
      }
      for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths("modify"))) {
        if (skipDocArrays) {
          const schemaType = doc.$__schema.path(modifiedPath);
          if (schemaType && schemaType.$isMongooseDocumentArray) {
            continue;
          }
        }
        if (modifiedPath.startsWith(path + ".")) {
          doc.$__.activePaths.clearPath(modifiedPath);
          ++deleted;
          if (doc.$isSubdocument) {
            const owner = doc.ownerDocument();
            const fullPath = doc.$__fullPath(modifiedPath);
            owner.$__.activePaths.clearPath(fullPath);
          }
        }
      }
      return deleted;
    };
  }
});

// asset-input/node_modules/mongoose/lib/types/array/methods/index.js
var require_methods = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/array/methods/index.js"(exports2, module2) {
    "use strict";
    var Document = require_document();
    var ArraySubdocument = require_ArraySubdocument();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var mpath = require_mpath();
    var utils = require_utils6();
    var isBsonType = require_isBsonType();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var slicedSymbol = Symbol("mongoose#Array#sliced");
    var _basePush = Array.prototype.push;
    var methods = {
      /**
       * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.
       *
       * If no atomics exist, we return all array values after conversion.
       *
       * @return {Array}
       * @method $__getAtomics
       * @memberOf MongooseArray
       * @instance
       * @api private
       */
      $__getAtomics() {
        const ret = [];
        const keys = Object.keys(this[arrayAtomicsSymbol] || {});
        let i = keys.length;
        const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
        if (i === 0) {
          ret[0] = ["$set", this.toObject(opts)];
          return ret;
        }
        while (i--) {
          const op = keys[i];
          let val = this[arrayAtomicsSymbol][op];
          if (utils.isMongooseObject(val)) {
            val = val.toObject(opts);
          } else if (Array.isArray(val)) {
            val = this.toObject.call(val, opts);
          } else if (val != null && Array.isArray(val.$each)) {
            val.$each = this.toObject.call(val.$each, opts);
          } else if (val != null && typeof val.valueOf === "function") {
            val = val.valueOf();
          }
          if (op === "$addToSet") {
            val = { $each: val };
          }
          ret.push([op, val]);
        }
        return ret;
      },
      /*!
       * ignore
       */
      $atomics() {
        return this[arrayAtomicsSymbol];
      },
      /*!
       * ignore
       */
      $parent() {
        return this[arrayParentSymbol];
      },
      /*!
       * ignore
       */
      $path() {
        return this[arrayPathSymbol];
      },
      /**
       * Atomically shifts the array at most one time per document `save()`.
       *
       * #### Note:
       *
       * _Calling this multiple times on an array before saving sends the same command as calling it once._
       * _This update is implemented using the MongoDB [$pop](https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
       *
       *      doc.array = [1,2,3];
       *
       *      const shifted = doc.array.$shift();
       *      console.log(shifted); // 1
       *      console.log(doc.array); // [2,3]
       *
       *      // no affect
       *      shifted = doc.array.$shift();
       *      console.log(doc.array); // [2,3]
       *
       *      doc.save(function (err) {
       *        if (err) return handleError(err);
       *
       *        // we saved, now $shift works again
       *        shifted = doc.array.$shift();
       *        console.log(shifted ); // 2
       *        console.log(doc.array); // [3]
       *      })
       *
       * @api public
       * @memberOf MongooseArray
       * @instance
       * @method $shift
       * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
       */
      $shift() {
        this._registerAtomic("$pop", -1);
        this._markModified();
        const __array = this.__array;
        if (__array._shifted) {
          return;
        }
        __array._shifted = true;
        return [].shift.call(__array);
      },
      /**
       * Pops the array atomically at most one time per document `save()`.
       *
       * #### NOTE:
       *
       * _Calling this multiple times on an array before saving sends the same command as calling it once._
       * _This update is implemented using the MongoDB [$pop](https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
       *
       *      doc.array = [1,2,3];
       *
       *      const popped = doc.array.$pop();
       *      console.log(popped); // 3
       *      console.log(doc.array); // [1,2]
       *
       *      // no affect
       *      popped = doc.array.$pop();
       *      console.log(doc.array); // [1,2]
       *
       *      doc.save(function (err) {
       *        if (err) return handleError(err);
       *
       *        // we saved, now $pop works again
       *        popped = doc.array.$pop();
       *        console.log(popped); // 2
       *        console.log(doc.array); // [1]
       *      })
       *
       * @api public
       * @method $pop
       * @memberOf MongooseArray
       * @instance
       * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
       * @method $pop
       * @memberOf MongooseArray
       */
      $pop() {
        this._registerAtomic("$pop", 1);
        this._markModified();
        if (this._popped) {
          return;
        }
        this._popped = true;
        return [].pop.call(this);
      },
      /*!
       * ignore
       */
      $schema() {
        return this[arraySchemaSymbol];
      },
      /**
       * Casts a member based on this arrays schema.
       *
       * @param {any} value
       * @return value the casted value
       * @method _cast
       * @api private
       * @memberOf MongooseArray
       */
      _cast(value) {
        let populated = false;
        let Model;
        const parent = this[arrayParentSymbol];
        if (parent) {
          populated = parent.$populated(this[arrayPathSymbol], true);
        }
        if (populated && value !== null && value !== void 0) {
          Model = populated.options[populateModelSymbol];
          if (Buffer.isBuffer(value) || isBsonType(value, "ObjectID") || !utils.isObject(value)) {
            value = { _id: value };
          }
          const isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== void 0;
          if (!isDisc) {
            value = new Model(value);
          }
          return this[arraySchemaSymbol].caster.applySetters(value, parent, true);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, parent, false);
      },
      /**
       * Internal helper for .map()
       *
       * @api private
       * @return {Number}
       * @method _mapCast
       * @memberOf MongooseArray
       */
      _mapCast(val, index) {
        return this._cast(val, this.length + index);
      },
      /**
       * Marks this array as modified.
       *
       * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)
       *
       * @param {ArraySubdocument} subdoc the embedded doc that invoked this method on the Array
       * @param {String} embeddedPath the path which changed in the subdoc
       * @method _markModified
       * @api private
       * @memberOf MongooseArray
       */
      _markModified(elem) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            dirtyPath = dirtyPath + "." + elem;
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
        }
        return this;
      },
      /**
       * Register an atomic operation with the parent.
       *
       * @param {Array} op operation
       * @param {any} val
       * @method _registerAtomic
       * @api private
       * @memberOf MongooseArray
       */
      _registerAtomic(op, val) {
        if (this[slicedSymbol]) {
          return;
        }
        if (op === "$set") {
          this[arrayAtomicsSymbol] = { $set: val };
          cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
          this._markModified();
          return this;
        }
        const atomics = this[arrayAtomicsSymbol];
        if (op === "$pop" && !("$pop" in atomics)) {
          const _this = this;
          this[arrayParentSymbol].once("save", function() {
            _this._popped = _this._shifted = null;
          });
        }
        if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {
          this[arrayAtomicsSymbol] = { $set: this };
          return this;
        }
        let selector;
        if (op === "$pullAll" || op === "$addToSet") {
          atomics[op] || (atomics[op] = []);
          atomics[op] = atomics[op].concat(val);
        } else if (op === "$pullDocs") {
          const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
          if (val[0] instanceof ArraySubdocument) {
            selector = pullOp["$or"] || (pullOp["$or"] = []);
            Array.prototype.push.apply(selector, val.map((v) => {
              return v.toObject({
                transform: (doc, ret) => {
                  if (v == null || v.$__ == null) {
                    return ret;
                  }
                  Object.keys(v.$__.activePaths.getStatePaths("default")).forEach((path) => {
                    mpath.unset(path, ret);
                    _minimizePath(ret, path);
                  });
                  return ret;
                },
                virtuals: false
              });
            }));
          } else {
            selector = pullOp["_id"] || (pullOp["_id"] = { $in: [] });
            selector["$in"] = selector["$in"].concat(val);
          }
        } else if (op === "$push") {
          atomics.$push = atomics.$push || { $each: [] };
          if (val != null && utils.hasUserDefinedProperty(val, "$each")) {
            atomics.$push = val;
          } else {
            atomics.$push.$each = atomics.$push.$each.concat(val);
          }
        } else {
          atomics[op] = val;
        }
        return this;
      },
      /**
       * Adds values to the array if not already present.
       *
       * #### Example:
       *
       *     console.log(doc.array) // [2,3,4]
       *     const added = doc.array.addToSet(4,5);
       *     console.log(doc.array) // [2,3,4,5]
       *     console.log(added)     // [5]
       *
       * @param {...any} [args]
       * @return {Array} the values that were added
       * @memberOf MongooseArray
       * @api public
       * @method addToSet
       */
      addToSet() {
        _checkManualPopulation(this, arguments);
        let values = [].map.call(arguments, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        const added = [];
        let type = "";
        if (values[0] instanceof ArraySubdocument) {
          type = "doc";
        } else if (values[0] instanceof Date) {
          type = "date";
        }
        const rawValues = utils.isMongooseArray(values) ? values.__array : this;
        const rawArray = utils.isMongooseArray(this) ? this.__array : this;
        rawValues.forEach(function(v) {
          let found;
          const val = +v;
          switch (type) {
            case "doc":
              found = this.some(function(doc) {
                return doc.equals(v);
              });
              break;
            case "date":
              found = this.some(function(d) {
                return +d === val;
              });
              break;
            default:
              found = ~this.indexOf(v);
          }
          if (!found) {
            this._markModified();
            rawArray.push(v);
            this._registerAtomic("$addToSet", v);
            [].push.call(added, v);
          }
        }, this);
        return added;
      },
      /**
       * Returns the number of pending atomic operations to send to the db for this array.
       *
       * @api private
       * @return {Number}
       * @method hasAtomics
       * @memberOf MongooseArray
       */
      hasAtomics() {
        if (!utils.isPOJO(this[arrayAtomicsSymbol])) {
          return 0;
        }
        return Object.keys(this[arrayAtomicsSymbol]).length;
      },
      /**
       * Return whether or not the `obj` is included in the array.
       *
       * @param {Object} obj the item to check
       * @param {Number} fromIndex
       * @return {Boolean}
       * @api public
       * @method includes
       * @memberOf MongooseArray
       */
      includes(obj, fromIndex) {
        const ret = this.indexOf(obj, fromIndex);
        return ret !== -1;
      },
      /**
       * Return the index of `obj` or `-1` if not found.
       *
       * @param {Object} obj the item to look for
       * @param {Number} fromIndex
       * @return {Number}
       * @api public
       * @method indexOf
       * @memberOf MongooseArray
       */
      indexOf(obj, fromIndex) {
        if (isBsonType(obj, "ObjectID")) {
          obj = obj.toString();
        }
        fromIndex = fromIndex == null ? 0 : fromIndex;
        const len = this.length;
        for (let i = fromIndex; i < len; ++i) {
          if (obj == this[i]) {
            return i;
          }
        }
        return -1;
      },
      /**
       * Helper for console.log
       *
       * @api public
       * @method inspect
       * @memberOf MongooseArray
       */
      inspect() {
        return JSON.stringify(this);
      },
      /**
       * Pushes items to the array non-atomically.
       *
       * #### Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @param {...any} [args]
       * @api public
       * @method nonAtomicPush
       * @memberOf MongooseArray
       */
      nonAtomicPush() {
        const values = [].map.call(arguments, this._mapCast, this);
        this._markModified();
        const ret = [].push.apply(this, values);
        this._registerAtomic("$set", this);
        return ret;
      },
      /**
       * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.
       *
       * #### Note:
       *
       * _marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it._
       *
       * @see MongooseArray#$pop #types_array_MongooseArray-%24pop
       * @api public
       * @method pop
       * @memberOf MongooseArray
       */
      pop() {
        this._markModified();
        const ret = [].pop.call(this);
        this._registerAtomic("$set", this);
        return ret;
      },
      /**
       * Pulls items from the array atomically. Equality is determined by casting
       * the provided value to an embedded document and comparing using
       * [the `Document.equals()` function.](/docs/api/document.html#document_Document-equals)
       *
       * #### Example:
       *
       *     doc.array.pull(ObjectId)
       *     doc.array.pull({ _id: 'someId' })
       *     doc.array.pull(36)
       *     doc.array.pull('tag 1', 'tag 2')
       *
       * To remove a document from a subdocument array we may pass an object with a matching `_id`.
       *
       *     doc.subdocs.push({ _id: 4815162342 })
       *     doc.subdocs.pull({ _id: 4815162342 }) // removed
       *
       * Or we may passing the _id directly and let mongoose take care of it.
       *
       *     doc.subdocs.push({ _id: 4815162342 })
       *     doc.subdocs.pull(4815162342); // works
       *
       * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.
       *
       * @param {...any} [args]
       * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
       * @api public
       * @method pull
       * @memberOf MongooseArray
       */
      pull() {
        const values = [].map.call(arguments, this._cast, this);
        const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
        let i = cur.length;
        let mem;
        this._markModified();
        while (i--) {
          mem = cur[i];
          if (mem instanceof Document) {
            const some = values.some(function(v) {
              return mem.equals(v);
            });
            if (some) {
              [].splice.call(cur, i, 1);
            }
          } else if (~cur.indexOf.call(values, mem)) {
            [].splice.call(cur, i, 1);
          }
        }
        if (values[0] instanceof ArraySubdocument) {
          this._registerAtomic("$pullDocs", values.map(function(v) {
            const _id = v.$__getValue("_id");
            if (_id === void 0 || v.$isDefault("_id")) {
              return v;
            }
            return _id;
          }));
        } else {
          this._registerAtomic("$pullAll", values);
        }
        if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
          this._registerAtomic("$set", this);
        }
        return this;
      },
      /**
       * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
       *
       * #### Example:
       *
       *     const schema = Schema({ nums: [Number] });
       *     const Model = mongoose.model('Test', schema);
       *
       *     const doc = await Model.create({ nums: [3, 4] });
       *     doc.nums.push(5); // Add 5 to the end of the array
       *     await doc.save();
       *
       *     // You can also pass an object with `$each` as the
       *     // first parameter to use MongoDB's `$position`
       *     doc.nums.push({
       *       $each: [1, 2],
       *       $position: 0
       *     });
       *     doc.nums; // [1, 2, 3, 4, 5]
       *
       * @param {...Object} [args]
       * @api public
       * @method push
       * @memberOf MongooseArray
       */
      push() {
        let values = arguments;
        let atomic = values;
        const isOverwrite = values[0] != null && utils.hasUserDefinedProperty(values[0], "$each");
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        if (isOverwrite) {
          atomic = values[0];
          values = values[0].$each;
        }
        if (this[arraySchemaSymbol] == null) {
          return _basePush.apply(this, values);
        }
        _checkManualPopulation(this, values);
        const parent = this[arrayParentSymbol];
        values = [].map.call(values, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(
          values,
          parent,
          void 0,
          void 0,
          { skipDocumentArrayCast: true }
        );
        let ret;
        const atomics = this[arrayAtomicsSymbol];
        this._markModified();
        if (isOverwrite) {
          atomic.$each = values;
          if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 && atomics.$push.$position != atomic.$position) {
            if (atomic.$position != null) {
              [].splice.apply(arr, [atomic.$position, 0].concat(values));
              ret = arr.length;
            } else {
              ret = [].push.apply(arr, values);
            }
            this._registerAtomic("$set", this);
          } else if (atomic.$position != null) {
            [].splice.apply(arr, [atomic.$position, 0].concat(values));
            ret = this.length;
          } else {
            ret = [].push.apply(arr, values);
          }
        } else {
          atomic = values;
          ret = [].push.apply(arr, values);
        }
        this._registerAtomic("$push", atomic);
        return ret;
      },
      /**
       * Alias of [pull](#mongoosearray_MongooseArray-pull)
       *
       * @see MongooseArray#pull #types_array_MongooseArray-pull
       * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
       * @api public
       * @memberOf MongooseArray
       * @instance
       * @method remove
       */
      remove() {
        return this.pull.apply(this, arguments);
      },
      /**
       * Sets the casted `val` at index `i` and marks the array modified.
       *
       * #### Example:
       *
       *     // given documents based on the following
       *     const Doc = mongoose.model('Doc', new Schema({ array: [Number] }));
       *
       *     const doc = new Doc({ array: [2,3,4] })
       *
       *     console.log(doc.array) // [2,3,4]
       *
       *     doc.array.set(1,"5");
       *     console.log(doc.array); // [2,5,4] // properly cast to number
       *     doc.save() // the change is saved
       *
       *     // VS not using array#set
       *     doc.array[1] = "5";
       *     console.log(doc.array); // [2,"5",4] // no casting
       *     doc.save() // change is not saved
       *
       * @return {Array} this
       * @api public
       * @method set
       * @memberOf MongooseArray
       */
      set(i, val, skipModified) {
        const arr = this.__array;
        if (skipModified) {
          arr[i] = val;
          return this;
        }
        const value = methods._cast.call(this, val, i);
        methods._markModified.call(this, i);
        arr[i] = value;
        return this;
      },
      /**
       * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
       *
       * #### Example:
       *
       *     doc.array = [2,3];
       *     const res = doc.array.shift();
       *     console.log(res) // 2
       *     console.log(doc.array) // [3]
       *
       * #### Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method shift
       * @memberOf MongooseArray
       */
      shift() {
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        const ret = [].shift.call(arr);
        this._registerAtomic("$set", this);
        return ret;
      },
      /**
       * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.
       *
       * #### Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method sort
       * @memberOf MongooseArray
       * @see https://masteringjs.io/tutorials/fundamentals/array-sort
       */
      sort() {
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        const ret = [].sort.apply(arr, arguments);
        this._registerAtomic("$set", this);
        return ret;
      },
      /**
       * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
       *
       * #### Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method splice
       * @memberOf MongooseArray
       * @see https://masteringjs.io/tutorials/fundamentals/array-splice
       */
      splice() {
        let ret;
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
        if (arguments.length) {
          let vals;
          if (this[arraySchemaSymbol] == null) {
            vals = arguments;
          } else {
            vals = [];
            for (let i = 0; i < arguments.length; ++i) {
              vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
            }
          }
          ret = [].splice.apply(arr, vals);
          this._registerAtomic("$set", this);
        }
        return ret;
      },
      /*!
       * ignore
       */
      toBSON() {
        return this.toObject(internalToObjectOptions);
      },
      /**
       * Returns a native js Array.
       *
       * @param {Object} options
       * @return {Array}
       * @api public
       * @method toObject
       * @memberOf MongooseArray
       */
      toObject(options) {
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        if (options && options.depopulate) {
          options = utils.clone(options);
          options._isNested = true;
          return [].concat(arr).map(function(doc) {
            return doc instanceof Document ? doc.toObject(options) : doc;
          });
        }
        return [].concat(arr);
      },
      $toObject() {
        return this.constructor.prototype.toObject.apply(this, arguments);
      },
      /**
       * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
       *
       * #### Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method unshift
       * @memberOf MongooseArray
       */
      unshift() {
        _checkManualPopulation(this, arguments);
        let values;
        if (this[arraySchemaSymbol] == null) {
          values = arguments;
        } else {
          values = [].map.call(arguments, this._cast, this);
          values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        }
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        [].unshift.apply(arr, values);
        this._registerAtomic("$set", this);
        return this.length;
      }
    };
    function _isAllSubdocs(docs, ref) {
      if (!ref) {
        return false;
      }
      for (const arg of docs) {
        if (arg == null) {
          return false;
        }
        const model = arg.constructor;
        if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {
          return false;
        }
      }
      return true;
    }
    function _minimizePath(obj, parts, i) {
      if (typeof parts === "string") {
        if (parts.indexOf(".") === -1) {
          return;
        }
        parts = mpath.stringToParts(parts);
      }
      i = i || 0;
      if (i >= parts.length) {
        return;
      }
      if (obj == null || typeof obj !== "object") {
        return;
      }
      _minimizePath(obj[parts[0]], parts, i + 1);
      if (obj[parts[0]] != null && typeof obj[parts[0]] === "object" && Object.keys(obj[parts[0]]).length === 0) {
        delete obj[parts[0]];
      }
    }
    function _checkManualPopulation(arr, docs) {
      const ref = arr == null ? null : arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;
      if (arr.length === 0 && docs.length !== 0) {
        if (_isAllSubdocs(docs, ref)) {
          arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {
            [populateModelSymbol]: docs[0].constructor
          });
        }
      }
    }
    var returnVanillaArrayMethods = [
      "filter",
      "flat",
      "flatMap",
      "map",
      "slice"
    ];
    for (const method of returnVanillaArrayMethods) {
      if (Array.prototype[method] == null) {
        continue;
      }
      methods[method] = function() {
        const _arr = utils.isMongooseArray(this) ? this.__array : this;
        const arr = [].concat(_arr);
        return arr[method].apply(arr, arguments);
      };
    }
    module2.exports = methods;
  }
});

// asset-input/node_modules/mongoose/lib/types/array/index.js
var require_array = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/array/index.js"(exports2, module2) {
    "use strict";
    var Document = require_document();
    var mongooseArrayMethods = require_methods();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var _basePush = Array.prototype.push;
    var numberRE = /^\d+$/;
    function MongooseArray(values, path, doc, schematype) {
      let __array;
      if (Array.isArray(values)) {
        const len = values.length;
        if (len === 0) {
          __array = new Array();
        } else if (len === 1) {
          __array = new Array(1);
          __array[0] = values[0];
        } else if (len < 1e4) {
          __array = new Array();
          _basePush.apply(__array, values);
        } else {
          __array = new Array();
          for (let i = 0; i < len; ++i) {
            _basePush.call(__array, values[i]);
          }
        }
      } else {
        __array = [];
      }
      const internals = {
        [arrayAtomicsSymbol]: {},
        [arrayAtomicsBackupSymbol]: void 0,
        [arrayPathSymbol]: path,
        [arraySchemaSymbol]: schematype,
        [arrayParentSymbol]: void 0,
        isMongooseArray: true,
        isMongooseArrayProxy: true,
        __array
      };
      if (values && values[arrayAtomicsSymbol] != null) {
        internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
      }
      if (doc != null && doc instanceof Document) {
        internals[arrayParentSymbol] = doc;
        internals[arraySchemaSymbol] = schematype || doc.schema.path(path);
      }
      const proxy = new Proxy(__array, {
        get: function(target, prop) {
          if (internals.hasOwnProperty(prop)) {
            return internals[prop];
          }
          if (mongooseArrayMethods.hasOwnProperty(prop)) {
            return mongooseArrayMethods[prop];
          }
          return __array[prop];
        },
        set: function(target, prop, value) {
          if (typeof prop === "string" && numberRE.test(prop)) {
            mongooseArrayMethods.set.call(proxy, prop, value, false);
          } else if (internals.hasOwnProperty(prop)) {
            internals[prop] = value;
          } else {
            __array[prop] = value;
          }
          return true;
        }
      });
      return proxy;
    }
    module2.exports = exports2 = MongooseArray;
  }
});

// asset-input/node_modules/mongoose/lib/types/buffer.js
var require_buffer = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/buffer.js"(exports2, module2) {
    "use strict";
    var Binary = require_driver().get().Binary;
    var utils = require_utils6();
    function MongooseBuffer(value, encode, offset) {
      let val = value;
      if (value == null) {
        val = 0;
      }
      let encoding;
      let path;
      let doc;
      if (Array.isArray(encode)) {
        path = encode[0];
        doc = encode[1];
      } else {
        encoding = encode;
      }
      let buf;
      if (typeof val === "number" || val instanceof Number) {
        buf = Buffer.alloc(val);
      } else {
        buf = Buffer.from(val, encoding, offset);
      }
      utils.decorate(buf, MongooseBuffer.mixin);
      buf.isMongooseBuffer = true;
      buf[MongooseBuffer.pathSymbol] = path;
      buf[parentSymbol] = doc;
      buf._subtype = 0;
      return buf;
    }
    var pathSymbol = Symbol.for("mongoose#Buffer#_path");
    var parentSymbol = Symbol.for("mongoose#Buffer#_parent");
    MongooseBuffer.pathSymbol = pathSymbol;
    MongooseBuffer.mixin = {
      /**
       * Default subtype for the Binary representing this Buffer
       *
       * @api private
       * @property _subtype
       * @memberOf MongooseBuffer.mixin
       * @static
       */
      _subtype: void 0,
      /**
       * Marks this buffer as modified.
       *
       * @api private
       * @method _markModified
       * @memberOf MongooseBuffer.mixin
       * @static
       */
      _markModified: function() {
        const parent = this[parentSymbol];
        if (parent) {
          parent.markModified(this[MongooseBuffer.pathSymbol]);
        }
        return this;
      },
      /**
       * Writes the buffer.
       *
       * @api public
       * @method write
       * @memberOf MongooseBuffer.mixin
       * @static
       */
      write: function() {
        const written = Buffer.prototype.write.apply(this, arguments);
        if (written > 0) {
          this._markModified();
        }
        return written;
      },
      /**
       * Copies the buffer.
       *
       * #### Note:
       *
       * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
       *
       * @return {Number} The number of bytes copied.
       * @param {Buffer} target
       * @method copy
       * @memberOf MongooseBuffer.mixin
       * @static
       */
      copy: function(target) {
        const ret = Buffer.prototype.copy.apply(this, arguments);
        if (target && target.isMongooseBuffer) {
          target._markModified();
        }
        return ret;
      }
    };
    utils.each(
      [
        // node < 0.5
        "writeUInt8",
        "writeUInt16",
        "writeUInt32",
        "writeInt8",
        "writeInt16",
        "writeInt32",
        "writeFloat",
        "writeDouble",
        "fill",
        "utf8Write",
        "binaryWrite",
        "asciiWrite",
        "set",
        // node >= 0.5
        "writeUInt16LE",
        "writeUInt16BE",
        "writeUInt32LE",
        "writeUInt32BE",
        "writeInt16LE",
        "writeInt16BE",
        "writeInt32LE",
        "writeInt32BE",
        "writeFloatLE",
        "writeFloatBE",
        "writeDoubleLE",
        "writeDoubleBE"
      ],
      function(method) {
        if (!Buffer.prototype[method]) {
          return;
        }
        MongooseBuffer.mixin[method] = function() {
          const ret = Buffer.prototype[method].apply(this, arguments);
          this._markModified();
          return ret;
        };
      }
    );
    MongooseBuffer.mixin.toObject = function(options) {
      const subtype = typeof options === "number" ? options : this._subtype || 0;
      return new Binary(Buffer.from(this), subtype);
    };
    MongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;
    MongooseBuffer.mixin.toBSON = function() {
      return new Binary(this, this._subtype || 0);
    };
    MongooseBuffer.mixin.equals = function(other) {
      if (!Buffer.isBuffer(other)) {
        return false;
      }
      if (this.length !== other.length) {
        return false;
      }
      for (let i = 0; i < this.length; ++i) {
        if (this[i] !== other[i]) {
          return false;
        }
      }
      return true;
    };
    MongooseBuffer.mixin.subtype = function(subtype) {
      if (typeof subtype !== "number") {
        throw new TypeError("Invalid subtype. Expected a number");
      }
      if (this._subtype !== subtype) {
        this._markModified();
      }
      this._subtype = subtype;
    };
    MongooseBuffer.Binary = Binary;
    module2.exports = MongooseBuffer;
  }
});

// asset-input/node_modules/mongoose/lib/cast/objectid.js
var require_objectid4 = __commonJS({
  "asset-input/node_modules/mongoose/lib/cast/objectid.js"(exports2, module2) {
    "use strict";
    var isBsonType = require_isBsonType();
    var ObjectId2 = require_driver().get().ObjectId;
    module2.exports = function castObjectId(value) {
      if (value == null) {
        return value;
      }
      if (isBsonType(value, "ObjectID")) {
        return value;
      }
      if (value._id) {
        if (isBsonType(value._id, "ObjectID")) {
          return value._id;
        }
        if (value._id.toString instanceof Function) {
          return new ObjectId2(value._id.toString());
        }
      }
      if (value.toString instanceof Function) {
        return new ObjectId2(value.toString());
      }
      return new ObjectId2(value);
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js
var require_areDiscriminatorValuesEqual = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js"(exports2, module2) {
    "use strict";
    var isBsonType = require_isBsonType();
    module2.exports = function areDiscriminatorValuesEqual(a, b) {
      if (typeof a === "string" && typeof b === "string") {
        return a === b;
      }
      if (typeof a === "number" && typeof b === "number") {
        return a === b;
      }
      if (isBsonType(a, "ObjectID") && isBsonType(b, "ObjectID")) {
        return a.toString() === b.toString();
      }
      return false;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js
var require_getDiscriminatorByValue = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js"(exports2, module2) {
    "use strict";
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getDiscriminatorByValue(discriminators, value) {
      if (discriminators == null) {
        return null;
      }
      for (const name of Object.keys(discriminators)) {
        const it = discriminators[name];
        if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
          return it;
        }
      }
      return null;
    };
  }
});

// asset-input/node_modules/mongoose/lib/types/DocumentArray/methods/index.js
var require_methods2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/DocumentArray/methods/index.js"(exports2, module2) {
    "use strict";
    var ArrayMethods = require_methods();
    var Document = require_document();
    var castObjectId = require_objectid4();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils = require_utils6();
    var isBsonType = require_isBsonType();
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var methods = {
      /*!
       * ignore
       */
      toBSON() {
        return this.toObject(internalToObjectOptions);
      },
      /*!
       * ignore
       */
      getArrayParent() {
        return this[arrayParentSymbol];
      },
      /**
       * Overrides MongooseArray#cast
       *
       * @method _cast
       * @api private
       * @memberOf MongooseDocumentArray
       */
      _cast(value, index) {
        if (this[arraySchemaSymbol] == null) {
          return value;
        }
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        const isInstance = Constructor.$isMongooseDocumentArray ? utils.isMongooseDocumentArray(value) : value instanceof Constructor;
        if (isInstance || // Hack re: #5001, see #5005
        value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
          if (!(value[documentArrayParent] && value.__parentArray)) {
            value[documentArrayParent] = this[arrayParentSymbol];
            value.__parentArray = this;
          }
          value.$setIndex(index);
          return value;
        }
        if (value === void 0 || value === null) {
          return null;
        }
        if (Buffer.isBuffer(value) || isBsonType(value, "ObjectID") || !utils.isObject(value)) {
          value = { _id: value };
        }
        if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof value[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        if (Constructor.$isMongooseDocumentArray) {
          return Constructor.cast(value, this, void 0, void 0, index);
        }
        const ret = new Constructor(value, this, void 0, void 0, index);
        ret.isNew = true;
        return ret;
      },
      /**
       * Searches array items for the first document with a matching _id.
       *
       * #### Example:
       *
       *     const embeddedDoc = m.array.id(some_id);
       *
       * @return {EmbeddedDocument|null} the subdocument or null if not found.
       * @param {ObjectId|String|Number|Buffer} id
       * @TODO cast to the _id based on schema for proper comparison
       * @method id
       * @api public
       * @memberOf MongooseDocumentArray
       */
      id(id) {
        let casted;
        let sid;
        let _id;
        try {
          casted = castObjectId(id).toString();
        } catch (e) {
          casted = null;
        }
        for (const val of this) {
          if (!val) {
            continue;
          }
          _id = val.get("_id");
          if (_id === null || typeof _id === "undefined") {
            continue;
          } else if (_id instanceof Document) {
            sid || (sid = String(id));
            if (sid == _id._id) {
              return val;
            }
          } else if (!isBsonType(id, "ObjectID") && !isBsonType(_id, "ObjectID")) {
            if (id == _id || utils.deepEqual(id, _id)) {
              return val;
            }
          } else if (casted == _id) {
            return val;
          }
        }
        return null;
      },
      /**
       * Returns a native js Array of plain js objects
       *
       * #### Note:
       *
       * _Each sub-document is converted to a plain object by calling its `#toObject` method._
       *
       * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion
       * @return {Array}
       * @method toObject
       * @api public
       * @memberOf MongooseDocumentArray
       */
      toObject(options) {
        return [].concat(this.map(function(doc) {
          if (doc == null) {
            return null;
          }
          if (typeof doc.toObject !== "function") {
            return doc;
          }
          return doc.toObject(options);
        }));
      },
      $toObject() {
        return this.constructor.prototype.toObject.apply(this, arguments);
      },
      /**
       * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
       *
       * @param {...Object} [args]
       * @api public
       * @method push
       * @memberOf MongooseDocumentArray
       */
      push() {
        const ret = ArrayMethods.push.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
      },
      /**
       * Pulls items from the array atomically.
       *
       * @param {...Object} [args]
       * @api public
       * @method pull
       * @memberOf MongooseDocumentArray
       */
      pull() {
        const ret = ArrayMethods.pull.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
      },
      /**
       * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
       * @api private
       */
      shift() {
        const ret = ArrayMethods.shift.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
      },
      /**
       * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
       * @api private
       */
      splice() {
        const ret = ArrayMethods.splice.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
      },
      /**
       * Helper for console.log
       *
       * @method inspect
       * @api public
       * @memberOf MongooseDocumentArray
       */
      inspect() {
        return this.toObject();
      },
      /**
       * Creates a subdocument casted to this schema.
       *
       * This is the same subdocument constructor used for casting.
       *
       * @param {Object} obj the value to cast to this arrays SubDocument schema
       * @method create
       * @api public
       * @memberOf MongooseDocumentArray
       */
      create(obj) {
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        if (obj && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof obj[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        return new Constructor(obj, this);
      },
      /*!
       * ignore
       */
      notify(event) {
        const _this = this;
        return function notify(val, _arr) {
          _arr = _arr || _this;
          let i = _arr.length;
          while (i--) {
            if (_arr[i] == null) {
              continue;
            }
            switch (event) {
              case "save":
                val = _this[i];
                break;
              default:
                break;
            }
            if (utils.isMongooseArray(_arr[i])) {
              notify(val, _arr[i]);
            } else if (_arr[i]) {
              _arr[i].emit(event, val);
            }
          }
        };
      },
      set(i, val, skipModified) {
        const arr = this.__array;
        if (skipModified) {
          arr[i] = val;
          return this;
        }
        const value = methods._cast.call(this, val, i);
        methods._markModified.call(this, i);
        arr[i] = value;
        return this;
      },
      _markModified(elem, embeddedPath) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            if (embeddedPath != null) {
              const index = elem.__index;
              dirtyPath = dirtyPath + "." + index + "." + embeddedPath;
            } else {
              dirtyPath = dirtyPath + "." + elem;
            }
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
        }
        return this;
      }
    };
    module2.exports = methods;
    function _updateParentPopulated(arr) {
      const parent = arr[arrayParentSymbol];
      if (!parent || parent.$__.populated == null) return;
      const populatedPaths = Object.keys(parent.$__.populated).filter((p) => p.startsWith(arr[arrayPathSymbol] + "."));
      for (const path of populatedPaths) {
        const remnant = path.slice((arr[arrayPathSymbol] + ".").length);
        if (!Array.isArray(parent.$__.populated[path].value)) {
          continue;
        }
        parent.$__.populated[path].value = arr.map((val) => val.$populated(remnant));
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/types/DocumentArray/index.js
var require_DocumentArray = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/DocumentArray/index.js"(exports2, module2) {
    "use strict";
    var ArrayMethods = require_methods();
    var DocumentArrayMethods = require_methods2();
    var Document = require_document();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var _basePush = Array.prototype.push;
    var numberRE = /^\d+$/;
    function MongooseDocumentArray(values, path, doc) {
      const __array = [];
      const internals = {
        [arrayAtomicsSymbol]: {},
        [arrayAtomicsBackupSymbol]: void 0,
        [arrayPathSymbol]: path,
        [arraySchemaSymbol]: void 0,
        [arrayParentSymbol]: void 0
      };
      if (Array.isArray(values)) {
        if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {
          internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
        }
        values.forEach((v) => {
          _basePush.call(__array, v);
        });
      }
      internals[arrayPathSymbol] = path;
      internals.__array = __array;
      if (doc && doc instanceof Document) {
        internals[arrayParentSymbol] = doc;
        internals[arraySchemaSymbol] = doc.$__schema.path(path);
        while (internals[arraySchemaSymbol] != null && internals[arraySchemaSymbol].$isMongooseArray && !internals[arraySchemaSymbol].$isMongooseDocumentArray) {
          internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;
        }
      }
      const proxy = new Proxy(__array, {
        get: function(target, prop) {
          if (prop === "isMongooseArray" || prop === "isMongooseArrayProxy" || prop === "isMongooseDocumentArray" || prop === "isMongooseDocumentArrayProxy") {
            return true;
          }
          if (internals.hasOwnProperty(prop)) {
            return internals[prop];
          }
          if (DocumentArrayMethods.hasOwnProperty(prop)) {
            return DocumentArrayMethods[prop];
          }
          if (ArrayMethods.hasOwnProperty(prop)) {
            return ArrayMethods[prop];
          }
          return __array[prop];
        },
        set: function(target, prop, value) {
          if (typeof prop === "string" && numberRE.test(prop)) {
            DocumentArrayMethods.set.call(proxy, prop, value, false);
          } else if (internals.hasOwnProperty(prop)) {
            internals[prop] = value;
          } else {
            __array[prop] = value;
          }
          return true;
        }
      });
      return proxy;
    }
    module2.exports = MongooseDocumentArray;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js
var require_handleSpreadDoc = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js"(exports2, module2) {
    "use strict";
    var utils = require_utils6();
    var keysToSkip = /* @__PURE__ */ new Set(["__index", "__parentArray", "_doc"]);
    module2.exports = function handleSpreadDoc(v, includeExtraKeys) {
      if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {
        if (includeExtraKeys) {
          const extraKeys = {};
          for (const key of Object.keys(v)) {
            if (typeof key === "symbol") {
              continue;
            }
            if (key[0] === "$") {
              continue;
            }
            if (keysToSkip.has(key)) {
              continue;
            }
            extraKeys[key] = v[key];
          }
          return { ...v._doc, ...extraKeys };
        }
        return v._doc;
      }
      return v;
    };
  }
});

// asset-input/node_modules/mongoose/lib/types/map.js
var require_map2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/map.js"(exports2, module2) {
    "use strict";
    var Mixed = require_mixed();
    var MongooseError = require_mongooseError();
    var clone = require_clone();
    var deepEqual = require_utils6().deepEqual;
    var getConstructorName = require_getConstructorName();
    var handleSpreadDoc = require_handleSpreadDoc();
    var util2 = require("util");
    var specialProperties = require_specialProperties();
    var isBsonType = require_isBsonType();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var MongooseMap = class extends Map {
      constructor(v, path, doc, schemaType) {
        if (getConstructorName(v) === "Object") {
          v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
        }
        super(v);
        this.$__parent = doc != null && doc.$__ != null ? doc : null;
        this.$__path = path;
        this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;
        this.$__runDeferred();
      }
      $init(key, value) {
        checkValidKey(key);
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
          value.$basePath = this.$__path + "." + key;
        }
      }
      $__set(key, value) {
        super.set(key, value);
      }
      /**
       * Overwrites native Map's `get()` function to support Mongoose getters.
       *
       * @api public
       * @method get
       * @memberOf Map
       */
      get(key, options) {
        if (isBsonType(key, "ObjectID")) {
          key = key.toString();
        }
        options = options || {};
        if (options.getters === false) {
          return super.get(key);
        }
        return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
      }
      /**
       * Overwrites native Map's `set()` function to support setters, `populate()`,
       * and change tracking. Note that Mongoose maps _only_ support strings and
       * ObjectIds as keys.
       *
       * #### Example:
       *
       *     doc.myMap.set('test', 42); // works
       *     doc.myMap.set({ obj: 42 }, 42); // Throws "Mongoose maps only support string keys"
       *
       * @api public
       * @method set
       * @memberOf Map
       */
      set(key, value) {
        if (isBsonType(key, "ObjectID")) {
          key = key.toString();
        }
        checkValidKey(key);
        value = handleSpreadDoc(value);
        if (this.$__schemaType == null) {
          this.$__deferred = this.$__deferred || [];
          this.$__deferred.push({ key, value });
          return;
        }
        let _fullPath;
        const parent = this.$__parent;
        const populated = parent != null && parent.$__ && parent.$__.populated ? parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) : null;
        const priorVal = this.get(key);
        if (populated != null) {
          if (this.$__schemaType.$isSingleNested) {
            throw new MongooseError(
              `Cannot manually populate single nested subdoc underneath Map at path "${this.$__path}". Try using an array instead of a Map.`
            );
          }
          if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {
            value = value.map((v) => {
              if (v.$__ == null) {
                v = new populated.options[populateModelSymbol](v);
              }
              v.$__.wasPopulated = { value: v._id };
              return v;
            });
          } else {
            if (value.$__ == null) {
              value = new populated.options[populateModelSymbol](value);
            }
            value.$__.wasPopulated = { value: value._id };
          }
        } else {
          try {
            const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ? { path: fullPath.call(this) } : null;
            value = this.$__schemaType.applySetters(
              value,
              this.$__parent,
              false,
              this.get(key),
              options
            );
          } catch (error) {
            if (this.$__parent != null && this.$__parent.$__ != null) {
              this.$__parent.invalidate(fullPath.call(this), error);
              return;
            }
            throw error;
          }
        }
        super.set(key, value);
        if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
          parent.markModified(fullPath.call(this));
        }
        function fullPath() {
          if (_fullPath) {
            return _fullPath;
          }
          _fullPath = this.$__path + "." + key;
          return _fullPath;
        }
      }
      /**
       * Overwrites native Map's `clear()` function to support change tracking.
       *
       * @api public
       * @method clear
       * @memberOf Map
       */
      clear() {
        super.clear();
        const parent = this.$__parent;
        if (parent != null) {
          parent.markModified(this.$__path);
        }
      }
      /**
       * Overwrites native Map's `delete()` function to support change tracking.
       *
       * @api public
       * @method delete
       * @memberOf Map
       */
      delete(key) {
        if (isBsonType(key, "ObjectID")) {
          key = key.toString();
        }
        this.set(key, void 0);
        return super.delete(key);
      }
      /**
       * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.
       *
       * @api public
       * @method toBSON
       * @memberOf Map
       */
      toBSON() {
        return new Map(this);
      }
      toObject(options) {
        if (options && options.flattenMaps) {
          const ret = {};
          const keys = this.keys();
          for (const key of keys) {
            ret[key] = clone(this.get(key), options);
          }
          return ret;
        }
        return new Map(this);
      }
      $toObject() {
        return this.constructor.prototype.toObject.apply(this, arguments);
      }
      /**
       * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set
       * the `flattenMaps` option to convert this map to a POJO instead.
       *
       * #### Example:
       *
       *     doc.myMap.toJSON() instanceof Map; // true
       *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false
       *
       * @api public
       * @method toJSON
       * @param {Object} [options]
       * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map
       * @memberOf Map
       */
      toJSON(options) {
        if (typeof (options && options.flattenMaps) === "boolean" ? options.flattenMaps : true) {
          const ret = {};
          const keys = this.keys();
          for (const key of keys) {
            ret[key] = clone(this.get(key), options);
          }
          return ret;
        }
        return new Map(this);
      }
      inspect() {
        return new Map(this);
      }
      $__runDeferred() {
        if (!this.$__deferred) {
          return;
        }
        for (const keyValueObject of this.$__deferred) {
          this.set(keyValueObject.key, keyValueObject.value);
        }
        this.$__deferred = null;
      }
    };
    if (util2.inspect.custom) {
      Object.defineProperty(MongooseMap.prototype, util2.inspect.custom, {
        enumerable: false,
        writable: false,
        configurable: false,
        value: MongooseMap.prototype.inspect
      });
    }
    Object.defineProperty(MongooseMap.prototype, "$__set", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__parent", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__path", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    function checkValidKey(key) {
      const keyType = typeof key;
      if (keyType !== "string") {
        throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
      }
      if (key.startsWith("$")) {
        throw new Error(`Mongoose maps do not support keys that start with "$", got "${key}"`);
      }
      if (key.includes(".")) {
        throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
      }
      if (specialProperties.has(key)) {
        throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
      }
    }
    module2.exports = MongooseMap;
  }
});

// asset-input/node_modules/mongoose/lib/types/index.js
var require_types = __commonJS({
  "asset-input/node_modules/mongoose/lib/types/index.js"(exports2) {
    "use strict";
    exports2.Array = require_array();
    exports2.Buffer = require_buffer();
    exports2.Document = // @deprecate
    exports2.Embedded = require_ArraySubdocument();
    exports2.DocumentArray = require_DocumentArray();
    exports2.Decimal128 = require_decimal1282();
    exports2.ObjectId = require_objectid3();
    exports2.Map = require_map2();
    exports2.Subdocument = require_subdocument();
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaStringOptions.js
var require_SchemaStringOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaStringOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaStringOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
    module2.exports = SchemaStringOptions;
  }
});

// asset-input/node_modules/mongoose/lib/cast/string.js
var require_string = __commonJS({
  "asset-input/node_modules/mongoose/lib/cast/string.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    module2.exports = function castString(value, path) {
      if (value == null) {
        return value;
      }
      if (value._id && typeof value._id === "string") {
        return value._id;
      }
      if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
        return value.toString();
      }
      throw new CastError("string", value, path);
    };
  }
});

// asset-input/node_modules/mongoose/lib/schema/string.js
var require_string2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/string.js"(exports2, module2) {
    "use strict";
    var SchemaType = require_schematype();
    var MongooseError = require_error3();
    var SchemaStringOptions = require_SchemaStringOptions();
    var castString = require_string();
    var utils = require_utils6();
    var isBsonType = require_isBsonType();
    var CastError = SchemaType.CastError;
    function SchemaString(key, options) {
      this.enumValues = [];
      this.regExp = null;
      SchemaType.call(this, key, options, "String");
    }
    SchemaString.schemaName = "String";
    SchemaString.defaultOptions = {};
    SchemaString.prototype = Object.create(SchemaType.prototype);
    SchemaString.prototype.constructor = SchemaString;
    Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: SchemaStringOptions
    });
    SchemaString._cast = castString;
    SchemaString.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaString._defaultCaster = (v) => {
      if (v != null && typeof v !== "string") {
        throw new Error();
      }
      return v;
    };
    SchemaString.get = SchemaType.get;
    SchemaString.set = SchemaType.set;
    SchemaString._checkRequired = (v) => (v instanceof String || typeof v === "string") && v.length;
    SchemaString.checkRequired = SchemaType.checkRequired;
    SchemaString.prototype.enum = function() {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
        this.enumValidator = false;
      }
      if (arguments[0] === void 0 || arguments[0] === false) {
        return this;
      }
      let values;
      let errorMessage;
      if (utils.isObject(arguments[0])) {
        if (Array.isArray(arguments[0].values)) {
          values = arguments[0].values;
          errorMessage = arguments[0].message;
        } else {
          values = utils.object.vals(arguments[0]);
          errorMessage = MongooseError.messages.String.enum;
        }
      } else {
        values = arguments;
        errorMessage = MongooseError.messages.String.enum;
      }
      for (const value of values) {
        if (value !== void 0) {
          this.enumValues.push(this.cast(value));
        }
      }
      const vals = this.enumValues;
      this.enumValidator = function(v) {
        return void 0 === v || ~vals.indexOf(v);
      };
      this.validators.push({
        validator: this.enumValidator,
        message: errorMessage,
        type: "enum",
        enumValues: vals
      });
      return this;
    };
    SchemaString.prototype.lowercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set((v) => {
        if (typeof v !== "string") {
          v = this.cast(v);
        }
        if (v) {
          return v.toLowerCase();
        }
        return v;
      });
    };
    SchemaString.prototype.uppercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set((v) => {
        if (typeof v !== "string") {
          v = this.cast(v);
        }
        if (v) {
          return v.toUpperCase();
        }
        return v;
      });
    };
    SchemaString.prototype.trim = function(shouldTrim) {
      if (arguments.length > 0 && !shouldTrim) {
        return this;
      }
      return this.set((v) => {
        if (typeof v !== "string") {
          v = this.cast(v);
        }
        if (v) {
          return v.trim();
        }
        return v;
      });
    };
    SchemaString.prototype.minlength = function(value, message) {
      if (this.minlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.minlength;
        msg = msg.replace(/{MINLENGTH}/, value);
        this.validators.push({
          validator: this.minlengthValidator = function(v) {
            return v === null || v.length >= value;
          },
          message: msg,
          type: "minlength",
          minlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.minLength = SchemaString.prototype.minlength;
    SchemaString.prototype.maxlength = function(value, message) {
      if (this.maxlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.maxlength;
        msg = msg.replace(/{MAXLENGTH}/, value);
        this.validators.push({
          validator: this.maxlengthValidator = function(v) {
            return v === null || v.length <= value;
          },
          message: msg,
          type: "maxlength",
          maxlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
    SchemaString.prototype.match = function match(regExp, message) {
      const msg = message || MongooseError.messages.String.match;
      const matchValidator = function(v) {
        if (!regExp) {
          return false;
        }
        regExp.lastIndex = 0;
        const ret = v != null && v !== "" ? regExp.test(v) : true;
        return ret;
      };
      this.validators.push({
        validator: matchValidator,
        message: msg,
        type: "regexp",
        regexp: regExp
      });
      return this;
    };
    SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
      if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return value != null;
      }
      const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
      return _checkRequired(value);
    };
    SchemaString.prototype.cast = function(value, doc, init) {
      if (typeof value !== "string" && SchemaType._isRef(this, value, doc, init)) {
        return this._castRef(value, doc, init);
      }
      let castString2;
      if (typeof this._castFunction === "function") {
        castString2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castString2 = this.constructor.cast();
      } else {
        castString2 = SchemaString.cast();
      }
      try {
        return castString2(value);
      } catch (error) {
        throw new CastError("string", value, this.path, null, this);
      }
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    function handleSingleNoSetters(val) {
      if (val == null) {
        return this._castNullish(val);
      }
      return this.cast(val, this);
    }
    var $conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $all: handleArray,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $options: handleSingleNoSetters,
      $regex: function handle$regex(val) {
        if (Object.prototype.toString.call(val) === "[object RegExp]") {
          return val;
        }
        return handleSingleNoSetters.call(this, val);
      },
      $not: handleSingle
    });
    Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Object.freeze($conditionalHandlers)
    });
    SchemaString.prototype.castForQuery = function($conditional, val) {
      let handler2;
      if (arguments.length === 2) {
        handler2 = this.$conditionalHandlers[$conditional];
        if (!handler2) {
          throw new Error("Can't use " + $conditional + " with String.");
        }
        return handler2.call(this, val);
      }
      val = $conditional;
      if (Object.prototype.toString.call(val) === "[object RegExp]" || isBsonType(val, "BSONRegExp")) {
        return val;
      }
      return this._castForQuery(val);
    };
    module2.exports = SchemaString;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaNumberOptions.js
var require_SchemaNumberOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaNumberOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaNumberOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
    module2.exports = SchemaNumberOptions;
  }
});

// asset-input/node_modules/mongoose/lib/cast/number.js
var require_number = __commonJS({
  "asset-input/node_modules/mongoose/lib/cast/number.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    module2.exports = function castNumber(val) {
      if (val == null) {
        return val;
      }
      if (val === "") {
        return null;
      }
      if (typeof val === "string" || typeof val === "boolean") {
        val = Number(val);
      }
      assert.ok(!isNaN(val));
      if (val instanceof Number) {
        return val.valueOf();
      }
      if (typeof val === "number") {
        return val;
      }
      if (!Array.isArray(val) && typeof val.valueOf === "function") {
        return Number(val.valueOf());
      }
      if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
        return Number(val);
      }
      assert.ok(false);
    };
  }
});

// asset-input/node_modules/mongoose/lib/schema/operators/bitwise.js
var require_bitwise = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/operators/bitwise.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    function handleBitwiseOperator(val) {
      const _this = this;
      if (Array.isArray(val)) {
        return val.map(function(v) {
          return _castNumber(_this.path, v);
        });
      } else if (Buffer.isBuffer(val)) {
        return val;
      }
      return _castNumber(_this.path, val);
    }
    function _castNumber(path, num) {
      const v = Number(num);
      if (isNaN(v)) {
        throw new CastError("number", num, path);
      }
      return v;
    }
    module2.exports = handleBitwiseOperator;
  }
});

// asset-input/node_modules/mongoose/lib/schema/number.js
var require_number2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/number.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SchemaNumberOptions = require_SchemaNumberOptions();
    var SchemaType = require_schematype();
    var castNumber = require_number();
    var handleBitwiseOperator = require_bitwise();
    var utils = require_utils6();
    var CastError = SchemaType.CastError;
    function SchemaNumber(key, options) {
      SchemaType.call(this, key, options, "Number");
    }
    SchemaNumber.get = SchemaType.get;
    SchemaNumber.set = SchemaType.set;
    SchemaNumber._cast = castNumber;
    SchemaNumber.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaNumber._defaultCaster = (v) => {
      if (typeof v !== "number") {
        throw new Error();
      }
      return v;
    };
    SchemaNumber.schemaName = "Number";
    SchemaNumber.defaultOptions = {};
    SchemaNumber.prototype = Object.create(SchemaType.prototype);
    SchemaNumber.prototype.constructor = SchemaNumber;
    SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
    SchemaNumber._checkRequired = (v) => typeof v === "number" || v instanceof Number;
    SchemaNumber.checkRequired = SchemaType.checkRequired;
    SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
      if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return value != null;
      }
      const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
      return _checkRequired(value);
    };
    SchemaNumber.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.min;
        msg = msg.replace(/{MIN}/, value);
        this.validators.push({
          validator: this.minValidator = function(v) {
            return v == null || v >= value;
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.max;
        msg = msg.replace(/{MAX}/, value);
        this.validators.push({
          validator: this.maxValidator = function(v) {
            return v == null || v <= value;
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.enum = function(values, message) {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
      }
      if (!Array.isArray(values)) {
        const isObjectSyntax = utils.isPOJO(values) && values.values != null;
        if (isObjectSyntax) {
          message = values.message;
          values = values.values;
        } else if (typeof values === "number") {
          values = Array.prototype.slice.call(arguments);
          message = null;
        }
        if (utils.isPOJO(values)) {
          values = Object.values(values);
        }
        message = message || MongooseError.messages.Number.enum;
      }
      message = message == null ? MongooseError.messages.Number.enum : message;
      this.enumValidator = (v) => v == null || values.indexOf(v) !== -1;
      this.validators.push({
        validator: this.enumValidator,
        message,
        type: "enum",
        enumValues: values
      });
      return this;
    };
    SchemaNumber.prototype.cast = function(value, doc, init) {
      if (typeof value !== "number" && SchemaType._isRef(this, value, doc, init)) {
        if (value == null || utils.isNonBuiltinObject(value)) {
          return this._castRef(value, doc, init);
        }
      }
      const val = value && typeof value._id !== "undefined" ? value._id : (
        // documents
        value
      );
      let castNumber2;
      if (typeof this._castFunction === "function") {
        castNumber2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castNumber2 = this.constructor.cast();
      } else {
        castNumber2 = SchemaNumber.cast();
      }
      try {
        return castNumber2(val);
      } catch (err) {
        throw new CastError("Number", val, this.path, err, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.cast(val)];
      }
      return val.map(function(m) {
        return _this.cast(m);
      });
    }
    SchemaNumber.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $mod: handleArray
    });
    SchemaNumber.prototype.castForQuery = function($conditional, val) {
      let handler2;
      if (arguments.length === 2) {
        handler2 = this.$conditionalHandlers[$conditional];
        if (!handler2) {
          throw new CastError("number", val, this.path, null, this);
        }
        return handler2.call(this, val);
      }
      val = this._castForQuery($conditional);
      return val;
    };
    module2.exports = SchemaNumber;
  }
});

// asset-input/node_modules/mongoose/lib/schema/boolean.js
var require_boolean2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/boolean.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var SchemaType = require_schematype();
    var castBoolean = require_boolean();
    var utils = require_utils6();
    function SchemaBoolean(path, options) {
      SchemaType.call(this, path, options, "Boolean");
    }
    SchemaBoolean.schemaName = "Boolean";
    SchemaBoolean.defaultOptions = {};
    SchemaBoolean.prototype = Object.create(SchemaType.prototype);
    SchemaBoolean.prototype.constructor = SchemaBoolean;
    SchemaBoolean._cast = castBoolean;
    SchemaBoolean.set = SchemaType.set;
    SchemaBoolean.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaBoolean._defaultCaster = (v) => {
      if (v != null && typeof v !== "boolean") {
        throw new Error();
      }
      return v;
    };
    SchemaBoolean._checkRequired = (v) => v === true || v === false;
    SchemaBoolean.checkRequired = SchemaType.checkRequired;
    SchemaBoolean.prototype.checkRequired = function(value) {
      return this.constructor._checkRequired(value);
    };
    Object.defineProperty(SchemaBoolean, "convertToTrue", {
      get: () => castBoolean.convertToTrue,
      set: (v) => {
        castBoolean.convertToTrue = v;
      }
    });
    Object.defineProperty(SchemaBoolean, "convertToFalse", {
      get: () => castBoolean.convertToFalse,
      set: (v) => {
        castBoolean.convertToFalse = v;
      }
    });
    SchemaBoolean.prototype.cast = function(value) {
      let castBoolean2;
      if (typeof this._castFunction === "function") {
        castBoolean2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castBoolean2 = this.constructor.cast();
      } else {
        castBoolean2 = SchemaBoolean.cast();
      }
      try {
        return castBoolean2(value);
      } catch (error) {
        throw new CastError("Boolean", value, this.path, error, this);
      }
    };
    SchemaBoolean.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {});
    SchemaBoolean.prototype.castForQuery = function($conditional, val) {
      let handler2;
      if (arguments.length === 2) {
        handler2 = SchemaBoolean.$conditionalHandlers[$conditional];
        if (handler2) {
          return handler2.call(this, val);
        }
        return this._castForQuery(val);
      }
      return this._castForQuery($conditional);
    };
    SchemaBoolean.prototype._castNullish = function _castNullish(v) {
      if (typeof v === "undefined") {
        return v;
      }
      const castBoolean2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
      if (castBoolean2 == null) {
        return v;
      }
      if (castBoolean2.convertToFalse instanceof Set && castBoolean2.convertToFalse.has(v)) {
        return false;
      }
      if (castBoolean2.convertToTrue instanceof Set && castBoolean2.convertToTrue.has(v)) {
        return true;
      }
      return v;
    };
    module2.exports = SchemaBoolean;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaArrayOptions.js
var require_SchemaArrayOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaArrayOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
    Object.defineProperty(SchemaArrayOptions.prototype, "castNonArrays", opts);
    module2.exports = SchemaArrayOptions;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/arrayDepth.js
var require_arrayDepth = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/arrayDepth.js"(exports2, module2) {
    "use strict";
    module2.exports = arrayDepth;
    function arrayDepth(arr) {
      if (!Array.isArray(arr)) {
        return { min: 0, max: 0, containsNonArrayItem: true };
      }
      if (arr.length === 0) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      if (arr.length === 1 && !Array.isArray(arr[0])) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      const res = arrayDepth(arr[0]);
      for (let i = 1; i < arr.length; ++i) {
        const _res = arrayDepth(arr[i]);
        if (_res.min < res.min) {
          res.min = _res.min;
        }
        if (_res.max > res.max) {
          res.max = _res.max;
        }
        res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
      }
      res.min = res.min + 1;
      res.max = res.max + 1;
      return res;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/cast$expr.js
var require_cast_expr = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/cast$expr.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var StrictModeError = require_strict();
    var castNumber = require_number();
    var booleanComparison = /* @__PURE__ */ new Set(["$and", "$or"]);
    var comparisonOperator = /* @__PURE__ */ new Set(["$cmp", "$eq", "$lt", "$lte", "$gt", "$gte"]);
    var arithmeticOperatorArray = /* @__PURE__ */ new Set([
      // avoid casting '$add' or '$subtract', because expressions can be either number or date,
      // and we don't have a good way of inferring which arguments should be numbers and which should
      // be dates.
      "$multiply",
      "$divide",
      "$log",
      "$mod",
      "$trunc",
      "$avg",
      "$max",
      "$min",
      "$stdDevPop",
      "$stdDevSamp",
      "$sum"
    ]);
    var arithmeticOperatorNumber = /* @__PURE__ */ new Set([
      "$abs",
      "$exp",
      "$ceil",
      "$floor",
      "$ln",
      "$log10",
      "$round",
      "$sqrt",
      "$sin",
      "$cos",
      "$tan",
      "$asin",
      "$acos",
      "$atan",
      "$atan2",
      "$asinh",
      "$acosh",
      "$atanh",
      "$sinh",
      "$cosh",
      "$tanh",
      "$degreesToRadians",
      "$radiansToDegrees"
    ]);
    var arrayElementOperators = /* @__PURE__ */ new Set([
      "$arrayElemAt",
      "$first",
      "$last"
    ]);
    var dateOperators = /* @__PURE__ */ new Set([
      "$year",
      "$month",
      "$week",
      "$dayOfMonth",
      "$dayOfYear",
      "$hour",
      "$minute",
      "$second",
      "$isoDayOfWeek",
      "$isoWeekYear",
      "$isoWeek",
      "$millisecond"
    ]);
    var expressionOperator = /* @__PURE__ */ new Set(["$not"]);
    module2.exports = function cast$expr(val, schema, strictQuery) {
      if (typeof val !== "object" || val === null) {
        throw new Error("`$expr` must be an object");
      }
      return _castExpression(val, schema, strictQuery);
    };
    function _castExpression(val, schema, strictQuery) {
      if (isPath(val) || val === null) {
        return val;
      }
      if (val.$cond != null) {
        if (Array.isArray(val.$cond)) {
          val.$cond = val.$cond.map((expr) => _castExpression(expr, schema, strictQuery));
        } else {
          val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);
          val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);
          val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);
        }
      } else if (val.$ifNull != null) {
        val.$ifNull.map((v) => _castExpression(v, schema, strictQuery));
      } else if (val.$switch != null) {
        val.branches.map((v) => _castExpression(v, schema, strictQuery));
        val.default = _castExpression(val.default, schema, strictQuery);
      }
      const keys = Object.keys(val);
      for (const key of keys) {
        if (booleanComparison.has(key)) {
          val[key] = val[key].map((v) => _castExpression(v, schema, strictQuery));
        } else if (comparisonOperator.has(key)) {
          val[key] = castComparison(val[key], schema, strictQuery);
        } else if (arithmeticOperatorArray.has(key)) {
          val[key] = castArithmetic(val[key], schema, strictQuery);
        } else if (arithmeticOperatorNumber.has(key)) {
          val[key] = castNumberOperator(val[key], schema, strictQuery);
        } else if (expressionOperator.has(key)) {
          val[key] = _castExpression(val[key], schema, strictQuery);
        }
      }
      if (val.$in) {
        val.$in = castIn(val.$in, schema, strictQuery);
      }
      if (val.$size) {
        val.$size = castNumberOperator(val.$size, schema, strictQuery);
      }
      _omitUndefined(val);
      return val;
    }
    function _omitUndefined(val) {
      const keys = Object.keys(val);
      for (let i = 0, len = keys.length; i < len; ++i) {
        val[keys[i]] === void 0 && delete val[keys[i]];
      }
    }
    function castNumberOperator(val) {
      if (!isLiteral(val)) {
        return val;
      }
      try {
        return castNumber(val);
      } catch (err) {
        throw new CastError("Number", val);
      }
    }
    function castIn(val, schema, strictQuery) {
      const path = val[1];
      if (!isPath(path)) {
        return val;
      }
      const search = val[0];
      const schematype = schema.path(path.slice(1));
      if (schematype === null) {
        if (strictQuery === false) {
          return val;
        } else if (strictQuery === "throw") {
          throw new StrictModeError("$in");
        }
        return void 0;
      }
      if (!schematype.$isMongooseArray) {
        throw new Error("Path must be an array for $in");
      }
      return [
        schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),
        path
      ];
    }
    function castArithmetic(val) {
      if (!Array.isArray(val)) {
        if (!isLiteral(val)) {
          return val;
        }
        try {
          return castNumber(val);
        } catch (err) {
          throw new CastError("Number", val);
        }
      }
      return val.map((v) => {
        if (!isLiteral(v)) {
          return v;
        }
        try {
          return castNumber(v);
        } catch (err) {
          throw new CastError("Number", v);
        }
      });
    }
    function castComparison(val, schema, strictQuery) {
      if (!Array.isArray(val) || val.length !== 2) {
        throw new Error("Comparison operator must be an array of length 2");
      }
      val[0] = _castExpression(val[0], schema, strictQuery);
      const lhs = val[0];
      if (isLiteral(val[1])) {
        let path = null;
        let schematype = null;
        let caster = null;
        if (isPath(lhs)) {
          path = lhs.slice(1);
          schematype = schema.path(path);
        } else if (typeof lhs === "object" && lhs != null) {
          for (const key of Object.keys(lhs)) {
            if (dateOperators.has(key) && isPath(lhs[key])) {
              path = lhs[key].slice(1) + "." + key;
              caster = castNumber;
            } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {
              path = lhs[key].slice(1) + "." + key;
              schematype = schema.path(lhs[key].slice(1));
              if (schematype != null) {
                if (schematype.$isMongooseDocumentArray) {
                  schematype = schematype.$embeddedSchemaType;
                } else if (schematype.$isMongooseArray) {
                  schematype = schematype.caster;
                }
              }
            }
          }
        }
        const is$literal = typeof val[1] === "object" && val[1] != null && val[1].$literal != null;
        if (schematype != null) {
          if (is$literal) {
            val[1] = { $literal: schematype.cast(val[1].$literal) };
          } else {
            val[1] = schematype.cast(val[1]);
          }
        } else if (caster != null) {
          if (is$literal) {
            try {
              val[1] = { $literal: caster(val[1].$literal) };
            } catch (err) {
              throw new CastError(caster.name.replace(/^cast/, ""), val[1], path + ".$literal");
            }
          } else {
            try {
              val[1] = caster(val[1]);
            } catch (err) {
              throw new CastError(caster.name.replace(/^cast/, ""), val[1], path);
            }
          }
        } else if (path != null && strictQuery === true) {
          return void 0;
        } else if (path != null && strictQuery === "throw") {
          throw new StrictModeError(path);
        }
      } else {
        val[1] = _castExpression(val[1]);
      }
      return val;
    }
    function isPath(val) {
      return typeof val === "string" && val[0] === "$";
    }
    function isLiteral(val) {
      if (typeof val === "string" && val[0] === "$") {
        return false;
      }
      if (typeof val === "object" && val !== null && Object.keys(val).find((key) => key[0] === "$")) {
        return val.$literal != null;
      }
      return true;
    }
  }
});

// asset-input/node_modules/mongoose/lib/schema/operators/text.js
var require_text = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/operators/text.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var castBoolean = require_boolean();
    var castString = require_string();
    module2.exports = function castTextSearch(val, path) {
      if (val == null || typeof val !== "object") {
        throw new CastError("$text", val, path);
      }
      if (val.$search != null) {
        val.$search = castString(val.$search, path + ".$search");
      }
      if (val.$language != null) {
        val.$language = castString(val.$language, path + ".$language");
      }
      if (val.$caseSensitive != null) {
        val.$caseSensitive = castBoolean(
          val.$caseSensitive,
          path + ".$castSensitive"
        );
      }
      if (val.$diacriticSensitive != null) {
        val.$diacriticSensitive = castBoolean(
          val.$diacriticSensitive,
          path + ".$diacriticSensitive"
        );
      }
      return val;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js
var require_getSchemaDiscriminatorByValue = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js"(exports2, module2) {
    "use strict";
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getSchemaDiscriminatorByValue(schema, value) {
      if (schema == null || schema.discriminators == null) {
        return null;
      }
      for (const key of Object.keys(schema.discriminators)) {
        const discriminatorSchema = schema.discriminators[key];
        if (discriminatorSchema.discriminatorMapping == null) {
          continue;
        }
        if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
          return discriminatorSchema;
        }
      }
      return null;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/isOperator.js
var require_isOperator = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/isOperator.js"(exports2, module2) {
    "use strict";
    var specialKeys = /* @__PURE__ */ new Set([
      "$ref",
      "$id",
      "$db"
    ]);
    module2.exports = function isOperator(path) {
      return path[0] === "$" && !specialKeys.has(path);
    };
  }
});

// asset-input/node_modules/mongoose/lib/cast.js
var require_cast2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/cast.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var StrictModeError = require_strict();
    var Types = require_schema();
    var cast$expr = require_cast_expr();
    var castString = require_string();
    var castTextSearch = require_text();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
    var isOperator = require_isOperator();
    var util2 = require("util");
    var isObject = require_isObject();
    var isMongooseObject = require_isMongooseObject();
    var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ["Polygon", "MultiPolygon"];
    module2.exports = function cast(schema, obj, options, context) {
      if (Array.isArray(obj)) {
        throw new Error("Query filter must be an object, got an array ", util2.inspect(obj));
      }
      if (obj == null) {
        return obj;
      }
      if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
        schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
      }
      const paths = Object.keys(obj);
      let i = paths.length;
      let _keys;
      let any$conditionals;
      let schematype;
      let nested;
      let path;
      let type;
      let val;
      options = options || {};
      while (i--) {
        path = paths[i];
        val = obj[path];
        if (path === "$or" || path === "$nor" || path === "$and") {
          if (!Array.isArray(val)) {
            throw new CastError("Array", val, path);
          }
          for (let k = 0; k < val.length; ++k) {
            if (val[k] == null || typeof val[k] !== "object") {
              throw new CastError("Object", val[k], path + "." + k);
            }
            val[k] = cast(schema, val[k], options, context);
          }
        } else if (path === "$where") {
          type = typeof val;
          if (type !== "string" && type !== "function") {
            throw new Error("Must have a string or function for $where");
          }
          if (type === "function") {
            obj[path] = val.toString();
          }
          continue;
        } else if (path === "$expr") {
          val = cast$expr(val, schema);
          continue;
        } else if (path === "$elemMatch") {
          val = cast(schema, val, options, context);
        } else if (path === "$text") {
          val = castTextSearch(val, path);
        } else if (path === "$comment" && !schema.paths.hasOwnProperty("$comment")) {
          val = castString(val, path);
          obj[path] = val;
        } else {
          if (!schema) {
            continue;
          }
          schematype = schema.path(path);
          if (!schematype) {
            const split = path.split(".");
            let j = split.length;
            while (j--) {
              const pathFirstHalf = split.slice(0, j).join(".");
              const pathLastHalf = split.slice(j).join(".");
              const _schematype = schema.path(pathFirstHalf);
              const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;
              if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
                const discriminatorVal = get(obj, pathFirstHalf + "." + discriminatorKey);
                if (discriminatorVal != null) {
                  schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);
                }
              }
            }
          }
          if (!schematype) {
            const split = path.split(".");
            let j = split.length;
            let pathFirstHalf;
            let pathLastHalf;
            let remainingConds;
            while (j--) {
              pathFirstHalf = split.slice(0, j).join(".");
              schematype = schema.path(pathFirstHalf);
              if (schematype) {
                break;
              }
            }
            if (schematype) {
              if (schematype.caster && schematype.caster.schema) {
                remainingConds = {};
                pathLastHalf = split.slice(j).join(".");
                remainingConds[pathLastHalf] = val;
                const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
                if (ret === void 0) {
                  delete obj[path];
                } else {
                  obj[path] = ret;
                }
              } else {
                obj[path] = val;
              }
              continue;
            }
            if (isObject(val)) {
              let geo = "";
              if (val.$near) {
                geo = "$near";
              } else if (val.$nearSphere) {
                geo = "$nearSphere";
              } else if (val.$within) {
                geo = "$within";
              } else if (val.$geoIntersects) {
                geo = "$geoIntersects";
              } else if (val.$geoWithin) {
                geo = "$geoWithin";
              }
              if (geo) {
                const numbertype = new Types.Number("__QueryCasting__");
                let value = val[geo];
                if (val.$maxDistance != null) {
                  val.$maxDistance = numbertype.castForQueryWrapper({
                    val: val.$maxDistance,
                    context
                  });
                }
                if (val.$minDistance != null) {
                  val.$minDistance = numbertype.castForQueryWrapper({
                    val: val.$minDistance,
                    context
                  });
                }
                if (geo === "$within") {
                  const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                  if (!withinType) {
                    throw new Error("Bad $within parameter: " + JSON.stringify(val));
                  }
                  value = withinType;
                } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                  value = value.coordinates;
                } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                  if (value.$maxDistance != null) {
                    value.$maxDistance = numbertype.castForQueryWrapper({
                      val: value.$maxDistance,
                      context
                    });
                  }
                  if (value.$minDistance != null) {
                    value.$minDistance = numbertype.castForQueryWrapper({
                      val: value.$minDistance,
                      context
                    });
                  }
                  if (isMongooseObject(value.$geometry)) {
                    value.$geometry = value.$geometry.toObject({
                      transform: false,
                      virtuals: false
                    });
                  }
                  value = value.$geometry.coordinates;
                } else if (geo === "$geoWithin") {
                  if (value.$geometry) {
                    if (isMongooseObject(value.$geometry)) {
                      value.$geometry = value.$geometry.toObject({ virtuals: false });
                    }
                    const geoWithinType = value.$geometry.type;
                    if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                      throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                    }
                    value = value.$geometry.coordinates;
                  } else {
                    value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                    if (isMongooseObject(value)) {
                      value = value.toObject({ virtuals: false });
                    }
                  }
                }
                _cast(value, numbertype, context);
                continue;
              }
            }
            if (schema.nested[path]) {
              continue;
            }
            const strict = "strict" in options ? options.strict : schema.options.strict;
            const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);
            if (options.upsert && strict) {
              if (strict === "throw") {
                throw new StrictModeError(path);
              }
              throw new StrictModeError(path, 'Path "' + path + '" is not in schema, strict mode is `true`, and upsert is `true`.');
            }
            if (strictQuery === "throw") {
              throw new StrictModeError(path, 'Path "' + path + `" is not in schema and strictQuery is 'throw'.`);
            } else if (strictQuery) {
              delete obj[path];
            }
          } else if (val == null) {
            continue;
          } else if (getConstructorName(val) === "Object") {
            any$conditionals = Object.keys(val).some(isOperator);
            if (!any$conditionals) {
              obj[path] = schematype.castForQueryWrapper({
                val,
                context
              });
            } else {
              const ks = Object.keys(val);
              let $cond;
              let k = ks.length;
              while (k--) {
                $cond = ks[k];
                nested = val[$cond];
                if ($cond === "$not") {
                  if (nested && schematype) {
                    _keys = Object.keys(nested);
                    if (_keys.length && isOperator(_keys[0])) {
                      for (const key in nested) {
                        nested[key] = schematype.castForQueryWrapper({
                          $conditional: key,
                          val: nested[key],
                          context
                        });
                      }
                    } else {
                      val[$cond] = schematype.castForQueryWrapper({
                        $conditional: $cond,
                        val: nested,
                        context
                      });
                    }
                    continue;
                  }
                } else {
                  val[$cond] = schematype.castForQueryWrapper({
                    $conditional: $cond,
                    val: nested,
                    context
                  });
                }
              }
            }
          } else if (Array.isArray(val) && ["Buffer", "Array"].indexOf(schematype.instance) === -1) {
            const casted = [];
            const valuesArray = val;
            for (const _val of valuesArray) {
              casted.push(schematype.castForQueryWrapper({
                val: _val,
                context
              }));
            }
            obj[path] = { $in: casted };
          } else {
            obj[path] = schematype.castForQueryWrapper({
              val,
              context
            });
          }
        }
      }
      return obj;
    };
    function _cast(val, numbertype, context) {
      if (Array.isArray(val)) {
        val.forEach(function(item, i) {
          if (Array.isArray(item) || isObject(item)) {
            return _cast(item, numbertype, context);
          }
          val[i] = numbertype.castForQueryWrapper({ val: item, context });
        });
      } else {
        const nearKeys = Object.keys(val);
        let nearLen = nearKeys.length;
        while (nearLen--) {
          const nkey = nearKeys[nearLen];
          const item = val[nkey];
          if (Array.isArray(item) || isObject(item)) {
            _cast(item, numbertype, context);
            val[nkey] = item;
          } else {
            val[nkey] = numbertype.castForQuery({ val: item, context });
          }
        }
      }
    }
    function getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {
      if ("strictQuery" in queryOptions) {
        return queryOptions.strictQuery;
      }
      if ("strict" in queryOptions) {
        return queryOptions.strict;
      }
      if ("strictQuery" in schemaUserProvidedOptions) {
        return schemaUserProvidedOptions.strictQuery;
      }
      if ("strict" in schemaUserProvidedOptions) {
        return schemaUserProvidedOptions.strict;
      }
      const mongooseOptions = context && context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;
      if (mongooseOptions) {
        if ("strictQuery" in mongooseOptions) {
          return mongooseOptions.strictQuery;
        }
        if ("strict" in mongooseOptions) {
          return mongooseOptions.strict;
        }
      }
      return schemaOptions.strictQuery;
    }
  }
});

// asset-input/node_modules/mongoose/lib/schema/operators/helpers.js
var require_helpers3 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/operators/helpers.js"(exports2) {
    "use strict";
    var SchemaNumber = require_number2();
    exports2.castToNumber = castToNumber;
    exports2.castArraysOfNumbers = castArraysOfNumbers;
    function castToNumber(val) {
      return SchemaNumber.cast()(val);
    }
    function castArraysOfNumbers(arr, self2) {
      arr.forEach(function(v, i) {
        if (Array.isArray(v)) {
          castArraysOfNumbers(v, self2);
        } else {
          arr[i] = castToNumber.call(self2, v);
        }
      });
    }
  }
});

// asset-input/node_modules/mongoose/lib/schema/operators/geospatial.js
var require_geospatial = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/operators/geospatial.js"(exports2) {
    "use strict";
    var castArraysOfNumbers = require_helpers3().castArraysOfNumbers;
    var castToNumber = require_helpers3().castToNumber;
    exports2.cast$geoIntersects = cast$geoIntersects;
    exports2.cast$near = cast$near;
    exports2.cast$within = cast$within;
    function cast$near(val) {
      const SchemaArray = require_array2();
      if (Array.isArray(val)) {
        castArraysOfNumbers(val, this);
        return val;
      }
      _castMinMaxDistance(this, val);
      if (val && val.$geometry) {
        return cast$geometry(val, this);
      }
      if (!Array.isArray(val)) {
        throw new TypeError("$near must be either an array or an object with a $geometry property");
      }
      return SchemaArray.prototype.castForQuery.call(this, val);
    }
    function cast$geometry(val, self2) {
      switch (val.$geometry.type) {
        case "Polygon":
        case "LineString":
        case "Point":
          castArraysOfNumbers(val.$geometry.coordinates, self2);
          break;
        default:
          break;
      }
      _castMinMaxDistance(self2, val);
      return val;
    }
    function cast$within(val) {
      _castMinMaxDistance(this, val);
      if (val.$box || val.$polygon) {
        const type = val.$box ? "$box" : "$polygon";
        val[type].forEach((arr) => {
          if (!Array.isArray(arr)) {
            const msg = "Invalid $within $box argument. Expected an array, received " + arr;
            throw new TypeError(msg);
          }
          arr.forEach((v, i) => {
            arr[i] = castToNumber.call(this, v);
          });
        });
      } else if (val.$center || val.$centerSphere) {
        const type = val.$center ? "$center" : "$centerSphere";
        val[type].forEach((item, i) => {
          if (Array.isArray(item)) {
            item.forEach((v, j) => {
              item[j] = castToNumber.call(this, v);
            });
          } else {
            val[type][i] = castToNumber.call(this, item);
          }
        });
      } else if (val.$geometry) {
        cast$geometry(val, this);
      }
      return val;
    }
    function cast$geoIntersects(val) {
      const geo = val.$geometry;
      if (!geo) {
        return;
      }
      cast$geometry(val, this);
      return val;
    }
    function _castMinMaxDistance(self2, val) {
      if (val.$maxDistance) {
        val.$maxDistance = castToNumber.call(self2, val.$maxDistance);
      }
      if (val.$minDistance) {
        val.$minDistance = castToNumber.call(self2, val.$minDistance);
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/schema/array.js
var require_array2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/array.js"(exports2, module2) {
    "use strict";
    var $exists = require_exists();
    var $type = require_type();
    var MongooseError = require_mongooseError();
    var SchemaArrayOptions = require_SchemaArrayOptions();
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var Mixed = require_mixed();
    var arrayDepth = require_arrayDepth();
    var cast = require_cast2();
    var isOperator = require_isOperator();
    var util2 = require("util");
    var utils = require_utils6();
    var castToNumber = require_helpers3().castToNumber;
    var geospatial = require_geospatial();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var MongooseArray;
    var EmbeddedDoc;
    var isNestedArraySymbol = Symbol("mongoose#isNestedArray");
    var emptyOpts = Object.freeze({});
    function SchemaArray(key, cast2, options, schemaOptions) {
      EmbeddedDoc || (EmbeddedDoc = require_types().Embedded);
      let typeKey = "type";
      if (schemaOptions && schemaOptions.typeKey) {
        typeKey = schemaOptions.typeKey;
      }
      this.schemaOptions = schemaOptions;
      if (cast2) {
        let castOptions = {};
        if (utils.isPOJO(cast2)) {
          if (cast2[typeKey]) {
            castOptions = utils.clone(cast2);
            delete castOptions[typeKey];
            cast2 = cast2[typeKey];
          } else {
            cast2 = Mixed;
          }
        }
        if (options != null && options.ref != null && castOptions.ref == null) {
          castOptions.ref = options.ref;
        }
        if (cast2 === Object) {
          cast2 = Mixed;
        }
        const name = typeof cast2 === "string" ? cast2 : utils.getFunctionName(cast2);
        const Types = require_schema();
        const caster = Types.hasOwnProperty(name) ? Types[name] : cast2;
        this.casterConstructor = caster;
        if (this.casterConstructor instanceof SchemaArray) {
          this.casterConstructor[isNestedArraySymbol] = true;
        }
        if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
          const path = this.caster instanceof EmbeddedDoc ? null : key;
          this.caster = new caster(path, castOptions);
        } else {
          this.caster = caster;
          if (!(this.caster instanceof EmbeddedDoc)) {
            this.caster.path = key;
          }
        }
        this.$embeddedSchemaType = this.caster;
      }
      this.$isMongooseArray = true;
      SchemaType.call(this, key, options, "Array");
      let defaultArr;
      let fn;
      if (this.defaultValue != null) {
        defaultArr = this.defaultValue;
        fn = typeof defaultArr === "function";
      }
      if (!("defaultValue" in this) || this.defaultValue !== void 0) {
        const defaultFn = function() {
          return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];
        };
        defaultFn.$runBeforeSetters = !fn;
        this.default(defaultFn);
      }
    }
    SchemaArray.schemaName = "Array";
    SchemaArray.options = { castNonArrays: true };
    SchemaArray.defaultOptions = {};
    SchemaArray.set = SchemaType.set;
    SchemaArray.prototype = Object.create(SchemaType.prototype);
    SchemaArray.prototype.constructor = SchemaArray;
    SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
    SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
    SchemaArray.checkRequired = SchemaType.checkRequired;
    SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
      if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
      return _checkRequired(value);
    };
    SchemaArray.prototype.enum = function() {
      let arr = this;
      while (true) {
        const instance = arr && arr.caster && arr.caster.instance;
        if (instance === "Array") {
          arr = arr.caster;
          continue;
        }
        if (instance !== "String" && instance !== "Number") {
          throw new Error("`enum` can only be set on an array of strings or numbers , not " + instance);
        }
        break;
      }
      let enumArray = arguments;
      if (!Array.isArray(arguments) && utils.isObject(arguments)) {
        enumArray = utils.object.vals(enumArray);
      }
      arr.caster.enum.apply(arr.caster, enumArray);
      return this;
    };
    SchemaArray.prototype.applyGetters = function(value, scope) {
      if (scope != null && scope.$__ != null && scope.$populated(this.path)) {
        return value;
      }
      const ret = SchemaType.prototype.applyGetters.call(this, value, scope);
      if (Array.isArray(ret)) {
        const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;
        const len = rawValue.length;
        for (let i = 0; i < len; ++i) {
          rawValue[i] = this.caster.applyGetters(rawValue[i], scope);
        }
      }
      return ret;
    };
    SchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {
      if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
        let depth = 0;
        let arr = this;
        while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
          ++depth;
          arr = arr.casterConstructor;
        }
        if (value != null && value.length !== 0) {
          const valueDepth = arrayDepth(value);
          if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
            for (let i = valueDepth.max; i < depth; ++i) {
              value = [value];
            }
          }
        }
      }
      return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);
    };
    SchemaArray.prototype.cast = function(value, doc, init, prev, options) {
      MongooseArray || (MongooseArray = require_types().Array);
      let i;
      let l;
      if (Array.isArray(value)) {
        const len = value.length;
        if (!len && doc) {
          const indexes = doc.schema.indexedPaths();
          const arrayPath = this.path;
          for (i = 0, l = indexes.length; i < l; ++i) {
            const pathIndex = indexes[i][0][arrayPath];
            if (pathIndex === "2dsphere" || pathIndex === "2d") {
              return;
            }
          }
          const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
          if (arrayGeojsonPath != null) {
            for (i = 0, l = indexes.length; i < l; ++i) {
              const pathIndex = indexes[i][0][arrayGeojsonPath];
              if (pathIndex === "2dsphere") {
                return;
              }
            }
          }
        }
        options = options || emptyOpts;
        let rawValue = utils.isMongooseArray(value) ? value.__array : value;
        value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);
        rawValue = value.__array;
        if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {
          return value;
        }
        const caster = this.caster;
        const isMongooseArray = caster.$isMongooseArray;
        if (caster && this.casterConstructor !== Mixed) {
          try {
            const len2 = rawValue.length;
            for (i = 0; i < len2; i++) {
              const opts = {};
              if (isMongooseArray) {
                if (options.arrayPath != null) {
                  opts.arrayPathIndex = i;
                } else if (caster._arrayParentPath != null) {
                  opts.arrayPathIndex = i;
                }
              }
              rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util2.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;
      if (init || castNonArraysOption) {
        if (!!doc && !!init) {
          doc.markModified(this.path);
        }
        return this.cast([value], doc, init);
      }
      throw new CastError("Array", util2.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
      MongooseArray || (MongooseArray = require_types().Array);
      if (Array.isArray(value)) {
        let i;
        const rawValue = value.__array ? value.__array : value;
        const len = rawValue.length;
        const caster = this.caster;
        if (caster && this.casterConstructor !== Mixed) {
          try {
            for (i = 0; i < len; i++) {
              const opts = {};
              if (caster.$isMongooseArray && caster._arrayParentPath != null) {
                opts.arrayPathIndex = i;
              }
              rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util2.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      throw new CastError("Array", util2.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;
    SchemaArray.prototype.discriminator = function(...args) {
      let arr = this;
      while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
        arr = arr.casterConstructor;
        if (arr == null || typeof arr === "function") {
          throw new MongooseError("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
        }
      }
      return arr.discriminator(...args);
    };
    SchemaArray.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      return schematype;
    };
    SchemaArray.prototype.castForQuery = function($conditional, value) {
      let handler2;
      let val;
      if (arguments.length === 2) {
        handler2 = this.$conditionalHandlers[$conditional];
        if (!handler2) {
          throw new Error("Can't use " + $conditional + " with Array.");
        }
        val = handler2.call(this, value);
      } else {
        val = $conditional;
        let Constructor = this.casterConstructor;
        if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof val[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        const proto = this.casterConstructor.prototype;
        let method = proto && (proto.castForQuery || proto.cast);
        if (!method && Constructor.castForQuery) {
          method = Constructor.castForQuery;
        }
        const caster = this.caster;
        if (Array.isArray(val)) {
          this.setters.reverse().forEach((setter) => {
            val = setter.call(this, val, this);
          });
          val = val.map(function(v) {
            if (utils.isObject(v) && v.$elemMatch) {
              return v;
            }
            if (method) {
              v = method.call(caster, v);
              return v;
            }
            if (v != null) {
              v = new Constructor(v);
              return v;
            }
            return v;
          });
        } else if (method) {
          val = method.call(caster, val);
        } else if (val != null) {
          val = new Constructor(val);
        }
      }
      return val;
    };
    function cast$all(val) {
      if (!Array.isArray(val)) {
        val = [val];
      }
      val = val.map((v) => {
        if (!utils.isObject(v)) {
          return v;
        }
        if (v.$elemMatch != null) {
          return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };
        }
        const o = {};
        o[this.path] = v;
        return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];
      }, this);
      return this.castForQuery(val);
    }
    function cast$elemMatch(val) {
      const keys = Object.keys(val);
      const numKeys = keys.length;
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const value = val[key];
        if (isOperator(key) && value != null) {
          val[key] = this.castForQuery(key, value);
        }
      }
      const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;
      const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
      if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
        return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);
      }
      return cast(this.casterConstructor.schema, val, null, this && this.$$context);
    }
    var handle = SchemaArray.prototype.$conditionalHandlers = {};
    handle.$all = cast$all;
    handle.$options = String;
    handle.$elemMatch = cast$elemMatch;
    handle.$geoIntersects = geospatial.cast$geoIntersects;
    handle.$or = createLogicalQueryOperatorHandler("$or");
    handle.$and = createLogicalQueryOperatorHandler("$and");
    handle.$nor = createLogicalQueryOperatorHandler("$nor");
    function createLogicalQueryOperatorHandler(op) {
      return function logicalQueryOperatorHandler(val) {
        if (!Array.isArray(val)) {
          throw new TypeError("conditional " + op + " requires an array");
        }
        const ret = [];
        for (const obj of val) {
          ret.push(cast(this.casterConstructor.schema, obj, null, this && this.$$context));
        }
        return ret;
      };
    }
    handle.$near = handle.$nearSphere = geospatial.cast$near;
    handle.$within = handle.$geoWithin = geospatial.cast$within;
    handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
    handle.$exists = $exists;
    handle.$type = $type;
    handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$not = handle.$regex = SchemaArray.prototype.castForQuery;
    handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
    handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
    module2.exports = SchemaArray;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaSubdocumentOptions.js
var require_SchemaSubdocumentOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaSubdocumentOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaSubdocumentOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaSubdocumentOptions.prototype, "_id", opts);
    module2.exports = SchemaSubdocumentOptions;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js
var require_isNestedProjection = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function isNestedProjection(val) {
      if (val == null || typeof val !== "object") {
        return false;
      }
      return val.$slice == null && val.$elemMatch == null && val.$meta == null && val.$ == null;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/document/applyDefaults.js
var require_applyDefaults = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/document/applyDefaults.js"(exports2, module2) {
    "use strict";
    var isNestedProjection = require_isNestedProjection();
    module2.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
      const paths = Object.keys(doc.$__schema.paths);
      const plen = paths.length;
      for (let i = 0; i < plen; ++i) {
        let def;
        let curPath = "";
        const p = paths[i];
        if (p === "_id" && doc.$__.skipId) {
          continue;
        }
        const type = doc.$__schema.paths[p];
        const path = type.splitPath();
        const len = path.length;
        let included = false;
        let doc_ = doc._doc;
        for (let j = 0; j < len; ++j) {
          if (doc_ == null) {
            break;
          }
          const piece = path[j];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;
            if (curPath in fields && !isNestedProjection(fields[curPath]) || j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath]) {
              included = true;
            } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (j === len - 1) {
            if (doc_[piece] !== void 0) {
              break;
            }
            if (isBeforeSetters != null) {
              if (typeof type.defaultValue === "function") {
                if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                  break;
                }
                if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                  break;
                }
              } else if (!isBeforeSetters) {
                continue;
              }
            }
            if (pathsToSkip && pathsToSkip[curPath]) {
              break;
            }
            if (fields && exclude !== null) {
              if (exclude === true) {
                if (p in fields) {
                  continue;
                }
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  applyChangeTracking(doc, p);
                }
              } else if (included) {
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  applyChangeTracking(doc, p);
                }
              }
            } else {
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                applyChangeTracking(doc, p);
              }
            }
          } else {
            doc_ = doc_[piece];
          }
        }
      }
    };
    function applyChangeTracking(doc, fullPath) {
      doc.$__.activePaths.default(fullPath);
      if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {
        doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/each.js
var require_each = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/each.js"(exports2, module2) {
    "use strict";
    module2.exports = function each(arr, cb, done) {
      if (arr.length === 0) {
        return done();
      }
      let remaining = arr.length;
      let err = null;
      for (const v of arr) {
        cb(v, function(_err) {
          if (err != null) {
            return;
          }
          if (_err != null) {
            err = _err;
            return done(err);
          }
          if (--remaining <= 0) {
            return done();
          }
        });
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/plugins/removeSubdocs.js
var require_removeSubdocs = __commonJS({
  "asset-input/node_modules/mongoose/lib/plugins/removeSubdocs.js"(exports2, module2) {
    "use strict";
    var each = require_each();
    module2.exports = function removeSubdocs(schema) {
      const unshift = true;
      schema.s.hooks.pre("remove", false, function removeSubDocsPreRemove(next) {
        if (this.$isSubdocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        each(subdocs, function(subdoc, cb) {
          subdoc.$__remove(cb);
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("remove:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// asset-input/node_modules/mongoose/lib/plugins/saveSubdocs.js
var require_saveSubdocs = __commonJS({
  "asset-input/node_modules/mongoose/lib/plugins/saveSubdocs.js"(exports2, module2) {
    "use strict";
    var each = require_each();
    module2.exports = function saveSubdocs(schema) {
      const unshift = true;
      schema.s.hooks.pre("save", false, function saveSubdocsPreSave(next) {
        if (this.$isSubdocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err) {
            cb(err);
          });
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
      schema.s.hooks.post("save", function saveSubdocsPostSave(doc, next) {
        if (this.$isSubdocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPost("save", subdoc, [subdoc], function(err) {
            cb(err);
          });
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// asset-input/node_modules/mongoose/lib/plugins/sharding.js
var require_sharding = __commonJS({
  "asset-input/node_modules/mongoose/lib/plugins/sharding.js"(exports2, module2) {
    "use strict";
    var objectIdSymbol = require_symbols().objectIdSymbol;
    var utils = require_utils6();
    module2.exports = function shardingPlugin(schema) {
      schema.post("init", function shardingPluginPostInit() {
        storeShard.call(this);
        return this;
      });
      schema.pre("save", function shardingPluginPreSave(next) {
        applyWhere.call(this);
        next();
      });
      schema.pre("remove", function shardingPluginPreRemove(next) {
        applyWhere.call(this);
        next();
      });
      schema.post("save", function shardingPluginPostSave() {
        storeShard.call(this);
      });
    };
    function applyWhere() {
      let paths;
      let len;
      if (this.$__.shardval) {
        paths = Object.keys(this.$__.shardval);
        len = paths.length;
        this.$where = this.$where || {};
        for (let i = 0; i < len; ++i) {
          this.$where[paths[i]] = this.$__.shardval[paths[i]];
        }
      }
    }
    module2.exports.storeShard = storeShard;
    function storeShard() {
      const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
      if (!utils.isPOJO(key)) {
        return;
      }
      const orig = this.$__.shardval = {};
      const paths = Object.keys(key);
      const len = paths.length;
      let val;
      for (let i = 0; i < len; ++i) {
        val = this.$__getValue(paths[i]);
        if (val == null) {
          orig[paths[i]] = val;
        } else if (utils.isMongooseObject(val)) {
          orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });
        } else if (val instanceof Date || val[objectIdSymbol]) {
          orig[paths[i]] = val;
        } else if (typeof val.valueOf === "function") {
          orig[paths[i]] = val.valueOf();
        } else {
          orig[paths[i]] = val;
        }
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/plugins/trackTransaction.js
var require_trackTransaction = __commonJS({
  "asset-input/node_modules/mongoose/lib/plugins/trackTransaction.js"(exports2, module2) {
    "use strict";
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    var utils = require_utils6();
    module2.exports = function trackTransaction(schema) {
      schema.pre("save", function trackTransactionPreSave() {
        const session = this.$session();
        if (session == null) {
          return;
        }
        if (session.transaction == null || session[sessionNewDocuments] == null) {
          return;
        }
        if (!session[sessionNewDocuments].has(this)) {
          const initialState = {};
          if (this.isNew) {
            initialState.isNew = true;
          }
          if (this.$__schema.options.versionKey) {
            initialState.versionKey = this.get(this.$__schema.options.versionKey);
          }
          initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify")));
          initialState.atomics = _getAtomics(this);
          session[sessionNewDocuments].set(this, initialState);
        } else {
          const state = session[sessionNewDocuments].get(this);
          for (const path of Object.keys(this.$__.activePaths.getStatePaths("modify"))) {
            state.modifiedPaths.add(path);
          }
          state.atomics = _getAtomics(this, state.atomics);
        }
      });
    };
    function _getAtomics(doc, previous) {
      const pathToAtomics = /* @__PURE__ */ new Map();
      previous = previous || /* @__PURE__ */ new Map();
      const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
      for (const path of pathsToCheck) {
        const val = doc.$__getValue(path);
        if (val != null && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
          const existing = previous.get(path) || {};
          pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      const dirty = doc.$__dirty();
      for (const dirt of dirty) {
        const path = dirt.path;
        const val = dirt.value;
        if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
          const existing = previous.get(path) || {};
          pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      return pathToAtomics;
    }
    function mergeAtomics(destination, source) {
      destination = destination || {};
      if (source.$pullAll != null) {
        destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
      }
      if (source.$push != null) {
        destination.$push = destination.$push || {};
        destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
      }
      if (source.$addToSet != null) {
        destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
      }
      if (source.$set != null) {
        destination.$set = Object.assign(destination.$set || {}, source.$set);
      }
      return destination;
    }
  }
});

// asset-input/node_modules/mongoose/lib/plugins/validateBeforeSave.js
var require_validateBeforeSave = __commonJS({
  "asset-input/node_modules/mongoose/lib/plugins/validateBeforeSave.js"(exports2, module2) {
    "use strict";
    module2.exports = function validateBeforeSave(schema) {
      const unshift = true;
      schema.pre("save", false, function validateBeforeSave2(next, options) {
        const _this = this;
        if (this.$isSubdocument) {
          return next();
        }
        const hasValidateBeforeSaveOption = options && typeof options === "object" && "validateBeforeSave" in options;
        let shouldValidate;
        if (hasValidateBeforeSaveOption) {
          shouldValidate = !!options.validateBeforeSave;
        } else {
          shouldValidate = this.$__schema.options.validateBeforeSave;
        }
        if (shouldValidate) {
          const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
          const validateOptions = hasValidateModifiedOnlyOption ? { validateModifiedOnly: options.validateModifiedOnly } : null;
          this.$validate(validateOptions, function(error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              _this.$op = "save";
              next(error2);
            });
          });
        } else {
          next();
        }
      }, null, unshift);
    };
  }
});

// asset-input/node_modules/mongoose/lib/plugins/index.js
var require_plugins = __commonJS({
  "asset-input/node_modules/mongoose/lib/plugins/index.js"(exports2) {
    "use strict";
    exports2.removeSubdocs = require_removeSubdocs();
    exports2.saveSubdocs = require_saveSubdocs();
    exports2.sharding = require_sharding();
    exports2.trackTransaction = require_trackTransaction();
    exports2.validateBeforeSave = require_validateBeforeSave();
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js
var require_applyBuiltinPlugins = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js"(exports2, module2) {
    "use strict";
    var builtinPlugins = require_plugins();
    module2.exports = function applyBuiltinPlugins(schema) {
      for (const plugin of Object.values(builtinPlugins)) {
        plugin(schema, { deduplicate: true });
      }
      schema.plugins = Object.values(builtinPlugins).map((fn) => ({ fn, opts: { deduplicate: true } })).concat(schema.plugins);
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/document/compile.js
var require_compile = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/document/compile.js"(exports2) {
    "use strict";
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils = require_utils6();
    var Document;
    var getSymbol = require_symbols().getSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    var isPOJO = utils.isPOJO;
    exports2.compile = compile;
    exports2.defineKey = defineKey;
    var _isEmptyOptions = Object.freeze({
      minimize: true,
      virtuals: false,
      getters: false,
      transform: false
    });
    var noDottedPathGetOptions = Object.freeze({
      noDottedPath: true
    });
    function compile(tree, proto, prefix, options) {
      Document = Document || require_document();
      const typeKey = options.typeKey;
      for (const key of Object.keys(tree)) {
        const limb = tree[key];
        const hasSubprops = isPOJO(limb) && Object.keys(limb).length > 0 && (!limb[typeKey] || typeKey === "type" && isPOJO(limb.type) && limb.type.type);
        const subprops = hasSubprops ? limb : null;
        defineKey({ prop: key, subprops, prototype: proto, prefix, options });
      }
    }
    function defineKey({ prop, subprops, prototype, prefix, options }) {
      Document = Document || require_document();
      const path = (prefix ? prefix + "." : "") + prop;
      prefix = prefix || "";
      const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;
      if (subprops) {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            const _this = this;
            if (!this.$__.getters) {
              this.$__.getters = {};
            }
            if (!this.$__.getters[path]) {
              const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
              if (!prefix) {
                nested.$__[scopeSymbol] = this;
              }
              nested.$__.nestedPath = path;
              Object.defineProperty(nested, "schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "$__schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, documentSchemaSymbol, {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "toObject", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return utils.clone(_this.get(path, null, {
                    virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                  }));
                }
              });
              Object.defineProperty(nested, "$__get", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path, null, {
                    virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                  });
                }
              });
              Object.defineProperty(nested, "toJSON", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path, null, {
                    virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null
                  });
                }
              });
              Object.defineProperty(nested, "$__isNested", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: true
              });
              Object.defineProperty(nested, "$isEmpty", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
                }
              });
              Object.defineProperty(nested, "$__parent", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: this
              });
              compile(subprops, nested, path, options);
              this.$__.getters[path] = nested;
            }
            return this.$__.getters[path];
          },
          set: function(v) {
            if (v != null && v.$__isNested) {
              v = v.$__get();
            } else if (v instanceof Document && !v.$__isNested) {
              v = v.$toObject(internalToObjectOptions);
            }
            const doc = this.$__[scopeSymbol] || this;
            doc.$set(path, v);
          }
        });
      } else {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            return this[getSymbol].call(
              this.$__[scopeSymbol] || this,
              path,
              null,
              useGetOptions
            );
          },
          set: function(v) {
            this.$set.call(this.$__[scopeSymbol] || this, path, v);
          }
        });
      }
    }
    function getOwnPropertyDescriptors(object) {
      const result = {};
      Object.getOwnPropertyNames(object).forEach(function(key) {
        const skip = [
          "isNew",
          "$__",
          "$errors",
          "errors",
          "_doc",
          "$locals",
          "$op",
          "__parentArray",
          "__index",
          "$isDocumentArrayElement"
        ].indexOf(key) === -1;
        if (skip) {
          return;
        }
        result[key] = Object.getOwnPropertyDescriptor(object, key);
        result[key].enumerable = false;
      });
      return result;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js
var require_mergeDiscriminatorSchema = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js"(exports2, module2) {
    "use strict";
    var schemaMerge = require_merge();
    var specialProperties = require_specialProperties();
    var isBsonType = require_isBsonType();
    var ObjectId2 = require_objectid3();
    var isObject = require_isObject();
    module2.exports = function mergeDiscriminatorSchema(to, from, path) {
      const keys = Object.keys(from);
      let i = 0;
      const len = keys.length;
      let key;
      path = path || "";
      while (i < len) {
        key = keys[i++];
        if (key === "discriminators" || key === "base" || key === "_applyDiscriminators") {
          continue;
        }
        if (path === "tree" && from != null && from.instanceOfSchema) {
          continue;
        }
        if (specialProperties.has(key)) {
          continue;
        }
        if (to[key] == null) {
          to[key] = from[key];
        } else if (isObject(from[key])) {
          if (!isObject(to[key])) {
            to[key] = {};
          }
          if (from[key] != null) {
            if (from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested || from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement) {
              continue;
            } else if (from[key].instanceOfSchema) {
              if (to[key].instanceOfSchema) {
                schemaMerge(to[key], from[key].clone(), true);
              } else {
                to[key] = from[key].clone();
              }
              continue;
            } else if (isBsonType(from[key], "ObjectID")) {
              to[key] = new ObjectId2(from[key]);
              continue;
            }
          }
          mergeDiscriminatorSchema(to[key], from[key], path ? path + "." + key : key);
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/discriminator.js
var require_discriminator = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/discriminator.js"(exports2, module2) {
    "use strict";
    var Mixed = require_mixed();
    var applyBuiltinPlugins = require_applyBuiltinPlugins();
    var defineKey = require_compile().defineKey;
    var get = require_get();
    var utils = require_utils6();
    var mergeDiscriminatorSchema = require_mergeDiscriminatorSchema();
    var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
      toJSON: true,
      toObject: true,
      _id: true,
      id: true,
      virtuals: true,
      methods: true
    };
    module2.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks) {
      if (!(schema && schema.instanceOfSchema)) {
        throw new Error("You must pass a valid discriminator Schema");
      }
      mergeHooks = mergeHooks == null ? true : mergeHooks;
      if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
        throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
      }
      if (applyPlugins) {
        const applyPluginsToDiscriminators = get(
          model.base,
          "options.applyPluginsToDiscriminators",
          false
        ) || !mergeHooks;
        model.base._applyPlugins(schema, {
          skipTopLevel: !applyPluginsToDiscriminators
        });
      } else if (!mergeHooks) {
        applyBuiltinPlugins(schema);
      }
      const key = model.schema.options.discriminatorKey;
      const existingPath = model.schema.path(key);
      if (existingPath != null) {
        if (!utils.hasUserDefinedProperty(existingPath.options, "select")) {
          existingPath.options.select = true;
        }
        existingPath.options.$skipDiscriminatorCheck = true;
      } else {
        const baseSchemaAddition = {};
        baseSchemaAddition[key] = {
          default: void 0,
          select: true,
          $skipDiscriminatorCheck: true
        };
        baseSchemaAddition[key][model.schema.options.typeKey] = String;
        model.schema.add(baseSchemaAddition);
        defineKey({
          prop: key,
          prototype: model.prototype,
          options: model.schema.options
        });
      }
      if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
        throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
      }
      let value = name;
      if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
        value = tiedValue;
      }
      function merge(schema2, baseSchema) {
        schema2._baseSchema = baseSchema;
        if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
          schema2.remove("_id");
        }
        const baseSchemaPaths = Object.keys(baseSchema.paths);
        const conflictingPaths = [];
        for (const path of baseSchemaPaths) {
          if (schema2.nested[path]) {
            conflictingPaths.push(path);
            continue;
          }
          if (path.indexOf(".") === -1) {
            continue;
          }
          const sp = path.split(".").slice(0, -1);
          let cur = "";
          for (const piece of sp) {
            cur += (cur.length ? "." : "") + piece;
            if (schema2.paths[cur] instanceof Mixed || schema2.singleNestedPaths[cur] instanceof Mixed) {
              conflictingPaths.push(path);
            }
          }
        }
        mergeDiscriminatorSchema(schema2, baseSchema, {
          omit: { discriminators: true, base: true, _applyDiscriminators: true },
          omitNested: conflictingPaths.reduce((cur, path) => {
            cur["tree." + path] = true;
            return cur;
          }, {})
        });
        for (const conflictingPath of conflictingPaths) {
          delete schema2.paths[conflictingPath];
        }
        schema2.childSchemas.forEach((obj2) => {
          obj2.model.prototype.$__setSchema(obj2.schema);
        });
        const obj = {};
        obj[key] = {
          default: value,
          select: true,
          set: function(newName) {
            if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {
              return value;
            }
            throw new Error(`Can't set discriminator key "` + key + '"');
          },
          $skipDiscriminatorCheck: true
        };
        obj[key][schema2.options.typeKey] = existingPath ? existingPath.options[schema2.options.typeKey] : String;
        schema2.add(obj);
        schema2.discriminatorMapping = { key, value, isRoot: false };
        if (baseSchema.options.collection) {
          schema2.options.collection = baseSchema.options.collection;
        }
        const toJSON = schema2.options.toJSON;
        const toObject = schema2.options.toObject;
        const _id = schema2.options._id;
        const id = schema2.options.id;
        const keys = Object.keys(schema2.options);
        schema2.options.discriminatorKey = baseSchema.options.discriminatorKey;
        for (const _key of keys) {
          if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
            if (_key === "pluralization" && schema2.options[_key] == true && baseSchema.options[_key] == null) {
              continue;
            }
            if (!utils.deepEqual(schema2.options[_key], baseSchema.options[_key])) {
              throw new Error("Can't customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
            }
          }
        }
        schema2.options = utils.clone(baseSchema.options);
        if (toJSON) schema2.options.toJSON = toJSON;
        if (toObject) schema2.options.toObject = toObject;
        if (typeof _id !== "undefined") {
          schema2.options._id = _id;
        }
        schema2.options.id = id;
        if (mergeHooks) {
          schema2.s.hooks = model.schema.s.hooks.merge(schema2.s.hooks);
        }
        if (applyPlugins) {
          schema2.plugins = Array.prototype.slice.call(baseSchema.plugins);
        }
        schema2.callQueue = baseSchema.callQueue.concat(schema2.callQueue);
        delete schema2._requiredpaths;
      }
      merge(schema, model.schema);
      if (!model.discriminators) {
        model.discriminators = {};
      }
      if (!model.schema.discriminatorMapping) {
        model.schema.discriminatorMapping = { key, value: null, isRoot: true };
      }
      if (!model.schema.discriminators) {
        model.schema.discriminators = {};
      }
      model.schema.discriminators[name] = schema;
      if (model.discriminators[name] && !schema.options.overwriteModels) {
        throw new Error('Discriminator with name "' + name + '" already exists');
      }
      return schema;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js
var require_getConstructor = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js"(exports2, module2) {
    "use strict";
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    module2.exports = function getConstructor(Constructor, value) {
      const discriminatorKey = Constructor.schema.options.discriminatorKey;
      if (value != null && Constructor.discriminators && value[discriminatorKey] != null) {
        if (Constructor.discriminators[value[discriminatorKey]]) {
          Constructor = Constructor.discriminators[value[discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      return Constructor;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/handleIdOption.js
var require_handleIdOption = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/handleIdOption.js"(exports2, module2) {
    "use strict";
    var addAutoId = require_addAutoId();
    module2.exports = function handleIdOption(schema, options) {
      if (options == null || options._id == null) {
        return schema;
      }
      schema = schema.clone();
      if (!options._id) {
        schema.remove("_id");
        schema.options._id = false;
      } else if (!schema.paths["_id"]) {
        addAutoId(schema);
        schema.options._id = true;
      }
      return schema;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js
var require_isDefiningProjection = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function isDefiningProjection(val) {
      if (val == null) {
        return true;
      }
      if (typeof val === "object") {
        return !("$meta" in val) && !("$slice" in val);
      }
      return true;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/isExclusive.js
var require_isExclusive = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/isExclusive.js"(exports2, module2) {
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isExclusive(projection) {
      if (projection == null) {
        return null;
      }
      const keys = Object.keys(projection);
      let ki = keys.length;
      let exclude = null;
      if (ki === 1 && keys[0] === "_id") {
        exclude = !projection._id;
      } else {
        while (ki--) {
          const key = keys[ki];
          if (key !== "_id" && isDefiningProjection(projection[key])) {
            exclude = projection[key] != null && typeof projection[key] === "object" ? isExclusive(projection[key]) : !projection[key];
            break;
          }
        }
      }
      return exclude;
    };
  }
});

// asset-input/node_modules/mongoose/lib/schema/SubdocumentPath.js
var require_SubdocumentPath = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/SubdocumentPath.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var EventEmitter = require("events").EventEmitter;
    var ObjectExpectedError = require_objectExpected();
    var SchemaSubdocumentOptions = require_SchemaSubdocumentOptions();
    var SchemaType = require_schematype();
    var applyDefaults = require_applyDefaults();
    var $exists = require_exists();
    var castToNumber = require_helpers3().castToNumber;
    var discriminator = require_discriminator();
    var geospatial = require_geospatial();
    var getConstructor = require_getConstructor();
    var handleIdOption = require_handleIdOption();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var isExclusive = require_isExclusive();
    var utils = require_utils6();
    var Subdocument;
    module2.exports = SubdocumentPath;
    function SubdocumentPath(schema, path, options) {
      const schemaTypeIdOption = SubdocumentPath.defaultOptions && SubdocumentPath.defaultOptions._id;
      if (schemaTypeIdOption != null) {
        options = options || {};
        options._id = schemaTypeIdOption;
      }
      schema = handleIdOption(schema, options);
      this.caster = _createConstructor(schema);
      this.caster.path = path;
      this.caster.prototype.$basePath = path;
      this.schema = schema;
      this.$isSingleNested = true;
      this.base = schema.base;
      SchemaType.call(this, path, options, "Embedded");
    }
    SubdocumentPath.prototype = Object.create(SchemaType.prototype);
    SubdocumentPath.prototype.constructor = SubdocumentPath;
    SubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;
    function _createConstructor(schema, baseClass) {
      Subdocument || (Subdocument = require_subdocument());
      const _embedded = function SingleNested(value, path, parent) {
        this.$__parent = parent;
        Subdocument.apply(this, arguments);
        if (parent == null) {
          return;
        }
        this.$session(parent.$session());
      };
      schema._preCompile();
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      _embedded.prototype = Object.create(proto);
      _embedded.prototype.$__setSchema(schema);
      _embedded.prototype.constructor = _embedded;
      _embedded.schema = schema;
      _embedded.$isSingleNested = true;
      _embedded.events = new EventEmitter();
      _embedded.prototype.toBSON = function() {
        return this.toObject(internalToObjectOptions);
      };
      for (const i in schema.methods) {
        _embedded.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        _embedded[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        _embedded[i] = EventEmitter.prototype[i];
      }
      return _embedded;
    }
    SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
      return { $geometry: this.castForQuery(val.$geometry) };
    };
    SubdocumentPath.prototype.$conditionalHandlers.$near = SubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
    SubdocumentPath.prototype.$conditionalHandlers.$within = SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
    SubdocumentPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
    SubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;
    SubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;
    SubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;
    SubdocumentPath.prototype.cast = function(val, doc, init, priorVal, options) {
      if (val && val.$isSingleNested && val.parent === doc) {
        return val;
      }
      if (val != null && (typeof val !== "object" || Array.isArray(val))) {
        throw new ObjectExpectedError(this.path, val);
      }
      const Constructor = getConstructor(this.caster, val);
      let subdoc;
      const parentSelected = doc && doc.$__ && doc.$__.selected;
      const path = this.path;
      const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {
        if (key.startsWith(path + ".")) {
          obj = obj || {};
          obj[key.substring(path.length + 1)] = parentSelected[key];
        }
        return obj;
      }, null);
      if (init) {
        subdoc = new Constructor(void 0, selected, doc, false, { defaults: false });
        delete subdoc.$__.defaults;
        subdoc.$init(val);
        const exclude = isExclusive(selected);
        applyDefaults(subdoc, selected, exclude);
      } else {
        options = Object.assign({}, options, { priorDoc: priorVal });
        if (Object.keys(val).length === 0) {
          return new Constructor({}, selected, doc, void 0, options);
        }
        return new Constructor(val, selected, doc, void 0, options);
      }
      return subdoc;
    };
    SubdocumentPath.prototype.castForQuery = function($conditional, val, options) {
      let handler2;
      if (arguments.length === 2) {
        handler2 = this.$conditionalHandlers[$conditional];
        if (!handler2) {
          throw new Error("Can't use " + $conditional);
        }
        return handler2.call(this, val);
      }
      val = $conditional;
      if (val == null) {
        return val;
      }
      if (this.options.runSetters) {
        val = this._applySetters(val);
      }
      const Constructor = getConstructor(this.caster, val);
      const overrideStrict = options != null && options.strict != null ? options.strict : void 0;
      try {
        val = new Constructor(val, overrideStrict);
      } catch (error) {
        if (!(error instanceof CastError)) {
          throw new CastError("Embedded", val, this.path, error, this);
        }
        throw error;
      }
      return val;
    };
    SubdocumentPath.prototype.doValidate = function(value, fn, scope, options) {
      const Constructor = getConstructor(this.caster, value);
      if (value && !(value instanceof Constructor)) {
        value = new Constructor(value, null, scope != null && scope.$__ != null ? scope : null);
      }
      if (options && options.skipSchemaValidators) {
        if (!value) {
          return fn(null);
        }
        return value.validate(fn);
      }
      SchemaType.prototype.doValidate.call(this, value, function(error) {
        if (error) {
          return fn(error);
        }
        if (!value) {
          return fn(null);
        }
        value.validate(fn);
      }, scope, options);
    };
    SubdocumentPath.prototype.doValidateSync = function(value, scope, options) {
      if (!options || !options.skipSchemaValidators) {
        const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
        if (schemaTypeError) {
          return schemaTypeError;
        }
      }
      if (!value) {
        return;
      }
      return value.validateSync();
    };
    SubdocumentPath.prototype.discriminator = function(name, schema, options) {
      options = options || {};
      const value = utils.isPOJO(options) ? options.value : options;
      const clone = typeof options.clone === "boolean" ? options.clone : true;
      if (schema.instanceOfSchema && clone) {
        schema = schema.clone();
      }
      schema = discriminator(this.caster, name, schema, value);
      this.caster.discriminators[name] = _createConstructor(schema, this.caster);
      return this.caster.discriminators[name];
    };
    SubdocumentPath.defaultOptions = {};
    SubdocumentPath.set = SchemaType.set;
    SubdocumentPath.prototype.toJSON = function toJSON() {
      return { path: this.path, options: this.options };
    };
    SubdocumentPath.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.schema, this.path, options);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
      return schematype;
    };
  }
});

// asset-input/node_modules/mongoose/lib/schema/DocumentArrayElement.js
var require_DocumentArrayElement = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/DocumentArrayElement.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var SchemaType = require_schematype();
    var SubdocumentPath = require_SubdocumentPath();
    var getConstructor = require_getConstructor();
    function DocumentArrayElement(path, options) {
      this.$parentSchemaType = options && options.$parentSchemaType;
      if (!this.$parentSchemaType) {
        throw new MongooseError("Cannot create DocumentArrayElement schematype without a parent");
      }
      delete options.$parentSchemaType;
      SchemaType.call(this, path, options, "DocumentArrayElement");
      this.$isMongooseDocumentArrayElement = true;
    }
    DocumentArrayElement.schemaName = "DocumentArrayElement";
    DocumentArrayElement.defaultOptions = {};
    DocumentArrayElement.prototype = Object.create(SchemaType.prototype);
    DocumentArrayElement.prototype.constructor = DocumentArrayElement;
    DocumentArrayElement.prototype.cast = function(...args) {
      return this.$parentSchemaType.cast(...args)[0];
    };
    DocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {
      const Constructor = getConstructor(this.caster, value);
      if (value && !(value instanceof Constructor)) {
        value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);
      }
      return SubdocumentPath.prototype.doValidate.call(this, value, fn, scope, options);
    };
    DocumentArrayElement.prototype.clone = function() {
      this.options.$parentSchemaType = this.$parentSchemaType;
      const ret = SchemaType.prototype.clone.apply(this, arguments);
      delete this.options.$parentSchemaType;
      ret.caster = this.caster;
      ret.schema = this.schema;
      return ret;
    };
    module2.exports = DocumentArrayElement;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js
var require_SchemaDocumentArrayOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDocumentArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
    module2.exports = SchemaDocumentArrayOptions;
  }
});

// asset-input/node_modules/mongoose/lib/schema/documentarray.js
var require_documentarray = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/documentarray.js"(exports2, module2) {
    "use strict";
    var ArrayType = require_array2();
    var CastError = require_cast();
    var DocumentArrayElement = require_DocumentArrayElement();
    var EventEmitter = require("events").EventEmitter;
    var SchemaDocumentArrayOptions = require_SchemaDocumentArrayOptions();
    var SchemaType = require_schematype();
    var discriminator = require_discriminator();
    var handleIdOption = require_handleIdOption();
    var handleSpreadDoc = require_handleSpreadDoc();
    var utils = require_utils6();
    var getConstructor = require_getConstructor();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var MongooseDocumentArray;
    var Subdocument;
    function DocumentArrayPath(key, schema, options, schemaOptions) {
      const schemaTypeIdOption = DocumentArrayPath.defaultOptions && DocumentArrayPath.defaultOptions._id;
      if (schemaTypeIdOption != null) {
        schemaOptions = schemaOptions || {};
        schemaOptions._id = schemaTypeIdOption;
      }
      if (schemaOptions != null && schemaOptions._id != null) {
        schema = handleIdOption(schema, schemaOptions);
      } else if (options != null && options._id != null) {
        schema = handleIdOption(schema, options);
      }
      const EmbeddedDocument = _createConstructor(schema, options);
      EmbeddedDocument.prototype.$basePath = key;
      ArrayType.call(this, key, EmbeddedDocument, options);
      this.schema = schema;
      this.schemaOptions = schemaOptions || {};
      this.$isMongooseDocumentArray = true;
      this.Constructor = EmbeddedDocument;
      EmbeddedDocument.base = schema.base;
      const fn = this.defaultValue;
      if (!("defaultValue" in this) || fn !== void 0) {
        this.default(function() {
          let arr = fn.call(this);
          if (arr != null && !Array.isArray(arr)) {
            arr = [arr];
          }
          return arr;
        });
      }
      const $parentSchemaType = this;
      this.$embeddedSchemaType = new DocumentArrayElement(key + ".$", {
        required: this && this.schemaOptions && this.schemaOptions.required || false,
        $parentSchemaType
      });
      this.$embeddedSchemaType.caster = this.Constructor;
      this.$embeddedSchemaType.schema = this.schema;
    }
    DocumentArrayPath.schemaName = "DocumentArray";
    DocumentArrayPath.options = { castNonArrays: true };
    DocumentArrayPath.prototype = Object.create(ArrayType.prototype);
    DocumentArrayPath.prototype.constructor = DocumentArrayPath;
    DocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
    function _createConstructor(schema, options, baseClass) {
      Subdocument || (Subdocument = require_ArraySubdocument());
      function EmbeddedDocument() {
        Subdocument.apply(this, arguments);
        if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {
          return;
        }
        this.$session(this.__parentArray.getArrayParent().$session());
      }
      schema._preCompile();
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      EmbeddedDocument.prototype = Object.create(proto);
      EmbeddedDocument.prototype.$__setSchema(schema);
      EmbeddedDocument.schema = schema;
      EmbeddedDocument.prototype.constructor = EmbeddedDocument;
      EmbeddedDocument.$isArraySubdocument = true;
      EmbeddedDocument.events = new EventEmitter();
      EmbeddedDocument.base = schema.base;
      for (const i in schema.methods) {
        EmbeddedDocument.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        EmbeddedDocument[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        EmbeddedDocument[i] = EventEmitter.prototype[i];
      }
      EmbeddedDocument.options = options;
      return EmbeddedDocument;
    }
    DocumentArrayPath.prototype.discriminator = function(name, schema, options) {
      if (typeof name === "function") {
        name = utils.getFunctionName(name);
      }
      options = options || {};
      const tiedValue = utils.isPOJO(options) ? options.value : options;
      const clone = typeof options.clone === "boolean" ? options.clone : true;
      if (schema.instanceOfSchema && clone) {
        schema = schema.clone();
      }
      schema = discriminator(this.casterConstructor, name, schema, tiedValue);
      const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
      EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
      try {
        Object.defineProperty(EmbeddedDocument, "name", {
          value: name
        });
      } catch (error) {
      }
      this.casterConstructor.discriminators[name] = EmbeddedDocument;
      return this.casterConstructor.discriminators[name];
    };
    DocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {
      MongooseDocumentArray || (MongooseDocumentArray = require_DocumentArray());
      const _this = this;
      try {
        SchemaType.prototype.doValidate.call(this, array, cb, scope);
      } catch (err) {
        return fn(err);
      }
      function cb(err) {
        if (err) {
          return fn(err);
        }
        let count = array && array.length;
        let error;
        if (!count) {
          return fn();
        }
        if (options && options.updateValidator) {
          return fn();
        }
        if (!utils.isMongooseDocumentArray(array)) {
          array = new MongooseDocumentArray(array, _this.path, scope);
        }
        function callback(err2) {
          if (err2 != null) {
            error = err2;
          }
          --count || fn(error);
        }
        for (let i = 0, len = count; i < len; ++i) {
          let doc = array[i];
          if (doc == null) {
            --count || fn(error);
            continue;
          }
          if (!(doc instanceof Subdocument)) {
            const Constructor = getConstructor(_this.casterConstructor, array[i]);
            doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
          }
          if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
            --count || fn(error);
            continue;
          }
          doc.$__validate(callback);
        }
      }
    };
    DocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {
      const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
      if (schemaTypeError != null) {
        return schemaTypeError;
      }
      const count = array && array.length;
      let resultError = null;
      if (!count) {
        return;
      }
      for (let i = 0, len = count; i < len; ++i) {
        let doc = array[i];
        if (!doc) {
          continue;
        }
        if (!(doc instanceof Subdocument)) {
          const Constructor = getConstructor(this.casterConstructor, array[i]);
          doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
        }
        if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
          continue;
        }
        const subdocValidateError = doc.validateSync();
        if (subdocValidateError && resultError == null) {
          resultError = subdocValidateError;
        }
      }
      return resultError;
    };
    DocumentArrayPath.prototype.getDefault = function(scope, init, options) {
      let ret = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
      if (ret == null) {
        return ret;
      }
      if (options && options.skipCast) {
        return ret;
      }
      MongooseDocumentArray || (MongooseDocumentArray = require_DocumentArray());
      if (!Array.isArray(ret)) {
        ret = [ret];
      }
      ret = new MongooseDocumentArray(ret, this.path, scope);
      for (let i = 0; i < ret.length; ++i) {
        const Constructor = getConstructor(this.casterConstructor, ret[i]);
        const _subdoc = new Constructor(
          {},
          ret,
          void 0,
          void 0,
          i
        );
        _subdoc.$init(ret[i]);
        _subdoc.isNew = true;
        Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
        _subdoc.$__.activePaths.init = {};
        ret[i] = _subdoc;
      }
      return ret;
    };
    var _toObjectOptions = Object.freeze({ transform: false, virtuals: false });
    var initDocumentOptions = Object.freeze({ skipId: false, willInit: true });
    DocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {
      MongooseDocumentArray || (MongooseDocumentArray = require_DocumentArray());
      if (value != null && value[arrayPathSymbol] != null && value === prev) {
        return value;
      }
      let selected;
      let subdoc;
      options = options || {};
      const path = options.path || this.path;
      if (!Array.isArray(value)) {
        if (!init && !DocumentArrayPath.options.castNonArrays) {
          throw new CastError("DocumentArray", value, this.path, null, this);
        }
        if (!!doc && init) {
          doc.markModified(path);
        }
        return this.cast([value], doc, init, prev, options);
      }
      if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {
        value = new MongooseDocumentArray(value, path, doc);
      }
      if (prev != null) {
        value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
      }
      if (options.arrayPathIndex != null) {
        value[arrayPathSymbol] = path + "." + options.arrayPathIndex;
      }
      const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;
      const len = rawArray.length;
      for (let i = 0; i < len; ++i) {
        if (!rawArray[i]) {
          continue;
        }
        const Constructor = getConstructor(this.casterConstructor, rawArray[i]);
        const spreadDoc = handleSpreadDoc(rawArray[i], true);
        if (rawArray[i] !== spreadDoc) {
          rawArray[i] = spreadDoc;
        }
        if (rawArray[i] instanceof Subdocument) {
          if (rawArray[i][documentArrayParent] !== doc) {
            if (init) {
              const subdoc2 = new Constructor(null, value, initDocumentOptions, selected, i);
              rawArray[i] = subdoc2.$init(rawArray[i]);
            } else {
              const subdoc2 = new Constructor(rawArray[i], value, void 0, void 0, i);
              rawArray[i] = subdoc2;
            }
          }
          if (rawArray[i].__index == null) {
            rawArray[i].$setIndex(i);
          }
        } else if (rawArray[i] != null) {
          if (init) {
            if (doc) {
              selected || (selected = scopePaths(this, doc.$__.selected, init));
            } else {
              selected = true;
            }
            subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
            rawArray[i] = subdoc.$init(rawArray[i]);
          } else {
            if (prev && typeof prev.id === "function") {
              subdoc = prev.id(rawArray[i]._id);
            }
            if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {
              subdoc.set(rawArray[i]);
              rawArray[i] = subdoc;
            } else {
              try {
                subdoc = new Constructor(
                  rawArray[i],
                  value,
                  void 0,
                  void 0,
                  i
                );
                rawArray[i] = subdoc;
              } catch (error) {
                throw new CastError(
                  "embedded",
                  rawArray[i],
                  value[arrayPathSymbol],
                  error,
                  this
                );
              }
            }
          }
        }
      }
      return value;
    };
    DocumentArrayPath.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.Constructor.discriminators = Object.assign(
        {},
        this.Constructor.discriminators
      );
      return schematype;
    };
    DocumentArrayPath.prototype.applyGetters = function(value, scope) {
      return SchemaType.prototype.applyGetters.call(this, value, scope);
    };
    function scopePaths(array, fields, init) {
      if (!(init && fields)) {
        return void 0;
      }
      const path = array.path + ".";
      const keys = Object.keys(fields);
      let i = keys.length;
      const selected = {};
      let hasKeys;
      let key;
      let sub;
      while (i--) {
        key = keys[i];
        if (key.startsWith(path)) {
          sub = key.substring(path.length);
          if (sub === "$") {
            continue;
          }
          if (sub.startsWith("$.")) {
            sub = sub.substring(2);
          }
          hasKeys || (hasKeys = true);
          selected[sub] = fields[key];
        }
      }
      return hasKeys && selected || void 0;
    }
    DocumentArrayPath.defaultOptions = {};
    DocumentArrayPath.set = SchemaType.set;
    module2.exports = DocumentArrayPath;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaBufferOptions.js
var require_SchemaBufferOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaBufferOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaBufferOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
    module2.exports = SchemaBufferOptions;
  }
});

// asset-input/node_modules/mongoose/lib/schema/buffer.js
var require_buffer2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/buffer.js"(exports2, module2) {
    "use strict";
    var MongooseBuffer = require_buffer();
    var SchemaBufferOptions = require_SchemaBufferOptions();
    var SchemaType = require_schematype();
    var handleBitwiseOperator = require_bitwise();
    var utils = require_utils6();
    var Binary = MongooseBuffer.Binary;
    var CastError = SchemaType.CastError;
    function SchemaBuffer(key, options) {
      SchemaType.call(this, key, options, "Buffer");
    }
    SchemaBuffer.schemaName = "Buffer";
    SchemaBuffer.defaultOptions = {};
    SchemaBuffer.prototype = Object.create(SchemaType.prototype);
    SchemaBuffer.prototype.constructor = SchemaBuffer;
    SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
    SchemaBuffer._checkRequired = (v) => !!(v && v.length);
    SchemaBuffer.set = SchemaType.set;
    SchemaBuffer.checkRequired = SchemaType.checkRequired;
    SchemaBuffer.prototype.checkRequired = function(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      return this.constructor._checkRequired(value);
    };
    SchemaBuffer.prototype.cast = function(value, doc, init) {
      let ret;
      if (SchemaType._isRef(this, value, doc, init)) {
        if (value && value.isMongooseBuffer) {
          return value;
        }
        if (Buffer.isBuffer(value)) {
          if (!value || !value.isMongooseBuffer) {
            value = new MongooseBuffer(value, [this.path, doc]);
            if (this.options.subtype != null) {
              value._subtype = this.options.subtype;
            }
          }
          return value;
        }
        if (value instanceof Binary) {
          ret = new MongooseBuffer(value.value(true), [this.path, doc]);
          if (typeof value.sub_type !== "number") {
            throw new CastError("Buffer", value, this.path, null, this);
          }
          ret._subtype = value.sub_type;
          return ret;
        }
        if (value == null || utils.isNonBuiltinObject(value)) {
          return this._castRef(value, doc, init);
        }
      }
      if (value && value._id) {
        value = value._id;
      }
      if (value && value.isMongooseBuffer) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
          value = new MongooseBuffer(value, [this.path, doc]);
          if (this.options.subtype != null) {
            value._subtype = this.options.subtype;
          }
        }
        return value;
      }
      if (value instanceof Binary) {
        ret = new MongooseBuffer(value.value(true), [this.path, doc]);
        if (typeof value.sub_type !== "number") {
          throw new CastError("Buffer", value, this.path, null, this);
        }
        ret._subtype = value.sub_type;
        return ret;
      }
      if (value === null) {
        return value;
      }
      const type = typeof value;
      if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
        if (type === "number") {
          value = [value];
        }
        ret = new MongooseBuffer(value, [this.path, doc]);
        if (this.options.subtype != null) {
          ret._subtype = this.options.subtype;
        }
        return ret;
      }
      throw new CastError("Buffer", value, this.path, null, this);
    };
    SchemaBuffer.prototype.subtype = function(subtype) {
      this.options.subtype = subtype;
      return this;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    SchemaBuffer.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaBuffer.prototype.castForQuery = function($conditional, val) {
      let handler2;
      if (arguments.length === 2) {
        handler2 = this.$conditionalHandlers[$conditional];
        if (!handler2) {
          throw new Error("Can't use " + $conditional + " with Buffer.");
        }
        return handler2.call(this, val);
      }
      val = $conditional;
      const casted = this._castForQuery(val);
      return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
    };
    module2.exports = SchemaBuffer;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaDateOptions.js
var require_SchemaDateOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaDateOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDateOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
    module2.exports = SchemaDateOptions;
  }
});

// asset-input/node_modules/mongoose/lib/cast/date.js
var require_date = __commonJS({
  "asset-input/node_modules/mongoose/lib/cast/date.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    module2.exports = function castDate(value) {
      if (value == null || value === "") {
        return null;
      }
      if (value instanceof Date) {
        assert.ok(!isNaN(value.valueOf()));
        return value;
      }
      let date;
      assert.ok(typeof value !== "boolean");
      if (value instanceof Number || typeof value === "number") {
        date = new Date(value);
      } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
        date = new Date(Number(value));
      } else if (typeof value.valueOf === "function") {
        date = new Date(value.valueOf());
      } else {
        date = new Date(value);
      }
      if (!isNaN(date.valueOf())) {
        return date;
      }
      assert.ok(false);
    };
  }
});

// asset-input/node_modules/mongoose/lib/schema/date.js
var require_date2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/date.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SchemaDateOptions = require_SchemaDateOptions();
    var SchemaType = require_schematype();
    var castDate = require_date();
    var getConstructorName = require_getConstructorName();
    var utils = require_utils6();
    var CastError = SchemaType.CastError;
    function SchemaDate(key, options) {
      SchemaType.call(this, key, options, "Date");
    }
    SchemaDate.schemaName = "Date";
    SchemaDate.defaultOptions = {};
    SchemaDate.prototype = Object.create(SchemaType.prototype);
    SchemaDate.prototype.constructor = SchemaDate;
    SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
    SchemaDate._cast = castDate;
    SchemaDate.set = SchemaType.set;
    SchemaDate.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaDate._defaultCaster = (v) => {
      if (v != null && !(v instanceof Date)) {
        throw new Error();
      }
      return v;
    };
    SchemaDate.prototype.expires = function(when) {
      if (getConstructorName(this._index) !== "Object") {
        this._index = {};
      }
      this._index.expires = when;
      utils.expires(this._index);
      return this;
    };
    SchemaDate._checkRequired = (v) => v instanceof Date;
    SchemaDate.checkRequired = SchemaType.checkRequired;
    SchemaDate.prototype.checkRequired = function(value, doc) {
      if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return value != null;
      }
      const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
      return _checkRequired(value);
    };
    SchemaDate.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.min;
        if (typeof msg === "string") {
          msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.minValidator = function(val) {
            let _value = value;
            if (typeof value === "function" && value !== Date.now) {
              _value = _value.call(this);
            }
            const min = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() >= min.valueOf();
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaDate.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.max;
        if (typeof msg === "string") {
          msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.maxValidator = function(val) {
            let _value = value;
            if (typeof _value === "function" && _value !== Date.now) {
              _value = _value.call(this);
            }
            const max = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() <= max.valueOf();
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaDate.prototype.cast = function(value) {
      let castDate2;
      if (typeof this._castFunction === "function") {
        castDate2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDate2 = this.constructor.cast();
      } else {
        castDate2 = SchemaDate.cast();
      }
      try {
        return castDate2(value);
      } catch (error) {
        throw new CastError("date", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    SchemaDate.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaDate.prototype.castForQuery = function($conditional, val) {
      if (arguments.length !== 2) {
        return this._castForQuery($conditional);
      }
      const handler2 = this.$conditionalHandlers[$conditional];
      if (!handler2) {
        throw new Error("Can't use " + $conditional + " with Date.");
      }
      return handler2.call(this, val);
    };
    module2.exports = SchemaDate;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js
var require_SchemaObjectIdOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaObjectIdOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
    Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
    module2.exports = SchemaObjectIdOptions;
  }
});

// asset-input/node_modules/mongoose/lib/schema/objectid.js
var require_objectid5 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/objectid.js"(exports2, module2) {
    "use strict";
    var SchemaObjectIdOptions = require_SchemaObjectIdOptions();
    var SchemaType = require_schematype();
    var castObjectId = require_objectid4();
    var getConstructorName = require_getConstructorName();
    var oid = require_objectid3();
    var isBsonType = require_isBsonType();
    var utils = require_utils6();
    var CastError = SchemaType.CastError;
    var Document;
    function ObjectId2(key, options) {
      const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
      const suppressWarning = options && options.suppressWarning;
      if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
        utils.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema.");
      }
      SchemaType.call(this, key, options, "ObjectID");
    }
    ObjectId2.schemaName = "ObjectId";
    ObjectId2.defaultOptions = {};
    ObjectId2.prototype = Object.create(SchemaType.prototype);
    ObjectId2.prototype.constructor = ObjectId2;
    ObjectId2.prototype.OptionsConstructor = SchemaObjectIdOptions;
    ObjectId2.get = SchemaType.get;
    ObjectId2.set = SchemaType.set;
    ObjectId2.prototype.auto = function(turnOn) {
      if (turnOn) {
        this.default(defaultId);
        this.set(resetId);
      }
      return this;
    };
    ObjectId2._checkRequired = (v) => isBsonType(v, "ObjectID");
    ObjectId2._cast = castObjectId;
    ObjectId2.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    ObjectId2._defaultCaster = (v) => {
      if (!isBsonType(v, "ObjectID")) {
        throw new Error(v + " is not an instance of ObjectId");
      }
      return v;
    };
    ObjectId2.checkRequired = SchemaType.checkRequired;
    ObjectId2.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : ObjectId2.checkRequired();
      return _checkRequired(value);
    };
    ObjectId2.prototype.cast = function(value, doc, init) {
      if (!isBsonType(value, "ObjectID") && SchemaType._isRef(this, value, doc, init)) {
        if ((getConstructorName(value) || "").toLowerCase() === "objectid") {
          return new oid(value.toHexString());
        }
        if (value == null || utils.isNonBuiltinObject(value)) {
          return this._castRef(value, doc, init);
        }
      }
      let castObjectId2;
      if (typeof this._castFunction === "function") {
        castObjectId2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castObjectId2 = this.constructor.cast();
      } else {
        castObjectId2 = ObjectId2.cast();
      }
      try {
        return castObjectId2(value);
      } catch (error) {
        throw new CastError("ObjectId", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    ObjectId2.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    function defaultId() {
      return new oid();
    }
    defaultId.$runBeforeSetters = true;
    function resetId(v) {
      Document || (Document = require_document());
      if (this instanceof Document) {
        if (v === void 0) {
          const _v = new oid();
          return _v;
        }
      }
      return v;
    }
    module2.exports = ObjectId2;
  }
});

// asset-input/node_modules/mongoose/lib/cast/decimal128.js
var require_decimal1283 = __commonJS({
  "asset-input/node_modules/mongoose/lib/cast/decimal128.js"(exports2, module2) {
    "use strict";
    var Decimal128Type = require_decimal1282();
    var assert = require("assert");
    module2.exports = function castDecimal128(value) {
      if (value == null) {
        return value;
      }
      if (typeof value === "object" && typeof value.$numberDecimal === "string") {
        return Decimal128Type.fromString(value.$numberDecimal);
      }
      if (value instanceof Decimal128Type) {
        return value;
      }
      if (typeof value === "string") {
        return Decimal128Type.fromString(value);
      }
      if (Buffer.isBuffer(value)) {
        return new Decimal128Type(value);
      }
      if (typeof value === "number") {
        return Decimal128Type.fromString(String(value));
      }
      if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
        return Decimal128Type.fromString(value.valueOf());
      }
      assert.ok(false);
    };
  }
});

// asset-input/node_modules/mongoose/lib/schema/decimal128.js
var require_decimal1284 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/decimal128.js"(exports2, module2) {
    "use strict";
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var castDecimal128 = require_decimal1283();
    var utils = require_utils6();
    var isBsonType = require_isBsonType();
    function Decimal128(key, options) {
      SchemaType.call(this, key, options, "Decimal128");
    }
    Decimal128.schemaName = "Decimal128";
    Decimal128.defaultOptions = {};
    Decimal128.prototype = Object.create(SchemaType.prototype);
    Decimal128.prototype.constructor = Decimal128;
    Decimal128._cast = castDecimal128;
    Decimal128.set = SchemaType.set;
    Decimal128.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    Decimal128._defaultCaster = (v) => {
      if (v != null && !isBsonType(v, "Decimal128")) {
        throw new Error();
      }
      return v;
    };
    Decimal128._checkRequired = (v) => isBsonType(v, "Decimal128");
    Decimal128.checkRequired = SchemaType.checkRequired;
    Decimal128.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : Decimal128.checkRequired();
      return _checkRequired(value);
    };
    Decimal128.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (isBsonType(value, "Decimal128")) {
          return value;
        }
        return this._castRef(value, doc, init);
      }
      let castDecimal1282;
      if (typeof this._castFunction === "function") {
        castDecimal1282 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDecimal1282 = this.constructor.cast();
      } else {
        castDecimal1282 = Decimal128.cast();
      }
      try {
        return castDecimal1282(value);
      } catch (error) {
        throw new CastError("Decimal128", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    Decimal128.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    module2.exports = Decimal128;
  }
});

// asset-input/node_modules/mongoose/lib/options/SchemaMapOptions.js
var require_SchemaMapOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/SchemaMapOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaMapOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
    module2.exports = SchemaMapOptions;
  }
});

// asset-input/node_modules/mongoose/lib/schema/map.js
var require_map3 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/map.js"(exports2, module2) {
    "use strict";
    var MongooseMap = require_map2();
    var SchemaMapOptions = require_SchemaMapOptions();
    var SchemaType = require_schematype();
    var Map2 = class extends SchemaType {
      constructor(key, options) {
        super(key, options, "Map");
        this.$isSchemaMap = true;
      }
      set(option, value) {
        return SchemaType.set(option, value);
      }
      cast(val, doc, init) {
        if (val instanceof MongooseMap) {
          return val;
        }
        const path = this.path;
        if (init) {
          const map = new MongooseMap({}, path, doc, this.$__schemaType);
          if (val instanceof global.Map) {
            for (const key of val.keys()) {
              let _val = val.get(key);
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
              }
              map.$init(key, _val);
            }
          } else {
            for (const key of Object.keys(val)) {
              let _val = val[key];
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
              }
              map.$init(key, _val);
            }
          }
          return map;
        }
        return new MongooseMap(val, path, doc, this.$__schemaType);
      }
      clone() {
        const schematype = super.clone();
        if (this.$__schemaType != null) {
          schematype.$__schemaType = this.$__schemaType.clone();
        }
        return schematype;
      }
    };
    Map2.schemaName = "Map";
    Map2.prototype.OptionsConstructor = SchemaMapOptions;
    Map2.defaultOptions = {};
    module2.exports = Map2;
  }
});

// asset-input/node_modules/mongoose/lib/schema/uuid.js
var require_uuid = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/uuid.js"(exports2, module2) {
    "use strict";
    var MongooseBuffer = require_buffer();
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var utils = require_utils6();
    var handleBitwiseOperator = require_bitwise();
    var UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;
    var Binary = MongooseBuffer.Binary;
    function hex2buffer(hex) {
      const buff = hex != null && Buffer.from(hex, "hex");
      return buff;
    }
    function binary2hex(buf) {
      const hex = buf != null && buf.toString("hex");
      return hex;
    }
    function stringToBinary(uuidStr) {
      if (typeof uuidStr !== "string") uuidStr = "";
      const hex = uuidStr.replace(/[{}-]/g, "");
      const bytes = hex2buffer(hex);
      const buff = new MongooseBuffer(bytes);
      buff._subtype = 4;
      return buff;
    }
    function binaryToString(uuidBin) {
      let hex;
      if (typeof uuidBin !== "string" && uuidBin != null) {
        hex = binary2hex(uuidBin);
        const uuidStr = hex.substring(0, 8) + "-" + hex.substring(8, 8 + 4) + "-" + hex.substring(12, 12 + 4) + "-" + hex.substring(16, 16 + 4) + "-" + hex.substring(20, 20 + 12);
        return uuidStr;
      }
      return uuidBin;
    }
    function SchemaUUID(key, options) {
      SchemaType.call(this, key, options, "UUID");
      this.getters.push(function(value) {
        if (value != null && value.$__ != null) {
          return value;
        }
        return binaryToString(value);
      });
    }
    SchemaUUID.schemaName = "UUID";
    SchemaUUID.defaultOptions = {};
    SchemaUUID.prototype = Object.create(SchemaType.prototype);
    SchemaUUID.prototype.constructor = SchemaUUID;
    SchemaUUID._cast = function(value) {
      if (value == null) {
        return value;
      }
      function newBuffer(initbuff) {
        const buff = new MongooseBuffer(initbuff);
        buff._subtype = 4;
        return buff;
      }
      if (typeof value === "string") {
        if (UUID_FORMAT.test(value)) {
          return stringToBinary(value);
        } else {
          throw new CastError(SchemaUUID.schemaName, value, this.path);
        }
      }
      if (Buffer.isBuffer(value)) {
        return newBuffer(value);
      }
      if (value instanceof Binary) {
        return newBuffer(value.value(true));
      }
      if (value.toString && value.toString !== Object.prototype.toString) {
        if (UUID_FORMAT.test(value.toString())) {
          return stringToBinary(value.toString());
        }
      }
      throw new CastError(SchemaUUID.schemaName, value, this.path);
    };
    SchemaUUID.set = SchemaType.set;
    SchemaUUID.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaUUID._checkRequired = (v) => v != null;
    SchemaUUID.checkRequired = SchemaType.checkRequired;
    SchemaUUID.prototype.checkRequired = function checkRequired(value) {
      if (Buffer.isBuffer(value)) {
        value = binaryToString(value);
      }
      return value != null && UUID_FORMAT.test(value);
    };
    SchemaUUID.prototype.cast = function(value, doc, init) {
      if (utils.isNonBuiltinObject(value) && SchemaType._isRef(this, value, doc, init)) {
        return this._castRef(value, doc, init);
      }
      let castFn;
      if (typeof this._castFunction === "function") {
        castFn = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castFn = this.constructor.cast();
      } else {
        castFn = SchemaUUID.cast();
      }
      try {
        return castFn(value);
      } catch (error) {
        throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    function handleArray(val) {
      return val.map((m) => {
        return this.cast(m);
      });
    }
    SchemaUUID.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $all: handleArray,
      $gt: handleSingle,
      $gte: handleSingle,
      $in: handleArray,
      $lt: handleSingle,
      $lte: handleSingle,
      $ne: handleSingle,
      $nin: handleArray
    });
    SchemaUUID.prototype.castForQuery = function($conditional, val) {
      let handler2;
      if (arguments.length === 2) {
        handler2 = this.$conditionalHandlers[$conditional];
        if (!handler2)
          throw new Error("Can't use " + $conditional + " with UUID.");
        return handler2.call(this, val);
      } else {
        return this.cast($conditional);
      }
    };
    module2.exports = SchemaUUID;
  }
});

// asset-input/node_modules/mongoose/lib/schema/index.js
var require_schema = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema/index.js"(exports2) {
    "use strict";
    exports2.String = require_string2();
    exports2.Number = require_number2();
    exports2.Boolean = require_boolean2();
    exports2.DocumentArray = require_documentarray();
    exports2.Subdocument = require_SubdocumentPath();
    exports2.Array = require_array2();
    exports2.Buffer = require_buffer2();
    exports2.Date = require_date2();
    exports2.ObjectId = require_objectid5();
    exports2.Mixed = require_mixed();
    exports2.Decimal128 = exports2.Decimal = require_decimal1284();
    exports2.Map = require_map3();
    exports2.UUID = require_uuid();
    exports2.Oid = exports2.ObjectId;
    exports2.Object = exports2.Mixed;
    exports2.Bool = exports2.Boolean;
    exports2.ObjectID = exports2.ObjectId;
  }
});

// asset-input/node_modules/mongoose/lib/schema.js
var require_schema2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/schema.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var SchemaType = require_schematype();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var VirtualOptions = require_VirtualOptions();
    var VirtualType = require_virtualtype();
    var addAutoId = require_addAutoId();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getIndexes = require_getIndexes();
    var idGetter = require_idGetter();
    var merge = require_merge();
    var mpath = require_mpath();
    var readPref = require_driver().get().ReadPreference;
    var setupTimestamps = require_setupTimestamps();
    var utils = require_utils6();
    var validateRef = require_validateRef();
    var util2 = require("util");
    var hasNumericSubpathRegex = /\.\d+(\.|$)/;
    var MongooseTypes;
    var queryHooks = require_applyQueryMiddleware().middlewareFunctions;
    var documentHooks = require_applyHooks().middlewareFunctions;
    var hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), /* @__PURE__ */ new Set());
    var isPOJO = utils.isPOJO;
    var id = 0;
    function Schema(obj, options) {
      if (!(this instanceof Schema)) {
        return new Schema(obj, options);
      }
      this.obj = obj;
      this.paths = {};
      this.aliases = {};
      this.subpaths = {};
      this.virtuals = {};
      this.singleNestedPaths = {};
      this.nested = {};
      this.inherits = {};
      this.callQueue = [];
      this._indexes = [];
      this.methods = options && options.methods || {};
      this.methodOptions = {};
      this.statics = options && options.statics || {};
      this.tree = {};
      this.query = options && options.query || {};
      this.childSchemas = [];
      this.plugins = [];
      this.$id = ++id;
      this.mapPaths = [];
      this.s = {
        hooks: new Kareem()
      };
      this.options = this.defaultOptions(options);
      if (Array.isArray(obj)) {
        for (const definition of obj) {
          this.add(definition);
        }
      } else if (obj) {
        this.add(obj);
      }
      if (options && options.virtuals) {
        const virtuals = options.virtuals;
        const pathNames = Object.keys(virtuals);
        for (const pathName of pathNames) {
          const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : void 0;
          const virtual = this.virtual(pathName, pathOptions);
          if (virtuals[pathName].get) {
            virtual.get(virtuals[pathName].get);
          }
          if (virtuals[pathName].set) {
            virtual.set(virtuals[pathName].set);
          }
        }
      }
      const _idSubDoc = obj && obj._id && utils.isObject(obj._id);
      const auto_id = !this.paths["_id"] && this.options._id && !_idSubDoc;
      if (auto_id) {
        addAutoId(this);
      }
      this.setupTimestamp(this.options.timestamps);
    }
    function aliasFields(schema, paths) {
      for (const path of Object.keys(paths)) {
        let alias = null;
        if (paths[path] != null) {
          alias = paths[path];
        } else {
          const options = get(schema.paths[path], "options");
          if (options == null) {
            continue;
          }
          alias = options.alias;
        }
        if (!alias) {
          continue;
        }
        const prop = schema.paths[path].path;
        if (Array.isArray(alias)) {
          for (const a of alias) {
            if (typeof a !== "string") {
              throw new Error("Invalid value for alias option on " + prop + ", got " + a);
            }
            schema.aliases[a] = prop;
            schema.virtual(a).get(/* @__PURE__ */ function(p) {
              return function() {
                if (typeof this.get === "function") {
                  return this.get(p);
                }
                return this[p];
              };
            }(prop)).set(/* @__PURE__ */ function(p) {
              return function(v) {
                return this.$set(p, v);
              };
            }(prop));
          }
          continue;
        }
        if (typeof alias !== "string") {
          throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
        }
        schema.aliases[alias] = prop;
        schema.virtual(alias).get(/* @__PURE__ */ function(p) {
          return function() {
            if (typeof this.get === "function") {
              return this.get(p);
            }
            return this[p];
          };
        }(prop)).set(/* @__PURE__ */ function(p) {
          return function(v) {
            return this.$set(p, v);
          };
        }(prop));
      }
    }
    Schema.prototype = Object.create(EventEmitter.prototype);
    Schema.prototype.constructor = Schema;
    Schema.prototype.instanceOfSchema = true;
    Object.defineProperty(Schema.prototype, "$schemaType", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Object.defineProperty(Schema.prototype, "childSchemas", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Schema.prototype, "virtuals", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Schema.prototype.obj;
    Schema.prototype.paths;
    Schema.prototype.tree;
    Schema.prototype.clone = function() {
      const s = this._clone();
      s.on("init", (v) => this.emit("init", v));
      return s;
    };
    Schema.prototype._clone = function _clone(Constructor) {
      Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);
      const s = new Constructor({}, this._userProvidedOptions);
      s.base = this.base;
      s.obj = this.obj;
      s.options = utils.clone(this.options);
      s.callQueue = this.callQueue.map(function(f) {
        return f;
      });
      s.methods = utils.clone(this.methods);
      s.methodOptions = utils.clone(this.methodOptions);
      s.statics = utils.clone(this.statics);
      s.query = utils.clone(this.query);
      s.plugins = Array.prototype.slice.call(this.plugins);
      s._indexes = utils.clone(this._indexes);
      s.s.hooks = this.s.hooks.clone();
      s.tree = utils.clone(this.tree);
      s.paths = utils.clone(this.paths);
      s.nested = utils.clone(this.nested);
      s.subpaths = utils.clone(this.subpaths);
      for (const schemaType of Object.values(s.paths)) {
        if (schemaType.$isSingleNested) {
          const path = schemaType.path;
          for (const key of Object.keys(schemaType.schema.paths)) {
            s.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
          }
          for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
            s.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
          }
          for (const key of Object.keys(schemaType.schema.subpaths)) {
            s.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
          }
          for (const key of Object.keys(schemaType.schema.nested)) {
            s.singleNestedPaths[path + "." + key] = "nested";
          }
        }
      }
      s.childSchemas = gatherChildSchemas(s);
      s.virtuals = utils.clone(this.virtuals);
      s.$globalPluginsApplied = this.$globalPluginsApplied;
      s.$isRootDiscriminator = this.$isRootDiscriminator;
      s.$implicitlyCreated = this.$implicitlyCreated;
      s.$id = ++id;
      s.$originalSchemaId = this.$id;
      s.mapPaths = [].concat(this.mapPaths);
      if (this.discriminatorMapping != null) {
        s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
      }
      if (this.discriminators != null) {
        s.discriminators = Object.assign({}, this.discriminators);
      }
      if (this._applyDiscriminators != null) {
        s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);
      }
      s.aliases = Object.assign({}, this.aliases);
      return s;
    };
    Schema.prototype.pick = function(paths, options) {
      const newSchema = new Schema({}, options || this.options);
      if (!Array.isArray(paths)) {
        throw new MongooseError('Schema#pick() only accepts an array argument, got "' + typeof paths + '"');
      }
      for (const path of paths) {
        if (this.nested[path]) {
          newSchema.add({ [path]: get(this.tree, path) });
        } else {
          const schematype = this.path(path);
          if (schematype == null) {
            throw new MongooseError("Path `" + path + "` is not in the schema");
          }
          newSchema.add({ [path]: schematype });
        }
      }
      return newSchema;
    };
    Schema.prototype.omit = function(paths, options) {
      const newSchema = new Schema(this, options || this.options);
      if (!Array.isArray(paths)) {
        throw new MongooseError(
          'Schema#omit() only accepts an array argument, got "' + typeof paths + '"'
        );
      }
      newSchema.remove(paths);
      for (const nested in newSchema.singleNestedPaths) {
        if (paths.includes(nested)) {
          delete newSchema.singleNestedPaths[nested];
        }
      }
      return newSchema;
    };
    Schema.prototype.defaultOptions = function(options) {
      this._userProvidedOptions = options == null ? {} : utils.clone(options);
      const baseOptions = this.base && this.base.options || {};
      const strict = "strict" in baseOptions ? baseOptions.strict : true;
      const id2 = "id" in baseOptions ? baseOptions.id : true;
      options = utils.options({
        strict,
        strictQuery: "strict" in this._userProvidedOptions ? this._userProvidedOptions.strict : "strictQuery" in baseOptions ? baseOptions.strictQuery : strict,
        bufferCommands: true,
        capped: false,
        // { size, max, autoIndexId }
        versionKey: "__v",
        optimisticConcurrency: false,
        minimize: true,
        autoIndex: null,
        discriminatorKey: "__t",
        shardKey: null,
        read: null,
        validateBeforeSave: true,
        // the following are only applied at construction time
        _id: true,
        id: id2,
        typeKey: "type"
      }, utils.clone(options));
      if (options.read) {
        options.read = readPref(options.read);
      }
      if (options.versionKey && typeof options.versionKey !== "string") {
        throw new MongooseError("`versionKey` must be falsy or string, got `" + typeof options.versionKey + "`");
      }
      if (options.optimisticConcurrency && !options.versionKey) {
        throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
      }
      return options;
    };
    Schema.prototype.discriminator = function(name, schema) {
      this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, { [name]: schema });
      return this;
    };
    Schema.prototype.add = function add(obj, prefix) {
      if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {
        merge(this, obj);
        return this;
      }
      if (obj._id === false && prefix == null) {
        this.options._id = false;
      }
      prefix = prefix || "";
      if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
        return this;
      }
      const keys = Object.keys(obj);
      const typeKey = this.options.typeKey;
      for (const key of keys) {
        if (utils.specialProperties.has(key)) {
          continue;
        }
        const fullPath = prefix + key;
        const val = obj[key];
        if (val == null) {
          throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + val + '"');
        }
        if (key === "_id" && val === false) {
          continue;
        }
        if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === "VirtualType") {
          this.virtual(val);
          continue;
        }
        if (Array.isArray(val) && val.length === 1 && val[0] == null) {
          throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + val[0] + '"');
        }
        if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          this.path(prefix + key, val);
          if (val[0] != null && !val[0].instanceOfSchema && utils.isPOJO(val[0].discriminators)) {
            const schemaType = this.path(prefix + key);
            for (const key2 in val[0].discriminators) {
              schemaType.discriminator(key2, val[0].discriminators[key2]);
            }
          } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {
            const applyDiscriminators = val[0]._applyDiscriminators || [];
            const schemaType = this.path(prefix + key);
            for (const disc in applyDiscriminators) {
              schemaType.discriminator(disc, applyDiscriminators[disc]);
            }
          } else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {
            const applyDiscriminators = val._applyDiscriminators || [];
            const schemaType = this.path(prefix + key);
            for (const disc in applyDiscriminators) {
              schemaType.discriminator(disc, applyDiscriminators[disc]);
            }
          }
        } else if (Object.keys(val).length < 1) {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          this.path(fullPath, val);
        } else if (!val[typeKey] || typeKey === "type" && isPOJO(val.type) && val.type.type) {
          this.nested[fullPath] = true;
          this.add(val, fullPath + ".");
        } else {
          const _typeDef = val[typeKey];
          if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {
            if (prefix) {
              this.nested[prefix.substring(0, prefix.length - 1)] = true;
            }
            const _schema = new Schema(_typeDef);
            const schemaWrappedPath = Object.assign({}, val, { type: _schema });
            this.path(prefix + key, schemaWrappedPath);
          } else {
            if (prefix) {
              this.nested[prefix.substring(0, prefix.length - 1)] = true;
            }
            this.path(prefix + key, val);
            if (val != null && !val.instanceOfSchema && utils.isPOJO(val.discriminators)) {
              const schemaType = this.path(prefix + key);
              for (const key2 in val.discriminators) {
                schemaType.discriminator(key2, val.discriminators[key2]);
              }
            }
          }
        }
      }
      const aliasObj = Object.fromEntries(
        Object.entries(obj).map(([key]) => [prefix + key, null])
      );
      aliasFields(this, aliasObj);
      return this;
    };
    Schema.prototype.alias = function alias(path, alias) {
      aliasFields(this, { [path]: alias });
      return this;
    };
    Schema.prototype.removeIndex = function removeIndex(index) {
      if (arguments.length > 1) {
        throw new Error("removeIndex() takes only 1 argument");
      }
      if (typeof index !== "object" && typeof index !== "string") {
        throw new Error("removeIndex() may only take either an object or a string as an argument");
      }
      if (typeof index === "object") {
        for (let i = this._indexes.length - 1; i >= 0; --i) {
          if (util2.isDeepStrictEqual(this._indexes[i][0], index)) {
            this._indexes.splice(i, 1);
          }
        }
      } else {
        for (let i = this._indexes.length - 1; i >= 0; --i) {
          if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {
            this._indexes.splice(i, 1);
          }
        }
      }
      return this;
    };
    Schema.prototype.clearIndexes = function clearIndexes() {
      this._indexes.length = 0;
      return this;
    };
    Schema.reserved = /* @__PURE__ */ Object.create(null);
    Schema.prototype.reserved = Schema.reserved;
    var reserved = Schema.reserved;
    reserved["prototype"] = // EventEmitter
    reserved.emit = reserved.listeners = reserved.removeListener = // document properties and functions
    reserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;
    reserved.collection = 1;
    Schema.prototype.path = function(path, obj) {
      if (obj === void 0) {
        if (this.paths[path] != null) {
          return this.paths[path];
        }
        const cleanPath = _pathToPositionalSyntax(path);
        let schematype = _getPath(this, path, cleanPath);
        if (schematype != null) {
          return schematype;
        }
        const mapPath = getMapPath(this, path);
        if (mapPath != null) {
          return mapPath;
        }
        schematype = this.hasMixedParent(cleanPath);
        if (schematype != null) {
          return schematype;
        }
        return hasNumericSubpathRegex.test(path) ? getPositionalPath(this, path) : void 0;
      }
      const firstPieceOfPath = path.split(".")[0];
      if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {
        const errorMessage = `\`${firstPieceOfPath}\` is a reserved schema pathname and may break some functionality. You are allowed to use it, but use at your own risk. To disable this warning pass \`supressReservedKeysWarning\` as a schema option.`;
        utils.warn(errorMessage);
      }
      if (typeof obj === "object" && utils.hasUserDefinedProperty(obj, "ref")) {
        validateRef(obj.ref, path);
      }
      const subpaths = path.split(/\./);
      const last = subpaths.pop();
      let branch = this.tree;
      let fullPath = "";
      for (const sub of subpaths) {
        if (utils.specialProperties.has(sub)) {
          throw new Error("Cannot set special property `" + sub + "` on a schema");
        }
        fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
        if (!branch[sub]) {
          this.nested[fullPath] = true;
          branch[sub] = {};
        }
        if (typeof branch[sub] !== "object") {
          const msg = "Cannot set nested path `" + path + "`. Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
          throw new Error(msg);
        }
        branch = branch[sub];
      }
      branch[last] = utils.clone(obj);
      this.paths[path] = this.interpretAsType(path, obj, this.options);
      const schemaType = this.paths[path];
      if (schemaType.$isSchemaMap) {
        const mapPath = path + ".$*";
        this.paths[mapPath] = schemaType.$__schemaType;
        this.mapPaths.push(this.paths[mapPath]);
      }
      if (schemaType.$isSingleNested) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)) {
          this.singleNestedPaths[path + "." + key] = "nested";
        }
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.caster.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.caster
        });
      } else if (schemaType.$isMongooseDocumentArray) {
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.casterConstructor.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.casterConstructor
        });
      }
      if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
        let arrayPath = path;
        let _schemaType = schemaType;
        const toAdd = [];
        while (_schemaType.$isMongooseArray) {
          arrayPath = arrayPath + ".$";
          if (_schemaType.$isMongooseDocumentArray) {
            _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
            _schemaType.$embeddedSchemaType._arrayParentPath = path;
            _schemaType = _schemaType.$embeddedSchemaType.clone();
          } else {
            _schemaType.caster._arrayPath = arrayPath;
            _schemaType.caster._arrayParentPath = path;
            _schemaType = _schemaType.caster.clone();
          }
          _schemaType.path = arrayPath;
          toAdd.push(_schemaType);
        }
        for (const _schemaType2 of toAdd) {
          this.subpaths[_schemaType2.path] = _schemaType2;
        }
      }
      if (schemaType.$isMongooseDocumentArray) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          const _schemaType = schemaType.schema.paths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          const _schemaType = schemaType.schema.subpaths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          const _schemaType = schemaType.schema.singleNestedPaths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
      }
      return this;
    };
    function gatherChildSchemas(schema) {
      const childSchemas = [];
      for (const path of Object.keys(schema.paths)) {
        const schematype = schema.paths[path];
        if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
          childSchemas.push({ schema: schematype.schema, model: schematype.caster });
        }
      }
      return childSchemas;
    }
    function _getPath(schema, path, cleanPath) {
      if (schema.paths.hasOwnProperty(path)) {
        return schema.paths[path];
      }
      if (schema.subpaths.hasOwnProperty(cleanPath)) {
        return schema.subpaths[cleanPath];
      }
      if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
        return schema.singleNestedPaths[cleanPath];
      }
      return null;
    }
    function _pathToPositionalSyntax(path) {
      if (!/\.\d+/.test(path)) {
        return path;
      }
      return path.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
    }
    function getMapPath(schema, path) {
      if (schema.mapPaths.length === 0) {
        return null;
      }
      for (const val of schema.mapPaths) {
        const _path = val.path;
        const re = new RegExp("^" + _path.replace(/\.\$\*/g, "\\.[^.]+") + "$");
        if (re.test(path)) {
          return schema.paths[_path];
        }
      }
      return null;
    }
    Object.defineProperty(Schema.prototype, "base", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: null
    });
    Schema.prototype.interpretAsType = function(path, obj, options) {
      if (obj instanceof SchemaType) {
        if (obj.path === path) {
          return obj;
        }
        const clone = obj.clone();
        clone.path = path;
        return clone;
      }
      const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
      const Types = this.base != null ? this.base.Types : require_types();
      if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {
        const constructorName = utils.getFunctionName(obj.constructor);
        if (constructorName !== "Object") {
          const oldObj = obj;
          obj = {};
          obj[options.typeKey] = oldObj;
        }
      }
      let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== "type" || !obj.type.type) ? obj[options.typeKey] : {};
      let name;
      if (utils.isPOJO(type) || type === "mixed") {
        return new MongooseTypes2.Mixed(path, obj);
      }
      if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes2.Array) {
        let cast = type === Array || type === "array" ? obj.cast || obj.of : type[0];
        if (cast && cast.instanceOfSchema) {
          if (!(cast instanceof Schema)) {
            throw new TypeError("Schema for array path `" + path + `\` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with \`npm list mongoose\`. If you are still getting this error, please add \`new Schema()\` around the path: ${path}: new Schema(...)`);
          }
          return new MongooseTypes2.DocumentArray(path, cast, obj);
        }
        if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {
          if (!(cast[options.typeKey] instanceof Schema)) {
            throw new TypeError("Schema for array path `" + path + `\` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with \`npm list mongoose\`. If you are still getting this error, please add \`new Schema()\` around the path: ${path}: new Schema(...)`);
          }
          return new MongooseTypes2.DocumentArray(path, cast[options.typeKey], obj, cast);
        }
        if (Array.isArray(cast)) {
          return new MongooseTypes2.Array(path, this.interpretAsType(path, cast, options), obj);
        }
        const castFromTypeKey = cast != null && cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
        if (typeof cast === "string") {
          cast = MongooseTypes2[cast.charAt(0).toUpperCase() + cast.substring(1)];
        } else if (utils.isPOJO(castFromTypeKey)) {
          if (Object.keys(castFromTypeKey).length) {
            const childSchemaOptions = { minimize: options.minimize };
            if (options.typeKey) {
              childSchemaOptions.typeKey = options.typeKey;
            }
            if (options.hasOwnProperty("strict")) {
              childSchemaOptions.strict = options.strict;
            }
            if (options.hasOwnProperty("strictQuery")) {
              childSchemaOptions.strictQuery = options.strictQuery;
            }
            if (this._userProvidedOptions.hasOwnProperty("_id")) {
              childSchemaOptions._id = this._userProvidedOptions._id;
            } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {
              childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;
            }
            const childSchema = new Schema(castFromTypeKey, childSchemaOptions);
            childSchema.$implicitlyCreated = true;
            return new MongooseTypes2.DocumentArray(path, childSchema, obj);
          } else {
            return new MongooseTypes2.Array(path, MongooseTypes2.Mixed, obj);
          }
        }
        if (cast) {
          type = cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
          if (Array.isArray(type)) {
            return new MongooseTypes2.Array(path, this.interpretAsType(path, type, options), obj);
          }
          name = typeof type === "string" ? type : type.schemaName || utils.getFunctionName(type);
          if (name === "ClockDate") {
            name = "Date";
          }
          if (name === void 0) {
            throw new TypeError(`Invalid schema configuration: Could not determine the embedded type for array \`${path}\`. See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.`);
          }
          if (!MongooseTypes2.hasOwnProperty(name)) {
            throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type within the array \`${path}\`.See https://bit.ly/mongoose-schematypes for a list of valid schema types.`);
          }
        }
        return new MongooseTypes2.Array(path, cast || MongooseTypes2.Mixed, obj, options);
      }
      if (type && type.instanceOfSchema) {
        return new MongooseTypes2.Subdocument(type, path, obj);
      }
      if (Buffer.isBuffer(type)) {
        name = "Buffer";
      } else if (typeof type === "function" || typeof type === "object") {
        name = type.schemaName || utils.getFunctionName(type);
      } else if (type === Types.ObjectId) {
        name = "ObjectId";
      } else if (type === Types.Decimal128) {
        name = "Decimal128";
      } else {
        name = type == null ? "" + type : type.toString();
      }
      if (name) {
        name = name.charAt(0).toUpperCase() + name.substring(1);
      }
      if (name === "ObjectID") {
        name = "ObjectId";
      }
      if (name === "ClockDate") {
        name = "Date";
      }
      if (name === void 0) {
        throw new TypeError(`Invalid schema configuration: \`${path}\` schematype definition is invalid. See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.`);
      }
      if (MongooseTypes2[name] == null) {
        throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type at path \`${path}\`. See https://bit.ly/mongoose-schematypes for a list of valid schema types.`);
      }
      const schemaType = new MongooseTypes2[name](path, obj);
      if (schemaType.$isSchemaMap) {
        createMapNestedSchemaType(this, schemaType, path, obj, options);
      }
      return schemaType;
    };
    function createMapNestedSchemaType(schema, schemaType, path, obj, options) {
      const mapPath = path + ".$*";
      let _mapType = { type: {} };
      if (utils.hasUserDefinedProperty(obj, "of")) {
        const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);
        if (isInlineSchema) {
          _mapType = { [schema.options.typeKey]: new Schema(obj.of) };
        } else if (utils.isPOJO(obj.of)) {
          _mapType = Object.assign({}, obj.of);
        } else {
          _mapType = { [schema.options.typeKey]: obj.of };
        }
        if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {
          const subdocumentSchema = _mapType[schema.options.typeKey];
          subdocumentSchema.eachPath((subpath, type) => {
            if (type.options.select === true || type.options.select === false) {
              throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + path + "." + subpath + '"');
            }
          });
        }
        if (utils.hasUserDefinedProperty(obj, "ref")) {
          _mapType.ref = obj.ref;
        }
      }
      schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);
    }
    Schema.prototype.eachPath = function(fn) {
      const keys = Object.keys(this.paths);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        fn(keys[i], this.paths[keys[i]]);
      }
      return this;
    };
    Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
      if (this._requiredpaths && !invalidate) {
        return this._requiredpaths;
      }
      const paths = Object.keys(this.paths);
      let i = paths.length;
      const ret = [];
      while (i--) {
        const path = paths[i];
        if (this.paths[path].isRequired) {
          ret.push(path);
        }
      }
      this._requiredpaths = ret;
      return this._requiredpaths;
    };
    Schema.prototype.indexedPaths = function indexedPaths() {
      if (this._indexedpaths) {
        return this._indexedpaths;
      }
      this._indexedpaths = this.indexes();
      return this._indexedpaths;
    };
    Schema.prototype.pathType = function(path) {
      if (this.paths.hasOwnProperty(path)) {
        return "real";
      }
      if (this.virtuals.hasOwnProperty(path)) {
        return "virtual";
      }
      if (this.nested.hasOwnProperty(path)) {
        return "nested";
      }
      const cleanPath = _pathToPositionalSyntax(path);
      if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {
        return "real";
      }
      const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);
      if (singleNestedPath) {
        return singleNestedPath === "nested" ? "nested" : "real";
      }
      const mapPath = getMapPath(this, path);
      if (mapPath != null) {
        return "real";
      }
      if (/\.\d+\.|\.\d+$/.test(path)) {
        return getPositionalPathType(this, path);
      }
      return "adhocOrUndefined";
    };
    Schema.prototype.hasMixedParent = function(path) {
      const subpaths = path.split(/\./g);
      path = "";
      for (let i = 0; i < subpaths.length; ++i) {
        path = i > 0 ? path + "." + subpaths[i] : subpaths[i];
        if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {
          return this.paths[path];
        }
      }
      return null;
    };
    Schema.prototype.setupTimestamp = function(timestamps) {
      return setupTimestamps(this, timestamps);
    };
    function getPositionalPathType(self2, path) {
      const subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
      if (subpaths.length < 2) {
        return self2.paths.hasOwnProperty(subpaths[0]) ? self2.paths[subpaths[0]] : "adhocOrUndefined";
      }
      let val = self2.path(subpaths[0]);
      let isNested = false;
      if (!val) {
        return "adhocOrUndefined";
      }
      const last = subpaths.length - 1;
      for (let i = 1; i < subpaths.length; ++i) {
        isNested = false;
        const subpath = subpaths[i];
        if (i === last && val && !/\D/.test(subpath)) {
          if (val.$isMongooseDocumentArray) {
            val = val.$embeddedSchemaType;
          } else if (val instanceof MongooseTypes.Array) {
            val = val.caster;
          } else {
            val = void 0;
          }
          break;
        }
        if (!/\D/.test(subpath)) {
          if (val instanceof MongooseTypes.Array && i !== last) {
            val = val.caster;
          }
          continue;
        }
        if (!(val && val.schema)) {
          val = void 0;
          break;
        }
        const type = val.schema.pathType(subpath);
        isNested = type === "nested";
        val = val.schema.path(subpath);
      }
      self2.subpaths[path] = val;
      if (val) {
        return "real";
      }
      if (isNested) {
        return "nested";
      }
      return "adhocOrUndefined";
    }
    function getPositionalPath(self2, path) {
      getPositionalPathType(self2, path);
      return self2.subpaths[path];
    }
    Schema.prototype.queue = function(name, args) {
      this.callQueue.push([name, args]);
      return this;
    };
    Schema.prototype.pre = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.pre.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.pre.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.pre.apply(this.s.hooks, arguments);
      return this;
    };
    Schema.prototype.post = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.post.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.post.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.post.apply(this.s.hooks, arguments);
      return this;
    };
    Schema.prototype.plugin = function(fn, opts) {
      if (typeof fn !== "function") {
        throw new Error('First param to `schema.plugin()` must be a function, got "' + typeof fn + '"');
      }
      if (opts && opts.deduplicate) {
        for (const plugin of this.plugins) {
          if (plugin.fn === fn) {
            return this;
          }
        }
      }
      this.plugins.push({ fn, opts });
      fn(this, opts);
      return this;
    };
    Schema.prototype.method = function(name, fn, options) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.methods[i] = name[i];
          this.methodOptions[i] = utils.clone(options);
        }
      } else {
        this.methods[name] = fn;
        this.methodOptions[name] = utils.clone(options);
      }
      return this;
    };
    Schema.prototype.static = function(name, fn) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.statics[i] = name[i];
        }
      } else {
        this.statics[name] = fn;
      }
      return this;
    };
    Schema.prototype.index = function(fields, options) {
      fields || (fields = {});
      options || (options = {});
      if (options.expires) {
        utils.expires(options);
      }
      this._indexes.push([fields, options]);
      return this;
    };
    Schema.prototype.set = function(key, value, _tags) {
      if (arguments.length === 1) {
        return this.options[key];
      }
      switch (key) {
        case "read":
          this.options[key] = readPref(value, _tags);
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "timestamps":
          this.setupTimestamp(value);
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "_id":
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          if (value && !this.paths["_id"]) {
            addAutoId(this);
          } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
            this.remove("_id");
          }
          break;
        default:
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
      }
      return this;
    };
    Schema.prototype.get = function(key) {
      return this.options[key];
    };
    var indexTypes = "2d 2dsphere hashed text".split(" ");
    Object.defineProperty(Schema, "indexTypes", {
      get: function() {
        return indexTypes;
      },
      set: function() {
        throw new Error("Cannot overwrite Schema.indexTypes");
      }
    });
    Schema.prototype.indexes = function() {
      return getIndexes(this);
    };
    Schema.prototype.virtual = function(name, options) {
      if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
        return this.virtual(name.path, name.options);
      }
      options = new VirtualOptions(options);
      if (utils.hasUserDefinedProperty(options, ["ref", "refPath"])) {
        if (options.localField == null) {
          throw new Error("Reference virtuals require `localField` option");
        }
        if (options.foreignField == null) {
          throw new Error("Reference virtuals require `foreignField` option");
        }
        this.pre("init", function virtualPreInit(obj) {
          if (mpath.has(name, obj)) {
            const _v = mpath.get(name, obj);
            if (!this.$$populatedVirtuals) {
              this.$$populatedVirtuals = {};
            }
            if (options.justOne || options.count) {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            } else {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            }
            mpath.unset(name, obj);
          }
        });
        const virtual = this.virtual(name);
        virtual.options = options;
        virtual.set(function(_v) {
          if (!this.$$populatedVirtuals) {
            this.$$populatedVirtuals = {};
          }
          if (options.justOne || options.count) {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            if (typeof this.$$populatedVirtuals[name] !== "object") {
              this.$$populatedVirtuals[name] = options.count ? _v : null;
            }
          } else {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {
              return doc && typeof doc === "object";
            });
          }
        });
        if (typeof options.get === "function") {
          virtual.get(options.get);
        }
        const parts2 = name.split(".");
        let cur = parts2[0];
        for (let i = 0; i < parts2.length - 1; ++i) {
          if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {
            const remnant = parts2.slice(i + 1).join(".");
            this.paths[cur].schema.virtual(remnant, options);
            break;
          }
          cur += "." + parts2[i + 1];
        }
        return virtual;
      }
      const virtuals = this.virtuals;
      const parts = name.split(".");
      if (this.pathType(name) === "real") {
        throw new Error('Virtual path "' + name + '" conflicts with a real path in the schema');
      }
      virtuals[name] = parts.reduce(function(mem, part, i) {
        mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});
        return mem[part];
      }, this.tree);
      return virtuals[name];
    };
    Schema.prototype.virtualpath = function(name) {
      return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
    };
    Schema.prototype.remove = function(path) {
      if (typeof path === "string") {
        path = [path];
      }
      if (Array.isArray(path)) {
        path.forEach(function(name) {
          if (this.path(name) == null && !this.nested[name]) {
            return;
          }
          if (this.nested[name]) {
            const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
            for (const path2 of allKeys) {
              if (path2.startsWith(name + ".")) {
                delete this.paths[path2];
                delete this.nested[path2];
                _deletePath(this, path2);
              }
            }
            delete this.nested[name];
            _deletePath(this, name);
            return;
          }
          delete this.paths[name];
          _deletePath(this, name);
        }, this);
      }
      return this;
    };
    function _deletePath(schema, name) {
      const pieces = name.split(".");
      const last = pieces.pop();
      let branch = schema.tree;
      for (const piece of pieces) {
        branch = branch[piece];
      }
      delete branch[last];
    }
    Schema.prototype.removeVirtual = function(path) {
      if (typeof path === "string") {
        path = [path];
      }
      if (Array.isArray(path)) {
        for (const virtual of path) {
          if (this.virtuals[virtual] == null) {
            throw new MongooseError(`Attempting to remove virtual "${virtual}" that does not exist.`);
          }
        }
        for (const virtual of path) {
          delete this.paths[virtual];
          delete this.virtuals[virtual];
          if (virtual.indexOf(".") !== -1) {
            mpath.unset(virtual, this.tree);
          } else {
            delete this.tree[virtual];
          }
        }
      }
      return this;
    };
    Schema.prototype.loadClass = function(model, virtualsOnly) {
      if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty("$isMongooseModelPrototype") || model.prototype.hasOwnProperty("$isMongooseDocumentPrototype")) {
        return this;
      }
      this.loadClass(Object.getPrototypeOf(model), virtualsOnly);
      if (!virtualsOnly) {
        Object.getOwnPropertyNames(model).forEach(function(name) {
          if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
            return;
          }
          const prop = Object.getOwnPropertyDescriptor(model, name);
          if (prop.hasOwnProperty("value")) {
            this.static(name, prop.value);
          }
        }, this);
      }
      Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
        if (name.match(/^(constructor)$/)) {
          return;
        }
        const method = Object.getOwnPropertyDescriptor(model.prototype, name);
        if (!virtualsOnly) {
          if (typeof method.value === "function") {
            this.method(name, method.value);
          }
        }
        if (typeof method.get === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].getters = [];
          }
          this.virtual(name).get(method.get);
        }
        if (typeof method.set === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].setters = [];
          }
          this.virtual(name).set(method.set);
        }
      }, this);
      return this;
    };
    Schema.prototype._getSchema = function(path) {
      const _this = this;
      const pathschema = _this.path(path);
      const resultPath = [];
      if (pathschema) {
        pathschema.$fullPath = path;
        return pathschema;
      }
      function search(parts2, schema) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            resultPath.push(trypath);
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                foundschema.caster.$fullPath = resultPath.join(".");
                return foundschema.caster;
              }
              if (p !== parts2.length) {
                if (foundschema.schema) {
                  let ret;
                  if (parts2[p] === "$" || isArrayFilter(parts2[p])) {
                    if (p + 1 === parts2.length) {
                      return foundschema;
                    }
                    ret = search(parts2.slice(p + 1), foundschema.schema);
                    if (ret) {
                      ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    }
                    return ret;
                  }
                  ret = search(parts2.slice(p), foundschema.schema);
                  if (ret) {
                    ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                  }
                  return ret;
                }
              }
            } else if (foundschema.$isSchemaMap) {
              if (p >= parts2.length) {
                return foundschema;
              }
              if (p + 1 >= parts2.length) {
                return foundschema.$__schemaType;
              }
              if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {
                return foundschema.$__schemaType;
              }
              if (foundschema.$__schemaType.schema != null) {
                const ret = search(parts2.slice(p + 1), foundschema.$__schemaType.schema);
                return ret;
              }
            }
            foundschema.$fullPath = resultPath.join(".");
            return foundschema;
          }
        }
      }
      const parts = path.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$" || isArrayFilter(parts[i])) {
          parts[i] = "0";
        }
      }
      return search(parts, _this);
    };
    Schema.prototype._getPathType = function(path) {
      const _this = this;
      const pathschema = _this.path(path);
      if (pathschema) {
        return "real";
      }
      function search(parts, schema) {
        let p = parts.length + 1, foundschema, trypath;
        while (p--) {
          trypath = parts.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                return { schema: foundschema, pathType: "mixed" };
              }
              if (p !== parts.length && foundschema.schema) {
                if (parts[p] === "$" || isArrayFilter(parts[p])) {
                  if (p === parts.length - 1) {
                    return { schema: foundschema, pathType: "nested" };
                  }
                  return search(parts.slice(p + 1), foundschema.schema);
                }
                return search(parts.slice(p), foundschema.schema);
              }
              return {
                schema: foundschema,
                pathType: foundschema.$isSingleNested ? "nested" : "array"
              };
            }
            return { schema: foundschema, pathType: "real" };
          } else if (p === parts.length && schema.nested[trypath]) {
            return { schema, pathType: "nested" };
          }
        }
        return { schema: foundschema || schema, pathType: "undefined" };
      }
      return search(path.split("."), _this);
    };
    function isArrayFilter(piece) {
      return piece.startsWith("$[") && piece.endsWith("]");
    }
    Schema.prototype._preCompile = function _preCompile() {
      idGetter(this);
    };
    module2.exports = exports2 = Schema;
    Schema.Types = MongooseTypes = require_schema();
    exports2.ObjectId = MongooseTypes.ObjectId;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js
var require_hasIncludedChildren = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasIncludedChildren(fields) {
      const hasIncludedChildren2 = {};
      const keys = Object.keys(fields);
      for (const key of keys) {
        if (key.indexOf(".") === -1) {
          hasIncludedChildren2[key] = 1;
          continue;
        }
        const parts = key.split(".");
        let c = parts[0];
        for (let i = 0; i < parts.length; ++i) {
          hasIncludedChildren2[c] = 1;
          if (i + 1 < parts.length) {
            c = c + "." + parts[i + 1];
          }
        }
      }
      return hasIncludedChildren2;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/common.js
var require_common5 = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/common.js"(exports2) {
    "use strict";
    var Binary = require_driver().get().Binary;
    var isBsonType = require_isBsonType();
    var isMongooseObject = require_isMongooseObject();
    var MongooseError = require_error3();
    var util2 = require("util");
    exports2.flatten = flatten;
    exports2.modifiedPaths = modifiedPaths;
    function flatten(update, path, options, schema) {
      let keys;
      if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
        keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});
      } else {
        keys = Object.keys(update || {});
      }
      const numKeys = keys.length;
      const result = {};
      path = path ? path + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const val = update[key];
        result[path + key] = val;
        const keySchema = schema && schema.path && schema.path(path + key);
        const isNested = schema && schema.nested && schema.nested[path + key];
        if (keySchema && keySchema.instance === "Mixed") continue;
        if (shouldFlatten(val)) {
          if (options && options.skipArrays && Array.isArray(val)) {
            continue;
          }
          const flat = flatten(val, path + key, options, schema);
          for (const k in flat) {
            result[k] = flat[k];
          }
          if (Array.isArray(val)) {
            result[path + key] = val;
          }
        }
        if (isNested) {
          const paths = Object.keys(schema.paths);
          for (const p of paths) {
            if (p.startsWith(path + key + ".") && !result.hasOwnProperty(p)) {
              result[p] = void 0;
            }
          }
        }
      }
      return result;
    }
    function modifiedPaths(update, path, result, recursion = null) {
      if (update == null || typeof update !== "object") {
        return;
      }
      if (recursion == null) {
        recursion = {
          raw: { update, path },
          trace: /* @__PURE__ */ new WeakSet()
        };
      }
      if (recursion.trace.has(update)) {
        throw new MongooseError(`a circular reference in the update value, updateValue:
${util2.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}
updatePath: '${recursion.raw.path}'`);
      }
      recursion.trace.add(update);
      const keys = Object.keys(update || {});
      const numKeys = keys.length;
      result = result || {};
      path = path ? path + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        let val = update[key];
        const _path = path + key;
        result[_path] = true;
        if (!Buffer.isBuffer(val) && isMongooseObject(val)) {
          val = val.toObject({ transform: false, virtuals: false });
        }
        if (shouldFlatten(val)) {
          modifiedPaths(val, path + key, result, recursion);
        }
      }
      recursion.trace.delete(update);
      return result;
    }
    function shouldFlatten(val) {
      return val && typeof val === "object" && !(val instanceof Date) && !isBsonType(val, "ObjectID") && (!Array.isArray(val) || val.length !== 0) && !(val instanceof Buffer) && !isBsonType(val, "Decimal128") && !(val instanceof Binary);
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
    module2.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {
      options = options || {};
      const typeOnly = options.typeOnly;
      const parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      let schemaType = null;
      let type = "adhocOrUndefined";
      const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;
      for (let i = 0; i < parts.length; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        schemaType = schema.path(subpath);
        if (schemaType == null) {
          type = "adhocOrUndefined";
          continue;
        }
        if (schemaType.instance === "Mixed") {
          return typeOnly ? "real" : schemaType;
        }
        type = schema.pathType(subpath);
        if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) && schemaType.schema.discriminators != null) {
          const discriminators = schemaType.schema.discriminators;
          const discriminatorKey = doc.get(subpath + "." + get(schemaType, "schema.options.discriminatorKey"));
          if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
            continue;
          }
          const rest = parts.slice(i + 1).join(".");
          return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);
        }
      }
      return typeOnly ? type : schemaType;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js
var require_getKeysInSchemaOrder = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function getKeysInSchemaOrder(schema, val, path) {
      const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);
      const valKeys = new Set(Object.keys(val));
      let keys;
      if (valKeys.size > 1) {
        keys = /* @__PURE__ */ new Set();
        for (const key of schemaKeys) {
          if (valKeys.has(key)) {
            keys.add(key);
          }
        }
        for (const key of valKeys) {
          if (!keys.has(key)) {
            keys.add(key);
          }
        }
        keys = Array.from(keys);
      } else {
        keys = Array.from(valKeys);
      }
      return keys;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js
var require_markArraySubdocsPopulated = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js"(exports2, module2) {
    "use strict";
    var utils = require_utils6();
    module2.exports = function markArraySubdocsPopulated(doc, populated) {
      if (doc._id == null || populated == null || populated.length === 0) {
        return;
      }
      const id = String(doc._id);
      for (const item of populated) {
        if (item.isVirtual) {
          continue;
        }
        const path = item.path;
        const pieces = path.split(".");
        for (let i = 0; i < pieces.length - 1; ++i) {
          const subpath = pieces.slice(0, i + 1).join(".");
          const rest = pieces.slice(i + 1).join(".");
          const val = doc.get(subpath);
          if (val == null) {
            continue;
          }
          if (utils.isMongooseDocumentArray(val)) {
            for (let j = 0; j < val.length; ++j) {
              val[j].populated(rest, item._docs[id] == null ? void 0 : item._docs[id][j], item);
            }
            break;
          }
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js
var require_checkEmbeddedDiscriminatorKeyProjection = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {
      const userProjectedInPath = Object.keys(userProjection).reduce((cur, key) => cur || key.startsWith(path + "."), false);
      const _discriminatorKey = path + "." + schema.options.discriminatorKey;
      if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
        selected.splice(selected.indexOf(_discriminatorKey), 1);
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/queryhelpers.js
var require_queryhelpers = __commonJS({
  "asset-input/node_modules/mongoose/lib/queryhelpers.js"(exports2) {
    "use strict";
    var checkEmbeddedDiscriminatorKeyProjection = require_checkEmbeddedDiscriminatorKeyProjection();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var isDefiningProjection = require_isDefiningProjection();
    var clone = require_clone();
    exports2.preparePopulationOptions = function preparePopulationOptions(query, options) {
      const _populate = query.options.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options.lean != null) {
        pop.filter((p) => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
      }
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
      const _populate = query._mongooseOptions.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options.lean != null) {
        pop.filter((p) => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
      }
      const session = query && query.options && query.options.session || null;
      if (session != null) {
        pop.forEach((path) => {
          if (path.options == null) {
            path.options = { session };
            return;
          }
          if (!("session" in path.options)) {
            path.options.session = session;
          }
        });
      }
      const projection = query._fieldsForExec();
      pop.forEach((p) => {
        p._queryProjection = projection;
      });
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.createModel = function createModel(model, doc, fields, userProvidedFields, options) {
      model.hooks.execPreSync("createModel", doc);
      const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
      const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
      const value = doc[key];
      if (key && value && model.discriminators) {
        const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);
        if (discriminator) {
          const _fields = clone(userProvidedFields);
          exports2.applyPaths(_fields, discriminator.schema);
          return new discriminator(void 0, _fields, true);
        }
      }
      const _opts = {
        skipId: true,
        isNew: false,
        willInit: true
      };
      if (options != null && "defaults" in options) {
        _opts.defaults = options.defaults;
      }
      return new model(void 0, fields, _opts);
    };
    exports2.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {
      const initOpts = populatedIds ? { populated: populatedIds } : void 0;
      const casted = exports2.createModel(model, doc, fields, userProvidedFields, options);
      try {
        casted.$init(doc, initOpts, callback);
      } catch (error) {
        callback(error, casted);
      }
    };
    exports2.applyPaths = function applyPaths(fields, schema) {
      let exclude;
      let keys;
      let keyIndex;
      if (fields) {
        keys = Object.keys(fields);
        keyIndex = keys.length;
        while (keyIndex--) {
          if (keys[keyIndex][0] === "+") {
            continue;
          }
          const field = fields[keys[keyIndex]];
          if (!isDefiningProjection(field)) {
            continue;
          }
          if (keys[keyIndex] === "_id" && keys.length > 1) {
            continue;
          }
          exclude = !field;
          break;
        }
      }
      const selected = [];
      const excluded = [];
      const stack = [];
      analyzeSchema(schema);
      switch (exclude) {
        case true:
          for (const fieldName of excluded) {
            fields[fieldName] = 0;
          }
          break;
        case false:
          if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
            fields._id = 0;
          }
          for (const fieldName of selected) {
            fields[fieldName] = fields[fieldName] || 1;
          }
          break;
        case void 0:
          if (fields == null) {
            break;
          }
          for (const key of Object.keys(fields || {})) {
            if (key.startsWith("+")) {
              delete fields[key];
            }
          }
          for (const fieldName of excluded) {
            if (fields[fieldName] != null) {
              continue;
            }
            fields[fieldName] = 0;
          }
          break;
      }
      function analyzeSchema(schema2, prefix) {
        prefix || (prefix = "");
        if (stack.indexOf(schema2) !== -1) {
          return [];
        }
        stack.push(schema2);
        const addedPaths = [];
        schema2.eachPath(function(path, type) {
          if (prefix) path = prefix + "." + path;
          if (type.$isSchemaMap || path.endsWith(".$*")) {
            const plusPath = "+" + path;
            const hasPlusPath = fields && plusPath in fields;
            if (type.options && type.options.select === false && !hasPlusPath) {
              excluded.push(path);
            }
            return;
          }
          let addedPath = analyzePath(path, type);
          if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
            addedPath = analyzePath(path, type.caster);
          }
          if (addedPath != null) {
            addedPaths.push(addedPath);
          }
          if (type.schema) {
            const _addedPaths = analyzeSchema(type.schema, path);
            if (exclude === false) {
              checkEmbeddedDiscriminatorKeyProjection(
                fields,
                path,
                type.schema,
                selected,
                _addedPaths
              );
            }
          }
        });
        stack.pop();
        return addedPaths;
      }
      function analyzePath(path, type) {
        const plusPath = "+" + path;
        const hasPlusPath = fields && plusPath in fields;
        if (hasPlusPath) {
          delete fields[plusPath];
        }
        if (typeof type.selected !== "boolean") {
          return;
        }
        if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {
          delete fields[path];
          return;
        }
        if (hasPlusPath) {
          delete fields[plusPath];
          if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {
            fields[path] = 1;
          }
          return;
        }
        const pieces = path.split(".");
        let cur = "";
        for (let i = 0; i < pieces.length; ++i) {
          cur += cur.length ? "." + pieces[i] : pieces[i];
          if (excluded.indexOf(cur) !== -1) {
            return;
          }
        }
        if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {
          let cur2 = "";
          for (let i = 0; i < pieces.length; ++i) {
            cur2 += (cur2.length === 0 ? "" : ".") + pieces[i];
            const projection = get(fields, cur2, false) || get(fields, cur2 + ".$", false);
            if (projection && typeof projection !== "object") {
              return;
            }
          }
        }
        (type.selected ? selected : excluded).push(path);
        return path;
      }
    };
    function makeLean(val) {
      return function(option) {
        option.options || (option.options = {});
        if (val != null && Array.isArray(val.virtuals)) {
          val = Object.assign({}, val);
          val.virtuals = val.virtuals.filter((path) => typeof path === "string" && path.startsWith(option.path + ".")).map((path) => path.slice(option.path.length + 1));
        }
        option.options.lean = val;
      };
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/isPromise.js
var require_isPromise = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/isPromise.js"(exports2, module2) {
    "use strict";
    function isPromise(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
    }
    module2.exports = isPromise;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/path/parentPaths.js
var require_parentPaths = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/path/parentPaths.js"(exports2, module2) {
    "use strict";
    var dotRE = /\./g;
    module2.exports = function parentPaths(path) {
      if (path.indexOf(".") === -1) {
        return [path];
      }
      const pieces = path.split(dotRE);
      const len = pieces.length;
      const ret = new Array(len);
      let cur = "";
      for (let i = 0; i < len; ++i) {
        cur += cur.length !== 0 ? "." + pieces[i] : pieces[i];
        ret[i] = cur;
      }
      return ret;
    };
  }
});

// asset-input/node_modules/mongoose/lib/document.js
var require_document = __commonJS({
  "asset-input/node_modules/mongoose/lib/document.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var InternalCache = require_internal();
    var MongooseError = require_error3();
    var MixedSchema = require_mixed();
    var ObjectExpectedError = require_objectExpected();
    var ObjectParameterError = require_objectParameter();
    var ParallelValidateError = require_parallelValidate();
    var Schema = require_schema2();
    var StrictModeError = require_strict();
    var ValidationError2 = require_validation();
    var ValidatorError = require_validator();
    var $__hasIncludedChildren = require_hasIncludedChildren();
    var promiseOrCallback = require_promiseOrCallback();
    var applyDefaults = require_applyDefaults();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var compile = require_compile().compile;
    var defineKey = require_compile().defineKey;
    var flatten = require_common5().flatten;
    var get = require_get();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath();
    var getKeysInSchemaOrder = require_getKeysInSchemaOrder();
    var handleSpreadDoc = require_handleSpreadDoc();
    var immediate = require_immediate();
    var isDefiningProjection = require_isDefiningProjection();
    var isExclusive = require_isExclusive();
    var inspect = require("util").inspect;
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
    var mpath = require_mpath();
    var queryhelpers = require_queryhelpers();
    var utils = require_utils6();
    var isPromise = require_isPromise();
    var clone = utils.clone;
    var deepEqual = utils.deepEqual;
    var isMongooseObject = utils.isMongooseObject;
    var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var documentIsModified = require_symbols().documentIsModified;
    var documentModifiedPaths = require_symbols().documentModifiedPaths;
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var getSymbol = require_symbols().getSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var parentPaths = require_parentPaths();
    var DocumentArray;
    var MongooseArray;
    var Embedded;
    var specialProperties = utils.specialProperties;
    function Document(obj, fields, skipId, options) {
      if (typeof skipId === "object" && skipId != null) {
        options = skipId;
        skipId = options.skipId;
      }
      options = Object.assign({}, options);
      if (this.$__schema == null) {
        const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;
        this.$__setSchema(_schema);
        fields = skipId;
        skipId = options;
        options = arguments[4] || {};
      }
      this.$__ = new InternalCache();
      if (options.isNew != null && options.isNew !== true) {
        this.$isNew = options.isNew;
      }
      if (options.priorDoc != null) {
        this.$__.priorDoc = options.priorDoc;
      }
      if (skipId) {
        this.$__.skipId = skipId;
      }
      if (obj != null && typeof obj !== "object") {
        throw new ObjectParameterError(obj, "obj", "Document");
      }
      let defaults2 = true;
      if (options.defaults !== void 0) {
        this.$__.defaults = options.defaults;
        defaults2 = options.defaults;
      }
      const schema = this.$__schema;
      if (typeof fields === "boolean" || fields === "throw") {
        if (fields !== true) {
          this.$__.strictMode = fields;
        }
        fields = void 0;
      } else if (schema.options.strict !== true) {
        this.$__.strictMode = schema.options.strict;
      }
      const requiredPaths = schema.requiredPaths(true);
      for (const path of requiredPaths) {
        this.$__.activePaths.require(path);
      }
      let exclude = null;
      if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {
        exclude = isExclusive(fields);
        this.$__.selected = fields;
        this.$__.exclude = exclude;
      }
      const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : null;
      if (this._doc == null) {
        this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
        if (defaults2) {
          applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);
        }
      }
      if (obj) {
        if (this.$__original_set) {
          this.$__original_set(obj, void 0, true, options);
        } else {
          this.$set(obj, void 0, true, options);
        }
        if (obj instanceof Document) {
          this.$isNew = obj.$isNew;
        }
      }
      if (options.willInit && defaults2) {
        if (options.skipDefaults) {
          this.$__.skipDefaults = options.skipDefaults;
        }
      } else if (defaults2) {
        applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);
      }
      if (!this.$__.strictMode && obj) {
        const _this = this;
        const keys = Object.keys(this._doc);
        keys.forEach(function(key) {
          if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith("$")) {
            defineKey({ prop: key, subprops: null, prototype: _this });
          }
        });
      }
      applyQueue(this);
    }
    Document.prototype.$isMongooseDocumentPrototype = true;
    Object.defineProperty(Document.prototype, "isNew", {
      get: function() {
        return this.$isNew;
      },
      set: function(value) {
        this.$isNew = value;
      }
    });
    Object.defineProperty(Document.prototype, "errors", {
      get: function() {
        return this.$errors;
      },
      set: function(value) {
        this.$errors = value;
      }
    });
    Document.prototype.$isNew = true;
    utils.each(
      [
        "on",
        "once",
        "emit",
        "listeners",
        "removeListener",
        "setMaxListeners",
        "removeAllListeners",
        "addListener"
      ],
      function(emitterFn) {
        Document.prototype[emitterFn] = function() {
          if (!this.$__.emitter) {
            if (emitterFn === "emit") {
              return;
            }
            this.$__.emitter = new EventEmitter();
            this.$__.emitter.setMaxListeners(0);
          }
          return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
        };
        Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];
      }
    );
    Document.prototype.constructor = Document;
    for (const i in EventEmitter.prototype) {
      Document[i] = EventEmitter.prototype[i];
    }
    Document.prototype.$__schema;
    Document.prototype.schema;
    Object.defineProperty(Document.prototype, "$locals", {
      configurable: false,
      enumerable: false,
      get: function() {
        if (this.$__.locals == null) {
          this.$__.locals = {};
        }
        return this.$__.locals;
      },
      set: function(v) {
        this.$__.locals = v;
      }
    });
    Document.prototype.isNew;
    Object.defineProperty(Document.prototype, "$where", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Document.prototype.id;
    Document.prototype.$errors;
    Object.defineProperty(Document.prototype, "$op", {
      get: function() {
        return this.$__.op || null;
      },
      set: function(value) {
        this.$__.op = value;
      }
    });
    function $applyDefaultsToNested(val, path, doc) {
      if (val == null) {
        return;
      }
      const paths = Object.keys(doc.$__schema.paths);
      const plen = paths.length;
      const pathPieces = path.indexOf(".") === -1 ? [path] : path.split(".");
      for (let i = 0; i < plen; ++i) {
        let curPath = "";
        const p = paths[i];
        if (!p.startsWith(path + ".")) {
          continue;
        }
        const type = doc.$__schema.paths[p];
        const pieces = type.splitPath().slice(pathPieces.length);
        const len = pieces.length;
        if (type.defaultValue === void 0) {
          continue;
        }
        let cur = val;
        for (let j = 0; j < len; ++j) {
          if (cur == null) {
            break;
          }
          const piece = pieces[j];
          if (j === len - 1) {
            if (cur[piece] !== void 0) {
              break;
            }
            try {
              const def = type.getDefault(doc, false);
              if (def !== void 0) {
                cur[piece] = def;
              }
            } catch (err) {
              doc.invalidate(path + "." + curPath, err);
              break;
            }
            break;
          }
          curPath += (!curPath.length ? "" : ".") + piece;
          cur[piece] = cur[piece] || {};
          cur = cur[piece];
        }
      }
    }
    Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
      const doc = {};
      const paths = Object.keys(this.$__schema.paths).filter((p) => !p.includes("$*"));
      const plen = paths.length;
      let ii = 0;
      for (; ii < plen; ++ii) {
        const p = paths[ii];
        if (p === "_id") {
          if (skipId) {
            continue;
          }
          if (obj && "_id" in obj) {
            continue;
          }
        }
        const path = this.$__schema.paths[p].splitPath();
        const len = path.length;
        const last = len - 1;
        let curPath = "";
        let doc_ = doc;
        let included = false;
        for (let i = 0; i < len; ++i) {
          const piece = path[i];
          if (!curPath.length) {
            curPath = piece;
          } else {
            curPath += "." + piece;
          }
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            if (curPath in fields) {
              included = true;
            } else if (!hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (i < last) {
            doc_ = doc_[piece] || (doc_[piece] = {});
          }
        }
      }
      this._doc = doc;
    };
    Document.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Document.prototype.init = function(doc, opts, fn) {
      if (typeof opts === "function") {
        fn = opts;
        opts = null;
      }
      this.$__init(doc, opts);
      if (fn) {
        fn(null, this);
      }
      return this;
    };
    Document.prototype.$init = function() {
      return this.constructor.prototype.init.apply(this, arguments);
    };
    Document.prototype.$__init = function(doc, opts) {
      this.$isNew = false;
      opts = opts || {};
      if (doc._id != null && opts.populated && opts.populated.length) {
        const id = String(doc._id);
        for (const item of opts.populated) {
          if (item.isVirtual) {
            this.$populated(item.path, utils.getValue(item.path, doc), item);
          } else {
            this.$populated(item.path, item._docs[id], item);
          }
          if (item._childDocs == null) {
            continue;
          }
          for (const child of item._childDocs) {
            if (child == null || child.$__ == null) {
              continue;
            }
            child.$__.parent = this;
          }
          item._childDocs = [];
        }
      }
      init(this, doc, this._doc, opts);
      markArraySubdocsPopulated(this, opts.populated);
      this.$emit("init", this);
      this.constructor.emit("init", this);
      const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ? $__hasIncludedChildren(this.$__.selected) : null;
      applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);
      return this;
    };
    function init(self2, obj, doc, opts, prefix) {
      prefix = prefix || "";
      if (obj.$__ != null) {
        obj = obj._doc;
      }
      const keys = Object.keys(obj);
      const len = keys.length;
      let schemaType;
      let path;
      let i;
      let index = 0;
      const strict = self2.$__.strictMode;
      const docSchema = self2.$__schema;
      while (index < len) {
        _init(index++);
      }
      function _init(index2) {
        i = keys[index2];
        if (i === "__proto__" || i === "constructor") {
          return;
        }
        path = prefix ? prefix + i : i;
        schemaType = docSchema.path(path);
        if (docSchema.$isRootDiscriminator && !self2.$__isSelected(path)) {
          return;
        }
        const value = obj[i];
        if (!schemaType && utils.isPOJO(value)) {
          if (!doc[i]) {
            doc[i] = {};
            if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {
              self2[i] = doc[i];
            }
          }
          init(self2, value, doc[i], opts, path + ".");
        } else if (!schemaType) {
          doc[i] = value;
          if (!strict && !prefix) {
            self2[i] = value;
          }
        } else {
          if (doc.hasOwnProperty(i) && value !== void 0) {
            delete doc[i];
          }
          if (value === null) {
            doc[i] = schemaType._castNullish(null);
          } else if (value !== void 0) {
            const wasPopulated = value.$__ == null ? null : value.$__.wasPopulated;
            if (schemaType && !wasPopulated) {
              try {
                if (opts && opts.setters) {
                  const overrideInit = false;
                  doc[i] = schemaType.applySetters(value, self2, overrideInit);
                } else {
                  doc[i] = schemaType.cast(value, self2, true);
                }
              } catch (e) {
                self2.invalidate(e.path, new ValidatorError({
                  path: e.path,
                  message: e.message,
                  type: "cast",
                  value: e.value,
                  reason: e
                }));
              }
            } else {
              doc[i] = value;
            }
          }
          if (!self2.$isModified(path)) {
            self2.$__.activePaths.init(path);
          }
        }
      }
    }
    Document.prototype.update = function update() {
      const args = [...arguments];
      args.unshift({ _id: this._id });
      const query = this.constructor.update.apply(this.constructor, args);
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      return query;
    };
    Document.prototype.updateOne = function updateOne(doc, options, callback) {
      const query = this.constructor.updateOne({ _id: this._id }, doc, options);
      const self2 = this;
      query.pre(function queryPreUpdateOne(cb) {
        self2.constructor._middleware.execPre("updateOne", self2, [self2], cb);
      });
      query.post(function queryPostUpdateOne(cb) {
        self2.constructor._middleware.execPost("updateOne", self2, [self2], {}, cb);
      });
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      if (callback != null) {
        return query.exec(callback);
      }
      return query;
    };
    Document.prototype.replaceOne = function replaceOne() {
      const args = [...arguments];
      args.unshift({ _id: this._id });
      return this.constructor.replaceOne.apply(this.constructor, args);
    };
    Document.prototype.$session = function $session(session) {
      if (arguments.length === 0) {
        if (this.$__.session != null && this.$__.session.hasEnded) {
          this.$__.session = null;
          return null;
        }
        return this.$__.session;
      }
      if (session != null && session.hasEnded) {
        throw new MongooseError("Cannot set a document's session to a session that has ended. Make sure you haven't called `endSession()` on the session you are passing to `$session()`.");
      }
      if (session == null && this.$__.session == null) {
        return;
      }
      this.$__.session = session;
      if (!this.$isSubdocument) {
        const subdocs = this.$getAllSubdocs();
        for (const child of subdocs) {
          child.$session(session);
        }
      }
      return session;
    };
    Document.prototype.$timestamps = function $timestamps(value) {
      if (arguments.length === 0) {
        if (this.$__.timestamps != null) {
          return this.$__.timestamps;
        }
        if (this.$__schema) {
          return this.$__schema.options.timestamps;
        }
        return void 0;
      }
      const currentValue = this.$timestamps();
      if (value !== currentValue) {
        this.$__.timestamps = value;
      }
      return this;
    };
    Document.prototype.overwrite = function overwrite(obj) {
      const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
      for (const key of keys) {
        if (key === "_id") {
          continue;
        }
        if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
          continue;
        }
        if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
          continue;
        }
        this.$set(key, obj[key]);
      }
      return this;
    };
    Document.prototype.$set = function $set(path, val, type, options) {
      if (utils.isPOJO(type)) {
        options = type;
        type = void 0;
      }
      const merge = options && options.merge;
      const adhoc = type && type !== true;
      const constructing = type === true;
      let adhocs;
      let keys;
      let i = 0;
      let pathtype;
      let key;
      let prefix;
      const strict = options && "strict" in options ? options.strict : this.$__.strictMode;
      if (adhoc) {
        adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
        adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
      }
      if (path == null) {
        [path, val] = [val, path];
      } else if (typeof path !== "string") {
        if (path instanceof Document) {
          if (path.$__isNested) {
            path = path.toObject();
          } else {
            path = path.$__schema === this.$__schema ? applyVirtuals(path, { ...path._doc }) : path._doc;
          }
        }
        if (path == null) {
          [path, val] = [val, path];
        }
        prefix = val ? val + "." : "";
        keys = getKeysInSchemaOrder(this.$__schema, path);
        const len = keys.length;
        const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;
        if (len === 0 && _skipMinimizeTopLevel) {
          delete options._skipMinimizeTopLevel;
          if (val) {
            this.$set(val, {});
          }
          return this;
        }
        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });
        for (let i2 = 0; i2 < len; ++i2) {
          key = keys[i2];
          const pathName = prefix ? prefix + key : key;
          pathtype = this.$__schema.pathType(pathName);
          const valForKey = path[key];
          if (type === true && !prefix && valForKey != null && pathtype === "nested" && this._doc[key] != null) {
            delete this._doc[key];
          }
          if (utils.isNonBuiltinObject(valForKey) && pathtype === "nested") {
            this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));
            $applyDefaultsToNested(this.$get(pathName), pathName, this);
            continue;
          } else if (strict) {
            if (constructing && valForKey === void 0 && this.$get(pathName) !== void 0) {
              continue;
            }
            if (pathtype === "adhocOrUndefined") {
              pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
            }
            if (pathtype === "real" || pathtype === "virtual") {
              this.$set(pathName, valForKey, constructing, options);
            } else if (pathtype === "nested" && valForKey instanceof Document) {
              this.$set(
                pathName,
                valForKey.toObject({ transform: false }),
                constructing,
                options
              );
            } else if (strict === "throw") {
              if (pathtype === "nested") {
                throw new ObjectExpectedError(key, valForKey);
              } else {
                throw new StrictModeError(key);
              }
            } else if (pathtype === "nested" && valForKey == null) {
              this.$set(pathName, valForKey, constructing, options);
            }
          } else if (valForKey !== void 0) {
            this.$set(pathName, valForKey, constructing, options);
          }
        }
        const orderedDoc = {};
        const orderedKeys = Object.keys(this.$__schema.tree);
        for (let i2 = 0, len2 = orderedKeys.length; i2 < len2; ++i2) {
          (key = orderedKeys[i2]) && this._doc.hasOwnProperty(key) && (orderedDoc[key] = void 0);
        }
        this._doc = Object.assign(orderedDoc, this._doc);
        return this;
      }
      let pathType = this.$__schema.pathType(path);
      if (pathType === "adhocOrUndefined") {
        pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
      }
      val = handleSpreadDoc(val);
      const priorVal = (() => {
        if (this.$__.priorDoc != null) {
          return this.$__.priorDoc.$__getValue(path);
        }
        if (constructing) {
          return void 0;
        }
        return this.$__getValue(path);
      })();
      if (pathType === "nested" && val) {
        if (typeof val === "object" && val != null) {
          if (val.$__ != null) {
            val = val.toObject(internalToObjectOptions);
          }
          if (val == null) {
            this.invalidate(path, new MongooseError.CastError("Object", val, path));
            return this;
          }
          const wasModified = this.$isModified(path);
          const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
          if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {
            const initialVal = this.$__getValue(path);
            this.$__.savedState[path] = initialVal;
            const keys3 = Object.keys(initialVal || {});
            for (const key2 of keys3) {
              this.$__.savedState[path + "." + key2] = initialVal[key2];
            }
          }
          if (!merge) {
            this.$__setValue(path, null);
            cleanModifiedSubpaths(this, path);
          } else {
            return this.$set(val, path, constructing);
          }
          const keys2 = getKeysInSchemaOrder(this.$__schema, val, path);
          this.$__setValue(path, {});
          for (const key2 of keys2) {
            this.$set(path + "." + key2, val[key2], constructing, { ...options, _skipMarkModified: true });
          }
          if (priorVal != null && (!wasModified || hasInitialVal) && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {
            this.unmarkModified(path);
          } else {
            this.markModified(path);
          }
          return this;
        }
        this.invalidate(path, new MongooseError.CastError("Object", val, path));
        return this;
      }
      let schema;
      const parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      if (typeof this.$__schema.aliases[parts[0]] === "string") {
        parts[0] = this.$__schema.aliases[parts[0]];
      }
      if (pathType === "adhocOrUndefined" && strict) {
        let mixed;
        for (i = 0; i < parts.length; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
            mpath.set(path, val, this);
            return this;
          }
          schema = this.$__schema.path(subpath);
          if (schema == null) {
            continue;
          }
          if (schema instanceof MixedSchema) {
            mixed = true;
            break;
          }
        }
        if (schema == null) {
          schema = getEmbeddedDiscriminatorPath(this, path);
        }
        if (!mixed && !schema) {
          if (strict === "throw") {
            throw new StrictModeError(path);
          }
          return this;
        }
      } else if (pathType === "virtual") {
        schema = this.$__schema.virtualpath(path);
        schema.applySetters(val, this);
        return this;
      } else {
        schema = this.$__path(path);
      }
      let cur = this._doc;
      let curPath = "";
      for (i = 0; i < parts.length - 1; ++i) {
        cur = cur[parts[i]];
        curPath += (curPath.length !== 0 ? "." : "") + parts[i];
        if (!cur) {
          this.$set(curPath, {});
          if (!this.$__isSelected(curPath)) {
            this.unmarkModified(curPath);
          }
          cur = this.$__getValue(curPath);
        }
      }
      let pathToMark;
      if (parts.length <= 1) {
        pathToMark = path;
      } else {
        const len = parts.length;
        for (i = 0; i < len; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (this.$get(subpath, null, { getters: false }) === null) {
            pathToMark = subpath;
            break;
          }
        }
        if (!pathToMark) {
          pathToMark = path;
        }
      }
      if (!schema) {
        this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
        if (pathType === "nested" && val == null) {
          cleanModifiedSubpaths(this, path);
        }
        return this;
      }
      if (schema.$isSingleNested || schema.$isMongooseArray) {
        _markValidSubpaths(this, path);
      }
      if (val != null && merge && schema.$isSingleNested) {
        if (val instanceof Document) {
          val = val.toObject({ virtuals: false, transform: false });
        }
        const keys2 = Object.keys(val);
        for (const key2 of keys2) {
          this.$set(path + "." + key2, val[key2], constructing, options);
        }
        return this;
      }
      let shouldSet = true;
      try {
        const refMatches = (() => {
          if (schema.options == null) {
            return false;
          }
          if (!(val instanceof Document)) {
            return false;
          }
          const model = val.constructor;
          const ref = schema.options.ref;
          if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
            return true;
          }
          const refPath = schema.options.refPath;
          if (refPath == null) {
            return false;
          }
          const modelName = val.get(refPath);
          return modelName === model.modelName || modelName === model.baseModelName;
        })();
        let didPopulate = false;
        if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {
          const unpopulatedValue = schema && schema.$isSingleNested ? schema.cast(val, this) : val._id;
          this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });
          val.$__.wasPopulated = { value: unpopulatedValue };
          didPopulate = true;
        }
        let popOpts;
        const typeKey = this.$__schema.options.typeKey;
        if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
          popOpts = { [populateModelSymbol]: val[0].constructor };
          this.$populated(path, val.map(function(v) {
            return v._id;
          }), popOpts);
          for (const doc of val) {
            doc.$__.wasPopulated = { value: doc._id };
          }
          didPopulate = true;
        }
        if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {
          if (options != null && options.overwriteImmutable) {
            val = schema.applySetters(val, this, false, priorVal, { overwriteImmutable: true });
          } else {
            val = schema.applySetters(val, this, false, priorVal);
          }
        }
        if (Array.isArray(val) && !Array.isArray(schema) && schema.$isMongooseDocumentArray && val.length !== 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
          const populatedPaths = Object.keys(val[0].$__.populated);
          for (const populatedPath of populatedPaths) {
            this.$populated(
              path + "." + populatedPath,
              val.map((v) => v.$populated(populatedPath)),
              val[0].$__.populated[populatedPath].options
            );
          }
          didPopulate = true;
        }
        if (!didPopulate && this.$__.populated) {
          if (Array.isArray(val) && this.$__.populated[path]) {
            for (let i2 = 0; i2 < val.length; ++i2) {
              if (val[i2] instanceof Document) {
                val.set(i2, val[i2]._id, true);
              }
            }
          }
          delete this.$__.populated[path];
        }
        if (val != null && schema.$isSingleNested) {
          _checkImmutableSubpaths(val, schema, priorVal);
        }
        this.$markValid(path);
      } catch (e) {
        if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
          this.invalidate(path, e);
        } else if (e instanceof MongooseError.CastError) {
          this.invalidate(e.path, e);
          if (e.$originalErrorPath) {
            this.invalidate(
              path,
              new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath)
            );
          }
        } else {
          this.invalidate(
            path,
            new MongooseError.CastError(schema.instance, val, path, e)
          );
        }
        shouldSet = false;
      }
      if (shouldSet) {
        let savedState = null;
        let savedStatePath = null;
        if (!constructing) {
          const doc = this.$isSubdocument ? this.ownerDocument() : this;
          savedState = doc.$__.savedState;
          savedStatePath = this.$isSubdocument ? this.$__.fullPath + "." + path : path;
          doc.$__saveInitialState(savedStatePath);
        }
        this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
        if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {
          this.unmarkModified(path);
        }
      }
      if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
        cleanModifiedSubpaths(this, path);
      }
      return this;
    };
    function _isManuallyPopulatedArray(val, ref) {
      if (!Array.isArray(val)) {
        return false;
      }
      if (val.length === 0) {
        return false;
      }
      for (const el of val) {
        if (!(el instanceof Document)) {
          return false;
        }
        const modelName = el.constructor.modelName;
        if (modelName == null) {
          return false;
        }
        if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
          return false;
        }
      }
      return true;
    }
    Document.prototype.set = Document.prototype.$set;
    Document.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
      if (options && options._skipMarkModified) {
        return false;
      }
      if (this.$isNew) {
        return true;
      }
      if (path in this.$__.activePaths.getStatePaths("modify")) {
        return true;
      }
      if (this.$__schema.singleNestedPaths[path] != null) {
        return false;
      }
      if (val === void 0 && !this.$__isSelected(path)) {
        return true;
      }
      if (val === void 0 && path in this.$__.activePaths.getStatePaths("default")) {
        return false;
      }
      if (this.$populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {
        return false;
      }
      if (!deepEqual(val, priorVal !== void 0 ? priorVal : utils.getValue(path, this))) {
        return true;
      }
      if (!constructing && val !== null && val !== void 0 && path in this.$__.activePaths.getStatePaths("default") && deepEqual(val, schema.getDefault(this, constructing))) {
        return true;
      }
      return false;
    };
    Document.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
      Embedded = Embedded || require_ArraySubdocument();
      const shouldModify = this.$__shouldModify(
        pathToMark,
        path,
        options,
        constructing,
        parts,
        schema,
        val,
        priorVal
      );
      if (shouldModify) {
        if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {
          delete this.$__.primitiveAtomics[path];
          if (Object.keys(this.$__.primitiveAtomics).length === 0) {
            delete this.$__.primitiveAtomics;
          }
        }
        this.markModified(pathToMark);
        MongooseArray || (MongooseArray = require_array());
        if (val && utils.isMongooseArray(val)) {
          val._registerAtomic("$set", val);
          if (utils.isMongooseDocumentArray(val)) {
            val.forEach(function(item) {
              item && item.__parentArray && (item.__parentArray = val);
            });
          }
        }
      } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {
        val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];
        val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];
        if (utils.isMongooseDocumentArray(val)) {
          val.forEach((doc) => {
            if (doc) {
              doc.isNew = false;
            }
          });
        }
      }
      let obj = this._doc;
      let i = 0;
      const l = parts.length;
      let cur = "";
      for (; i < l; i++) {
        const next = i + 1;
        const last = next === l;
        cur += cur ? "." + parts[i] : parts[i];
        if (specialProperties.has(parts[i])) {
          return;
        }
        if (last) {
          if (obj instanceof Map) {
            obj.set(parts[i], val);
          } else {
            obj[parts[i]] = val;
          }
        } else {
          if (utils.isPOJO(obj[parts[i]])) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
            obj = obj[parts[i]];
          } else {
            obj[parts[i]] = obj[parts[i]] || {};
            obj = obj[parts[i]];
          }
        }
      }
    };
    Document.prototype.$__getValue = function(path) {
      return utils.getValue(path, this._doc);
    };
    Document.prototype.$inc = function $inc(path, val) {
      if (val == null) {
        val = 1;
      }
      if (Array.isArray(path)) {
        path.forEach((p) => this.$inc(p, val));
        return this;
      }
      const schemaType = this.$__path(path);
      if (schemaType == null) {
        if (this.$__.strictMode === "throw") {
          throw new StrictModeError(path);
        } else if (this.$__.strictMode === true) {
          return this;
        }
      } else if (schemaType.instance !== "Number") {
        this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));
        return this;
      }
      const currentValue = this.$__getValue(path) || 0;
      let shouldSet = false;
      let valToSet = null;
      let valToInc = val;
      try {
        val = schemaType.cast(val);
        valToSet = schemaType.applySetters(currentValue + val, this);
        valToInc = valToSet - currentValue;
        shouldSet = true;
      } catch (err) {
        this.invalidate(path, new MongooseError.CastError("number", val, path, err));
      }
      if (shouldSet) {
        this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};
        if (this.$__.primitiveAtomics[path] == null) {
          this.$__.primitiveAtomics[path] = { $inc: valToInc };
        } else {
          this.$__.primitiveAtomics[path].$inc += valToInc;
        }
        this.markModified(path);
        this.$__setValue(path, valToSet);
      }
      return this;
    };
    Document.prototype.$__setValue = function(path, val) {
      utils.setValue(path, val, this._doc);
      return this;
    };
    Document.prototype.get = function(path, type, options) {
      let adhoc;
      if (options == null) {
        options = {};
      }
      if (type) {
        adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
      }
      const noDottedPath = options.noDottedPath;
      let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);
      if (schema == null) {
        schema = this.$__schema.virtualpath(path);
        if (schema != null) {
          return schema.applyGetters(void 0, this);
        }
      }
      if (noDottedPath) {
        let obj2 = this._doc[path];
        if (adhoc) {
          obj2 = adhoc.cast(obj2);
        }
        if (schema != null && options.getters !== false) {
          return schema.applyGetters(obj2, this);
        }
        return obj2;
      }
      if (schema != null && schema.instance === "Mixed") {
        const virtual = this.$__schema.virtualpath(path);
        if (virtual != null) {
          schema = virtual;
        }
      }
      const hasDot = path.indexOf(".") !== -1;
      let obj = this._doc;
      const pieces = hasDot ? path.split(".") : [path];
      if (typeof this.$__schema.aliases[pieces[0]] === "string") {
        pieces[0] = this.$__schema.aliases[pieces[0]];
      }
      for (let i = 0, l = pieces.length; i < l; i++) {
        if (obj && obj._doc) {
          obj = obj._doc;
        }
        if (obj == null) {
          obj = void 0;
        } else if (obj instanceof Map) {
          obj = obj.get(pieces[i], { getters: false });
        } else if (i === l - 1) {
          obj = utils.getValue(pieces[i], obj);
        } else {
          obj = obj[pieces[i]];
        }
      }
      if (adhoc) {
        obj = adhoc.cast(obj);
      }
      if (schema != null && options.getters !== false) {
        obj = schema.applyGetters(obj, this);
      } else if (this.$__schema.nested[path] && options.virtuals) {
        return applyVirtuals(this, utils.clone(obj) || {}, { path });
      }
      return obj;
    };
    Document.prototype[getSymbol] = Document.prototype.get;
    Document.prototype.$get = Document.prototype.get;
    Document.prototype.$__path = function(path) {
      const adhocs = this.$__.adhocPaths;
      const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
      if (adhocType) {
        return adhocType;
      }
      return this.$__schema.path(path);
    };
    Document.prototype.markModified = function(path, scope) {
      this.$__saveInitialState(path);
      this.$__.activePaths.modify(path);
      if (scope != null && !this.$isSubdocument) {
        this.$__.pathsToScopes = this.$__pathsToScopes || {};
        this.$__.pathsToScopes[path] = scope;
      }
    };
    Document.prototype.$__saveInitialState = function $__saveInitialState(path) {
      const savedState = this.$__.savedState;
      const savedStatePath = path;
      if (savedState != null) {
        const firstDot = savedStatePath.indexOf(".");
        const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);
        if (!savedState.hasOwnProperty(topLevelPath)) {
          savedState[topLevelPath] = utils.clone(this.$__getValue(topLevelPath));
        }
      }
    };
    Document.prototype.unmarkModified = function(path) {
      this.$__.activePaths.init(path);
      if (this.$__.pathsToScopes != null) {
        delete this.$__.pathsToScopes[path];
      }
    };
    Document.prototype.$ignore = function(path) {
      this.$__.activePaths.ignore(path);
    };
    Document.prototype.directModifiedPaths = function() {
      return Object.keys(this.$__.activePaths.getStatePaths("modify"));
    };
    Document.prototype.$isEmpty = function(path) {
      const isEmptyOptions = {
        minimize: true,
        virtuals: false,
        getters: false,
        transform: false
      };
      if (arguments.length !== 0) {
        const v = this.$get(path);
        if (v == null) {
          return true;
        }
        if (typeof v !== "object") {
          return false;
        }
        if (utils.isPOJO(v)) {
          return _isEmpty(v);
        }
        return Object.keys(v.toObject(isEmptyOptions)).length === 0;
      }
      return Object.keys(this.toObject(isEmptyOptions)).length === 0;
    };
    function _isEmpty(v) {
      if (v == null) {
        return true;
      }
      if (typeof v !== "object" || Array.isArray(v)) {
        return false;
      }
      for (const key of Object.keys(v)) {
        if (!_isEmpty(v[key])) {
          return false;
        }
      }
      return true;
    }
    Document.prototype.modifiedPaths = function(options) {
      options = options || {};
      const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths("modify"));
      const result = /* @__PURE__ */ new Set();
      let i = 0;
      let j = 0;
      const len = directModifiedPaths.length;
      for (i = 0; i < len; ++i) {
        const path = directModifiedPaths[i];
        const parts = parentPaths(path);
        const pLen = parts.length;
        for (j = 0; j < pLen; ++j) {
          result.add(parts[j]);
        }
        if (!options.includeChildren) {
          continue;
        }
        let ii = 0;
        let cur = this.$get(path);
        if (typeof cur === "object" && cur !== null) {
          if (cur._doc) {
            cur = cur._doc;
          }
          const len2 = cur.length;
          if (Array.isArray(cur)) {
            for (ii = 0; ii < len2; ++ii) {
              const subPath = path + "." + ii;
              if (!result.has(subPath)) {
                result.add(subPath);
                if (cur[ii] != null && cur[ii].$__) {
                  const modified = cur[ii].modifiedPaths();
                  let iii = 0;
                  const iiiLen = modified.length;
                  for (iii = 0; iii < iiiLen; ++iii) {
                    result.add(subPath + "." + modified[iii]);
                  }
                }
              }
            }
          } else {
            const keys = Object.keys(cur);
            let ii2 = 0;
            const len3 = keys.length;
            for (ii2 = 0; ii2 < len3; ++ii2) {
              result.add(path + "." + keys[ii2]);
            }
          }
        }
      }
      return Array.from(result);
    };
    Document.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;
    Document.prototype.isModified = function(paths, options, modifiedPaths) {
      if (paths) {
        const ignoreAtomics = options && options.ignoreAtomics;
        const directModifiedPathsObj = this.$__.activePaths.states.modify;
        if (directModifiedPathsObj == null) {
          return false;
        }
        if (typeof paths === "string") {
          paths = paths.indexOf(" ") === -1 ? [paths] : paths.split(" ");
        }
        for (const path of paths) {
          if (directModifiedPathsObj[path] != null) {
            return true;
          }
        }
        const modified = modifiedPaths || this[documentModifiedPaths]();
        const isModifiedChild = paths.some(function(path) {
          return !!~modified.indexOf(path);
        });
        let directModifiedPaths = Object.keys(directModifiedPathsObj);
        if (ignoreAtomics) {
          directModifiedPaths = directModifiedPaths.filter((path) => {
            const value = this.$__getValue(path);
            if (value != null && value[arrayAtomicsSymbol] != null && value[arrayAtomicsSymbol].$set === void 0) {
              return false;
            }
            return true;
          });
        }
        return isModifiedChild || paths.some(function(path) {
          return directModifiedPaths.some(function(mod) {
            return mod === path || path.startsWith(mod + ".");
          });
        });
      }
      return this.$__.activePaths.some("modify");
    };
    Document.prototype.$isModified = Document.prototype.isModified;
    Document.prototype[documentIsModified] = Document.prototype.isModified;
    Document.prototype.$isDefault = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("default");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.getStatePaths("default").hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.getStatePaths("default").hasOwnProperty(path2));
    };
    Document.prototype.$isDeleted = function(val) {
      if (arguments.length === 0) {
        return !!this.$__.isDeleted;
      }
      this.$__.isDeleted = !!val;
      return this;
    };
    Document.prototype.isDirectModified = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("modify");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path2));
    };
    Document.prototype.isInit = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("init");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.getStatePaths("init").hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.getStatePaths("init").hasOwnProperty(path2));
    };
    Document.prototype.isSelected = function isSelected(path) {
      if (this.$__.selected == null) {
        return true;
      }
      if (!path) {
        return false;
      }
      if (path === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.$__isSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (path in this.$__.selected) {
        return inclusive;
      }
      const pathDot = path + ".";
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (cur.startsWith(pathDot)) {
          return inclusive || cur !== pathDot;
        }
        if (pathDot.startsWith(cur + ".")) {
          return inclusive;
        }
      }
      return !inclusive;
    };
    Document.prototype.$__isSelected = Document.prototype.isSelected;
    Document.prototype.isDirectSelected = function isDirectSelected(path) {
      if (this.$__.selected == null) {
        return true;
      }
      if (path === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.isDirectSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (this.$__.selected.hasOwnProperty(path)) {
        return inclusive;
      }
      return !inclusive;
    };
    Document.prototype.validate = function(pathsToValidate, options, callback) {
      let parallelValidate;
      this.$op = "validate";
      if (this.$isSubdocument != null) {
      } else if (this.$__.validating) {
        parallelValidate = new ParallelValidateError(this, {
          parentStack: options && options.parentStack,
          conflictStack: this.$__.validating.stack
        });
      } else {
        this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
      }
      if (arguments.length === 1) {
        if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
          options = arguments[0];
          callback = null;
          pathsToValidate = null;
        } else if (typeof arguments[0] === "function") {
          callback = arguments[0];
          options = null;
          pathsToValidate = null;
        }
      } else if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
      } else if (typeof options === "function") {
        callback = options;
        options = pathsToValidate;
        pathsToValidate = null;
      }
      if (options && typeof options.pathsToSkip === "string") {
        const isOnePathOnly = options.pathsToSkip.indexOf(" ") === -1;
        options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(" ");
      }
      return promiseOrCallback(callback, (cb) => {
        if (parallelValidate != null) {
          return cb(parallelValidate);
        }
        this.$__validate(pathsToValidate, options, (error) => {
          this.$op = null;
          this.$__.validating = null;
          cb(error);
        });
      }, this.constructor.events);
    };
    Document.prototype.$validate = Document.prototype.validate;
    function _evaluateRequiredFunctions(doc) {
      const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths("require"));
      let i = 0;
      const len = requiredFields.length;
      for (i = 0; i < len; ++i) {
        const path = requiredFields[i];
        const p = doc.$__schema.path(path);
        if (p != null && typeof p.originalRequiredValue === "function") {
          doc.$__.cachedRequired = doc.$__.cachedRequired || {};
          try {
            doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
          } catch (err) {
            doc.invalidate(path, err);
          }
        }
      }
    }
    function _getPathsToValidate(doc) {
      const doValidateOptions = {};
      _evaluateRequiredFunctions(doc);
      let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths("require")).filter(function(path) {
        if (!doc.$__isSelected(path) && !doc.$isModified(path)) {
          return false;
        }
        if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {
          return doc.$__.cachedRequired[path];
        }
        return true;
      }));
      Object.keys(doc.$__.activePaths.getStatePaths("init")).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.getStatePaths("modify")).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.getStatePaths("default")).forEach(addToPaths);
      function addToPaths(p) {
        paths.add(p);
      }
      const subdocs = doc.$getAllSubdocs();
      const modifiedPaths = doc.modifiedPaths();
      for (const subdoc of subdocs) {
        if (subdoc.$basePath) {
          const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();
          for (const modifiedPath of subdoc.modifiedPaths()) {
            paths.delete(fullPathToSubdoc + "." + modifiedPath);
          }
          if (doc.$isModified(fullPathToSubdoc, null, modifiedPaths) && !doc.isDirectModified(fullPathToSubdoc) && !doc.$isDefault(fullPathToSubdoc)) {
            paths.add(fullPathToSubdoc);
            if (doc.$__.pathsToScopes == null) {
              doc.$__.pathsToScopes = {};
            }
            doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ? subdoc.__parentArray : subdoc.$parent();
            doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };
            if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {
              doValidateOptions[fullPathToSubdoc].index = subdoc.__index;
            }
          }
        }
      }
      for (const path of paths) {
        const _pathType = doc.$__schema.path(path);
        if (!_pathType) {
          continue;
        }
        if (_pathType.$isMongooseDocumentArray) {
          for (const p of paths) {
            if (p == null || p.startsWith(_pathType.path + ".")) {
              paths.delete(p);
            }
          }
        }
        if (!_pathType.caster && _pathType.validators.length === 0) {
          paths.delete(path);
        } else if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && // Skip document arrays...
        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays
        _pathType.validators.length === 0 && // and arrays with top-level validators
        _pathType.$embeddedSchemaType.validators.length === 0) {
          paths.delete(path);
        }
      }
      for (const path of paths) {
        const _pathType = doc.$__schema.path(path);
        if (!_pathType) {
          continue;
        }
        if (!_pathType.$isMongooseArray || // To avoid potential performance issues, skip doc arrays whose children
        // are not required. `getPositionalPathType()` may be slow, so avoid
        // it unless we have a case of #6364
        !Array.isArray(_pathType) && _pathType.$isMongooseDocumentArray && !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required)) {
          continue;
        }
        if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && // Skip document arrays...
        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays
        _pathType.$embeddedSchemaType.validators.length === 0) {
          continue;
        }
        const val = doc.$__getValue(path);
        _pushNestedArrayPaths(val, paths, path);
      }
      function _pushNestedArrayPaths(val, paths2, path) {
        if (val != null) {
          const numElements = val.length;
          for (let j = 0; j < numElements; ++j) {
            if (Array.isArray(val[j])) {
              _pushNestedArrayPaths(val[j], paths2, path + "." + j);
            } else {
              paths2.add(path + "." + j);
            }
          }
        }
      }
      const flattenOptions = { skipArrays: true };
      for (const pathToCheck of paths) {
        if (doc.$__schema.nested[pathToCheck]) {
          let _v = doc.$__getValue(pathToCheck);
          if (isMongooseObject(_v)) {
            _v = _v.toObject({ transform: false });
          }
          const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
          Object.keys(flat).forEach(addToPaths);
        }
      }
      for (const path of paths) {
        if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {
          paths.delete(path);
          continue;
        }
        const _pathType = doc.$__schema.path(path);
        if (!_pathType || !_pathType.$isSchemaMap) {
          continue;
        }
        const val = doc.$__getValue(path);
        if (val == null) {
          continue;
        }
        for (const key of val.keys()) {
          paths.add(path + "." + key);
        }
      }
      paths = Array.from(paths);
      return [paths, doValidateOptions];
    }
    Document.prototype.$__validate = function(pathsToValidate, options, callback) {
      if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
      const pathsToSkip = options && options.pathsToSkip || null;
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      const _this = this;
      const _complete = () => {
        let validationError = this.$__.validationError;
        this.$__.validationError = null;
        this.$__.validating = null;
        if (shouldValidateModifiedOnly && validationError != null) {
          const errors = Object.keys(validationError.errors);
          for (const errPath of errors) {
            if (!this.$isModified(errPath)) {
              delete validationError.errors[errPath];
            }
          }
          if (Object.keys(validationError.errors).length === 0) {
            validationError = void 0;
          }
        }
        this.$__.cachedRequired = {};
        this.$emit("validate", _this);
        this.constructor.emit("validate", _this);
        if (validationError) {
          for (const key in validationError.errors) {
            if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
              this.invalidate(key, validationError.errors[key]);
            }
          }
          return validationError;
        }
      };
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
      const doValidateOptionsByPath = pathDetails[1];
      if (typeof pathsToValidate === "string") {
        pathsToValidate = pathsToValidate.split(" ");
      }
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (pathsToSkip) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      if (paths.length === 0) {
        return immediate(function() {
          const error = _complete();
          if (error) {
            return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
              callback(error2);
            });
          }
          callback(null, _this);
        });
      }
      const validated = {};
      let total = 0;
      for (const path of paths) {
        validatePath(path);
      }
      function validatePath(path) {
        if (path == null || validated[path]) {
          return;
        }
        validated[path] = true;
        total++;
        immediate(function() {
          const schemaType = _this.$__schema.path(path);
          if (!schemaType) {
            return --total || complete();
          }
          if (!_this.$isValid(path)) {
            --total || complete();
            return;
          }
          if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
            return --total || complete();
          }
          let val = _this.$__getValue(path);
          let pop;
          if (pop = _this.$populated(path)) {
            val = pop;
          } else if (val != null && val.$__ != null && val.$__.wasPopulated) {
            val = val._id;
          }
          const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;
          const doValidateOptions = {
            ...doValidateOptionsByPath[path],
            path,
            validateModifiedOnly: shouldValidateModifiedOnly
          };
          schemaType.doValidate(val, function(err) {
            if (err) {
              const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;
              if (isSubdoc && err instanceof ValidationError2) {
                return --total || complete();
              }
              _this.invalidate(path, err, void 0, true);
            }
            --total || complete();
          }, scope, doValidateOptions);
        });
      }
      function complete() {
        const error = _complete();
        if (error) {
          return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
            callback(error2);
          });
        }
        callback(null, _this);
      }
    };
    function _handlePathsToValidate(paths, pathsToValidate) {
      const _pathsToValidate = new Set(pathsToValidate);
      const parentPaths2 = /* @__PURE__ */ new Map([]);
      for (const path of pathsToValidate) {
        if (path.indexOf(".") === -1) {
          continue;
        }
        const pieces = path.split(".");
        let cur = pieces[0];
        for (let i = 1; i < pieces.length; ++i) {
          parentPaths2.set(cur, path);
          cur = cur + "." + pieces[i];
        }
      }
      const ret = [];
      for (const path of paths) {
        if (_pathsToValidate.has(path)) {
          ret.push(path);
        } else if (parentPaths2.has(path)) {
          ret.push(parentPaths2.get(path));
        }
      }
      return ret;
    }
    function _handlePathsToSkip(paths, pathsToSkip) {
      pathsToSkip = new Set(pathsToSkip);
      paths = paths.filter((p) => !pathsToSkip.has(p));
      return paths;
    }
    Document.prototype.validateSync = function(pathsToValidate, options) {
      const _this = this;
      if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options = arguments[0];
        pathsToValidate = null;
      }
      const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      let pathsToSkip = options && options.pathsToSkip;
      if (typeof pathsToValidate === "string") {
        const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
        pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(" ");
      } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
        pathsToSkip = pathsToSkip.split(" ");
      }
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
      const skipSchemaValidators = pathDetails[1];
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (Array.isArray(pathsToSkip)) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      const validating = {};
      for (let i = 0, len = paths.length; i < len; ++i) {
        const path = paths[i];
        if (validating[path]) {
          continue;
        }
        validating[path] = true;
        const p = _this.$__schema.path(path);
        if (!p) {
          continue;
        }
        if (!_this.$isValid(path)) {
          continue;
        }
        const val = _this.$__getValue(path);
        const err2 = p.doValidateSync(val, _this, {
          skipSchemaValidators: skipSchemaValidators[path],
          path,
          validateModifiedOnly: shouldValidateModifiedOnly
        });
        if (err2) {
          const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;
          if (isSubdoc && err2 instanceof ValidationError2) {
            continue;
          }
          _this.invalidate(path, err2, void 0, true);
        }
      }
      const err = _this.$__.validationError;
      _this.$__.validationError = void 0;
      _this.$emit("validate", _this);
      _this.constructor.emit("validate", _this);
      if (err) {
        for (const key in err.errors) {
          if (err.errors[key] instanceof MongooseError.CastError) {
            _this.invalidate(key, err.errors[key]);
          }
        }
      }
      return err;
    };
    Document.prototype.invalidate = function(path, err, val, kind) {
      if (!this.$__.validationError) {
        this.$__.validationError = new ValidationError2(this);
      }
      if (this.$__.validationError.errors[path]) {
        return;
      }
      if (!err || typeof err === "string") {
        err = new ValidatorError({
          path,
          message: err,
          type: kind || "user defined",
          value: val
        });
      }
      if (this.$__.validationError === err) {
        return this.$__.validationError;
      }
      this.$__.validationError.addError(path, err);
      return this.$__.validationError;
    };
    Document.prototype.$markValid = function(path) {
      if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
        return;
      }
      delete this.$__.validationError.errors[path];
      if (Object.keys(this.$__.validationError.errors).length === 0) {
        this.$__.validationError = null;
      }
    };
    function _markValidSubpaths(doc, path) {
      if (!doc.$__.validationError) {
        return;
      }
      const keys = Object.keys(doc.$__.validationError.errors);
      for (const key of keys) {
        if (key.startsWith(path + ".")) {
          delete doc.$__.validationError.errors[key];
        }
      }
      if (Object.keys(doc.$__.validationError.errors).length === 0) {
        doc.$__.validationError = null;
      }
    }
    function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
      const schema = schematype.schema;
      if (schema == null) {
        return;
      }
      for (const key of Object.keys(schema.paths)) {
        const path = schema.paths[key];
        if (path.$immutableSetter == null) {
          continue;
        }
        const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);
        path.$immutableSetter.call(subdoc, oldVal);
      }
    }
    Document.prototype.$isValid = function(path) {
      if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
        return true;
      }
      if (path == null) {
        return false;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.$__.validationError.errors[p] == null);
      }
      return this.$__.validationError.errors[path] == null;
    };
    Document.prototype.$__reset = function reset() {
      let _this = this;
      const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];
      const resetArrays = /* @__PURE__ */ new Set();
      for (const subdoc of subdocs) {
        const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();
        if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {
          subdoc.$__reset();
          if (subdoc.$isDocumentArrayElement) {
            if (!resetArrays.has(subdoc.parentArray())) {
              const array = subdoc.parentArray();
              this.$__.activePaths.clearPath(fullPathWithIndexes.replace(/\.\d+$/, "").slice(-subdoc.$basePath - 1));
              array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
              array[arrayAtomicsSymbol] = {};
              resetArrays.add(array);
            }
          } else {
            const parent = subdoc.$parent();
            if (parent === this) {
              this.$__.activePaths.clearPath(subdoc.$basePath);
            } else if (parent != null && parent.$isSubdocument) {
              parent.$__reset();
            }
          }
        }
      }
      function isParentInit(path) {
        path = path.indexOf(".") === -1 ? [path] : path.split(".");
        let cur = "";
        for (let i = 0; i < path.length; ++i) {
          cur += (cur.length ? "." : "") + path[i];
          if (_this.$__.activePaths[cur] === "init") {
            return true;
          }
        }
        return false;
      }
      this.$__dirty().forEach(function(dirt) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol]) {
          type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
          type[arrayAtomicsSymbol] = {};
        }
      });
      this.$__.backup = {};
      this.$__.backup.activePaths = {
        modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")),
        default: Object.assign({}, this.$__.activePaths.getStatePaths("default"))
      };
      this.$__.backup.validationError = this.$__.validationError;
      this.$__.backup.errors = this.$errors;
      this.$__.activePaths.clear("modify");
      this.$__.activePaths.clear("default");
      this.$__.validationError = void 0;
      this.$errors = void 0;
      _this = this;
      this.$__schema.requiredPaths().forEach(function(path) {
        _this.$__.activePaths.require(path);
      });
      return this;
    };
    Document.prototype.$__undoReset = function $__undoReset() {
      if (this.$__.backup == null || this.$__.backup.activePaths == null) {
        return;
      }
      this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
      this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
      this.$__.validationError = this.$__.backup.validationError;
      this.$errors = this.$__.backup.errors;
      for (const dirt of this.$__dirty()) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
          type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
        }
      }
      for (const subdoc of this.$getAllSubdocs()) {
        subdoc.$__undoReset();
      }
    };
    Document.prototype.$__dirty = function() {
      const _this = this;
      let all = this.$__.activePaths.map("modify", function(path) {
        return {
          path,
          value: _this.$__getValue(path),
          schema: _this.$__path(path)
        };
      });
      all = all.concat(this.$__.activePaths.map("default", function(path) {
        if (path === "_id" || _this.$__getValue(path) == null) {
          return;
        }
        return {
          path,
          value: _this.$__getValue(path),
          schema: _this.$__path(path)
        };
      }));
      const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));
      const minimal = [];
      all.forEach(function(item) {
        if (!item) {
          return;
        }
        let top = null;
        const array = parentPaths(item.path);
        for (let i = 0; i < array.length - 1; i++) {
          if (allPaths.has(array[i])) {
            top = allPaths.get(array[i]);
            break;
          }
        }
        if (top == null) {
          minimal.push(item);
        } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {
          top[arrayAtomicsSymbol] = {};
          top[arrayAtomicsSymbol].$set = top;
        }
      });
      return minimal;
    };
    Document.prototype.$__setSchema = function(schema) {
      compile(schema.tree, this, void 0, schema.options);
      for (const key of Object.keys(schema.virtuals)) {
        schema.virtuals[key]._applyDefaultGetters();
      }
      if (schema.path("schema") == null) {
        this.schema = schema;
      }
      this.$__schema = schema;
      this[documentSchemaSymbol] = schema;
    };
    Document.prototype.$__getArrayPathsToValidate = function() {
      DocumentArray || (DocumentArray = require_DocumentArray());
      return this.$__.activePaths.map("init", "modify", function(i) {
        return this.$__getValue(i);
      }.bind(this)).filter(function(val) {
        return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;
      }).reduce(function(seed, array) {
        return seed.concat(array);
      }, []).filter(function(doc) {
        return doc;
      });
    };
    Document.prototype.$getAllSubdocs = function() {
      DocumentArray || (DocumentArray = require_DocumentArray());
      Embedded = Embedded || require_ArraySubdocument();
      function docReducer(doc, seed, path) {
        let val = doc;
        let isNested = false;
        if (path) {
          if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
            val = doc._doc[path];
          } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {
            val = doc._doc[path];
            isNested = true;
          } else {
            val = doc[path];
          }
        }
        if (val instanceof Embedded) {
          seed.push(val);
        } else if (val instanceof Map) {
          seed = Array.from(val.keys()).reduce(function(seed2, path2) {
            return docReducer(val.get(path2), seed2, null);
          }, seed);
        } else if (val && !Array.isArray(val) && val.$isSingleNested) {
          seed = Object.keys(val._doc).reduce(function(seed2, path2) {
            return docReducer(val, seed2, path2);
          }, seed);
          seed.push(val);
        } else if (val && utils.isMongooseDocumentArray(val)) {
          val.forEach(function _docReduce(doc2) {
            if (!doc2 || !doc2._doc) {
              return;
            }
            seed = Object.keys(doc2._doc).reduce(function(seed2, path2) {
              return docReducer(doc2._doc, seed2, path2);
            }, seed);
            if (doc2 instanceof Embedded) {
              seed.push(doc2);
            }
          });
        } else if (isNested && val != null) {
          for (const path2 of Object.keys(val)) {
            docReducer(val, seed, path2);
          }
        }
        return seed;
      }
      const subDocs = [];
      for (const path of Object.keys(this._doc)) {
        docReducer(this, subDocs, path);
      }
      return subDocs;
    };
    function applyQueue(doc) {
      const q = doc.$__schema && doc.$__schema.callQueue;
      if (!q.length) {
        return;
      }
      for (const pair of q) {
        if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
          doc[pair[0]].apply(doc, pair[1]);
        }
      }
    }
    Document.prototype.$__handleReject = function handleReject(err) {
      if (this.$listeners("error").length) {
        this.$emit("error", err);
      } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
        this.constructor.emit("error", err);
      }
    };
    Document.prototype.$toObject = function(options, json) {
      let defaultOptions = {
        transform: true,
        flattenDecimals: true
      };
      const path = json ? "toJSON" : "toObject";
      const baseOptions = this.constructor && this.constructor.base && this.constructor.base.options && get(this.constructor.base.options, path) || {};
      const schemaOptions = this.$__schema && this.$__schema.options || {};
      defaultOptions = utils.options(defaultOptions, clone(baseOptions));
      defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));
      options = utils.isPOJO(options) ? { ...options } : {};
      options._calledWithOptions = options._calledWithOptions || { ...options };
      let _minimize;
      if (options._calledWithOptions.minimize != null) {
        _minimize = options.minimize;
      } else if (defaultOptions.minimize != null) {
        _minimize = defaultOptions.minimize;
      } else {
        _minimize = schemaOptions.minimize;
      }
      let flattenMaps;
      if (options._calledWithOptions.flattenMaps != null) {
        flattenMaps = options.flattenMaps;
      } else if (defaultOptions.flattenMaps != null) {
        flattenMaps = defaultOptions.flattenMaps;
      } else {
        flattenMaps = schemaOptions.flattenMaps;
      }
      const cloneOptions = Object.assign({}, options, {
        _isNested: true,
        json,
        minimize: _minimize,
        flattenMaps,
        _seen: options && options._seen || /* @__PURE__ */ new Map()
      });
      if (utils.hasUserDefinedProperty(options, "getters")) {
        cloneOptions.getters = options.getters;
      }
      if (utils.hasUserDefinedProperty(options, "virtuals")) {
        cloneOptions.virtuals = options.virtuals;
      }
      const depopulate = options.depopulate || (options._parentOptions && options._parentOptions.depopulate || false);
      if (depopulate && options._isNested && this.$__.wasPopulated) {
        return clone(this.$__.wasPopulated.value || this._id, cloneOptions);
      }
      options = utils.options(defaultOptions, options);
      options._isNested = true;
      options.json = json;
      options.minimize = _minimize;
      cloneOptions._parentOptions = options;
      cloneOptions._skipSingleNestedGetters = false;
      const gettersOptions = Object.assign({}, cloneOptions);
      gettersOptions._skipSingleNestedGetters = true;
      const originalTransform = options.transform;
      let ret = clone(this._doc, cloneOptions) || {};
      if (options.getters) {
        applyGetters(this, ret, gettersOptions);
        if (options.minimize) {
          ret = minimize(ret) || {};
        }
      }
      if (options.virtuals || options.getters && options.virtuals !== false) {
        applyVirtuals(this, ret, gettersOptions, options);
      }
      if (options.versionKey === false && this.$__schema.options.versionKey) {
        delete ret[this.$__schema.options.versionKey];
      }
      let transform = options.transform;
      if (transform) {
        applySchemaTypeTransforms(this, ret);
      }
      if (options.useProjection) {
        omitDeselectedFields(this, ret);
      }
      if (transform === true || schemaOptions.toObject && transform) {
        const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;
        if (opts) {
          transform = typeof options.transform === "function" ? options.transform : opts.transform;
        }
      } else {
        options.transform = originalTransform;
      }
      if (typeof transform === "function") {
        const xformed = transform(this, ret, options);
        if (typeof xformed !== "undefined") {
          ret = xformed;
        }
      }
      return ret;
    };
    Document.prototype.toObject = function(options) {
      return this.$toObject(options);
    };
    function minimize(obj) {
      const keys = Object.keys(obj);
      let i = keys.length;
      let hasKeys;
      let key;
      let val;
      while (i--) {
        key = keys[i];
        val = obj[key];
        if (utils.isPOJO(val)) {
          obj[key] = minimize(val);
        }
        if (void 0 === obj[key]) {
          delete obj[key];
          continue;
        }
        hasKeys = true;
      }
      return hasKeys ? obj : void 0;
    }
    function applyVirtuals(self2, json, options, toObjectOptions) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.virtuals);
      let i = paths.length;
      const numPaths = i;
      let path;
      let assignPath;
      let cur = self2._doc;
      let v;
      const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === "boolean" ? toObjectOptions.aliases : true;
      options = options || {};
      let virtualsToApply = null;
      if (Array.isArray(options.virtuals)) {
        virtualsToApply = new Set(options.virtuals);
      } else if (options.virtuals && options.virtuals.pathsToSkip) {
        virtualsToApply = new Set(paths);
        for (let i2 = 0; i2 < options.virtuals.pathsToSkip.length; i2++) {
          if (virtualsToApply.has(options.virtuals.pathsToSkip[i2])) {
            virtualsToApply.delete(options.virtuals.pathsToSkip[i2]);
          }
        }
      }
      if (!cur) {
        return json;
      }
      for (i = 0; i < numPaths; ++i) {
        path = paths[i];
        if (virtualsToApply != null && !virtualsToApply.has(path)) {
          continue;
        }
        if (!aliases && schema.aliases.hasOwnProperty(path)) {
          continue;
        }
        assignPath = path;
        if (options.path != null) {
          if (!path.startsWith(options.path + ".")) {
            continue;
          }
          assignPath = path.substring(options.path.length + 1);
        }
        const parts = assignPath.split(".");
        v = clone(self2.get(path), options);
        if (v === void 0) {
          continue;
        }
        const plen = parts.length;
        cur = json;
        for (let j = 0; j < plen - 1; ++j) {
          cur[parts[j]] = cur[parts[j]] || {};
          cur = cur[parts[j]];
        }
        cur[parts[plen - 1]] = v;
      }
      return json;
    }
    function applyGetters(self2, json, options) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths);
      let i = paths.length;
      let path;
      let cur = self2._doc;
      let v;
      if (!cur) {
        return json;
      }
      while (i--) {
        path = paths[i];
        const parts = path.split(".");
        const plen = parts.length;
        const last = plen - 1;
        let branch = json;
        let part;
        cur = self2._doc;
        if (!self2.$__isSelected(path)) {
          continue;
        }
        for (let ii = 0; ii < plen; ++ii) {
          part = parts[ii];
          v = cur[part];
          if (branch != null && typeof branch !== "object") {
            break;
          } else if (ii === last) {
            const val = self2.$get(path);
            branch[part] = clone(val, options);
          } else if (v == null) {
            if (part in cur) {
              branch[part] = v;
            }
            break;
          } else {
            branch = branch[part] || (branch[part] = {});
          }
          cur = v;
        }
      }
      return json;
    }
    function applySchemaTypeTransforms(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      for (const path of paths) {
        const schematype = schema.paths[path];
        if (typeof schematype.options.transform === "function") {
          const val = self2.$get(path);
          if (val === void 0) {
            continue;
          }
          const transformedValue = schematype.options.transform.call(self2, val);
          throwErrorIfPromise(path, transformedValue);
          utils.setValue(path, transformedValue, json);
        } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === "function") {
          const val = self2.$get(path);
          if (val === void 0) {
            continue;
          }
          const vals = [].concat(val);
          const transform = schematype.$embeddedSchemaType.options.transform;
          for (let i = 0; i < vals.length; ++i) {
            const transformedValue = transform.call(self2, vals[i]);
            vals[i] = transformedValue;
            throwErrorIfPromise(path, transformedValue);
          }
          json[path] = vals;
        }
      }
      return json;
    }
    function throwErrorIfPromise(path, transformedValue) {
      if (isPromise(transformedValue)) {
        throw new Error("`transform` function must be synchronous, but the transform on path `" + path + "` returned a promise.");
      }
    }
    function omitDeselectedFields(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      let selected = self2.$__.selected;
      if (selected === void 0) {
        selected = {};
        queryhelpers.applyPaths(selected, schema);
      }
      if (selected == null || Object.keys(selected).length === 0) {
        return json;
      }
      for (const path of paths) {
        if (selected[path] != null && !selected[path]) {
          delete json[path];
        }
      }
      return json;
    }
    Document.prototype.toJSON = function(options) {
      return this.$toObject(options, true);
    };
    Document.prototype.ownerDocument = function() {
      return this;
    };
    Document.prototype.parent = function() {
      if (this.$isSubdocument || this.$__.wasPopulated) {
        return this.$__.parent;
      }
      return this;
    };
    Document.prototype.$parent = Document.prototype.parent;
    Document.prototype.inspect = function(options) {
      const isPOJO = utils.isPOJO(options);
      let opts;
      if (isPOJO) {
        opts = options;
        opts.minimize = false;
      }
      const ret = this.toObject(opts);
      if (ret == null) {
        return "MongooseDocument { " + ret + " }";
      }
      return ret;
    };
    if (inspect.custom) {
      Document.prototype[inspect.custom] = Document.prototype.inspect;
    }
    Document.prototype.toString = function() {
      const ret = this.inspect();
      if (typeof ret === "string") {
        return ret;
      }
      return inspect(ret);
    };
    Document.prototype.equals = function(doc) {
      if (!doc) {
        return false;
      }
      const tid = this.$__getValue("_id");
      const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
      if (!tid && !docid) {
        return deepEqual(this, doc);
      }
      return tid && tid.equals ? tid.equals(docid) : tid === docid;
    };
    Document.prototype.populate = function populate() {
      const pop = {};
      const args = [...arguments];
      let fn;
      if (args.length !== 0) {
        if (typeof args[args.length - 1] === "function") {
          fn = args.pop();
        }
        const res = utils.populate.apply(null, args);
        for (const populateOptions of res) {
          pop[populateOptions.path] = populateOptions;
        }
      }
      const paths = utils.object.vals(pop);
      let topLevelModel = this.constructor;
      if (this.$__isNested) {
        topLevelModel = this.$__[scopeSymbol].constructor;
        const nestedPath = this.$__.nestedPath;
        paths.forEach(function(populateOptions) {
          populateOptions.path = nestedPath + "." + populateOptions.path;
        });
      }
      if (this.$session() != null) {
        const session = this.$session();
        paths.forEach((path) => {
          if (path.options == null) {
            path.options = { session };
            return;
          }
          if (!("session" in path.options)) {
            path.options.session = session;
          }
        });
      }
      paths.forEach((p) => {
        p._localModel = topLevelModel;
      });
      return topLevelModel.populate(this, paths, fn);
    };
    Document.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
      let keys = [];
      if (this.$__.populated != null) {
        keys = keys.concat(Object.keys(this.$__.populated));
      }
      let result = [];
      for (const key of keys) {
        const value = this.$get(key);
        if (Array.isArray(value)) {
          result = result.concat(value);
        } else if (value instanceof Document) {
          result.push(value);
        }
      }
      return result;
    };
    Document.prototype.populated = function(path, val, options) {
      if (val == null || val === true) {
        if (!this.$__.populated) {
          return void 0;
        }
        if (typeof path !== "string") {
          return void 0;
        }
        const _path = path.endsWith(".$*") ? path.replace(/\.\$\*$/, "") : path;
        const v = this.$__.populated[_path];
        if (v) {
          return val === true ? v : v.value;
        }
        return void 0;
      }
      this.$__.populated || (this.$__.populated = {});
      this.$__.populated[path] = { value: val, options };
      const pieces = path.split(".");
      for (let i = 0; i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const subdoc = this.$get(subpath);
        if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {
          const rest = pieces.slice(i + 1).join(".");
          subdoc.$populated(rest, val, options);
          break;
        }
      }
      return val;
    };
    Document.prototype.$populated = Document.prototype.populated;
    Document.prototype.$assertPopulated = function $assertPopulated(path, values) {
      if (Array.isArray(path)) {
        path.forEach((p) => this.$assertPopulated(p, values));
        return this;
      }
      if (arguments.length > 1) {
        this.$set(values);
      }
      if (!this.$populated(path)) {
        throw new MongooseError(`Expected path "${path}" to be populated`);
      }
      return this;
    };
    Document.prototype.depopulate = function(path) {
      if (typeof path === "string") {
        path = path.indexOf(" ") === -1 ? [path] : path.split(" ");
      }
      let populatedIds;
      const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
      const populated = this.$__ && this.$__.populated || {};
      if (arguments.length === 0) {
        for (const virtualKey of virtualKeys) {
          delete this.$$populatedVirtuals[virtualKey];
          delete this._doc[virtualKey];
          delete populated[virtualKey];
        }
        const keys = Object.keys(populated);
        for (const key of keys) {
          populatedIds = this.$populated(key);
          if (!populatedIds) {
            continue;
          }
          delete populated[key];
          utils.setValue(key, populatedIds, this._doc);
        }
        return this;
      }
      for (const singlePath of path) {
        populatedIds = this.$populated(singlePath);
        delete populated[singlePath];
        if (virtualKeys.indexOf(singlePath) !== -1) {
          delete this.$$populatedVirtuals[singlePath];
          delete this._doc[singlePath];
        } else if (populatedIds) {
          utils.setValue(singlePath, populatedIds, this._doc);
        }
      }
      return this;
    };
    Document.prototype.$__fullPath = function(path) {
      return path || "";
    };
    Document.prototype.getChanges = function() {
      const delta = this.$__delta();
      const changes = delta ? delta[1] : {};
      return changes;
    };
    Document.prototype.$clone = function() {
      const Model = this.constructor;
      const clonedDoc = new Model();
      clonedDoc.$isNew = this.$isNew;
      if (this._doc) {
        clonedDoc._doc = clone(this._doc);
      }
      if (this.$__) {
        const Cache = this.$__.constructor;
        const clonedCache = new Cache();
        for (const key of Object.getOwnPropertyNames(this.$__)) {
          if (key === "activePaths") {
            continue;
          }
          clonedCache[key] = clone(this.$__[key]);
        }
        Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));
        clonedDoc.$__ = clonedCache;
      }
      return clonedDoc;
    };
    Document.ValidationError = ValidationError2;
    module2.exports = exports2 = Document;
  }
});

// asset-input/node_modules/mongoose/lib/utils.js
var require_utils6 = __commonJS({
  "asset-input/node_modules/mongoose/lib/utils.js"(exports2) {
    "use strict";
    var UUID = require_bson().UUID;
    var ms = require_ms();
    var mpath = require_mpath();
    var ObjectId2 = require_objectid3();
    var PopulateOptions = require_PopulateOptions();
    var clone = require_clone();
    var immediate = require_immediate();
    var isObject = require_isObject();
    var isMongooseArray = require_isMongooseArray();
    var isMongooseDocumentArray = require_isMongooseDocumentArray();
    var isBsonType = require_isBsonType();
    var getFunctionName = require_getFunctionName();
    var isMongooseObject = require_isMongooseObject();
    var promiseOrCallback = require_promiseOrCallback();
    var schemaMerge = require_merge();
    var specialProperties = require_specialProperties();
    var { trustedSymbol } = require_trusted();
    var Document;
    exports2.specialProperties = specialProperties;
    exports2.isMongooseArray = isMongooseArray.isMongooseArray;
    exports2.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;
    exports2.registerMongooseArray = isMongooseArray.registerMongooseArray;
    exports2.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;
    exports2.toCollectionName = function(name, pluralize) {
      if (name === "system.profile") {
        return name;
      }
      if (name === "system.indexes") {
        return name;
      }
      if (typeof pluralize === "function") {
        return pluralize(name);
      }
      return name;
    };
    exports2.deepEqual = function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== "object" || typeof b !== "object") {
        return a === b;
      }
      if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      }
      if (isBsonType(a, "ObjectID") && isBsonType(b, "ObjectID") || isBsonType(a, "Decimal128") && isBsonType(b, "Decimal128")) {
        return a.toString() === b.toString();
      }
      if (a instanceof RegExp && b instanceof RegExp) {
        return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global && a.dotAll === b.dotAll && a.unicode === b.unicode && a.sticky === b.sticky && a.hasIndices === b.hasIndices;
      }
      if (a == null || b == null) {
        return false;
      }
      if (a.prototype !== b.prototype) {
        return false;
      }
      if (a instanceof Map || b instanceof Map) {
        if (!(a instanceof Map) || !(b instanceof Map)) {
          return false;
        }
        return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
      }
      if (a instanceof Number && b instanceof Number) {
        return a.valueOf() === b.valueOf();
      }
      if (Buffer.isBuffer(a)) {
        return exports2.buffer.areEqual(a, b);
      }
      if (Array.isArray(a) || Array.isArray(b)) {
        if (!Array.isArray(a) || !Array.isArray(b)) {
          return false;
        }
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        for (let i = 0; i < len; ++i) {
          if (!deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a.$__ != null) {
        a = a._doc;
      } else if (isMongooseObject(a)) {
        a = a.toObject();
      }
      if (b.$__ != null) {
        b = b._doc;
      } else if (isMongooseObject(b)) {
        b = b.toObject();
      }
      const ka = Object.keys(a);
      const kb = Object.keys(b);
      const kaLength = ka.length;
      if (kaLength !== kb.length) {
        return false;
      }
      for (let i = kaLength - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) {
          return false;
        }
      }
      for (const key of ka) {
        if (!deepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    };
    exports2.last = function(arr) {
      if (arr.length > 0) {
        return arr[arr.length - 1];
      }
      return void 0;
    };
    exports2.clone = clone;
    exports2.promiseOrCallback = promiseOrCallback;
    exports2.cloneArrays = function cloneArrays(arr) {
      if (!Array.isArray(arr)) {
        return arr;
      }
      return arr.map((el) => exports2.cloneArrays(el));
    };
    exports2.omit = function omit(obj, keys) {
      if (keys == null) {
        return Object.assign({}, obj);
      }
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      const ret = Object.assign({}, obj);
      for (const key of keys) {
        delete ret[key];
      }
      return ret;
    };
    exports2.options = function(defaults2, options) {
      const keys = Object.keys(defaults2);
      let i = keys.length;
      let k;
      options = options || {};
      while (i--) {
        k = keys[i];
        if (!(k in options)) {
          options[k] = defaults2[k];
        }
      }
      return options;
    };
    exports2.merge = function merge(to, from, options, path) {
      options = options || {};
      const keys = Object.keys(from);
      let i = 0;
      const len = keys.length;
      let key;
      if (from[trustedSymbol]) {
        to[trustedSymbol] = from[trustedSymbol];
      }
      path = path || "";
      const omitNested = options.omitNested || {};
      while (i < len) {
        key = keys[i++];
        if (options.omit && options.omit[key]) {
          continue;
        }
        if (omitNested[path]) {
          continue;
        }
        if (specialProperties.has(key)) {
          continue;
        }
        if (to[key] == null) {
          to[key] = from[key];
        } else if (exports2.isObject(from[key])) {
          if (!exports2.isObject(to[key])) {
            to[key] = {};
          }
          if (from[key] != null) {
            if (options.isDiscriminatorSchemaMerge && (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
              continue;
            } else if (from[key].instanceOfSchema) {
              if (to[key].instanceOfSchema) {
                schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);
              } else {
                to[key] = from[key].clone();
              }
              continue;
            } else if (isBsonType(from[key], "ObjectID")) {
              to[key] = new ObjectId2(from[key]);
              continue;
            }
          }
          merge(to[key], from[key], options, path ? path + "." + key : key);
        } else if (options.overwrite) {
          to[key] = from[key];
        }
      }
    };
    exports2.toObject = function toObject(obj) {
      Document || (Document = require_document());
      let ret;
      if (obj == null) {
        return obj;
      }
      if (obj instanceof Document) {
        return obj.toObject();
      }
      if (Array.isArray(obj)) {
        ret = [];
        for (const doc of obj) {
          ret.push(toObject(doc));
        }
        return ret;
      }
      if (exports2.isPOJO(obj)) {
        ret = {};
        if (obj[trustedSymbol]) {
          ret[trustedSymbol] = obj[trustedSymbol];
        }
        for (const k of Object.keys(obj)) {
          if (specialProperties.has(k)) {
            continue;
          }
          ret[k] = toObject(obj[k]);
        }
        return ret;
      }
      return obj;
    };
    exports2.isObject = isObject;
    exports2.isPOJO = function isPOJO(arg) {
      if (arg == null || typeof arg !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(arg);
      return !proto || proto.constructor.name === "Object";
    };
    exports2.isNonBuiltinObject = function isNonBuiltinObject(val) {
      return typeof val === "object" && !exports2.isNativeObject(val) && !exports2.isMongooseType(val) && !(val instanceof UUID) && val != null;
    };
    exports2.isNativeObject = function(arg) {
      return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
    };
    exports2.isEmptyObject = function(val) {
      return val != null && typeof val === "object" && Object.keys(val).length === 0;
    };
    exports2.hasKey = function hasKey(obj, key) {
      const props = Object.keys(obj);
      for (const prop of props) {
        if (prop === key) {
          return true;
        }
        if (exports2.isPOJO(obj[prop]) && exports2.hasKey(obj[prop], key)) {
          return true;
        }
      }
      return false;
    };
    exports2.tick = function tick(callback) {
      if (typeof callback !== "function") {
        return;
      }
      return function() {
        try {
          callback.apply(this, arguments);
        } catch (err) {
          immediate(function() {
            throw err;
          });
        }
      };
    };
    exports2.isMongooseType = function(v) {
      return isBsonType(v, "ObjectID") || isBsonType(v, "Decimal128") || v instanceof Buffer;
    };
    exports2.isMongooseObject = isMongooseObject;
    exports2.expires = function expires(object) {
      if (!(object && object.constructor.name === "Object")) {
        return;
      }
      if (!("expires" in object)) {
        return;
      }
      object.expireAfterSeconds = typeof object.expires !== "string" ? object.expires : Math.round(ms(object.expires) / 1e3);
      delete object.expires;
    };
    exports2.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {
      let obj = null;
      if (arguments.length === 1) {
        if (path instanceof PopulateOptions) {
          path._docs = [];
          path._childDocs = [];
          return [path];
        }
        if (Array.isArray(path)) {
          const singles = makeSingles(path);
          return singles.map((o) => exports2.populate(o)[0]);
        }
        if (exports2.isObject(path)) {
          obj = Object.assign({}, path);
        } else {
          obj = { path };
        }
      } else if (typeof model === "object") {
        obj = {
          path,
          select,
          match: model,
          options: match
        };
      } else {
        obj = {
          path,
          select,
          model,
          match,
          options,
          populate: subPopulate,
          justOne,
          count
        };
      }
      if (typeof obj.path !== "string") {
        throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + typeof path + "`");
      }
      return _populateObj(obj);
      function makeSingles(arr) {
        const ret = [];
        arr.forEach(function(obj2) {
          if (/[\s]/.test(obj2.path)) {
            const paths = obj2.path.split(" ");
            paths.forEach(function(p) {
              const copy = Object.assign({}, obj2);
              copy.path = p;
              ret.push(copy);
            });
          } else {
            ret.push(obj2);
          }
        });
        return ret;
      }
    };
    function _populateObj(obj) {
      if (Array.isArray(obj.populate)) {
        const ret2 = [];
        obj.populate.forEach(function(obj2) {
          if (/[\s]/.test(obj2.path)) {
            const copy = Object.assign({}, obj2);
            const paths2 = copy.path.split(" ");
            paths2.forEach(function(p) {
              copy.path = p;
              ret2.push(exports2.populate(copy)[0]);
            });
          } else {
            ret2.push(exports2.populate(obj2)[0]);
          }
        });
        obj.populate = exports2.populate(ret2);
      } else if (obj.populate != null && typeof obj.populate === "object") {
        obj.populate = exports2.populate(obj.populate);
      }
      const ret = [];
      const paths = obj.path.split(" ");
      if (obj.options != null) {
        obj.options = exports2.clone(obj.options);
      }
      for (const path of paths) {
        ret.push(new PopulateOptions(Object.assign({}, obj, { path })));
      }
      return ret;
    }
    exports2.getValue = function(path, obj, map) {
      return mpath.get(path, obj, "_doc", map);
    };
    exports2.setValue = function(path, val, obj, map, _copying) {
      mpath.set(path, val, obj, "_doc", map, _copying);
    };
    exports2.object = {};
    exports2.object.vals = function vals(o) {
      const keys = Object.keys(o);
      let i = keys.length;
      const ret = [];
      while (i--) {
        ret.push(o[keys[i]]);
      }
      return ret;
    };
    exports2.object.shallowCopy = exports2.options;
    var hop = Object.prototype.hasOwnProperty;
    exports2.object.hasOwnProperty = function(obj, prop) {
      return hop.call(obj, prop);
    };
    exports2.isNullOrUndefined = function(val) {
      return val === null || val === void 0;
    };
    exports2.array = {};
    exports2.array.flatten = function flatten(arr, filter, ret) {
      ret || (ret = []);
      arr.forEach(function(item) {
        if (Array.isArray(item)) {
          flatten(item, filter, ret);
        } else {
          if (!filter || filter(item)) {
            ret.push(item);
          }
        }
      });
      return ret;
    };
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    exports2.hasUserDefinedProperty = function(obj, key) {
      if (obj == null) {
        return false;
      }
      if (Array.isArray(key)) {
        for (const k of key) {
          if (exports2.hasUserDefinedProperty(obj, k)) {
            return true;
          }
        }
        return false;
      }
      if (_hasOwnProperty.call(obj, key)) {
        return true;
      }
      if (typeof obj === "object" && key in obj) {
        const v = obj[key];
        return v !== Object.prototype[key] && v !== Array.prototype[key];
      }
      return false;
    };
    var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
    exports2.isArrayIndex = function(val) {
      if (typeof val === "number") {
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      if (typeof val === "string") {
        if (!/^\d+$/.test(val)) {
          return false;
        }
        val = +val;
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      return false;
    };
    exports2.array.unique = function(arr) {
      const primitives = /* @__PURE__ */ new Set();
      const ids = /* @__PURE__ */ new Set();
      const ret = [];
      for (const item of arr) {
        if (typeof item === "number" || typeof item === "string" || item == null) {
          if (primitives.has(item)) {
            continue;
          }
          ret.push(item);
          primitives.add(item);
        } else if (isBsonType(item, "ObjectID")) {
          if (ids.has(item.toString())) {
            continue;
          }
          ret.push(item);
          ids.add(item.toString());
        } else {
          ret.push(item);
        }
      }
      return ret;
    };
    exports2.buffer = {};
    exports2.buffer.areEqual = function(a, b) {
      if (!Buffer.isBuffer(a)) {
        return false;
      }
      if (!Buffer.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, len = a.length; i < len; ++i) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    exports2.getFunctionName = getFunctionName;
    exports2.decorate = function(destination, source) {
      for (const key in source) {
        if (specialProperties.has(key)) {
          continue;
        }
        destination[key] = source[key];
      }
    };
    exports2.mergeClone = function(to, fromObj) {
      if (isMongooseObject(fromObj)) {
        fromObj = fromObj.toObject({
          transform: false,
          virtuals: false,
          depopulate: true,
          getters: false,
          flattenDecimals: false
        });
      }
      const keys = Object.keys(fromObj);
      const len = keys.length;
      let i = 0;
      let key;
      while (i < len) {
        key = keys[i++];
        if (specialProperties.has(key)) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = exports2.clone(fromObj[key], {
            transform: false,
            virtuals: false,
            depopulate: true,
            getters: false,
            flattenDecimals: false
          });
        } else {
          let val = fromObj[key];
          if (val != null && val.valueOf && !(val instanceof Date)) {
            val = val.valueOf();
          }
          if (exports2.isObject(val)) {
            let obj = val;
            if (isMongooseObject(val) && !val.isMongooseBuffer) {
              obj = obj.toObject({
                transform: false,
                virtuals: false,
                depopulate: true,
                getters: false,
                flattenDecimals: false
              });
            }
            if (val.isMongooseBuffer) {
              obj = Buffer.from(obj);
            }
            exports2.mergeClone(to[key], obj);
          } else {
            to[key] = exports2.clone(val, {
              flattenDecimals: false
            });
          }
        }
      }
    };
    exports2.each = function(arr, fn) {
      for (const item of arr) {
        fn(item);
      }
    };
    exports2.getOption = function(name) {
      const sources = Array.prototype.slice.call(arguments, 1);
      for (const source of sources) {
        if (source == null) {
          continue;
        }
        if (source[name] != null) {
          return source[name];
        }
      }
      return null;
    };
    exports2.noop = function() {
    };
    exports2.errorToPOJO = function errorToPOJO(error) {
      const isError = error instanceof Error;
      if (!isError) {
        throw new Error("`error` must be `instanceof Error`.");
      }
      const ret = {};
      for (const properyName of Object.getOwnPropertyNames(error)) {
        ret[properyName] = error[properyName];
      }
      return ret;
    };
    exports2.warn = function warn(message) {
      return process.emitWarning(message, { code: "MONGOOSE" });
    };
    exports2.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {
      if (timestampsOption == null) {
        return;
      }
      writeOperation.timestamps = timestampsOption;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/clone.js
var require_clone = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/clone.js"(exports2, module2) {
    "use strict";
    var Decimal = require_decimal1282();
    var ObjectId2 = require_objectid3();
    var specialProperties = require_specialProperties();
    var isMongooseObject = require_isMongooseObject();
    var getFunctionName = require_getFunctionName();
    var isBsonType = require_isBsonType();
    var isObject = require_isObject();
    var symbols = require_symbols();
    var trustedSymbol = require_trusted().trustedSymbol;
    var utils = require_utils6();
    function clone(obj, options, isArrayChild) {
      if (obj == null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return cloneArray(utils.isMongooseArray(obj) ? obj.__array : obj, options);
      }
      if (isMongooseObject(obj)) {
        if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {
          options = Object.assign({}, options, { getters: false });
        }
        const isSingleNested = obj.$isSingleNested;
        if (utils.isPOJO(obj) && obj.$__ != null && obj._doc != null) {
          return obj._doc;
        }
        let ret;
        if (options && options.json && typeof obj.toJSON === "function") {
          ret = obj.toJSON(options);
        } else {
          ret = obj.toObject(options);
        }
        if (options && options.minimize && isSingleNested && Object.keys(ret).length === 0) {
          return void 0;
        }
        return ret;
      }
      const objConstructor = obj.constructor;
      if (objConstructor) {
        switch (getFunctionName(objConstructor)) {
          case "Object":
            return cloneObject(obj, options, isArrayChild);
          case "Date":
            return new objConstructor(+obj);
          case "RegExp":
            return cloneRegExp(obj);
          default:
            break;
        }
      }
      if (isBsonType(obj, "ObjectID")) {
        return new ObjectId2(obj.id);
      }
      if (isBsonType(obj, "Decimal128")) {
        if (options && options.flattenDecimals) {
          return obj.toJSON();
        }
        return Decimal.fromString(obj.toString());
      }
      if (!objConstructor && isObject(obj)) {
        return cloneObject(obj, options, isArrayChild);
      }
      if (typeof obj === "object" && obj[symbols.schemaTypeSymbol]) {
        return obj.clone();
      }
      if (options && options.bson && typeof obj.toBSON === "function") {
        return obj;
      }
      if (typeof obj.valueOf === "function") {
        return obj.valueOf();
      }
      return cloneObject(obj, options, isArrayChild);
    }
    module2.exports = clone;
    function cloneObject(obj, options, isArrayChild) {
      const minimize = options && options.minimize;
      const omitUndefined = options && options.omitUndefined;
      const seen = options && options._seen;
      const ret = {};
      let hasKeys;
      if (seen && seen.has(obj)) {
        return seen.get(obj);
      } else if (seen) {
        seen.set(obj, ret);
      }
      if (trustedSymbol in obj) {
        ret[trustedSymbol] = obj[trustedSymbol];
      }
      let i = 0;
      let key = "";
      const keys = Object.keys(obj);
      const len = keys.length;
      for (i = 0; i < len; ++i) {
        if (specialProperties.has(key = keys[i])) {
          continue;
        }
        const val = clone(obj[key], options, false);
        if ((minimize === false || omitUndefined) && typeof val === "undefined") {
          delete ret[key];
        } else if (minimize !== true || typeof val !== "undefined") {
          hasKeys || (hasKeys = true);
          ret[key] = val;
        }
      }
      return minimize && !isArrayChild ? hasKeys && ret : ret;
    }
    function cloneArray(arr, options) {
      let i = 0;
      const len = arr.length;
      const ret = new Array(len);
      for (i = 0; i < len; ++i) {
        ret[i] = clone(arr[i], options, true);
      }
      return ret;
    }
    function cloneRegExp(regexp) {
      const ret = new RegExp(regexp.source, regexp.flags);
      if (ret.lastIndex !== regexp.lastIndex) {
        ret.lastIndex = regexp.lastIndex;
      }
      return ret;
    }
  }
});

// asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js
var require_collection5 = __commonJS({
  "asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js"(exports2, module2) {
    "use strict";
    var MongooseCollection = require_collection2();
    var MongooseError = require_mongooseError();
    var Collection = require_lib3().Collection;
    var ObjectId2 = require_objectid2();
    var getConstructorName = require_getConstructorName();
    var stream = require("stream");
    var util2 = require("util");
    function NativeCollection(name, conn, options) {
      this.collection = null;
      this.Promise = options.Promise || Promise;
      this.modelName = options.modelName;
      delete options.modelName;
      this._closed = false;
      MongooseCollection.apply(this, arguments);
    }
    Object.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);
    NativeCollection.prototype.onOpen = function() {
      this.collection = this.conn.db.collection(this.name);
      MongooseCollection.prototype.onOpen.call(this);
      return this.collection;
    };
    NativeCollection.prototype.onClose = function(force) {
      MongooseCollection.prototype.onClose.call(this, force);
    };
    NativeCollection.prototype._getCollection = function _getCollection() {
      if (this.collection) {
        return this.collection;
      }
      if (this.conn.db != null) {
        this.collection = this.conn.db.collection(this.name);
        return this.collection;
      }
      return null;
    };
    var syncCollectionMethods = { watch: true, find: true, aggregate: true };
    function iter(i) {
      NativeCollection.prototype[i] = function() {
        const collection = this._getCollection();
        const args = Array.from(arguments);
        const _this = this;
        const globalDebug = _this && _this.conn && _this.conn.base && _this.conn.base.options && _this.conn.base.options.debug;
        const connectionDebug = _this && _this.conn && _this.conn.options && _this.conn.options.debug;
        const debug = connectionDebug == null ? globalDebug : connectionDebug;
        const lastArg = arguments[arguments.length - 1];
        const opId = new ObjectId2();
        if (this.conn.$wasForceClosed) {
          const error = new MongooseError("Connection was force closed");
          if (args.length > 0 && typeof args[args.length - 1] === "function") {
            args[args.length - 1](error);
            return;
          } else {
            throw error;
          }
        }
        let _args = args;
        let callback = null;
        if (this._shouldBufferCommands() && this.buffer) {
          if (syncCollectionMethods[i] && typeof lastArg !== "function") {
            throw new Error("Collection method " + i + " is synchronous");
          }
          this.conn.emit("buffer", {
            _id: opId,
            modelName: _this.modelName,
            collectionName: _this.name,
            method: i,
            args
          });
          let callback2;
          let _args2 = args;
          let promise = null;
          let timeout = null;
          if (syncCollectionMethods[i] && typeof lastArg === "function") {
            this.addQueue(i, _args2);
            callback2 = lastArg;
          } else if (syncCollectionMethods[i]) {
            promise = new this.Promise((resolve, reject) => {
              callback2 = function collectionOperationCallback(err, res) {
                if (timeout != null) {
                  clearTimeout(timeout);
                }
                if (err != null) {
                  return reject(err);
                }
                resolve(res);
              };
              _args2 = args.concat([callback2]);
              this.addQueue(i, _args2);
            });
          } else if (typeof lastArg === "function") {
            callback2 = function collectionOperationCallback() {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              return lastArg.apply(this, arguments);
            };
            _args2 = args.slice(0, args.length - 1).concat([callback2]);
          } else {
            promise = new this.Promise((resolve, reject) => {
              callback2 = function collectionOperationCallback(err, res) {
                if (timeout != null) {
                  clearTimeout(timeout);
                }
                if (err != null) {
                  return reject(err);
                }
                resolve(res);
              };
              _args2 = args.concat([callback2]);
              this.addQueue(i, _args2);
            });
          }
          const bufferTimeoutMS = this._getBufferTimeoutMS();
          timeout = setTimeout(() => {
            const removed = this.removeQueue(i, _args2);
            if (removed) {
              const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
              const err = new MongooseError(message);
              this.conn.emit("buffer-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
              callback2(err);
            }
          }, bufferTimeoutMS);
          if (!syncCollectionMethods[i] && typeof lastArg === "function") {
            this.addQueue(i, _args2);
            return;
          }
          return promise;
        } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
          callback = function collectionOperationCallback(err, res) {
            if (err != null) {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
            } else {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });
            }
            return lastArg.apply(this, arguments);
          };
          _args = args.slice(0, args.length - 1).concat([callback]);
        }
        if (debug) {
          if (typeof debug === "function") {
            let argsToAdd = null;
            if (typeof args[args.length - 1] == "function") {
              argsToAdd = args.slice(0, args.length - 1);
            } else {
              argsToAdd = args;
            }
            debug.apply(
              _this,
              [_this.name, i].concat(argsToAdd)
            );
          } else if (debug instanceof stream.Writable) {
            this.$printToStream(_this.name, i, args, debug);
          } else {
            const color = debug.color == null ? true : debug.color;
            const shell = debug.shell == null ? false : debug.shell;
            this.$print(_this.name, i, args, color, shell);
          }
        }
        this.conn.emit("operation-start", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });
        try {
          if (collection == null) {
            const message = "Cannot call `" + this.name + "." + i + "()` before initial connection is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if you have `bufferCommands = false`.";
            throw new MongooseError(message);
          }
          if (syncCollectionMethods[i] && typeof lastArg === "function") {
            return lastArg.call(this, null, collection[i].apply(collection, _args.slice(0, _args.length - 1)));
          }
          const ret = collection[i].apply(collection, _args);
          if (ret != null && typeof ret.then === "function") {
            return ret.then(
              (res) => {
                this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, result: res });
                return res;
              },
              (err) => {
                this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, error: err });
                throw err;
              }
            );
          }
          return ret;
        } catch (error) {
          if (typeof lastArg === "function") {
            return lastArg(error);
          } else {
            this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
            throw error;
          }
        }
      };
    }
    for (const key of Object.getOwnPropertyNames(Collection.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
      if (descriptor.get !== void 0) {
        continue;
      }
      if (typeof Collection.prototype[key] !== "function") {
        continue;
      }
      iter(key);
    }
    NativeCollection.prototype.$print = function(name, i, args, color, shell) {
      const moduleName = color ? "\x1B[0;36mMongoose:\x1B[0m " : "Mongoose: ";
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j], color, shell));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      console.info(moduleName + functionCall + params);
    };
    NativeCollection.prototype.$printToStream = function(name, i, args, stream2) {
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j]));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      stream2.write(functionCall + params, "utf8");
    };
    NativeCollection.prototype.$format = function(arg, color, shell) {
      const type = typeof arg;
      if (type === "function" || type === "undefined") return "";
      return format(arg, false, color, shell);
    };
    function inspectable(representation) {
      const ret = {
        inspect: function() {
          return representation;
        }
      };
      if (util2.inspect.custom) {
        ret[util2.inspect.custom] = ret.inspect;
      }
      return ret;
    }
    function map(o) {
      return format(o, true);
    }
    function formatObjectId(x, key) {
      x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
    }
    function formatDate(x, key, shell) {
      if (shell) {
        x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
      } else {
        x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
      }
    }
    function format(obj, sub, color, shell) {
      if (obj && typeof obj.toBSON === "function") {
        obj = obj.toBSON();
      }
      if (obj == null) {
        return obj;
      }
      const clone = require_clone();
      let x = clone(obj, { transform: false });
      const constructorName = getConstructorName(x);
      if (constructorName === "Binary") {
        x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
      } else if (constructorName === "ObjectID") {
        x = inspectable('ObjectId("' + x.toHexString() + '")');
      } else if (constructorName === "Date") {
        x = inspectable('new Date("' + x.toUTCString() + '")');
      } else if (constructorName === "Object") {
        const keys = Object.keys(x);
        const numKeys = keys.length;
        let key;
        for (let i = 0; i < numKeys; ++i) {
          key = keys[i];
          if (x[key]) {
            let error;
            if (typeof x[key].toBSON === "function") {
              try {
                x[key] = x[key].toBSON();
              } catch (_error) {
                error = _error;
              }
            }
            const _constructorName = getConstructorName(x[key]);
            if (_constructorName === "Binary") {
              x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
            } else if (_constructorName === "Object") {
              x[key] = format(x[key], true);
            } else if (_constructorName === "ObjectID") {
              formatObjectId(x, key);
            } else if (_constructorName === "Date") {
              formatDate(x, key, shell);
            } else if (_constructorName === "ClientSession") {
              x[key] = inspectable('ClientSession("' + (x[key] && x[key].id && x[key].id.id && x[key].id.id.buffer || "").toString("hex") + '")');
            } else if (Array.isArray(x[key])) {
              x[key] = x[key].map(map);
            } else if (error != null) {
              throw error;
            }
          }
        }
      }
      if (sub) {
        return x;
      }
      return util2.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
    }
    NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
    module2.exports = NativeCollection;
  }
});

// asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js
var require_decimal1285 = __commonJS({
  "asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js"(exports2, module2) {
    "use strict";
    module2.exports = require_lib3().Decimal128;
  }
});

// asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js
var require_ReadPreference = __commonJS({
  "asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js"(exports2, module2) {
    "use strict";
    var mongodb = require_lib3();
    var ReadPref = mongodb.ReadPreference;
    module2.exports = function readPref(pref, tags) {
      if (Array.isArray(pref)) {
        tags = pref[1];
        pref = pref[0];
      }
      if (pref instanceof ReadPref) {
        return pref;
      }
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return new ReadPref(pref, tags);
    };
  }
});

// asset-input/node_modules/mongoose/lib/cursor/ChangeStream.js
var require_ChangeStream = __commonJS({
  "asset-input/node_modules/mongoose/lib/cursor/ChangeStream.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var ChangeStream = class extends EventEmitter {
      constructor(changeStreamThunk, pipeline2, options) {
        super();
        this.driverChangeStream = null;
        this.closed = false;
        this.bindedEvents = false;
        this.pipeline = pipeline2;
        this.options = options;
        if (options && options.hydrate && !options.model) {
          throw new Error(
            "Cannot create change stream with `hydrate: true` unless calling `Model.watch()`"
          );
        }
        changeStreamThunk((err, driverChangeStream) => {
          if (err != null) {
            this.emit("error", err);
            return;
          }
          this.driverChangeStream = driverChangeStream;
          this.emit("ready");
        });
      }
      _bindEvents() {
        if (this.bindedEvents) {
          return;
        }
        this.bindedEvents = true;
        if (this.driverChangeStream == null) {
          this.once("ready", () => {
            this.driverChangeStream.on("close", () => {
              this.closed = true;
            });
            ["close", "change", "end", "error"].forEach((ev) => {
              this.driverChangeStream.on(ev, (data) => {
                if (ev === "error" && this.closed) {
                  return;
                }
                if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
                  data.fullDocument = this.options.model.hydrate(data.fullDocument);
                }
                this.emit(ev, data);
              });
            });
          });
          return;
        }
        this.driverChangeStream.on("close", () => {
          this.closed = true;
        });
        ["close", "change", "end", "error", "resumeTokenChanged"].forEach((ev) => {
          this.driverChangeStream.on(ev, (data) => {
            if (ev === "error" && this.closed) {
              return;
            }
            if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
            }
            this.emit(ev, data);
          });
        });
      }
      hasNext(cb) {
        return this.driverChangeStream.hasNext(cb);
      }
      next(cb) {
        if (this.options && this.options.hydrate) {
          if (cb != null) {
            const originalCb = cb;
            cb = (err, data) => {
              if (err != null) {
                return originalCb(err);
              }
              if (data.fullDocument != null) {
                data.fullDocument = this.options.model.hydrate(data.fullDocument);
              }
              return originalCb(null, data);
            };
          }
          let maybePromise = this.driverChangeStream.next(cb);
          if (maybePromise && typeof maybePromise.then === "function") {
            maybePromise = maybePromise.then((data) => {
              if (data.fullDocument != null) {
                data.fullDocument = this.options.model.hydrate(data.fullDocument);
              }
              return data;
            });
          }
          return maybePromise;
        }
        return this.driverChangeStream.next(cb);
      }
      on(event, handler2) {
        this._bindEvents();
        return super.on(event, handler2);
      }
      once(event, handler2) {
        this._bindEvents();
        return super.once(event, handler2);
      }
      _queue(cb) {
        this.once("ready", () => cb());
      }
      close() {
        this.closed = true;
        if (this.driverChangeStream) {
          this.driverChangeStream.close();
        }
      }
    };
    module2.exports = ChangeStream;
  }
});

// asset-input/node_modules/mongoose/lib/error/disconnected.js
var require_disconnected = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/disconnected.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var DisconnectedError = class extends MongooseError {
      /**
       * @param {String} connectionString
       */
      constructor(id, fnName) {
        super("Connection " + id + " was disconnected when calling `" + fnName + "()`");
      }
    };
    Object.defineProperty(DisconnectedError.prototype, "name", {
      value: "DisconnectedError"
    });
    module2.exports = DisconnectedError;
  }
});

// asset-input/node_modules/mongoose/lib/error/syncIndexes.js
var require_syncIndexes = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/syncIndexes.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var SyncIndexesError = class extends MongooseError {
      constructor(message, errorsMap) {
        super(message);
        this.errors = errorsMap;
      }
    };
    Object.defineProperty(SyncIndexesError.prototype, "name", {
      value: "SyncIndexesError"
    });
    module2.exports = SyncIndexesError;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/applyPlugins.js
var require_applyPlugins = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/applyPlugins.js"(exports2, module2) {
    "use strict";
    module2.exports = function applyPlugins(schema, plugins, options, cacheKey) {
      if (schema[cacheKey]) {
        return;
      }
      schema[cacheKey] = true;
      if (!options || !options.skipTopLevel) {
        let pluginTags = null;
        for (const plugin of plugins) {
          const tags = plugin[1] == null ? null : plugin[1].tags;
          if (!Array.isArray(tags)) {
            schema.plugin(plugin[0], plugin[1]);
            continue;
          }
          pluginTags = pluginTags || new Set(schema.options.pluginTags || []);
          if (!tags.find((tag) => pluginTags.has(tag))) {
            continue;
          }
          schema.plugin(plugin[0], plugin[1]);
        }
      }
      options = Object.assign({}, options);
      delete options.skipTopLevel;
      if (options.applyPluginsToChildSchemas !== false) {
        for (const path of Object.keys(schema.paths)) {
          const type = schema.paths[path];
          if (type.schema != null) {
            applyPlugins(type.schema, plugins, options, cacheKey);
            type.caster.prototype.$__setSchema(type.schema);
          }
        }
      }
      const discriminators = schema.discriminators;
      if (discriminators == null) {
        return;
      }
      const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;
      const keys = Object.keys(discriminators);
      for (const discriminatorKey of keys) {
        const discriminatorSchema = discriminators[discriminatorKey];
        applyPlugins(
          discriminatorSchema,
          plugins,
          { skipTopLevel: !applyPluginsToDiscriminators },
          cacheKey
        );
      }
    };
  }
});

// asset-input/node_modules/mongoose/package.json
var require_package2 = __commonJS({
  "asset-input/node_modules/mongoose/package.json"(exports2, module2) {
    module2.exports = {
      name: "mongoose",
      description: "Mongoose MongoDB ODM",
      version: "6.13.0",
      author: "Guillermo Rauch <guillermo@learnboost.com>",
      keywords: [
        "mongodb",
        "document",
        "model",
        "schema",
        "database",
        "odm",
        "data",
        "datastore",
        "query",
        "nosql",
        "orm",
        "db"
      ],
      license: "MIT",
      dependencies: {
        bson: "^4.7.2",
        kareem: "2.5.1",
        mongodb: "4.17.2",
        mpath: "0.9.0",
        mquery: "4.0.3",
        ms: "2.1.3",
        sift: "16.0.1"
      },
      devDependencies: {
        "@babel/core": "7.20.12",
        "@babel/preset-env": "7.20.2",
        "@typescript-eslint/eslint-plugin": "5.50.0",
        "@typescript-eslint/parser": "5.50.0",
        acquit: "1.3.0",
        "acquit-ignore": "0.2.1",
        "acquit-require": "0.1.1",
        "assert-browserify": "2.0.0",
        axios: "1.1.3",
        "babel-loader": "8.2.5",
        benchmark: "2.1.4",
        bluebird: "3.7.2",
        "broken-link-checker": "^0.7.8",
        buffer: "^5.6.0",
        cheerio: "1.0.0-rc.12",
        "crypto-browserify": "3.12.0",
        dotenv: "16.0.3",
        dox: "1.0.0",
        eslint: "8.33.0",
        "eslint-plugin-markdown": "^3.0.0",
        "eslint-plugin-mocha-no-only": "1.1.1",
        express: "^4.18.1",
        "fs-extra": "~11.1.1",
        "highlight.js": "11.7.0",
        "lodash.isequal": "4.5.0",
        "lodash.isequalwith": "4.4.0",
        marked: "4.2.12",
        mkdirp: "^2.1.3",
        mocha: "10.2.0",
        moment: "2.x",
        "mongodb-memory-server": "8.11.4",
        ncp: "^2.0.0",
        nyc: "15.1.0",
        pug: "3.0.2",
        q: "1.5.1",
        sinon: "15.0.1",
        "stream-browserify": "3.0.0",
        tmp: "0.2.1",
        tsd: "0.25.0",
        typescript: "4.9.5",
        uuid: "9.0.0",
        webpack: "5.75.0"
      },
      directories: {
        lib: "./lib/mongoose"
      },
      scripts: {
        "docs:clean": "npm run docs:clean:stable",
        "docs:clean:stable": "rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
        "docs:clean:5x": "rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
        "docs:clean:6x": "rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
        "docs:copy:tmp": "mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/",
        "docs:copy:tmp:5x": "rimraf ./docs/5.x && ncp ./tmp ./docs/5.x",
        "docs:move:6x:tmp": "mv ./docs/6.x ./tmp",
        "docs:copy:tmp:6x": "rimraf ./docs/6.x && ncp ./tmp ./docs/6.x",
        "docs:checkout:gh-pages": "git checkout gh-pages",
        "docs:checkout:5x": "git checkout 5.x",
        "docs:checkout:6x": "git checkout 6.x",
        "docs:generate": "node ./scripts/website.js",
        "docs:generate:search": "node ./scripts/generateSearch.js",
        "docs:generate:sponsorData": "node ./scripts/loadSponsorData.js",
        "docs:merge:stable": "git merge master",
        "docs:merge:5x": "git merge 5.x",
        "docs:merge:6x": "git merge 6.x",
        "docs:test": "npm run docs:generate && npm run docs:generate:search",
        "docs:view": "node ./scripts/static.js",
        "docs:prepare:publish:stable": "npm run docs:checkout:gh-pages && npm run docs:merge:stable && npm run docs:clean:stable && npm run docs:generate && npm run docs:generate:search",
        "docs:prepare:publish:5x": "npm run docs:checkout:5x && npm run docs:merge:5x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:5x",
        "docs:prepare:publish:6x": "npm run docs:checkout:6x && npm run docs:merge:6x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && npm run docs:move:6x:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:6x",
        "docs:check-links": "blc http://127.0.0.1:8089 -ro",
        lint: "eslint .",
        "lint-js": "eslint . --ext .js",
        "lint-ts": "eslint . --ext .ts",
        "lint-md": "eslint . --ext .md",
        "build-browser": "(rm ./dist/* || true) && node ./scripts/build-browser.js",
        prepublishOnly: "npm run build-browser",
        release: "git pull && git push origin master --tags && npm publish",
        "release-5x": "git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x",
        "release-6x": "git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag 6x",
        mongo: "node ./tools/repl.js",
        test: "mocha --exit ./test/*.test.js",
        "test-deno": "deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.js",
        "test-rs": "START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js",
        "test-tsd": "node ./test/types/check-types-filename && tsd",
        tdd: "mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}",
        "test-coverage": "nyc --reporter=html --reporter=text npm test",
        "ts-benchmark": "cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"
      },
      main: "./index.js",
      types: "./types/index.d.ts",
      engines: {
        node: ">=12.0.0"
      },
      bugs: {
        url: "https://github.com/Automattic/mongoose/issues/new"
      },
      repository: {
        type: "git",
        url: "git://github.com/Automattic/mongoose.git"
      },
      homepage: "https://mongoosejs.com",
      browser: "./dist/browser.umd.js",
      mocha: {
        extension: [
          "test.js"
        ],
        "watch-files": [
          "test/**/*.js"
        ]
      },
      config: {
        mongodbMemoryServer: {
          disablePostinstall: true
        }
      },
      funding: {
        type: "opencollective",
        url: "https://opencollective.com/mongoose"
      },
      tsd: {
        directory: "test/types",
        compilerOptions: {
          esModuleInterop: false,
          strict: true,
          allowSyntheticDefaultImports: true,
          strictPropertyInitialization: false,
          noImplicitAny: false,
          strictNullChecks: true,
          module: "commonjs",
          target: "ES2017"
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/processConnectionOptions.js
var require_processConnectionOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/processConnectionOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var MongooseError = require_error3();
    function processConnectionOptions(uri, options) {
      const opts = options ? options : {};
      const readPreference = opts.readPreference ? opts.readPreference : getUriReadPreference(uri);
      const clonedOpts = clone(opts);
      const resolvedOpts = readPreference && readPreference !== "primary" && readPreference !== "primaryPreferred" ? resolveOptsConflicts(readPreference, clonedOpts) : clonedOpts;
      return resolvedOpts;
    }
    function resolveOptsConflicts(pref, opts) {
      if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {
        throwReadPreferenceError();
      } else {
        return defaultIndexOptsToFalse(opts);
      }
    }
    function setsIndexOptions(opts) {
      const configIdx = opts.config && opts.config.autoIndex;
      const { autoCreate, autoIndex } = opts;
      return !!(configIdx || autoCreate || autoIndex);
    }
    function setsSecondaryRead(prefString) {
      return !!(prefString === "secondary" || prefString === "secondaryPreferred");
    }
    function getUriReadPreference(connectionString) {
      const exp = /(?:&|\?)readPreference=(\w+)(?:&|$)/;
      const match = exp.exec(connectionString);
      return match ? match[1] : null;
    }
    function defaultIndexOptsToFalse(opts) {
      opts.config = { autoIndex: false };
      opts.autoCreate = false;
      opts.autoIndex = false;
      return opts;
    }
    function throwReadPreferenceError() {
      throw new MongooseError(
        'MongoDB prohibits index creation on connections that read from non-primary replicas.  Connections that set "readPreference" to "secondary" or "secondaryPreferred" may not opt-in to the following connection options: autoCreate, autoIndex'
      );
    }
    module2.exports = processConnectionOptions;
  }
});

// asset-input/node_modules/mongoose/lib/connection.js
var require_connection2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/connection.js"(exports2, module2) {
    "use strict";
    var ChangeStream = require_ChangeStream();
    var EventEmitter = require("events").EventEmitter;
    var Schema = require_schema2();
    var STATES = require_connectionstate();
    var MongooseError = require_error3();
    var DisconnectedError = require_disconnected();
    var SyncIndexesError = require_syncIndexes();
    var PromiseProvider = require_promise_provider2();
    var ServerSelectionError = require_serverSelection();
    var applyPlugins = require_applyPlugins();
    var driver = require_driver();
    var promiseOrCallback = require_promiseOrCallback();
    var get = require_get();
    var immediate = require_immediate();
    var mongodb = require_lib3();
    var pkg = require_package2();
    var utils = require_utils6();
    var processConnectionOptions = require_processConnectionOptions();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    var noPasswordAuthMechanisms = [
      "MONGODB-X509"
    ];
    function Connection(base) {
      this.base = base;
      this.collections = {};
      this.models = {};
      this.config = {};
      this.replica = false;
      this.options = null;
      this.otherDbs = [];
      this.relatedDbs = {};
      this.states = STATES;
      this._readyState = STATES.disconnected;
      this._closeCalled = false;
      this._hasOpened = false;
      this.plugins = [];
      if (typeof base === "undefined" || !base.connections.length) {
        this.id = 0;
      } else {
        this.id = base.nextConnectionId;
      }
      this._queue = [];
    }
    Object.setPrototypeOf(Connection.prototype, EventEmitter.prototype);
    Object.defineProperty(Connection.prototype, "readyState", {
      get: function() {
        return this._readyState;
      },
      set: function(val) {
        if (!(val in STATES)) {
          throw new Error("Invalid connection state: " + val);
        }
        if (this._readyState !== val) {
          this._readyState = val;
          for (const db of this.otherDbs) {
            db.readyState = val;
          }
          if (STATES.connected === val) {
            this._hasOpened = true;
          }
          this.emit(STATES[val]);
        }
      }
    });
    Connection.prototype.get = function(key) {
      if (this.config.hasOwnProperty(key)) {
        return this.config[key];
      }
      return get(this.options, key);
    };
    Connection.prototype.set = function(key, val) {
      if (this.config.hasOwnProperty(key)) {
        this.config[key] = val;
        return val;
      }
      this.options = this.options || {};
      this.options[key] = val;
      return val;
    };
    Connection.prototype.collections;
    Connection.prototype.name;
    Connection.prototype.models;
    Connection.prototype.id;
    Object.defineProperty(Connection.prototype, "plugins", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "host", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "port", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "user", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "pass", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Connection.prototype.db;
    Connection.prototype.client;
    Connection.prototype.config;
    Connection.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      this.db.createCollection(collection, options, cb);
    });
    Connection.prototype.startSession = _wrapConnHelper(function startSession(options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      const session = this.client.startSession(options);
      cb(null, session);
    });
    Connection.prototype.transaction = function transaction(fn, options) {
      return this.startSession().then((session) => {
        session[sessionNewDocuments] = /* @__PURE__ */ new Map();
        return session.withTransaction(() => fn(session), options).then((res) => {
          delete session[sessionNewDocuments];
          return res;
        }).catch((err) => {
          for (const doc of session[sessionNewDocuments].keys()) {
            const state = session[sessionNewDocuments].get(doc);
            if (state.hasOwnProperty("isNew")) {
              doc.$isNew = state.$isNew;
            }
            if (state.hasOwnProperty("versionKey")) {
              doc.set(doc.schema.options.versionKey, state.versionKey);
            }
            if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {
              doc.$__.activePaths.states.modify = {};
            }
            for (const path of state.modifiedPaths) {
              doc.$__.activePaths.paths[path] = "modify";
              doc.$__.activePaths.states.modify[path] = true;
            }
            for (const path of state.atomics.keys()) {
              const val = doc.$__getValue(path);
              if (val == null) {
                continue;
              }
              val[arrayAtomicsSymbol] = state.atomics.get(path);
            }
          }
          delete session[sessionNewDocuments];
          throw err;
        }).finally(() => {
          session.endSession().catch(() => {
          });
        });
      });
    };
    Connection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
      this.db.dropCollection(collection, cb);
    });
    Connection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
      for (const model of Object.values(this.models)) {
        delete model.$init;
      }
      this.db.dropDatabase(cb);
    });
    function _wrapConnHelper(fn) {
      return function() {
        const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;
        const argsWithoutCb = typeof cb === "function" ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : Array.prototype.slice.call(arguments);
        const disconnectedError = new DisconnectedError(this.id, fn.name);
        return promiseOrCallback(cb, (cb2) => {
          immediate(() => {
            if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
              this._queue.push({ fn, ctx: this, args: argsWithoutCb.concat([cb2]) });
            } else if (this.readyState === STATES.disconnected && this.db == null) {
              cb2(disconnectedError);
            } else {
              try {
                fn.apply(this, argsWithoutCb.concat([cb2]));
              } catch (err) {
                return cb2(err);
              }
            }
          });
        });
      };
    }
    Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      if (this.config.bufferCommands != null) {
        return this.config.bufferCommands;
      }
      if (this.base.get("bufferCommands") != null) {
        return this.base.get("bufferCommands");
      }
      return true;
    };
    Connection.prototype.error = function(err, callback) {
      if (callback) {
        callback(err);
        return null;
      }
      if (this.listeners("error").length > 0) {
        this.emit("error", err);
      }
      return Promise.reject(err);
    };
    Connection.prototype.onOpen = function() {
      this.readyState = STATES.connected;
      for (const d of this._queue) {
        d.fn.apply(d.ctx, d.args);
      }
      this._queue = [];
      for (const i in this.collections) {
        if (utils.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onOpen();
        }
      }
      this.emit("open");
    };
    Connection.prototype.openUri = function(uri, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (["string", "number"].indexOf(typeof options) !== -1) {
        throw new MongooseError("Mongoose 5.x no longer supports `mongoose.connect(host, dbname, port)` or `mongoose.createConnection(host, dbname, port)`. See https://mongoosejs.com/docs/connections.html for supported connection syntax");
      }
      if (typeof uri !== "string") {
        throw new MongooseError(`The \`uri\` parameter to \`openUri()\` must be a string, got "${typeof uri}". Make sure the first parameter to \`mongoose.connect()\` or \`mongoose.createConnection()\` is a string.`);
      }
      if (callback != null && typeof callback !== "function") {
        throw new MongooseError('3rd parameter to `mongoose.connect()` or `mongoose.createConnection()` must be a function, got "' + typeof callback + '"');
      }
      if (this._destroyCalled) {
        const error = "Connection has been closed and destroyed, and cannot be used for re-opening the connection. Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.";
        if (typeof callback === "function") {
          callback(error);
          return;
        } else {
          throw new MongooseError(error);
        }
      }
      if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
        if (this._connectionString !== uri) {
          throw new MongooseError("Can't call `openUri()` on an active connection with different connection strings. Make sure you aren't calling `mongoose.connect()` multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
        }
        if (typeof callback === "function") {
          this.$initialConnection = this.$initialConnection.then(
            () => callback(null, this),
            (err) => callback(err)
          );
        }
        return this;
      }
      this._connectionString = uri;
      this.readyState = STATES.connecting;
      this._closeCalled = false;
      const Promise2 = PromiseProvider.get();
      const _this = this;
      options = processConnectionOptions(uri, options);
      if (options) {
        options = utils.clone(options);
        const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;
        if (autoIndex != null) {
          this.config.autoIndex = autoIndex !== false;
          delete options.config;
          delete options.autoIndex;
        }
        if ("autoCreate" in options) {
          this.config.autoCreate = !!options.autoCreate;
          delete options.autoCreate;
        }
        if ("sanitizeFilter" in options) {
          this.config.sanitizeFilter = options.sanitizeFilter;
          delete options.sanitizeFilter;
        }
        if (options.user || options.pass) {
          options.auth = options.auth || {};
          options.auth.username = options.user;
          options.auth.password = options.pass;
          this.user = options.user;
          this.pass = options.pass;
        }
        delete options.user;
        delete options.pass;
        if (options.bufferCommands != null) {
          this.config.bufferCommands = options.bufferCommands;
          delete options.bufferCommands;
        }
      } else {
        options = {};
      }
      this._connectionOptions = options;
      const dbName = options.dbName;
      if (dbName != null) {
        this.$dbName = dbName;
      }
      delete options.dbName;
      if (!utils.hasUserDefinedProperty(options, "driverInfo")) {
        options.driverInfo = {
          name: "Mongoose",
          version: pkg.version
        };
      }
      const promise = new Promise2((resolve, reject) => {
        let client;
        try {
          client = new mongodb.MongoClient(uri, options);
        } catch (error) {
          _this.readyState = STATES.disconnected;
          return reject(error);
        }
        _this.client = client;
        client.setMaxListeners(0);
        client.connect((error) => {
          if (error) {
            return reject(error);
          }
          _setClient(_this, client, options, dbName);
          for (const db of this.otherDbs) {
            _setClient(db, client, {}, db.name);
          }
          resolve(_this);
        });
      });
      const serverSelectionError = new ServerSelectionError();
      this.$initialConnection = promise.then(() => this).catch((err) => {
        this.readyState = STATES.disconnected;
        if (err != null && err.name === "MongoServerSelectionError") {
          err = serverSelectionError.assimilateError(err);
        }
        if (this.listeners("error").length > 0) {
          immediate(() => this.emit("error", err));
        }
        throw err;
      });
      if (callback != null) {
        this.$initialConnection = this.$initialConnection.then(
          () => {
            callback(null, this);
            return this;
          },
          (err) => callback(err)
        );
      }
      for (const model of Object.values(this.models)) {
        model.init(function $modelInitNoop() {
        });
      }
      return this.$initialConnection;
    };
    function _setClient(conn, client, options, dbName) {
      const db = dbName != null ? client.db(dbName) : client.db();
      conn.db = db;
      conn.client = client;
      conn.host = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].host || void 0;
      conn.port = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].port || void 0;
      conn.name = dbName != null ? dbName : client && client.s && client.s.options && client.s.options.dbName || void 0;
      conn._closeCalled = client._closeCalled;
      const _handleReconnect = () => {
        if (conn.readyState !== STATES.connected) {
          conn.readyState = STATES.connected;
          conn.emit("reconnect");
          conn.emit("reconnected");
          conn.onOpen();
        }
      };
      const type = client && client.topology && client.topology.description && client.topology.description.type || "";
      if (type === "Single") {
        client.on("serverDescriptionChanged", (ev) => {
          const newDescription = ev.newDescription;
          if (newDescription.type === "Unknown") {
            conn.readyState = STATES.disconnected;
          } else {
            _handleReconnect();
          }
        });
      } else if (type.startsWith("ReplicaSet")) {
        client.on("topologyDescriptionChanged", (ev) => {
          const description = ev.newDescription;
          if (conn.readyState === STATES.connected && description.type !== "ReplicaSetWithPrimary") {
            conn.readyState = STATES.disconnected;
          } else if (conn.readyState === STATES.disconnected && description.type === "ReplicaSetWithPrimary") {
            _handleReconnect();
          }
        });
      }
      conn.onOpen();
      for (const i in conn.collections) {
        if (utils.object.hasOwnProperty(conn.collections, i)) {
          conn.collections[i].onOpen();
        }
      }
    }
    Connection.prototype.destroy = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (force != null && typeof force === "object") {
        this.$wasForceClosed = !!force.force;
      } else {
        this.$wasForceClosed = !!force;
      }
      return promiseOrCallback(callback, (cb) => {
        this._close(force, true, cb);
      });
    };
    Connection.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (force != null && typeof force === "object") {
        this.$wasForceClosed = !!force.force;
      } else {
        this.$wasForceClosed = !!force;
      }
      for (const model of Object.values(this.models)) {
        delete model.$init;
      }
      return promiseOrCallback(callback, (cb) => {
        this._close(force, false, cb);
      });
    };
    Connection.prototype._close = function(force, destroy, callback) {
      const _this = this;
      const closeCalled = this._closeCalled;
      this._closeCalled = true;
      this._destroyCalled = destroy;
      if (this.client != null) {
        this.client._closeCalled = true;
        this.client._destroyCalled = destroy;
      }
      const conn = this;
      switch (this.readyState) {
        case STATES.disconnected:
          if (destroy && this.base.connections.indexOf(conn) !== -1) {
            this.base.connections.splice(this.base.connections.indexOf(conn), 1);
          }
          if (closeCalled) {
            callback();
          } else {
            this.doClose(force, function(err) {
              if (err) {
                return callback(err);
              }
              _this.onClose(force);
              callback(null);
            });
          }
          break;
        case STATES.connected:
          this.readyState = STATES.disconnecting;
          this.doClose(force, function(err) {
            if (err) {
              return callback(err);
            }
            if (destroy && _this.base.connections.indexOf(conn) !== -1) {
              _this.base.connections.splice(_this.base.connections.indexOf(conn), 1);
            }
            _this.onClose(force);
            callback(null);
          });
          break;
        case STATES.connecting:
          this.once("open", function() {
            destroy ? _this.destroy(force, callback) : _this.close(force, callback);
          });
          break;
        case STATES.disconnecting:
          this.once("close", function() {
            if (destroy && _this.base.connections.indexOf(conn) !== -1) {
              _this.base.connections.splice(_this.base.connections.indexOf(conn), 1);
            }
            callback();
          });
          break;
      }
      return this;
    };
    Connection.prototype.doClose = function() {
      throw new Error("Connection#doClose unimplemented by driver");
    };
    Connection.prototype.onClose = function(force) {
      this.readyState = STATES.disconnected;
      for (const i in this.collections) {
        if (utils.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onClose(force);
        }
      }
      this.emit("close", force);
      for (const db of this.otherDbs) {
        this._destroyCalled ? db.destroy({ force, skipCloseClient: true }) : db.close({ force, skipCloseClient: true });
      }
    };
    Connection.prototype.collection = function(name, options) {
      const defaultOptions = {
        autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
        autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate
      };
      options = Object.assign({}, defaultOptions, options ? utils.clone(options) : {});
      options.$wasForceClosed = this.$wasForceClosed;
      const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;
      if (!(name in this.collections)) {
        this.collections[name] = new Collection(name, this, options);
      }
      return this.collections[name];
    };
    Connection.prototype.plugin = function(fn, opts) {
      this.plugins.push([fn, opts]);
      return this;
    };
    Connection.prototype.model = function(name, schema, collection, options) {
      if (!(this instanceof Connection)) {
        throw new MongooseError("`connection.model()` should not be run with `new`. If you are doing `new db.model(foo)(bar)`, use `db.model(foo)(bar)` instead");
      }
      let fn;
      if (typeof name === "function") {
        fn = name;
        name = fn.name;
      }
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (utils.isObject(schema)) {
        if (!schema.instanceOfSchema) {
          schema = new Schema(schema);
        } else if (!(schema instanceof this.base.Schema)) {
          schema = schema._clone(this.base.Schema);
        }
      }
      if (schema && !schema.instanceOfSchema) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
      const opts = Object.assign(defaultOptions, options, { connection: this });
      if (this.models[name] && !collection && opts.overwriteModels !== true) {
        if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
          throw new MongooseError.OverwriteModelError(name);
        }
        return this.models[name];
      }
      let model;
      if (schema && schema.instanceOfSchema) {
        applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
        model = this.base._model(fn || name, schema, collection, opts);
        if (!this.models[name]) {
          this.models[name] = model;
        }
        model.init(function $modelInitNoop() {
        });
        return model;
      }
      if (this.models[name] && collection) {
        model = this.models[name];
        schema = model.prototype.schema;
        const sub = model.__subclass(this, schema, collection);
        return sub;
      }
      if (arguments.length === 1) {
        model = this.models[name];
        if (!model) {
          throw new MongooseError.MissingSchemaError(name);
        }
        return model;
      }
      if (!model) {
        throw new MongooseError.MissingSchemaError(name);
      }
      if (this === model.prototype.db && (!collection || collection === model.collection.name)) {
        if (!this.models[name]) {
          this.models[name] = model;
        }
        return model;
      }
      this.models[name] = model.__subclass(this, schema, collection);
      return this.models[name];
    };
    Connection.prototype.deleteModel = function(name) {
      if (typeof name === "string") {
        const model = this.model(name);
        if (model == null) {
          return this;
        }
        const collectionName = model.collection.name;
        delete this.models[name];
        delete this.collections[collectionName];
        this.emit("deleteModel", model);
      } else if (name instanceof RegExp) {
        const pattern = name;
        const names = this.modelNames();
        for (const name2 of names) {
          if (pattern.test(name2)) {
            this.deleteModel(name2);
          }
        }
      } else {
        throw new Error('First parameter to `deleteModel()` must be a string or regexp, got "' + name + '"');
      }
      return this;
    };
    Connection.prototype.watch = function(pipeline2, options) {
      const disconnectedError = new DisconnectedError(this.id, "watch");
      const changeStreamThunk = (cb) => {
        immediate(() => {
          if (this.readyState === STATES.connecting) {
            this.once("open", function() {
              const driverChangeStream = this.db.watch(pipeline2, options);
              cb(null, driverChangeStream);
            });
          } else if (this.readyState === STATES.disconnected && this.db == null) {
            cb(disconnectedError);
          } else {
            const driverChangeStream = this.db.watch(pipeline2, options);
            cb(null, driverChangeStream);
          }
        });
      };
      const changeStream = new ChangeStream(changeStreamThunk, pipeline2, options);
      return changeStream;
    };
    Connection.prototype.asPromise = function asPromise() {
      return this.$initialConnection;
    };
    Connection.prototype.modelNames = function() {
      return Object.keys(this.models);
    };
    Connection.prototype.shouldAuthenticate = function() {
      return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
    };
    Connection.prototype.authMechanismDoesNotRequirePassword = function() {
      if (this.options && this.options.auth) {
        return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
      }
      return true;
    };
    Connection.prototype.optionsProvideAuthenticationData = function(options) {
      return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());
    };
    Connection.prototype.getClient = function getClient() {
      return this.client;
    };
    Connection.prototype.setClient = function setClient(client) {
      if (!(client instanceof mongodb.MongoClient)) {
        throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
      }
      if (this.readyState !== STATES.disconnected) {
        throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
      }
      if (client.topology == null) {
        throw new MongooseError("Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.");
      }
      this._connectionString = client.s.url;
      _setClient(this, client, {}, client.s.options.dbName);
      for (const model of Object.values(this.models)) {
        model.init(function $modelInitNoop() {
        });
      }
      return this;
    };
    Connection.prototype.syncIndexes = async function syncIndexes(options = {}) {
      const result = {};
      const errorsMap = {};
      const { continueOnError } = options;
      delete options.continueOnError;
      for (const model of Object.values(this.models)) {
        try {
          result[model.modelName] = await model.syncIndexes(options);
        } catch (err) {
          if (!continueOnError) {
            errorsMap[model.modelName] = err;
            break;
          } else {
            result[model.modelName] = err;
          }
        }
      }
      if (!continueOnError && Object.keys(errorsMap).length) {
        const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(", ");
        const syncIndexesError = new SyncIndexesError(message, errorsMap);
        throw syncIndexesError;
      }
      return result;
    };
    Connection.STATES = STATES;
    module2.exports = Connection;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/timers.js
var require_timers = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/timers.js"(exports2) {
    "use strict";
    exports2.setTimeout = setTimeout;
  }
});

// asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js
var require_connection3 = __commonJS({
  "asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"(exports2, module2) {
    "use strict";
    var MongooseConnection = require_connection2();
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    var setTimeout3 = require_timers().setTimeout;
    function NativeConnection() {
      MongooseConnection.apply(this, arguments);
      this._listening = false;
    }
    NativeConnection.STATES = STATES;
    Object.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);
    NativeConnection.prototype.useDb = function(name, options) {
      options = options || {};
      if (options.useCache && this.relatedDbs[name]) {
        return this.relatedDbs[name];
      }
      const newConn = new this.constructor();
      newConn.name = name;
      newConn.base = this.base;
      newConn.collections = {};
      newConn.models = {};
      newConn.replica = this.replica;
      newConn.config = Object.assign({}, this.config, newConn.config);
      newConn.name = this.name;
      newConn.options = this.options;
      newConn._readyState = this._readyState;
      newConn._closeCalled = this._closeCalled;
      newConn._hasOpened = this._hasOpened;
      newConn._listening = false;
      newConn._parent = this;
      newConn.host = this.host;
      newConn.port = this.port;
      newConn.user = this.user;
      newConn.pass = this.pass;
      const _this = this;
      newConn.client = _this.client;
      if (this.db && this._readyState === STATES.connected) {
        wireup();
      } else {
        this.once("connected", wireup);
      }
      function wireup() {
        newConn.client = _this.client;
        const _opts = {};
        if (options.hasOwnProperty("noListener")) {
          _opts.noListener = options.noListener;
        }
        newConn.db = _this.client.db(name, _opts);
        newConn.onOpen();
      }
      newConn.name = name;
      if (options.noListener !== true) {
        this.otherDbs.push(newConn);
      }
      newConn.otherDbs.push(this);
      if (options && options.useCache) {
        this.relatedDbs[newConn.name] = newConn;
        newConn.relatedDbs = this.relatedDbs;
      }
      return newConn;
    };
    NativeConnection.prototype.doClose = function(force, fn) {
      if (this.client == null) {
        immediate(() => fn());
        return this;
      }
      let skipCloseClient = false;
      if (force != null && typeof force === "object") {
        skipCloseClient = force.skipCloseClient;
        force = force.force;
      }
      if (skipCloseClient) {
        immediate(() => fn());
        return this;
      }
      this.client.close(force, (err, res) => {
        setTimeout3(() => fn(err, res), 1);
      });
      return this;
    };
    module2.exports = NativeConnection;
  }
});

// asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js
var require_node_mongodb_native = __commonJS({
  "asset-input/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js"(exports2) {
    "use strict";
    exports2.Binary = require_binary2();
    exports2.Collection = require_collection5();
    exports2.Decimal128 = require_decimal1285();
    exports2.ObjectId = require_objectid2();
    exports2.ReadPreference = require_ReadPreference();
    exports2.getConnection = () => require_connection3();
  }
});

// asset-input/node_modules/mongoose/lib/validoptions.js
var require_validoptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/validoptions.js"(exports2, module2) {
    "use strict";
    var VALID_OPTIONS = Object.freeze([
      "allowDiskUse",
      "applyPluginsToChildSchemas",
      "applyPluginsToDiscriminators",
      "autoCreate",
      "autoIndex",
      "bufferCommands",
      "bufferTimeoutMS",
      "cloneSchemas",
      "debug",
      "id",
      "timestamps.createdAt.immutable",
      "maxTimeMS",
      "objectIdGetter",
      "overwriteModels",
      "returnOriginal",
      "runValidators",
      "sanitizeFilter",
      "sanitizeProjection",
      "selectPopulatedPaths",
      "setDefaultsOnInsert",
      "strict",
      "strictPopulate",
      "strictQuery",
      "toJSON",
      "toObject"
    ]);
    module2.exports = VALID_OPTIONS;
  }
});

// asset-input/node_modules/mongoose/lib/error/eachAsyncMultiError.js
var require_eachAsyncMultiError = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/eachAsyncMultiError.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var EachAsyncMultiError = class extends MongooseError {
      /**
       * @param {String} connectionString
       */
      constructor(errors) {
        let preview = errors.map((e) => e.message).join(", ");
        if (preview.length > 50) {
          preview = preview.slice(0, 50) + "...";
        }
        super(`eachAsync() finished with ${errors.length} errors: ${preview}`);
        this.errors = errors;
      }
    };
    Object.defineProperty(EachAsyncMultiError.prototype, "name", {
      value: "EachAsyncMultiError"
    });
    module2.exports = EachAsyncMultiError;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/cursor/eachAsync.js
var require_eachAsync = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/cursor/eachAsync.js"(exports2, module2) {
    "use strict";
    var EachAsyncMultiError = require_eachAsyncMultiError();
    var immediate = require_immediate();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function eachAsync(next, fn, options, callback) {
      const parallel = options.parallel || 1;
      const batchSize = options.batchSize;
      const signal = options.signal;
      const continueOnError = options.continueOnError;
      const aggregatedErrors = [];
      const enqueue = asyncQueue();
      let aborted = false;
      return promiseOrCallback(callback, (cb) => {
        if (signal != null) {
          if (signal.aborted) {
            return cb(null);
          }
          signal.addEventListener("abort", () => {
            aborted = true;
            return cb(null);
          }, { once: true });
        }
        if (batchSize != null) {
          if (typeof batchSize !== "number") {
            throw new TypeError("batchSize must be a number");
          } else if (!Number.isInteger(batchSize)) {
            throw new TypeError("batchSize must be an integer");
          } else if (batchSize < 1) {
            throw new TypeError("batchSize must be at least 1");
          }
        }
        iterate(cb);
      });
      function iterate(finalCallback) {
        let handleResultsInProgress = 0;
        let currentDocumentIndex = 0;
        let error = null;
        for (let i = 0; i < parallel; ++i) {
          enqueue(createFetch());
        }
        function createFetch() {
          let documentsBatch = [];
          let drained = false;
          return fetch;
          function fetch(done) {
            if (drained || aborted) {
              return done();
            } else if (error) {
              return done();
            }
            next(function(err, doc) {
              if (error != null) {
                return done();
              }
              if (err != null) {
                if (err.name === "MongoCursorExhaustedError") {
                  doc = null;
                } else if (continueOnError) {
                  aggregatedErrors.push(err);
                } else {
                  error = err;
                  finalCallback(err);
                  return done();
                }
              }
              if (doc == null) {
                drained = true;
                if (handleResultsInProgress <= 0) {
                  const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                  finalCallback(finalErr);
                } else if (batchSize && documentsBatch.length) {
                  handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
                }
                return done();
              }
              ++handleResultsInProgress;
              immediate(() => done());
              if (batchSize) {
                documentsBatch.push(doc);
              }
              if (batchSize && documentsBatch.length !== batchSize) {
                immediate(() => enqueue(fetch));
                return;
              }
              const docsToProcess = batchSize ? documentsBatch : doc;
              function handleNextResultCallBack(err2) {
                if (batchSize) {
                  handleResultsInProgress -= documentsBatch.length;
                  documentsBatch = [];
                } else {
                  --handleResultsInProgress;
                }
                if (err2 != null) {
                  if (continueOnError) {
                    aggregatedErrors.push(err2);
                  } else {
                    error = err2;
                    return finalCallback(err2);
                  }
                }
                if ((drained || aborted) && handleResultsInProgress <= 0) {
                  const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                  return finalCallback(finalErr);
                }
                immediate(() => enqueue(fetch));
              }
              handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
            });
          }
        }
      }
      function handleNextResult(doc, i, callback2) {
        let maybePromise;
        try {
          maybePromise = fn(doc, i);
        } catch (err) {
          return callback2(err);
        }
        if (maybePromise && typeof maybePromise.then === "function") {
          maybePromise.then(
            function() {
              callback2(null);
            },
            function(error) {
              callback2(error || new Error("`eachAsync()` promise rejected without error"));
            }
          );
        } else {
          callback2(null);
        }
      }
    };
    function asyncQueue() {
      const _queue = [];
      let inProgress = null;
      let id = 0;
      return function enqueue(fn) {
        if (inProgress === null && _queue.length === 0) {
          inProgress = id++;
          return fn(_step);
        }
        _queue.push(fn);
      };
      function _step() {
        if (_queue.length !== 0) {
          inProgress = id++;
          const fn = _queue.shift();
          fn(_step);
        } else {
          inProgress = null;
        }
      }
    }
    function createEachAsyncMultiError(aggregatedErrors) {
      if (aggregatedErrors.length === 0) {
        return null;
      }
      return new EachAsyncMultiError(aggregatedErrors);
    }
  }
});

// asset-input/node_modules/mongoose/lib/cursor/QueryCursor.js
var require_QueryCursor = __commonJS({
  "asset-input/node_modules/mongoose/lib/cursor/QueryCursor.js"(exports2, module2) {
    "use strict";
    var Readable2 = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var util2 = require("util");
    function QueryCursor(query, options) {
      Readable2.call(this, { autoDestroy: true, objectMode: true });
      this.cursor = null;
      this.query = query;
      const _this = this;
      const model = query.model;
      this._mongooseOptions = {};
      this._transforms = [];
      this.model = model;
      this.options = options || {};
      model.hooks.execPre("find", query, (err) => {
        if (err != null) {
          _this._markError(err);
          _this.listeners("error").length > 0 && _this.emit("error", err);
          return;
        }
        this._transforms = this._transforms.concat(query._transforms.slice());
        if (this.options.transform) {
          this._transforms.push(options.transform);
        }
        if (this.options.batchSize) {
          this.options.cursor = options.cursor || {};
          this.options.cursor.batchSize = options.batchSize;
          this.options._populateBatchSize = Math.min(this.options.batchSize, 5e3);
        }
        Object.assign(this.options, query._optionsForExec());
        model.collection.find(query._conditions, this.options, (err2, cursor) => {
          if (err2 != null) {
            _this._markError(err2);
            _this.listeners("error").length > 0 && _this.emit("error", _this._error);
            return;
          }
          if (_this._error) {
            cursor.close(function() {
            });
            _this.listeners("error").length > 0 && _this.emit("error", _this._error);
          }
          _this.cursor = cursor;
          _this.emit("cursor", cursor);
        });
      });
    }
    util2.inherits(QueryCursor, Readable2);
    QueryCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error, doc) {
        if (error) {
          return _this.emit("error", error);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error2) {
            if (error2) {
              return _this.emit("error", error2);
            }
          });
          return;
        }
        _this.push(doc);
      });
    };
    Object.defineProperty(QueryCursor.prototype, "map", {
      value: function(fn) {
        this._transforms.push(fn);
        return this;
      },
      enumerable: true,
      configurable: true,
      writable: true
    });
    QueryCursor.prototype._markError = function(error) {
      this._error = error;
      return this;
    };
    QueryCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error) => {
          if (error) {
            cb(error);
            return this.listeners("error").length > 0 && this.emit("error", error);
          }
          this.emit("close");
          cb(null);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.rewind = function() {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.rewind();
      });
      return this;
    };
    QueryCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, function(error, doc) {
          if (error) {
            return cb(error);
          }
          cb(null, doc);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    QueryCursor.prototype.options;
    QueryCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    QueryCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    QueryCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    if (Symbol.asyncIterator != null) {
      QueryCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn.call(ctx, doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        if (ctx.query._mongooseOptions.populate && !ctx._pop) {
          ctx._pop = helpers.preparePopulationOptionsMQ(
            ctx.query,
            ctx.query._mongooseOptions
          );
          ctx._pop.__noPromise = true;
        }
        if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
          if (ctx._batchDocs && ctx._batchDocs.length) {
            return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
          } else if (ctx._batchExhausted) {
            return callback(null, null);
          } else {
            ctx._batchDocs = [];
            return ctx.cursor.next(_onNext.bind({ ctx, callback }));
          }
        } else {
          return ctx.cursor.next(function(error, doc) {
            if (error) {
              return callback(error);
            }
            if (!doc) {
              return callback(null, null);
            }
            if (!ctx.query._mongooseOptions.populate) {
              return _nextDoc(ctx, doc, null, callback);
            }
            ctx.query.model.populate(doc, ctx._pop, function(err, doc2) {
              if (err) {
                return callback(err);
              }
              return _nextDoc(ctx, doc2, ctx._pop, callback);
            });
          });
        }
      } else {
        ctx.once("error", cb);
        ctx.once("cursor", function(cursor) {
          ctx.removeListener("error", cb);
          if (cursor == null) {
            return;
          }
          _next(ctx, cb);
        });
      }
    }
    function _onNext(error, doc) {
      if (error) {
        return this.callback(error);
      }
      if (!doc) {
        this.ctx._batchExhausted = true;
        return _populateBatch.call(this);
      }
      this.ctx._batchDocs.push(doc);
      if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
        if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1e3 === 0) {
          return immediate(() => this.ctx.cursor.next(_onNext.bind(this)));
        }
        this.ctx.cursor.next(_onNext.bind(this));
      } else {
        _populateBatch.call(this);
      }
    }
    function _populateBatch() {
      if (!this.ctx._batchDocs.length) {
        return this.callback(null, null);
      }
      const _this = this;
      this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function(err) {
        if (err) {
          return _this.callback(err);
        }
        _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);
      });
    }
    function _nextDoc(ctx, doc, pop, callback) {
      if (ctx.query._mongooseOptions.lean) {
        return ctx.model.hooks.execPost("find", ctx.query, [[doc]], (err) => {
          if (err != null) {
            return callback(err);
          }
          callback(null, doc);
        });
      }
      const { model, _fields, _userProvidedFields, options } = ctx.query;
      helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc2) => {
        if (err != null) {
          return callback(err);
        }
        ctx.model.hooks.execPost("find", ctx.query, [[doc2]], (err2) => {
          if (err2 != null) {
            return callback(err2);
          }
          callback(null, doc2);
        });
      });
    }
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function(cursor) {
        if (cursor == null) {
          return;
        }
        cb();
      });
    }
    module2.exports = QueryCursor;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js
var require_applyGlobalOption = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js"(exports2, module2) {
    "use strict";
    var utils = require_utils6();
    function applyGlobalMaxTimeMS(options, model) {
      applyGlobalOption(options, model, "maxTimeMS");
    }
    function applyGlobalDiskUse(options, model) {
      applyGlobalOption(options, model, "allowDiskUse");
    }
    module2.exports = {
      applyGlobalMaxTimeMS,
      applyGlobalDiskUse
    };
    function applyGlobalOption(options, model, optionName) {
      if (utils.hasUserDefinedProperty(options, optionName)) {
        return;
      }
      if (utils.hasUserDefinedProperty(model.db.options, optionName)) {
        options[optionName] = model.db.options[optionName];
      } else if (utils.hasUserDefinedProperty(model.base.options, optionName)) {
        options[optionName] = model.base.options[optionName];
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js
var require_applyWriteConcern = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function applyWriteConcern(schema, options) {
      const writeConcern = get(schema, "options.writeConcern", {});
      if (Object.keys(writeConcern).length != 0) {
        options.writeConcern = {};
        if (!("w" in options) && writeConcern.w != null) {
          options.writeConcern.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
          options.writeConcern.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
          options.writeConcern.wtimeout = writeConcern.wtimeout;
        }
      } else {
        if (!("w" in options) && writeConcern.w != null) {
          options.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
          options.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
          options.wtimeout = writeConcern.wtimeout;
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/castFilterPath.js
var require_castFilterPath = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/castFilterPath.js"(exports2, module2) {
    "use strict";
    var isOperator = require_isOperator();
    module2.exports = function castFilterPath(query, schematype, val) {
      const ctx = query;
      const any$conditionals = Object.keys(val).some(isOperator);
      if (!any$conditionals) {
        return schematype.castForQueryWrapper({
          val,
          context: ctx
        });
      }
      const ks = Object.keys(val);
      let k = ks.length;
      while (k--) {
        const $cond = ks[k];
        const nested = val[$cond];
        if ($cond === "$not") {
          if (nested && schematype && !schematype.caster) {
            const _keys = Object.keys(nested);
            if (_keys.length && isOperator(_keys[0])) {
              for (const key of Object.keys(nested)) {
                nested[key] = schematype.castForQueryWrapper({
                  $conditional: key,
                  val: nested[key],
                  context: ctx
                });
              }
            } else {
              val[$cond] = schematype.castForQueryWrapper({
                $conditional: $cond,
                val: nested,
                context: ctx
              });
            }
            continue;
          }
        } else {
          val[$cond] = schematype.castForQueryWrapper({
            $conditional: $cond,
            val: nested,
            context: ctx
          });
        }
      }
      return val;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/schema/getPath.js
var require_getPath = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/schema/getPath.js"(exports2, module2) {
    "use strict";
    var numberRE = /^\d+$/;
    module2.exports = function getPath(schema, path) {
      let schematype = schema.path(path);
      if (schematype != null) {
        return schematype;
      }
      const pieces = path.split(".");
      let cur = "";
      let isArray = false;
      for (const piece of pieces) {
        if (isArray && numberRE.test(piece)) {
          continue;
        }
        cur = cur.length === 0 ? piece : cur + "." + piece;
        schematype = schema.path(cur);
        if (schematype != null && schematype.schema) {
          schema = schematype.schema;
          cur = "";
          if (!isArray && schematype.$isMongooseDocumentArray) {
            isArray = true;
          }
        }
      }
      return schematype;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/update/modifiedPaths.js
var require_modifiedPaths = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/update/modifiedPaths.js"(exports2, module2) {
    "use strict";
    var _modifiedPaths = require_common5().modifiedPaths;
    module2.exports = function modifiedPaths(update) {
      const keys = Object.keys(update);
      const res = {};
      const withoutDollarKeys = {};
      for (const key of keys) {
        if (key.startsWith("$")) {
          _modifiedPaths(update[key], "", res);
          continue;
        }
        withoutDollarKeys[key] = update[key];
      }
      _modifiedPaths(withoutDollarKeys, "", res);
      return res;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js
var require_updatedPathsByArrayFilter = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js"(exports2, module2) {
    "use strict";
    var modifiedPaths = require_modifiedPaths();
    module2.exports = function updatedPathsByArrayFilter(update) {
      if (update == null) {
        return {};
      }
      const updatedPaths = modifiedPaths(update);
      return Object.keys(updatedPaths).reduce((cur, path) => {
        const matches = path.match(/\$\[[^\]]+\]/g);
        if (matches == null) {
          return cur;
        }
        for (const match of matches) {
          const firstMatch = path.indexOf(match);
          if (firstMatch !== path.lastIndexOf(match)) {
            throw new Error(`Path '${path}' contains the same array filter multiple times`);
          }
          cur[match.substring(2, match.length - 1)] = path.substring(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
        }
        return cur;
      }, {});
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/update/castArrayFilters.js
var require_castArrayFilters = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/update/castArrayFilters.js"(exports2, module2) {
    "use strict";
    var castFilterPath = require_castFilterPath();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var getPath = require_getPath();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function castArrayFilters(query) {
      const arrayFilters = query.options.arrayFilters;
      const update = query.getUpdate();
      const schema = query.schema;
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      let strictQuery = schema.options.strict;
      if (query._mongooseOptions.strict != null) {
        strictQuery = query._mongooseOptions.strict;
      }
      if (query.model && query.model.base.options.strictQuery != null) {
        strictQuery = query.model.base.options.strictQuery;
      }
      if (schema._userProvidedOptions.strictQuery != null) {
        strictQuery = schema._userProvidedOptions.strictQuery;
      }
      if (query._mongooseOptions.strictQuery != null) {
        strictQuery = query._mongooseOptions.strictQuery;
      }
      _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);
    };
    function _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {
      if (!Array.isArray(arrayFilters)) {
        return;
      }
      for (const filter of arrayFilters) {
        if (filter == null) {
          throw new Error(`Got null array filter in ${arrayFilters}`);
        }
        const keys = Object.keys(filter).filter((key) => filter[key] != null);
        if (keys.length === 0) {
          continue;
        }
        const firstKey = keys[0];
        if (firstKey === "$and" || firstKey === "$or") {
          for (const key of keys) {
            _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);
          }
          continue;
        }
        const dot = firstKey.indexOf(".");
        const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);
        if (updatedPathsByFilter[filterWildcardPath] == null) {
          continue;
        }
        const baseFilterPath = cleanPositionalOperators(
          updatedPathsByFilter[filterWildcardPath]
        );
        const baseSchematype = getPath(schema, baseFilterPath);
        let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;
        if (filterBaseSchema != null && filterBaseSchema.discriminators != null && filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]) {
          filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;
        }
        for (const key of keys) {
          if (updatedPathsByFilter[key] === null) {
            continue;
          }
          if (Object.keys(updatedPathsByFilter).length === 0) {
            continue;
          }
          const dot2 = key.indexOf(".");
          let filterPathRelativeToBase = dot2 === -1 ? null : key.substring(dot2);
          let schematype;
          if (filterPathRelativeToBase == null || filterBaseSchema == null) {
            schematype = baseSchematype;
          } else {
            filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);
            schematype = getPath(filterBaseSchema, filterPathRelativeToBase);
          }
          if (schematype == null) {
            if (!strictQuery) {
              return;
            }
            const filterPath = filterPathRelativeToBase == null ? baseFilterPath + ".0" : baseFilterPath + ".0" + filterPathRelativeToBase;
            throw new Error(`Could not find path "${filterPath}" in schema`);
          }
          if (typeof filter[key] === "object") {
            filter[key] = castFilterPath(query, schematype, filter[key]);
          } else {
            filter[key] = schematype.castForQuery(filter[key]);
          }
        }
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    "use strict";
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
      const parts = path.split(".");
      let schematype = null;
      let type = "adhocOrUndefined";
      filter = filter || {};
      update = update || {};
      const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      for (let i = 0; i < parts.length; ++i) {
        const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join("."));
        schematype = schema.path(subpath);
        if (schematype == null) {
          continue;
        }
        type = schema.pathType(subpath);
        if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
          const key = get(schematype, "schema.options.discriminatorKey");
          const discriminatorValuePath = subpath + "." + key;
          const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
          let discriminatorKey = null;
          if (discriminatorValuePath in filter) {
            discriminatorKey = filter[discriminatorValuePath];
          }
          if (discriminatorFilterPath in filter) {
            discriminatorKey = filter[discriminatorFilterPath];
          }
          const wrapperPath = subpath.replace(/\.\d+$/, "");
          if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], "$elemMatch." + key) != null) {
            discriminatorKey = filter[wrapperPath].$elemMatch[key];
          }
          if (discriminatorValuePath in update) {
            discriminatorKey = update[discriminatorValuePath];
          }
          for (const filterKey of Object.keys(updatedPathsByFilter)) {
            const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
            const arrayFilterKey = filterKey + "." + key;
            if (schemaKey === discriminatorFilterPath) {
              const filter2 = arrayFilters.find((filter3) => filter3.hasOwnProperty(arrayFilterKey));
              if (filter2 != null) {
                discriminatorKey = filter2[arrayFilterKey];
              }
            }
          }
          if (discriminatorKey == null) {
            continue;
          }
          const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;
          const rest = parts.slice(i + 1).join(".");
          schematype = discriminatorSchema.path(rest);
          if (schematype != null) {
            type = discriminatorSchema._getPathType(rest);
            break;
          }
        }
      }
      return { type, schematype };
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/handleImmutable.js
var require_handleImmutable2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/handleImmutable.js"(exports2, module2) {
    "use strict";
    var StrictModeError = require_strict();
    module2.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {
      if (schematype == null || !schematype.options || !schematype.options.immutable) {
        return false;
      }
      let immutable = schematype.options.immutable;
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return false;
      }
      if (strict === false) {
        return false;
      }
      if (strict === "throw") {
        throw new StrictModeError(
          null,
          `Field ${fullPath} is immutable and strict = 'throw'`
        );
      }
      delete obj[key];
      return true;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js
var require_moveImmutableProperties = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function moveImmutableProperties(schema, update, ctx) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      for (const key of keys) {
        const isDollarKey = key.startsWith("$");
        if (key === "$set") {
          const updatedPaths = Object.keys(update[key]);
          for (const path of updatedPaths) {
            _walkUpdatePath(schema, update[key], path, update, ctx);
          }
        } else if (!isDollarKey) {
          _walkUpdatePath(schema, update, key, update, ctx);
        }
      }
    };
    function _walkUpdatePath(schema, op, path, update, ctx) {
      const schematype = schema.path(path);
      if (schematype == null) {
        return;
      }
      let immutable = get(schematype, "options.immutable", null);
      if (immutable == null) {
        return;
      }
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return;
      }
      update.$setOnInsert = update.$setOnInsert || {};
      update.$setOnInsert[path] = op[path];
      delete op[path];
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/path/setDottedPath.js
var require_setDottedPath = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/path/setDottedPath.js"(exports2, module2) {
    "use strict";
    var specialProperties = require_specialProperties();
    module2.exports = function setDottedPath(obj, path, val) {
      if (path.indexOf(".") === -1) {
        if (specialProperties.has(path)) {
          return;
        }
        obj[path] = val;
        return;
      }
      const parts = path.split(".");
      const last = parts.pop();
      let cur = obj;
      for (const part of parts) {
        if (specialProperties.has(part)) {
          continue;
        }
        if (cur[part] == null) {
          cur[part] = {};
        }
        cur = cur[part];
      }
      if (!specialProperties.has(last)) {
        cur[last] = val;
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/castUpdate.js
var require_castUpdate = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/castUpdate.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var MongooseError = require_mongooseError();
    var StrictModeError = require_strict();
    var ValidationError2 = require_validation();
    var castNumber = require_number();
    var cast = require_cast2();
    var getConstructorName = require_getConstructorName();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath2();
    var handleImmutable = require_handleImmutable2();
    var moveImmutableProperties = require_moveImmutableProperties();
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var setDottedPath = require_setDottedPath();
    var utils = require_utils6();
    module2.exports = function castUpdate(schema, obj, options, context, filter) {
      if (obj == null) {
        return void 0;
      }
      options = options || {};
      if (Array.isArray(obj)) {
        const len = obj.length;
        for (let i2 = 0; i2 < len; ++i2) {
          const ops2 = Object.keys(obj[i2]);
          for (const op of ops2) {
            obj[i2][op] = castPipelineOperator(op, obj[i2][op]);
          }
        }
        return obj;
      }
      if (options.upsert && !options.overwrite) {
        moveImmutableProperties(schema, obj, context);
      }
      const ops = Object.keys(obj);
      let i = ops.length;
      const ret = {};
      let val;
      let hasDollarKey = false;
      const overwrite = options.overwrite;
      filter = filter || {};
      while (i--) {
        const op = ops[i];
        if (op[0] !== "$" && !overwrite) {
          if (!ret.$set) {
            if (obj.$set) {
              ret.$set = obj.$set;
            } else {
              ret.$set = {};
            }
          }
          ret.$set[op] = obj[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set")) ops.push("$set");
        } else if (op === "$set") {
          if (!ret.$set) {
            ret[op] = obj[op];
          }
        } else {
          ret[op] = obj[op];
        }
      }
      i = ops.length;
      while (i--) {
        const op = ops[i];
        val = ret[op];
        hasDollarKey = hasDollarKey || op.startsWith("$");
        if (val && typeof val === "object" && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {
          walkUpdatePath(schema, val, op, options, context, filter);
        } else if (overwrite && ret && typeof ret === "object") {
          walkUpdatePath(schema, ret, "$set", options, context, filter);
        } else {
          const msg = "Invalid atomic update value for " + op + ". Expected an object, received " + typeof val;
          throw new Error(msg);
        }
        if (op.startsWith("$") && utils.isEmptyObject(val)) {
          delete ret[op];
        }
      }
      if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {
        return { $setOnInsert: filter };
      }
      return ret;
    };
    function castPipelineOperator(op, val) {
      if (op === "$unset") {
        if (typeof val !== "string" && (!Array.isArray(val) || val.find((v) => typeof v !== "string"))) {
          throw new MongooseError("Invalid $unset in pipeline, must be  a string or an array of strings");
        }
        return val;
      }
      if (op === "$project") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid $project in pipeline, must be an object");
        }
        return val;
      }
      if (op === "$addFields" || op === "$set") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      } else if (op === "$replaceRoot" || op === "$replaceWith") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      }
      throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
    }
    function walkUpdatePath(schema, obj, op, options, context, filter, pref) {
      const strict = options.strict;
      const prefix = pref ? pref + "." : "";
      const keys = Object.keys(obj);
      let i = keys.length;
      let hasKeys = false;
      let schematype;
      let key;
      let val;
      let aggregatedError = null;
      const strictMode = strict != null ? strict : schema.options.strict;
      while (i--) {
        key = keys[i];
        val = obj[key];
        if (op === "$pull") {
          schematype = schema._getSchema(prefix + key);
          if (schematype != null && schematype.schema != null) {
            obj[key] = cast(schematype.schema, obj[key], options, context);
            hasKeys = true;
            continue;
          }
        }
        const discriminatorKey = prefix ? prefix + key : key;
        if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {
          if (strictMode === "throw") {
            const err = new Error(`Can't modify discriminator key "` + discriminatorKey + '" on discriminator model');
            aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);
            continue;
          } else if (strictMode) {
            delete obj[key];
            continue;
          }
        }
        if (getConstructorName(val) === "Object") {
          schematype = schema._getSchema(prefix + key);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
            if (_res.schematype != null) {
              schematype = _res.schematype;
            }
          }
          if (op !== "$setOnInsert" && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
            continue;
          }
          if (schematype && schematype.caster && op in castOps) {
            if ("$each" in val) {
              hasKeys = true;
              try {
                obj[key] = {
                  $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
                };
              } catch (error) {
                aggregatedError = _appendError(error, context, key, aggregatedError);
              }
              if (val.$slice != null) {
                obj[key].$slice = val.$slice | 0;
              }
              if (val.$sort) {
                obj[key].$sort = val.$sort;
              }
              if (val.$position != null) {
                obj[key].$position = castNumber(val.$position);
              }
            } else {
              if (schematype != null && schematype.$isSingleNested) {
                const _strict = strict == null ? schematype.schema.options.strict : strict;
                try {
                  obj[key] = schematype.castForQuery(val, context, { strict: _strict });
                } catch (error) {
                  aggregatedError = _appendError(error, context, key, aggregatedError);
                }
              } else {
                try {
                  obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
                } catch (error) {
                  aggregatedError = _appendError(error, context, key, aggregatedError);
                }
              }
              if (obj[key] === void 0) {
                delete obj[key];
                continue;
              }
              hasKeys = true;
            }
          } else if (op === "$currentDate" || op in castOps && schematype) {
            try {
              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } catch (error) {
              aggregatedError = _appendError(error, context, key, aggregatedError);
            }
            if (obj[key] === void 0) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          } else {
            const pathToCheck = prefix + key;
            const v = schema._getPathType(pathToCheck);
            let _strict = strict;
            if (v && v.schema && _strict == null) {
              _strict = v.schema.options.strict;
            }
            if (v.pathType === "undefined") {
              if (_strict === "throw") {
                throw new StrictModeError(pathToCheck);
              } else if (_strict) {
                delete obj[key];
                continue;
              }
            }
            hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;
          }
        } else {
          const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
          schematype = schema._getSchema(checkPath);
          if (op !== "$setOnInsert" && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
            continue;
          }
          let pathDetails = schema._getPathType(checkPath);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);
            if (_res.schematype != null) {
              schematype = _res.schematype;
              pathDetails = _res.type;
            }
          }
          let isStrict = strict;
          if (pathDetails && pathDetails.schema && strict == null) {
            isStrict = pathDetails.schema.options.strict;
          }
          const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
          if (skip) {
            if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
              throw new StrictModeError(prefix + key);
            } else {
              delete obj[key];
            }
          } else {
            if (op === "$rename") {
              hasKeys = true;
              continue;
            }
            try {
              if (prefix.length === 0 || key.indexOf(".") === -1) {
                obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
              } else {
                setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
                delete obj[key];
              }
            } catch (error) {
              aggregatedError = _appendError(error, context, key, aggregatedError);
            }
            if (Array.isArray(obj[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
              if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {
                obj[key] = { $each: obj[key] };
              }
            }
            if (obj[key] === void 0) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          }
        }
      }
      if (aggregatedError != null) {
        throw aggregatedError;
      }
      return hasKeys;
    }
    function _appendError(error, query, key, aggregatedError) {
      if (typeof query !== "object" || !query.options.multipleCastError) {
        throw error;
      }
      aggregatedError = aggregatedError || new ValidationError2();
      aggregatedError.addError(key, error);
      return aggregatedError;
    }
    var numberOps = {
      $pop: 1,
      $inc: 1
    };
    var noCastOps = {
      $unset: 1
    };
    var castOps = {
      $push: 1,
      $addToSet: 1,
      $set: 1,
      $setOnInsert: 1
    };
    var overwriteOps = {
      $set: 1,
      $setOnInsert: 1
    };
    function castUpdateVal(schema, val, op, $conditional, context, path) {
      if (!schema) {
        if (op in numberOps) {
          try {
            return castNumber(val);
          } catch (err) {
            throw new CastError("number", val, path);
          }
        }
        return val;
      }
      const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));
      if (cond && !overwriteOps[op]) {
        let schemaArrayDepth = 0;
        let cur = schema;
        while (cur.$isMongooseArray) {
          ++schemaArrayDepth;
          cur = cur.caster;
        }
        let arrayDepth = 0;
        let _val = val;
        while (Array.isArray(_val)) {
          ++arrayDepth;
          _val = _val[0];
        }
        const additionalNesting = schemaArrayDepth - arrayDepth;
        while (arrayDepth < schemaArrayDepth) {
          val = [val];
          ++arrayDepth;
        }
        let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);
        for (let i = 0; i < additionalNesting; ++i) {
          tmp = tmp[0];
        }
        return tmp;
      }
      if (op in noCastOps) {
        return val;
      }
      if (op in numberOps) {
        if (val == null) {
          throw new CastError("number", val, schema.path);
        }
        if (op === "$inc") {
          return schema.castForQueryWrapper({
            val,
            context
          });
        }
        try {
          return castNumber(val);
        } catch (error) {
          throw new CastError("number", val, schema.path);
        }
      }
      if (op === "$currentDate") {
        if (typeof val === "object") {
          return { $type: val.$type };
        }
        return Boolean(val);
      }
      if (/^\$/.test($conditional)) {
        return schema.castForQueryWrapper({
          $conditional,
          val,
          context
        });
      }
      if (overwriteOps[op]) {
        return schema.castForQueryWrapper({
          val,
          context,
          $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/),
          $applySetters: schema[schemaMixedSymbol] != null
        });
      }
      return schema.castForQueryWrapper({ val, context });
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/completeMany.js
var require_completeMany = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/completeMany.js"(exports2, module2) {
    "use strict";
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    module2.exports = completeMany;
    function completeMany(model, docs, fields, userProvidedFields, opts, callback) {
      const arr = [];
      let count = docs.length;
      const len = count;
      let error = null;
      function init(_error) {
        if (_error != null) {
          error = error || _error;
        }
        if (error != null) {
          --count || immediate(() => callback(error));
          return;
        }
        --count || immediate(() => callback(error, arr));
      }
      for (let i = 0; i < len; ++i) {
        arr[i] = helpers.createModel(model, docs[i], fields, userProvidedFields);
        try {
          arr[i].$init(docs[i], opts, init);
        } catch (error2) {
          init(error2);
        }
        if (opts.session != null) {
          arr[i].$session(opts.session);
        }
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js
var require_hasDollarKeys = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasDollarKeys(obj) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      const keys = Object.keys(obj);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        if (keys[i][0] === "$") {
          return true;
        }
      }
      return false;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/isInclusive.js
var require_isInclusive = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/isInclusive.js"(exports2, module2) {
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isInclusive(projection) {
      if (projection == null) {
        return false;
      }
      const props = Object.keys(projection);
      const numProps = props.length;
      if (numProps === 0) {
        return false;
      }
      for (let i = 0; i < numProps; ++i) {
        const prop = props[i];
        if (prop.startsWith("+")) {
          continue;
        }
        if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
          if (projection[prop] != null && typeof projection[prop] === "object") {
            return isInclusive(projection[prop]);
          } else {
            return !!projection[prop];
          }
        }
      }
      return false;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/isSubpath.js
var require_isSubpath = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/isSubpath.js"(exports2, module2) {
    "use strict";
    module2.exports = function isSubpath(path1, path2) {
      return path1 === path2 || path2.startsWith(path1 + ".");
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/parseProjection.js
var require_parseProjection = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/parseProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function parseProjection(v, retainMinusPaths) {
      const type = typeof v;
      if (type === "string") {
        v = v.split(/\s+/);
      }
      if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
        return v;
      }
      const len = v.length;
      const ret = {};
      for (let i = 0; i < len; ++i) {
        let field = v[i];
        if (!field) {
          continue;
        }
        const include = "-" == field[0] ? 0 : 1;
        if (!retainMinusPaths && include === 0) {
          field = field.substring(1);
        }
        ret[field] = include;
      }
      return ret;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js
var require_removeUnusedArrayFilters = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js"(exports2, module2) {
    "use strict";
    module2.exports = function removeUnusedArrayFilters(update, arrayFilters) {
      const updateKeys = Object.keys(update).map((key) => Object.keys(update[key])).reduce((cur, arr) => cur.concat(arr), []);
      return arrayFilters.filter((obj) => {
        return _checkSingleFilterKey(obj, updateKeys);
      });
    };
    function _checkSingleFilterKey(arrayFilter, updateKeys) {
      const firstKey = Object.keys(arrayFilter)[0];
      if (firstKey === "$and" || firstKey === "$or") {
        if (!Array.isArray(arrayFilter[firstKey])) {
          return false;
        }
        return arrayFilter[firstKey].find((filter) => _checkSingleFilterKey(filter, updateKeys)) != null;
      }
      const firstDot = firstKey.indexOf(".");
      const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
      return updateKeys.find((key) => key.includes("$[" + arrayFilterKey + "]")) != null;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js
var require_sanitizeFilter = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js"(exports2, module2) {
    "use strict";
    var hasDollarKeys = require_hasDollarKeys();
    var { trustedSymbol } = require_trusted();
    module2.exports = function sanitizeFilter(filter) {
      if (filter == null || typeof filter !== "object") {
        return filter;
      }
      if (Array.isArray(filter)) {
        for (const subfilter of filter) {
          sanitizeFilter(subfilter);
        }
        return filter;
      }
      const filterKeys = Object.keys(filter);
      for (const key of filterKeys) {
        const value = filter[key];
        if (value != null && value[trustedSymbol]) {
          continue;
        }
        if (key === "$and" || key === "$or") {
          sanitizeFilter(value);
          continue;
        }
        if (hasDollarKeys(value)) {
          const keys = Object.keys(value);
          if (keys.length === 1 && keys[0] === "$eq") {
            continue;
          }
          filter[key] = { $eq: filter[key] };
        }
      }
      return filter;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js
var require_sanitizeProjection = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function sanitizeProjection(projection) {
      if (projection == null) {
        return;
      }
      const keys = Object.keys(projection);
      for (let i = 0; i < keys.length; ++i) {
        if (typeof projection[keys[i]] === "string") {
          projection[keys[i]] = 1;
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js
var require_selectPopulatedFields = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js"(exports2, module2) {
    "use strict";
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    module2.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
      if (populateOptions == null) {
        return;
      }
      const paths = Object.keys(populateOptions);
      userProvidedFields = userProvidedFields || {};
      if (isInclusive(fields)) {
        for (const path of paths) {
          if (!isPathInFields(userProvidedFields, path)) {
            fields[path] = 1;
          } else if (userProvidedFields[path] === 0) {
            delete fields[path];
          }
        }
      } else if (isExclusive(fields)) {
        for (const path of paths) {
          if (userProvidedFields[path] == null) {
            delete fields[path];
          }
        }
      }
    };
    function isPathInFields(userProvidedFields, path) {
      const pieces = path.split(".");
      const len = pieces.length;
      let cur = pieces[0];
      for (let i = 1; i < len; ++i) {
        if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
          return true;
        }
        cur += "." + pieces[i];
      }
      return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js
var require_setDefaultsOnInsert = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"(exports2, module2) {
    "use strict";
    var modifiedPaths = require_common5().modifiedPaths;
    var get = require_get();
    module2.exports = function(filter, schema, castedDoc, options) {
      options = options || {};
      const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
      if (!options.upsert || shouldSetDefaultsOnInsert === false) {
        return castedDoc;
      }
      const keys = Object.keys(castedDoc || {});
      const updatedKeys = {};
      const updatedValues = {};
      const numKeys = keys.length;
      const modified = {};
      let hasDollarUpdate = false;
      for (let i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          modifiedPaths(castedDoc[keys[i]], "", modified);
          hasDollarUpdate = true;
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
      }
      const paths = Object.keys(filter);
      const numPaths = paths.length;
      for (let i = 0; i < numPaths; ++i) {
        const path = paths[i];
        const condition = filter[path];
        if (condition && typeof condition === "object") {
          const conditionKeys = Object.keys(condition);
          const numConditionKeys = conditionKeys.length;
          let hasDollarKey = false;
          for (let j = 0; j < numConditionKeys; ++j) {
            if (conditionKeys[j].startsWith("$")) {
              hasDollarKey = true;
              break;
            }
          }
          if (hasDollarKey) {
            continue;
          }
        }
        updatedKeys[path] = true;
        modified[path] = true;
      }
      if (options && options.overwrite && !hasDollarUpdate) {
        return castedDoc;
      }
      schema.eachPath(function(path, schemaType) {
        if (schemaType.path === "_id" && schemaType.options.auto) {
          return;
        }
        const def = schemaType.getDefault(null, true);
        if (isModified(modified, path)) {
          return;
        }
        if (typeof def === "undefined") {
          return;
        }
        if (schemaType.splitPath().includes("$*")) {
          return;
        }
        castedDoc = castedDoc || {};
        castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
        if (get(castedDoc, path) == null) {
          castedDoc.$setOnInsert[path] = def;
        }
        updatedValues[path] = def;
      });
      return castedDoc;
    };
    function isModified(modified, path) {
      if (modified[path]) {
        return true;
      }
      const sp = path.split(".");
      let cur = sp[0];
      for (let i = 1; i < sp.length; ++i) {
        if (modified[cur]) {
          return true;
        }
        cur += "." + sp[i];
      }
      const modifiedKeys = Object.keys(modified);
      if (modifiedKeys.length) {
        const parentPath = path + ".";
        for (const modifiedPath of modifiedKeys) {
          if (modifiedPath.slice(0, path.length + 1) === parentPath) {
            return true;
          }
        }
      }
      return false;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/updateValidators.js
var require_updateValidators = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/updateValidators.js"(exports2, module2) {
    "use strict";
    var ValidationError2 = require_validation();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var flatten = require_common5().flatten;
    var modifiedPaths = require_common5().modifiedPaths;
    module2.exports = function(query, schema, castedDoc, options, callback) {
      const keys = Object.keys(castedDoc || {});
      let updatedKeys = {};
      let updatedValues = {};
      const isPull = {};
      const arrayAtomicUpdates = {};
      const numKeys = keys.length;
      let hasDollarUpdate = false;
      const modified = {};
      let currentUpdate;
      let key;
      let i;
      for (i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          hasDollarUpdate = true;
          if (keys[i] === "$push" || keys[i] === "$addToSet") {
            const _keys = Object.keys(castedDoc[keys[i]]);
            for (let ii = 0; ii < _keys.length; ++ii) {
              currentUpdate = castedDoc[keys[i]][_keys[ii]];
              if (currentUpdate && currentUpdate.$each) {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
              } else {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
              }
            }
            continue;
          }
          modifiedPaths(castedDoc[keys[i]], "", modified);
          const flat = flatten(castedDoc[keys[i]], null, null, schema);
          const paths = Object.keys(flat);
          const numPaths = paths.length;
          for (let j = 0; j < numPaths; ++j) {
            const updatedPath = cleanPositionalOperators(paths[j]);
            key = keys[i];
            if (updatedPath.includes("$")) {
              continue;
            }
            if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
              updatedValues[updatedPath] = flat[paths[j]];
              isPull[updatedPath] = key === "$pull" || key === "$pullAll";
            } else if (key === "$unset") {
              updatedValues[updatedPath] = void 0;
            }
            updatedKeys[updatedPath] = true;
          }
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
        updatedValues = flatten(castedDoc, null, null, schema);
        updatedKeys = Object.keys(updatedValues);
      }
      const updates = Object.keys(updatedValues);
      const numUpdates = updates.length;
      const validatorsToExecute = [];
      const validationErrors = [];
      const alreadyValidated = [];
      const context = query;
      function iter(i2, v) {
        const schemaPath = schema._getSchema(updates[i2]);
        if (schemaPath == null) {
          return;
        }
        if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i2]) {
          return;
        }
        if (v && Array.isArray(v.$in)) {
          v.$in.forEach((v2, i3) => {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(
                v2,
                function(err) {
                  if (err) {
                    err.path = updates[i3] + ".$in." + i3;
                    validationErrors.push(err);
                  }
                  callback2(null);
                },
                context,
                { updateValidator: true }
              );
            });
          });
        } else {
          if (isPull[updates[i2]] && schemaPath.$isMongooseArray) {
            return;
          }
          if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
            alreadyValidated.push(updates[i2]);
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(v, function(err) {
                if (err) {
                  if (err.errors) {
                    for (const key2 of Object.keys(err.errors)) {
                      const _err = err.errors[key2];
                      _err.path = updates[i2] + "." + key2;
                      validationErrors.push(_err);
                    }
                  } else {
                    err.path = updates[i2];
                    validationErrors.push(err);
                  }
                }
                return callback2(null);
              }, context, { updateValidator: true });
            });
          } else {
            validatorsToExecute.push(function(callback2) {
              for (const path of alreadyValidated) {
                if (updates[i2].startsWith(path + ".")) {
                  return callback2(null);
                }
              }
              schemaPath.doValidate(v, function(err) {
                if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError2) {
                  return callback2(null);
                }
                if (err) {
                  err.path = updates[i2];
                  validationErrors.push(err);
                }
                callback2(null);
              }, context, { updateValidator: true });
            });
          }
        }
      }
      for (i = 0; i < numUpdates; ++i) {
        iter(i, updatedValues[updates[i]]);
      }
      const arrayUpdates = Object.keys(arrayAtomicUpdates);
      for (const arrayUpdate of arrayUpdates) {
        let schemaPath = schema._getSchema(arrayUpdate);
        if (schemaPath && schemaPath.$isMongooseDocumentArray) {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(
              arrayAtomicUpdates[arrayUpdate],
              getValidationCallback(arrayUpdate, validationErrors, callback2),
              options && options.context === "query" ? query : null
            );
          });
        } else {
          schemaPath = schema._getSchema(arrayUpdate + ".0");
          for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(
                atomicUpdate,
                getValidationCallback(arrayUpdate, validationErrors, callback2),
                options && options.context === "query" ? query : null,
                { updateValidator: true }
              );
            });
          }
        }
      }
      if (callback != null) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback);
            }
          });
        }
        return;
      }
      return function(callback2) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback2);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback2);
            }
          });
        }
      };
      function _done(callback2) {
        if (validationErrors.length) {
          const err = new ValidationError2(null);
          for (const validationError of validationErrors) {
            err.addError(validationError.path, validationError);
          }
          return callback2(err);
        }
        callback2(null);
      }
      function getValidationCallback(arrayUpdate, validationErrors2, callback2) {
        return function(err) {
          if (err) {
            err.path = arrayUpdate;
            validationErrors2.push(err);
          }
          callback2(null);
        };
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/query/wrapThunk.js
var require_wrapThunk = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/query/wrapThunk.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    module2.exports = function wrapThunk(fn) {
      return function _wrappedThunk(cb) {
        if (this._executionStack != null) {
          let str = this.toString();
          if (str.length > 60) {
            str = str.slice(0, 60) + "...";
          }
          const err = new MongooseError("Query was already executed: " + str);
          err.originalStack = this._executionStack.stack;
          return cb(err);
        }
        this._executionStack = new Error();
        fn.call(this, cb);
      };
    };
  }
});

// asset-input/node_modules/mongoose/lib/query.js
var require_query = __commonJS({
  "asset-input/node_modules/mongoose/lib/query.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var DocumentNotFoundError = require_notFound();
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var ObjectParameterError = require_objectParameter();
    var QueryCursor = require_QueryCursor();
    var ReadPreference = require_driver().get().ReadPreference;
    var ValidationError2 = require_validation();
    var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
    var applyWriteConcern = require_applyWriteConcern();
    var cast = require_cast2();
    var castArrayFilters = require_castArrayFilters();
    var castNumber = require_number();
    var castUpdate = require_castUpdate();
    var completeMany = require_completeMany();
    var promiseOrCallback = require_promiseOrCallback();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var hasDollarKeys = require_hasDollarKeys();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    var isSubpath = require_isSubpath();
    var mpath = require_mpath();
    var mquery = require_mquery();
    var parseProjection = require_parseProjection();
    var removeUnusedArrayFilters = require_removeUnusedArrayFilters();
    var sanitizeFilter = require_sanitizeFilter();
    var sanitizeProjection = require_sanitizeProjection();
    var selectPopulatedFields = require_selectPopulatedFields();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    var updateValidators = require_updateValidators();
    var util2 = require("util");
    var utils = require_utils6();
    var validOps = require_validOps();
    var wrapThunk = require_wrapThunk();
    var queryOptionMethods = /* @__PURE__ */ new Set([
      "allowDiskUse",
      "batchSize",
      "collation",
      "comment",
      "explain",
      "hint",
      "j",
      "lean",
      "limit",
      "maxScan",
      "maxTimeMS",
      "maxscan",
      "populate",
      "projection",
      "read",
      "select",
      "skip",
      "slice",
      "sort",
      "tailable",
      "w",
      "writeConcern",
      "wtimeout"
    ]);
    function Query(conditions, options, model, collection) {
      if (!this._mongooseOptions) {
        this._mongooseOptions = {};
      }
      options = options || {};
      this._transforms = [];
      this._hooks = new Kareem();
      this._executionStack = null;
      const keys = Object.keys(options);
      for (const key of keys) {
        this._mongooseOptions[key] = options[key];
      }
      if (collection) {
        this.mongooseCollection = collection;
      }
      if (model) {
        this.model = model;
        this.schema = model.schema;
      }
      if (this.model && this.model._mapreduce) {
        this.lean();
      }
      mquery.call(this, null, options);
      if (collection) {
        this.collection(collection);
      }
      if (conditions) {
        this.find(conditions);
      }
      this.options = this.options || {};
      this.$useProjection = true;
      const collation = this && this.schema && this.schema.options && this.schema.options.collation || null;
      if (collation != null) {
        this.options.collation = collation;
      }
    }
    Query.prototype = new mquery();
    Query.prototype.constructor = Query;
    Query.base = mquery.prototype;
    Query.use$geoWithin = mquery.use$geoWithin;
    Query.prototype.toConstructor = function toConstructor() {
      const model = this.model;
      const coll = this.mongooseCollection;
      const CustomQuery = function(criteria, options2) {
        if (!(this instanceof CustomQuery)) {
          return new CustomQuery(criteria, options2);
        }
        this._mongooseOptions = utils.clone(p._mongooseOptions);
        Query.call(this, criteria, options2 || null, model, coll);
      };
      util2.inherits(CustomQuery, model.Query);
      const p = CustomQuery.prototype;
      p.options = {};
      const options = Object.assign({}, this.options);
      if (options.sort != null) {
        p.sort(options.sort);
        delete options.sort;
      }
      p.setOptions(options);
      p.op = this.op;
      p._validateOp();
      p._conditions = utils.clone(this._conditions);
      p._fields = utils.clone(this._fields);
      p._update = utils.clone(this._update, {
        flattenDecimals: false
      });
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._mongooseOptions = this._mongooseOptions;
      return CustomQuery;
    };
    Query.prototype.clone = function clone() {
      const model = this.model;
      const collection = this.mongooseCollection;
      const q = new this.model.Query({}, {}, model, collection);
      const options = Object.assign({}, this.options);
      if (options.sort != null) {
        q.sort(options.sort);
        delete options.sort;
      }
      q.setOptions(options);
      q.op = this.op;
      q._validateOp();
      q._conditions = utils.clone(this._conditions);
      q._fields = utils.clone(this._fields);
      q._update = utils.clone(this._update, {
        flattenDecimals: false
      });
      q._path = this._path;
      q._distinct = this._distinct;
      q._collection = this._collection;
      q._mongooseOptions = this._mongooseOptions;
      return q;
    };
    Query.prototype.slice = function() {
      if (arguments.length === 0) {
        return this;
      }
      this._validate("slice");
      let path;
      let val;
      if (arguments.length === 1) {
        const arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          const keys = Object.keys(arg);
          const numKeys = keys.length;
          for (let i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        if ("number" === typeof arguments[0]) {
          this._ensurePath("slice");
          path = this._path;
          val = [arguments[0], arguments[1]];
        } else {
          path = arguments[0];
          val = arguments[1];
        }
      } else if (arguments.length === 3) {
        path = arguments[0];
        val = [arguments[1], arguments[2]];
      }
      const p = {};
      p[path] = { $slice: val };
      this.select(p);
      return this;
    };
    var validOpsSet = new Set(validOps);
    Query.prototype._validateOp = function() {
      if (this.op != null && !validOpsSet.has(this.op)) {
        this.error(new Error('Query has invalid `op`: "' + this.op + '"'));
      }
    };
    Query.prototype.mod = function() {
      let val;
      let path;
      if (arguments.length === 1) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
      } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = [arguments[0], arguments[1]];
        path = this._path;
      } else if (arguments.length === 3) {
        val = [arguments[1], arguments[2]];
        path = arguments[0];
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.limit = function limit(v) {
      this._validate("limit");
      if (typeof v === "string") {
        try {
          v = castNumber(v);
        } catch (err) {
          throw new CastError("Number", v, "limit");
        }
      }
      this.options.limit = v;
      return this;
    };
    Query.prototype.skip = function skip(v) {
      this._validate("skip");
      if (typeof v === "string") {
        try {
          v = castNumber(v);
        } catch (err) {
          throw new CastError("Number", v, "skip");
        }
      }
      this.options.skip = v;
      return this;
    };
    Query.prototype.projection = function(arg) {
      if (arguments.length === 0) {
        return this._fields;
      }
      this._fields = {};
      this._userProvidedFields = {};
      this.select(arg);
      return this._fields;
    };
    Query.prototype.select = function select() {
      let arg = arguments[0];
      if (!arg) return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      const fields = this._fields || (this._fields = {});
      const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
      let sanitizeProjection2 = void 0;
      if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.db.options.sanitizeProjection;
      } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.base.options.sanitizeProjection;
      } else {
        sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
      }
      function sanitizeValue(value) {
        return typeof value === "string" && sanitizeProjection2 ? value = 1 : value;
      }
      arg = parseProjection(arg);
      if (utils.isObject(arg)) {
        if (this.selectedInclusively()) {
          Object.entries(arg).forEach(([key, value]) => {
            if (value) {
              fields[key] = userProvidedFields[key] = sanitizeValue(value);
            } else {
              Object.keys(userProvidedFields).forEach((field) => {
                if (isSubpath(key, field)) {
                  delete fields[field];
                  delete userProvidedFields[field];
                }
              });
            }
          });
        } else if (this.selectedExclusively()) {
          Object.entries(arg).forEach(([key, value]) => {
            if (!value) {
              fields[key] = userProvidedFields[key] = sanitizeValue(value);
            } else {
              Object.keys(userProvidedFields).forEach((field) => {
                if (isSubpath(key, field)) {
                  delete fields[field];
                  delete userProvidedFields[field];
                }
              });
            }
          });
        } else {
          const keys = Object.keys(arg);
          for (let i = 0; i < keys.length; ++i) {
            const value = arg[keys[i]];
            fields[keys[i]] = sanitizeValue(value);
            userProvidedFields[keys[i]] = sanitizeValue(value);
          }
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.read = function read(pref, tags) {
      const read2 = new ReadPreference(pref, tags);
      this.options.readPreference = read2;
      return this;
    };
    Query.prototype.toString = function toString2() {
      if (this.op === "count" || this.op === "countDocuments" || this.op === "find" || this.op === "findOne" || this.op === "deleteMany" || this.op === "deleteOne" || this.op === "findOneAndDelete" || this.op === "findOneAndRemove" || this.op === "remove") {
        return `${this.model.modelName}.${this.op}(${util2.inspect(this._conditions)})`;
      }
      if (this.op === "distinct") {
        return `${this.model.modelName}.distinct('${this._distinct}', ${util2.inspect(this._conditions)})`;
      }
      if (this.op === "findOneAndReplace" || this.op === "findOneAndUpdate" || this.op === "replaceOne" || this.op === "update" || this.op === "updateMany" || this.op === "updateOne") {
        return `${this.model.modelName}.${this.op}(${util2.inspect(this._conditions)}, ${util2.inspect(this._update)})`;
      }
      return `${this.model.modelName}.${this.op}()`;
    };
    Query.prototype.session = function session(v) {
      if (v == null) {
        delete this.options.session;
      }
      this.options.session = v;
      return this;
    };
    Query.prototype.writeConcern = function writeConcern(val) {
      if (val == null) {
        delete this.options.writeConcern;
        return this;
      }
      this.options.writeConcern = val;
      return this;
    };
    Query.prototype.w = function w(val) {
      if (val == null) {
        delete this.options.w;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.w = val;
      } else {
        this.options.w = val;
      }
      return this;
    };
    Query.prototype.j = function j(val) {
      if (val == null) {
        delete this.options.j;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.j = val;
      } else {
        this.options.j = val;
      }
      return this;
    };
    Query.prototype.wtimeout = function wtimeout(ms) {
      if (ms == null) {
        delete this.options.wtimeout;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.wtimeout = ms;
      } else {
        this.options.wtimeout = ms;
      }
      return this;
    };
    Query.prototype.getOptions = function() {
      return this.options;
    };
    Query.prototype.setOptions = function(options, overwrite) {
      if (overwrite) {
        this._mongooseOptions = options && utils.clone(options) || {};
        this.options = options || {};
        if ("populate" in options) {
          this.populate(this._mongooseOptions);
        }
        return this;
      }
      if (options == null) {
        return this;
      }
      if (typeof options !== "object") {
        throw new Error('Options must be an object, got "' + options + '"');
      }
      options = Object.assign({}, options);
      if (Array.isArray(options.populate)) {
        const populate = options.populate;
        delete options.populate;
        const _numPopulate = populate.length;
        for (let i = 0; i < _numPopulate; ++i) {
          this.populate(populate[i]);
        }
      }
      if ("setDefaultsOnInsert" in options) {
        this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
        delete options.setDefaultsOnInsert;
      }
      if ("overwriteDiscriminatorKey" in options) {
        this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
        delete options.overwriteDiscriminatorKey;
      }
      if ("sanitizeProjection" in options) {
        if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
          sanitizeProjection(this._fields);
        }
        this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
        delete options.sanitizeProjection;
      }
      if ("sanitizeFilter" in options) {
        this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;
        delete options.sanitizeFilter;
      }
      if ("defaults" in options) {
        this._mongooseOptions.defaults = options.defaults;
      }
      if (options.lean == null && this.schema && "lean" in this.schema.options) {
        this._mongooseOptions.lean = this.schema.options.lean;
      }
      if (typeof options.limit === "string") {
        try {
          options.limit = castNumber(options.limit);
        } catch (err) {
          throw new CastError("Number", options.limit, "limit");
        }
      }
      if (typeof options.skip === "string") {
        try {
          options.skip = castNumber(options.skip);
        } catch (err) {
          throw new CastError("Number", options.skip, "skip");
        }
      }
      for (const key of Object.keys(options)) {
        if (queryOptionMethods.has(key)) {
          const args = Array.isArray(options[key]) ? options[key] : [options[key]];
          this[key].apply(this, args);
        } else {
          this.options[key] = options[key];
        }
      }
      return this;
    };
    Query.prototype.explain = function(verbose) {
      if (arguments.length === 0) {
        this.options.explain = true;
      } else if (verbose === false) {
        delete this.options.explain;
      } else {
        this.options.explain = verbose;
      }
      return this;
    };
    Query.prototype.allowDiskUse = function(v) {
      if (arguments.length === 0) {
        this.options.allowDiskUse = true;
      } else if (v === false) {
        delete this.options.allowDiskUse;
      } else {
        this.options.allowDiskUse = v;
      }
      return this;
    };
    Query.prototype.maxTimeMS = function(ms) {
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.getFilter = function() {
      return this._conditions;
    };
    Query.prototype.getQuery = function() {
      return this._conditions;
    };
    Query.prototype.setQuery = function(val) {
      this._conditions = val;
    };
    Query.prototype.getUpdate = function() {
      return this._update;
    };
    Query.prototype.setUpdate = function(val) {
      this._update = val;
    };
    Query.prototype._fieldsForExec = function() {
      if (this._fields == null) {
        return null;
      }
      if (Object.keys(this._fields).length === 0) {
        return null;
      }
      return utils.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      const update = utils.clone(this._update, {
        transform: false,
        depopulate: true
      });
      const ops = Object.keys(update);
      let i = ops.length;
      const ret = {};
      while (i--) {
        const op = ops[i];
        if (this.options.overwrite) {
          ret[op] = update[op];
          continue;
        }
        if ("$" !== op[0]) {
          if (!ret.$set) {
            if (update.$set) {
              ret.$set = update.$set;
            } else {
              ret.$set = {};
            }
          }
          ret.$set[op] = update[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set")) ops.push("$set");
        } else if ("$set" === op) {
          if (!ret.$set) {
            ret[op] = update[op];
          }
        } else {
          ret[op] = update[op];
        }
      }
      return ret;
    };
    Query.prototype._optionsForExec = function(model) {
      const options = utils.clone(this.options);
      delete options.populate;
      model = model || this.model;
      if (!model) {
        return options;
      }
      applyWriteConcern(model.schema, options);
      const readPreference = model && model.schema && model.schema.options && model.schema.options.read;
      if (!("readPreference" in options) && readPreference) {
        options.readPreference = readPreference;
      }
      if (options.upsert !== void 0) {
        options.upsert = !!options.upsert;
      }
      if (options.writeConcern) {
        if (options.j) {
          options.writeConcern.j = options.j;
          delete options.j;
        }
        if (options.w) {
          options.writeConcern.w = options.w;
          delete options.w;
        }
        if (options.wtimeout) {
          options.writeConcern.wtimeout = options.wtimeout;
          delete options.wtimeout;
        }
      }
      this._applyPaths();
      if (this._fields != null) {
        this._fields = this._castFields(this._fields);
        const projection = this._fieldsForExec();
        if (projection != null) {
          options.projection = projection;
        }
      }
      return options;
    };
    Query.prototype.lean = function(v) {
      this._mongooseOptions.lean = arguments.length ? v : true;
      return this;
    };
    Query.prototype.set = function(path, val) {
      if (typeof path === "object") {
        const keys = Object.keys(path);
        for (const key of keys) {
          this.set(key, path[key]);
        }
        return this;
      }
      this._update = this._update || {};
      if (path in this._update) {
        delete this._update[path];
      }
      this._update.$set = this._update.$set || {};
      this._update.$set[path] = val;
      return this;
    };
    Query.prototype.get = function get(path) {
      const update = this._update;
      if (update == null) {
        return void 0;
      }
      const $set = update.$set;
      if ($set == null) {
        return update[path];
      }
      if (utils.hasUserDefinedProperty(update, path)) {
        return update[path];
      }
      if (utils.hasUserDefinedProperty($set, path)) {
        return $set[path];
      }
      return void 0;
    };
    Query.prototype.error = function error(err) {
      if (arguments.length === 0) {
        return this._error;
      }
      this._error = err;
      return this;
    };
    Query.prototype._unsetCastError = function _unsetCastError() {
      if (this._error != null && !(this._error instanceof CastError)) {
        return;
      }
      return this.error(null);
    };
    Query.prototype.mongooseOptions = function(v) {
      if (arguments.length > 0) {
        this._mongooseOptions = v;
      }
      return this._mongooseOptions;
    };
    Query.prototype._castConditions = function() {
      let sanitizeFilterOpt = void 0;
      if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeFilter")) {
        sanitizeFilterOpt = this.model.db.options.sanitizeFilter;
      } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeFilter")) {
        sanitizeFilterOpt = this.model.base.options.sanitizeFilter;
      } else {
        sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;
      }
      if (sanitizeFilterOpt) {
        sanitizeFilter(this._conditions);
      }
      try {
        this.cast(this.model);
        this._unsetCastError();
      } catch (err) {
        this.error(err);
      }
    };
    function _castArrayFilters(query) {
      try {
        castArrayFilters(query);
      } catch (err) {
        query.error(err);
      }
    }
    Query.prototype._find = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      const mongooseOptions = this._mongooseOptions;
      const _this = this;
      const userProvidedFields = _this._userProvidedFields || {};
      applyGlobalMaxTimeMS(this.options, this.model);
      applyGlobalDiskUse(this.options, this.model);
      const completeManyOptions = Object.assign({}, {
        session: this && this.options && this.options.session || null,
        lean: mongooseOptions.lean || null
      });
      const options = this._optionsForExec();
      const filter = this._conditions;
      const fields = options.projection;
      const cb = (err, docs) => {
        if (err) {
          return callback(err);
        }
        if (docs.length === 0) {
          return callback(null, docs);
        }
        if (this.options.explain) {
          return callback(null, docs);
        }
        if (!mongooseOptions.populate) {
          const versionKey = _this.schema.options.versionKey;
          if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
            docs.forEach((doc) => {
              if (versionKey in doc) {
                delete doc[versionKey];
              }
            });
          }
          return mongooseOptions.lean ? (
            // call _completeManyLean here?
            _completeManyLean(_this.model.schema, docs, null, completeManyOptions, callback)
          ) : (
            // callback(null, docs) :
            completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback)
          );
        }
        const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
        if (mongooseOptions.lean) {
          return _this.model.populate(docs, pop, callback);
        }
        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, (err2, docs2) => {
          if (err2 != null) {
            return callback(err2);
          }
          _this.model.populate(docs2, pop, callback);
        });
      };
      this._collection.collection.find(filter, options, (err, cursor) => {
        if (err != null) {
          return cb(err);
        }
        if (options.explain) {
          return cursor.explain(cb);
        }
        try {
          return cursor.toArray(cb);
        } catch (err2) {
          return cb(err2);
        }
      });
    });
    Query.prototype.find = function(conditions, callback) {
      this.op = "find";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      conditions = utils.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "find"));
      }
      if (!callback) {
        return Query.base.find.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source) {
        return this;
      }
      const opts = { overwrite: true };
      if (source instanceof Query) {
        if (source._conditions) {
          utils.merge(this._conditions, source._conditions, opts);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils.merge(this._fields, source._fields, opts);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils.merge(this.options, source.options, opts);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        utils.merge(this._mongooseOptions, source._mongooseOptions);
        return this;
      } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {
        utils.merge(this._conditions, { _id: source }, opts);
        return this;
      }
      utils.merge(this._conditions, source, opts);
      return this;
    };
    Query.prototype.collation = function(value) {
      if (this.options == null) {
        this.options = {};
      }
      this.options.collation = value;
      return this;
    };
    Query.prototype._completeOne = function(doc, res, callback) {
      if (!doc && !this.options.rawResult) {
        return callback(null, null);
      }
      const model = this.model;
      const projection = utils.clone(this._fields);
      const userProvidedFields = this._userProvidedFields || {};
      const mongooseOptions = this._mongooseOptions;
      const options = this.options;
      if (!options.lean && mongooseOptions.lean) {
        options.lean = mongooseOptions.lean;
      }
      if (options.explain) {
        return callback(null, doc);
      }
      if (!mongooseOptions.populate) {
        const versionKey = this.schema.options.versionKey;
        if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
          if (versionKey in doc) {
            delete doc[versionKey];
          }
        }
        return mongooseOptions.lean ? _completeOneLean(model.schema, doc, null, res, options, callback) : completeOne(
          model,
          doc,
          res,
          options,
          projection,
          userProvidedFields,
          null,
          callback
        );
      }
      const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
      if (mongooseOptions.lean) {
        return model.populate(doc, pop, (err, doc2) => {
          if (err != null) {
            return callback(err);
          }
          _completeOneLean(model.schema, doc2, null, res, options, callback);
        });
      }
      completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc2) => {
        if (err != null) {
          return callback(err);
        }
        model.populate(doc2, pop, callback);
      });
    };
    Query.prototype._findOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      applyGlobalDiskUse(this.options, this.model);
      const conds = this._conditions;
      const options = this._optionsForExec();
      this._collection.findOne(conds, options, (err, doc) => {
        if (err) {
          callback(err);
          return null;
        }
        this._completeOne(doc, null, _wrapThunkCallback(this, callback));
      });
    });
    Query.prototype.findOne = function(conditions, projection, options, callback) {
      this.op = "findOne";
      this._validateOp();
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = null;
        projection = null;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        options = null;
        projection = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      conditions = utils.toObject(conditions);
      if (options) {
        this.setOptions(options);
      }
      if (projection) {
        this.select(projection);
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "findOne"));
      }
      if (!callback) {
        return Query.base.findOne.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._count = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      applyGlobalDiskUse(this.options, this.model);
      const conds = this._conditions;
      const options = this._optionsForExec();
      this._collection.count(conds, options, utils.tick(callback));
    });
    Query.prototype._countDocuments = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      applyGlobalDiskUse(this.options, this.model);
      const conds = this._conditions;
      const options = this._optionsForExec();
      this._collection.collection.countDocuments(conds, options, utils.tick(callback));
    });
    Query.prototype._estimatedDocumentCount = wrapThunk(function(callback) {
      if (this.error()) {
        return callback(this.error());
      }
      const options = this._optionsForExec();
      this._collection.collection.estimatedDocumentCount(options, utils.tick(callback));
    });
    Query.prototype.count = function(filter, callback) {
      this.op = "count";
      this._validateOp();
      if (typeof filter === "function") {
        callback = filter;
        filter = void 0;
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.estimatedDocumentCount = function(options, callback) {
      this.op = "estimatedDocumentCount";
      this._validateOp();
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      if (typeof options === "object" && options != null) {
        this.setOptions(options);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.countDocuments = function(conditions, options, callback) {
      this.op = "countDocuments";
      this._validateOp();
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        options = void 0;
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      conditions = utils.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      if (typeof options === "object" && options != null) {
        this.setOptions(options);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.__distinct = wrapThunk(function __distinct(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      applyGlobalDiskUse(this.options, this.model);
      const options = this._optionsForExec();
      this._collection.collection.distinct(this._distinct, this._conditions, options, callback);
    });
    Query.prototype.distinct = function(field, conditions, callback) {
      this.op = "distinct";
      this._validateOp();
      if (!callback) {
        if (typeof conditions === "function") {
          callback = conditions;
          conditions = void 0;
        } else if (typeof field === "function") {
          callback = field;
          field = void 0;
          conditions = void 0;
        }
      }
      conditions = utils.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "distinct"));
      }
      if (field != null) {
        this._distinct = field;
      }
      if (callback != null) {
        this.exec(callback);
      }
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (arguments.length > 1) {
        throw new Error("sort() only takes 1 Argument");
      }
      return Query.base.sort.call(this, arg);
    };
    Query.prototype.remove = function(filter, callback) {
      this.op = "remove";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "remove"));
      }
      if (!callback) {
        return Query.base.remove.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._remove = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.remove.call(this, callback);
    });
    Query.prototype.deleteOne = function(filter, options, callback) {
      this.op = "deleteOne";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      } else {
        this.setOptions(options);
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
      }
      if (!callback) {
        return Query.base.deleteOne.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteOne.call(this, callback);
    });
    Query.prototype.deleteMany = function(filter, options, callback) {
      this.op = "deleteMany";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      } else {
        this.setOptions(options);
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
      }
      if (!callback) {
        return Query.base.deleteMany.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteMany = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteMany.call(this, callback);
    });
    function completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {
      if (options.rawResult && doc == null) {
        _init(null);
        return null;
      }
      helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);
      function _init(err, casted) {
        if (err) {
          return immediate(() => callback(err));
        }
        if (options.rawResult) {
          if (doc && casted) {
            if (options.session != null) {
              casted.$session(options.session);
            }
            res.value = casted;
          } else {
            res.value = null;
          }
          return immediate(() => callback(null, res));
        }
        if (options.session != null) {
          casted.$session(options.session);
        }
        immediate(() => callback(null, casted));
      }
    }
    function prepareDiscriminatorCriteria(query) {
      if (!query || !query.model || !query.model.schema) {
        return;
      }
      const schema = query.model.schema;
      if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    Query.prototype.findOneAndUpdate = function(filter, doc, options, callback) {
      this.op = "findOneAndUpdate";
      this._validateOp();
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 2:
          if (typeof doc === "function") {
            callback = doc;
            doc = filter;
            filter = void 0;
          }
          options = void 0;
          break;
        case 1:
          if (typeof filter === "function") {
            callback = filter;
            filter = options = doc = void 0;
          } else {
            doc = filter;
            filter = options = void 0;
          }
      }
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      } else if (filter != null) {
        this.error(
          new ObjectParameterError(filter, "filter", "findOneAndUpdate")
        );
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options = options ? utils.clone(options) : {};
      if (options.projection) {
        this.select(options.projection);
        delete options.projection;
      }
      if (options.fields) {
        this.select(options.fields);
        delete options.fields;
      }
      const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
      if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
      }
      this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndUpdate = wrapThunk(function(callback) {
      if (this.error() != null) {
        return callback(this.error());
      }
      this._findAndModify("update", callback);
    });
    Query.prototype.findOneAndRemove = function(conditions, options, callback) {
      this.op = "findOneAndRemove";
      this._validateOp();
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 1:
          if (typeof conditions === "function") {
            callback = conditions;
            conditions = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.findOneAndDelete = function(filter, options, callback) {
      this.op = "findOneAndDelete";
      this._validateOp();
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 1:
          if (typeof filter === "function") {
            callback = filter;
            filter = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      } else if (filter != null) {
        this.error(
          new ObjectParameterError(filter, "filter", "findOneAndDelete")
        );
      }
      options && this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndDelete = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options = this._optionsForExec();
      let fields = null;
      if (this._fields != null) {
        options.projection = this._castFields(utils.clone(this._fields));
        fields = options.projection;
        if (fields instanceof Error) {
          callback(fields);
          return null;
        }
      }
      this._collection.collection.findOneAndDelete(filter, options, _wrapThunkCallback(this, (err, res) => {
        if (err) {
          return callback(err);
        }
        const doc = res.value;
        return this._completeOne(doc, res, callback);
      }));
    });
    Query.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
      this.op = "findOneAndReplace";
      this._validateOp();
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if (typeof replacement === "function") {
            callback = replacement;
            replacement = void 0;
          }
          break;
        case 1:
          if (typeof filter === "function") {
            callback = filter;
            filter = void 0;
            replacement = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      } else if (filter != null) {
        this.error(
          new ObjectParameterError(filter, "filter", "findOneAndReplace")
        );
      }
      if (replacement != null) {
        if (hasDollarKeys(replacement)) {
          throw new Error("The replacement document must not contain atomic operators.");
        }
        this._mergeUpdate(replacement);
      }
      options = options || {};
      const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
      if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
      }
      this.setOptions(options);
      this.setOptions({ overwrite: true });
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndReplace = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options = this._optionsForExec();
      convertNewToReturnDocument(options);
      const runValidators = _getOption(this, "runValidators", false);
      if (runValidators === false) {
        try {
          this._update = this._castUpdate(this._update, true);
        } catch (err) {
          const validationError = new ValidationError2();
          validationError.errors[err.path] = err;
          callback(validationError);
          return null;
        }
        this._collection.collection.findOneAndReplace(filter, this._update || {}, options, _wrapThunkCallback(this, (err, res) => {
          if (err) {
            return callback(err);
          }
          const doc = res.value;
          return this._completeOne(doc, res, callback);
        }));
        return;
      }
      let castedDoc = new this.model(this._update, null, true);
      this._update = castedDoc;
      castedDoc.validate((err) => {
        if (err != null) {
          return callback(err);
        }
        if (castedDoc.toBSON) {
          castedDoc = castedDoc.toBSON();
        }
        this._collection.collection.findOneAndReplace(filter, castedDoc, options, _wrapThunkCallback(this, (err2, res) => {
          if (err2) {
            return callback(err2);
          }
          const doc = res.value;
          return this._completeOne(doc, res, callback);
        }));
      });
    });
    function convertNewToReturnDocument(options) {
      if ("new" in options) {
        options.returnDocument = options["new"] ? "after" : "before";
        delete options["new"];
      }
      if ("returnOriginal" in options) {
        options.returnDocument = options["returnOriginal"] ? "before" : "after";
        delete options["returnOriginal"];
      }
      if (typeof options.returnDocument === "string") {
        options.returnOriginal = options.returnDocument === "before";
      }
    }
    Query.prototype._findOneAndRemove = wrapThunk(function(callback) {
      if (this.error() != null) {
        callback(this.error());
        return;
      }
      this._findAndModify("remove", callback);
    });
    function _getOption(query, option, def) {
      const opts = query._optionsForExec(query.model);
      if (option in opts) {
        return opts[option];
      }
      if (option in query.model.base.options) {
        return query.model.base.options[option];
      }
      return def;
    }
    Query.prototype._findAndModify = function(type, callback) {
      if (typeof callback !== "function") {
        throw new Error("Expected callback in _findAndModify");
      }
      const model = this.model;
      const schema = model.schema;
      const _this = this;
      const castedQuery = castQuery(this);
      if (castedQuery instanceof Error) {
        return callback(castedQuery);
      }
      _castArrayFilters(this);
      const opts = this._optionsForExec(model);
      if ("strict" in opts) {
        this._mongooseOptions.strict = opts.strict;
      }
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        this._update = new this.model(this._update, null, true);
      }
      if (type === "remove") {
        opts.remove = true;
      } else {
        if (!("new" in opts) && !("returnOriginal" in opts) && !("returnDocument" in opts)) {
          opts.new = false;
        }
        if (!("upsert" in opts)) {
          opts.upsert = false;
        }
        if (opts.upsert || opts["new"]) {
          opts.remove = false;
        }
        if (!isOverwriting) {
          try {
            this._update = this._castUpdate(this._update, opts.overwrite);
          } catch (err) {
            return callback(err);
          }
          const _opts = Object.assign({}, opts, {
            setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
          });
          this._update = setDefaultsOnInsert(this._conditions, schema, this._update, _opts);
          if (!this._update || Object.keys(this._update).length === 0) {
            if (opts.upsert) {
              const doc = utils.clone(castedQuery);
              delete doc._id;
              this._update = { $set: doc };
            } else {
              this._executionStack = null;
              this.findOne(callback);
              return this;
            }
          } else if (this._update instanceof Error) {
            return callback(this._update);
          } else {
            if (this._update.$set && Object.keys(this._update.$set).length === 0) {
              delete this._update.$set;
            }
          }
        }
        if (Array.isArray(opts.arrayFilters)) {
          opts.arrayFilters = removeUnusedArrayFilters(this._update, opts.arrayFilters);
        }
      }
      if (opts.sort) convertSortToArray(opts);
      const cb = function(err, doc, res) {
        if (err) {
          return callback(err);
        }
        _this._completeOne(doc, res, callback);
      };
      const runValidators = _getOption(this, "runValidators", false);
      const collection = _this._collection.collection;
      convertNewToReturnDocument(opts);
      if (type === "remove") {
        collection.findOneAndDelete(castedQuery, opts, _wrapThunkCallback(_this, function(error, res) {
          return cb(error, res ? res.value : res, res);
        }));
        return this;
      }
      const updateMethod = isOverwriting ? "findOneAndReplace" : "findOneAndUpdate";
      if (runValidators) {
        this.validate(this._update, opts, isOverwriting, (error) => {
          if (error) {
            return callback(error);
          }
          if (this._update && this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error2, res) {
            return cb(error2, res ? res.value : res, res);
          }));
        });
      } else {
        if (this._update && this._update.toBSON) {
          this._update = this._update.toBSON();
        }
        collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error, res) {
          return cb(error, res ? res.value : res, res);
        }));
      }
      return this;
    };
    function _completeOneLean(schema, doc, path, res, opts, callback) {
      if (opts.lean && typeof opts.lean.transform === "function") {
        opts.lean.transform(doc);
        for (let i = 0; i < schema.childSchemas.length; i++) {
          const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
          const _schema = schema.childSchemas[i].schema;
          const obj = mpath.get(childPath, doc);
          if (obj == null) {
            continue;
          }
          if (Array.isArray(obj)) {
            for (let i2 = 0; i2 < obj.length; i2++) {
              opts.lean.transform(obj[i2]);
            }
          } else {
            opts.lean.transform(obj);
          }
          _completeOneLean(_schema, obj, childPath, res, opts);
        }
        if (callback) {
          return callback(null, doc);
        } else {
          return;
        }
      }
      if (opts.rawResult) {
        return callback(null, res);
      }
      return callback(null, doc);
    }
    function _completeManyLean(schema, docs, path, opts, callback) {
      if (opts.lean && typeof opts.lean.transform === "function") {
        for (const doc of docs) {
          opts.lean.transform(doc);
        }
        for (let i = 0; i < schema.childSchemas.length; i++) {
          const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
          const _schema = schema.childSchemas[i].schema;
          let doc = mpath.get(childPath, docs);
          if (doc == null) {
            continue;
          }
          doc = doc.flat();
          for (let i2 = 0; i2 < doc.length; i2++) {
            opts.lean.transform(doc[i2]);
          }
          _completeManyLean(_schema, doc, childPath, opts);
        }
      }
      if (!callback) {
        return;
      }
      return callback(null, docs);
    }
    Query.prototype._mergeUpdate = function(doc) {
      if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
        return;
      }
      if (!this._update) {
        this._update = Array.isArray(doc) ? [] : {};
      }
      if (doc instanceof Query) {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        if (doc._update) {
          utils.mergeClone(this._update, doc._update);
        }
      } else if (Array.isArray(doc)) {
        if (!Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        this._update = this._update.concat(doc);
      } else {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        utils.mergeClone(this._update, doc);
      }
    };
    function convertSortToArray(opts) {
      if (Array.isArray(opts.sort)) {
        return;
      }
      if (!utils.isObject(opts.sort)) {
        return;
      }
      const sort = [];
      for (const key in opts.sort) {
        if (utils.object.hasOwnProperty(opts.sort, key)) {
          sort.push([key, opts.sort[key]]);
        }
      }
      opts.sort = sort;
    }
    function _updateThunk(op, callback) {
      this._castConditions();
      _castArrayFilters(this);
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      const castedQuery = this._conditions;
      const options = this._optionsForExec(this.model);
      this._update = utils.clone(this._update, options);
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        if (op === "updateOne" || op === "updateMany") {
          return callback(new MongooseError("The MongoDB server disallows overwriting documents using `" + op + "`. See: https://mongoosejs.com/docs/deprecations.html#update"));
        }
        this._update = new this.model(this._update, null, true);
      } else {
        try {
          this._update = this._castUpdate(this._update, options.overwrite);
        } catch (err) {
          callback(err);
          return null;
        }
        if (this._update == null || Object.keys(this._update).length === 0) {
          callback(null, { acknowledged: false });
          return null;
        }
        const _opts = Object.assign({}, options, {
          setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
        });
        this._update = setDefaultsOnInsert(
          this._conditions,
          this.model.schema,
          this._update,
          _opts
        );
      }
      if (Array.isArray(options.arrayFilters)) {
        options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
      }
      const runValidators = _getOption(this, "runValidators", false);
      if (runValidators) {
        this.validate(this._update, options, isOverwriting, (err) => {
          if (err) {
            return callback(err);
          }
          if (this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          this._collection[op](castedQuery, this._update, options, callback);
        });
        return null;
      }
      if (this._update.toBSON) {
        this._update = this._update.toBSON();
      }
      this._collection[op](castedQuery, this._update, options, callback);
      return null;
    }
    Query.prototype.validate = function validate2(castedDoc, options, isOverwriting, callback) {
      return promiseOrCallback(callback, (cb) => {
        try {
          if (isOverwriting) {
            castedDoc.$validate(cb);
          } else {
            updateValidators(this, this.model.schema, castedDoc, options, cb);
          }
        } catch (err) {
          immediate(function() {
            cb(err);
          });
        }
      });
    };
    Query.prototype._execUpdate = wrapThunk(function(callback) {
      return _updateThunk.call(this, "update", callback);
    });
    Query.prototype._updateMany = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateMany", callback);
    });
    Query.prototype._updateOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateOne", callback);
    });
    Query.prototype._replaceOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "replaceOne", callback);
    });
    Query.prototype.update = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "update", conditions, doc, options, callback);
    };
    Query.prototype.updateMany = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "updateMany", conditions, doc, options, callback);
    };
    Query.prototype.updateOne = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "updateOne", conditions, doc, options, callback);
    };
    Query.prototype.replaceOne = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", conditions, doc, options, callback);
    };
    function _update(query, op, filter, doc, options, callback) {
      query.op = op;
      query._validateOp();
      filter = utils.toObject(filter);
      doc = doc || {};
      if (options != null) {
        if ("strict" in options) {
          query._mongooseOptions.strict = options.strict;
        }
      }
      if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
        query.error(new ObjectParameterError(filter, "filter", op));
      } else {
        query.merge(filter);
      }
      if (utils.isObject(options)) {
        query.setOptions(options);
      }
      query._mergeUpdate(doc);
      if (callback) {
        query.exec(callback);
        return query;
      }
      return Query.base[op].call(query, filter, void 0, options, callback);
    }
    Query.prototype.transform = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    Query.prototype.orFail = function(err) {
      this.transform((res) => {
        switch (this.op) {
          case "find":
            if (res.length === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOne":
            if (res == null) {
              throw _orFailError(err, this);
            }
            break;
          case "replaceOne":
          case "update":
          case "updateMany":
          case "updateOne":
            if (res && res.modifiedCount === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndDelete":
          case "findOneAndRemove":
            if ((res && res.lastErrorObject && res.lastErrorObject.n) === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndUpdate":
          case "findOneAndReplace":
            if ((res && res.lastErrorObject && res.lastErrorObject.updatedExisting) === false) {
              throw _orFailError(err, this);
            }
            break;
          case "deleteMany":
          case "deleteOne":
          case "remove":
            if (res.deletedCount === 0) {
              throw _orFailError(err, this);
            }
            break;
          default:
            break;
        }
        return res;
      });
      return this;
    };
    function _orFailError(err, query) {
      if (typeof err === "function") {
        err = err.call(query);
      }
      if (err == null) {
        err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
      }
      return err;
    }
    Query.prototype.exec = function exec(op, callback) {
      const _this = this;
      if (this.options && this.options.sort) {
        const keys = Object.keys(this.options.sort);
        if (keys.includes("")) {
          throw new Error('Invalid field "" passed to sort()');
        }
      }
      const castError = new CastError();
      if (typeof op === "function") {
        callback = op;
        op = null;
      } else if (typeof op === "string") {
        this.op = op;
      }
      if (this.op == null) {
        throw new Error("Query must have `op` before executing");
      }
      this._validateOp();
      callback = this.model.$handleCallbackError(callback);
      return promiseOrCallback(callback, (cb) => {
        cb = this.model.$wrapCallback(cb);
        if (!_this.op) {
          cb();
          return;
        }
        this._hooks.execPre("exec", this, [], (error) => {
          if (error != null) {
            return cb(_cleanCastErrorStack(castError, error));
          }
          let thunk = "_" + this.op;
          if (this.op === "update") {
            thunk = "_execUpdate";
          } else if (this.op === "distinct") {
            thunk = "__distinct";
          }
          this[thunk].call(this, (error2, res) => {
            if (error2) {
              return cb(_cleanCastErrorStack(castError, error2));
            }
            this._hooks.execPost("exec", this, [], {}, (error3) => {
              if (error3) {
                return cb(_cleanCastErrorStack(castError, error3));
              }
              cb(null, res);
            });
          });
        });
      }, this.model.events);
    };
    function _cleanCastErrorStack(castError, error) {
      if (error instanceof CastError) {
        castError.copy(error);
        return castError;
      }
      return error;
    }
    function _wrapThunkCallback(query, cb) {
      return function(error, res) {
        if (error != null) {
          return cb(error);
        }
        for (const fn of query._transforms) {
          try {
            res = fn(res);
          } catch (error2) {
            return cb(error2);
          }
        }
        return cb(null, res);
      };
    }
    Query.prototype.then = function(resolve, reject) {
      return this.exec().then(resolve, reject);
    };
    Query.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    Query.prototype.pre = function(fn) {
      this._hooks.pre("exec", fn);
      return this;
    };
    Query.prototype.post = function(fn) {
      this._hooks.post("exec", fn);
      return this;
    };
    Query.prototype._castUpdate = function _castUpdate(obj, overwrite) {
      let schema = this.schema;
      const discriminatorKey = schema.options.discriminatorKey;
      const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
      if (this._mongooseOptions.overwriteDiscriminatorKey && obj[discriminatorKey] != null && baseSchema.discriminators) {
        const _schema = Object.values(baseSchema.discriminators).find(
          (discriminator) => discriminator.discriminatorMapping.value === obj[discriminatorKey]
        );
        if (_schema != null) {
          schema = _schema;
        }
      }
      let upsert;
      if ("upsert" in this.options) {
        upsert = this.options.upsert;
      }
      const filter = this._conditions;
      if (schema != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
        const discriminatorValue = filter[schema.options.discriminatorKey];
        const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);
        schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
      }
      return castUpdate(schema, obj, {
        overwrite,
        strict: this._mongooseOptions.strict,
        upsert,
        arrayFilters: this.options.arrayFilters,
        overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey
      }, this, this._conditions);
    };
    function castQuery(query) {
      try {
        return query.cast(query.model);
      } catch (err) {
        return err;
      }
    }
    Query.prototype.populate = function() {
      if (!Array.from(arguments).some(Boolean)) {
        return this;
      }
      const res = utils.populate.apply(null, arguments);
      if (this.options != null) {
        const readConcern = this.options.readConcern;
        const readPref = this.options.readPreference;
        for (const populateOptions of res) {
          if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readConcern = readConcern;
          }
          if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readPreference = readPref;
          }
        }
      }
      const opts = this._mongooseOptions;
      if (opts.lean != null) {
        const lean = opts.lean;
        for (const populateOptions of res) {
          if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.lean = lean;
          }
        }
      }
      if (!utils.isObject(opts.populate)) {
        opts.populate = {};
      }
      const pop = opts.populate;
      for (const populateOptions of res) {
        const path = populateOptions.path;
        if (pop[path] && pop[path].populate && populateOptions.populate) {
          populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
        }
        pop[populateOptions.path] = populateOptions;
      }
      return this;
    };
    Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
      const obj = this._mongooseOptions.populate || {};
      const ret = Object.keys(obj);
      for (const path of Object.keys(obj)) {
        const pop = obj[path];
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(ret, pop.populate, path + ".");
      }
      return ret;
    };
    function _getPopulatedPaths(list, arr, prefix) {
      for (const pop of arr) {
        list.push(prefix + pop.path);
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
      }
    }
    Query.prototype.cast = function(model, obj) {
      obj || (obj = this._conditions);
      model = model || this.model;
      const discriminatorKey = model.schema.options.discriminatorKey;
      if (obj != null && obj.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;
      }
      const opts = { upsert: this.options && this.options.upsert };
      if (this.options) {
        if ("strict" in this.options) {
          opts.strict = this.options.strict;
          opts.strictQuery = opts.strict;
        }
        if ("strictQuery" in this.options) {
          opts.strictQuery = this.options.strictQuery;
        }
      }
      try {
        return cast(model.schema, obj, opts, this);
      } catch (err) {
        if (typeof err.setModel === "function") {
          err.setModel(model);
        }
        throw err;
      }
    };
    Query.prototype._castFields = function _castFields(fields) {
      let selected, elemMatchKeys, keys, key, out, i;
      if (fields) {
        keys = Object.keys(fields);
        elemMatchKeys = [];
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (fields[key].$elemMatch) {
            selected || (selected = {});
            selected[key] = fields[key];
            elemMatchKeys.push(key);
          }
        }
      }
      if (selected) {
        try {
          out = this.cast(this.model, selected);
        } catch (err) {
          return err;
        }
        i = elemMatchKeys.length;
        while (i--) {
          key = elemMatchKeys[i];
          fields[key] = out[key];
        }
      }
      return fields;
    };
    Query.prototype._applyPaths = function applyPaths() {
      if (!this.model) {
        return;
      }
      this._fields = this._fields || {};
      helpers.applyPaths(this._fields, this.model.schema);
      let _selectPopulatedPaths = true;
      if ("selectPopulatedPaths" in this.model.base.options) {
        _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
      }
      if ("selectPopulatedPaths" in this.model.schema.options) {
        _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
      }
      if (_selectPopulatedPaths) {
        selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
      }
    };
    Query.prototype.cursor = function cursor(opts) {
      if (opts) {
        this.setOptions(opts);
      }
      const options = this._optionsForExec();
      try {
        this.cast(this.model);
      } catch (err) {
        return new QueryCursor(this, options)._markError(err);
      }
      return new QueryCursor(this, options);
    };
    Query.prototype.maxscan = Query.base.maxScan;
    Query.prototype.tailable = function(val, opts) {
      if (val != null && typeof val.constructor === "function" && val.constructor.name === "Object") {
        opts = val;
        val = true;
      }
      if (val === void 0) {
        val = true;
      }
      if (opts && typeof opts === "object") {
        for (const key of Object.keys(opts)) {
          if (key === "awaitData" || key === "awaitdata") {
            this.options["awaitData"] = !!opts[key];
          } else {
            this.options[key] = opts[key];
          }
        }
      }
      return Query.base.tailable.call(this, val);
    };
    Query.prototype.near = function() {
      const params = [];
      const sphere = this._mongooseOptions.nearSphere;
      if (arguments.length === 1) {
        if (Array.isArray(arguments[0])) {
          params.push({ center: arguments[0], spherical: sphere });
        } else if (typeof arguments[0] === "string") {
          params.push(arguments[0]);
        } else if (utils.isObject(arguments[0])) {
          if (typeof arguments[0].spherical !== "boolean") {
            arguments[0].spherical = sphere;
          }
          params.push(arguments[0]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
          params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
        } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
          params.push(arguments[0]);
          params.push({ center: arguments[1], spherical: sphere });
        } else if (typeof arguments[0] === "string" && utils.isObject(arguments[1])) {
          params.push(arguments[0]);
          if (typeof arguments[1].spherical !== "boolean") {
            arguments[1].spherical = sphere;
          }
          params.push(arguments[1]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
          params.push(arguments[0]);
          params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
        } else {
          throw new TypeError("invalid argument");
        }
      } else {
        throw new TypeError("invalid argument");
      }
      return Query.base.near.apply(this, params);
    };
    Query.prototype.nearSphere = function() {
      this._mongooseOptions.nearSphere = true;
      this.near.apply(this, arguments);
      return this;
    };
    if (Symbol.asyncIterator != null) {
      Query.prototype[Symbol.asyncIterator] = function() {
        return this.cursor().transformNull()._transformForAsyncIterator();
      };
    }
    Query.prototype.box = function(ll, ur) {
      if (!Array.isArray(ll) && utils.isObject(ll)) {
        ur = ll.ur;
        ll = ll.ll;
      }
      return Query.base.box.call(this, ll, ur);
    };
    Query.prototype.center = Query.base.circle;
    Query.prototype.centerSphere = function() {
      if (arguments[0] != null && typeof arguments[0].constructor === "function" && arguments[0].constructor.name === "Object") {
        arguments[0].spherical = true;
      }
      if (arguments[1] != null && typeof arguments[1].constructor === "function" && arguments[1].constructor.name === "Object") {
        arguments[1].spherical = true;
      }
      Query.base.circle.apply(this, arguments);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      return isInclusive(this._fields);
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      return isExclusive(this._fields);
    };
    Query.prototype.model;
    module2.exports = Query;
  }
});

// asset-input/node_modules/mongoose/lib/cursor/AggregationCursor.js
var require_AggregationCursor = __commonJS({
  "asset-input/node_modules/mongoose/lib/cursor/AggregationCursor.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var Readable2 = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var immediate = require_immediate();
    var util2 = require("util");
    function AggregationCursor(agg) {
      Readable2.call(this, { autoDestroy: true, objectMode: true });
      this.cursor = null;
      this.agg = agg;
      this._transforms = [];
      const model = agg._model;
      delete agg.options.cursor.useMongooseAggCursor;
      this._mongooseOptions = {};
      _init(model, this, agg);
    }
    util2.inherits(AggregationCursor, Readable2);
    function _init(model, c, agg) {
      if (!model.collection.buffer) {
        model.hooks.execPre("aggregate", agg, function() {
          c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
          c.emit("cursor", c.cursor);
        });
      } else {
        model.collection.emitter.once("queue", function() {
          model.hooks.execPre("aggregate", agg, function() {
            c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
            c.emit("cursor", c.cursor);
          });
        });
      }
    }
    AggregationCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error, doc) {
        if (error) {
          return _this.emit("error", error);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error2) {
            if (error2) {
              return _this.emit("error", error2);
            }
          });
          return;
        }
        _this.push(doc);
      });
    };
    if (Symbol.asyncIterator != null) {
      const msg = "Mongoose does not support using async iterators with an existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation";
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        throw new MongooseError(msg);
      };
    }
    Object.defineProperty(AggregationCursor.prototype, "map", {
      value: function(fn) {
        this._transforms.push(fn);
        return this;
      },
      enumerable: true,
      configurable: true,
      writable: true
    });
    AggregationCursor.prototype._markError = function(error) {
      this._error = error;
      return this;
    };
    AggregationCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error) => {
          if (error) {
            cb(error);
            return this.listeners("error").length > 0 && this.emit("error", error);
          }
          this.emit("close");
          cb(null);
        });
      });
    };
    AggregationCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, cb);
      });
    };
    AggregationCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    if (Symbol.asyncIterator != null) {
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    AggregationCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    AggregationCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    AggregationCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function() {
        cb();
      });
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn(doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        return ctx.cursor.next(function(error, doc) {
          if (error) {
            return callback(error);
          }
          if (!doc) {
            return callback(null, null);
          }
          callback(null, doc);
        });
      } else {
        ctx.once("cursor", function() {
          _next(ctx, cb);
        });
      }
    }
    module2.exports = AggregationCursor;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js
var require_prepareDiscriminatorPipeline = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js"(exports2, module2) {
    "use strict";
    module2.exports = function prepareDiscriminatorPipeline(pipeline2, schema, prefix) {
      const discriminatorMapping = schema && schema.discriminatorMapping;
      prefix = prefix || "";
      if (discriminatorMapping && !discriminatorMapping.isRoot) {
        const originalPipeline = pipeline2;
        const filterKey = (prefix.length > 0 ? prefix + "." : prefix) + discriminatorMapping.key;
        const discriminatorValue = discriminatorMapping.value;
        if (originalPipeline[0] != null && originalPipeline[0].$match && (originalPipeline[0].$match[filterKey] === void 0 || originalPipeline[0].$match[filterKey] === discriminatorValue)) {
          originalPipeline[0].$match[filterKey] = discriminatorValue;
        } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {
          originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
          originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;
        } else if (originalPipeline[0] != null && originalPipeline[0].$search) {
          if (originalPipeline[1] && originalPipeline[1].$match != null) {
            originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;
          } else {
            const match = {};
            match[filterKey] = discriminatorValue;
            originalPipeline.splice(1, 0, { $match: match });
          }
        } else {
          const match = {};
          match[filterKey] = discriminatorValue;
          originalPipeline.unshift({ $match: match });
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js
var require_stringifyFunctionOperators = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js"(exports2, module2) {
    "use strict";
    module2.exports = function stringifyFunctionOperators(pipeline2) {
      if (!Array.isArray(pipeline2)) {
        return;
      }
      for (const stage of pipeline2) {
        if (stage == null) {
          continue;
        }
        const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
        if (canHaveAccumulator != null) {
          for (const key of Object.keys(canHaveAccumulator)) {
            handleAccumulator(canHaveAccumulator[key]);
          }
        }
        const stageType = Object.keys(stage)[0];
        if (stageType && typeof stage[stageType] === "object") {
          const stageOptions = stage[stageType];
          for (const key of Object.keys(stageOptions)) {
            if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
              stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
            }
          }
        }
        if (stage.$facet != null) {
          for (const key of Object.keys(stage.$facet)) {
            stringifyFunctionOperators(stage.$facet[key]);
          }
        }
      }
    };
    function handleAccumulator(operator) {
      if (operator == null || operator.$accumulator == null) {
        return;
      }
      for (const key of ["init", "accumulate", "merge", "finalize"]) {
        if (typeof operator.$accumulator[key] === "function") {
          operator.$accumulator[key] = String(operator.$accumulator[key]);
        }
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/aggregate.js
var require_aggregate2 = __commonJS({
  "asset-input/node_modules/mongoose/lib/aggregate.js"(exports2, module2) {
    "use strict";
    var AggregationCursor = require_AggregationCursor();
    var Query = require_query();
    var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
    var getConstructorName = require_getConstructorName();
    var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
    var promiseOrCallback = require_promiseOrCallback();
    var stringifyFunctionOperators = require_stringifyFunctionOperators();
    var utils = require_utils6();
    var read = Query.prototype.read;
    var readConcern = Query.prototype.readConcern;
    var validRedactStringValues = /* @__PURE__ */ new Set(["$$DESCEND", "$$PRUNE", "$$KEEP"]);
    function Aggregate(pipeline2, model) {
      this._pipeline = [];
      this._model = model;
      this.options = {};
      if (arguments.length === 1 && Array.isArray(pipeline2)) {
        this.append.apply(this, pipeline2);
      }
    }
    Aggregate.prototype.options;
    Aggregate.prototype.model = function(model) {
      if (arguments.length === 0) {
        return this._model;
      }
      this._model = model;
      if (model.schema != null) {
        if (this.options.readPreference == null && model.schema.options.read != null) {
          this.options.readPreference = model.schema.options.read;
        }
        if (this.options.collation == null && model.schema.options.collation != null) {
          this.options.collation = model.schema.options.collation;
        }
      }
      return model;
    };
    Aggregate.prototype.append = function() {
      const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : [...arguments];
      if (!args.every(isOperator)) {
        throw new Error("Arguments must be aggregate pipeline operators");
      }
      this._pipeline = this._pipeline.concat(args);
      return this;
    };
    Aggregate.prototype.addFields = function(arg) {
      if (typeof arg !== "object" || arg === null || Array.isArray(arg)) {
        throw new Error("Invalid addFields() argument. Must be an object");
      }
      return this.append({ $addFields: Object.assign({}, arg) });
    };
    Aggregate.prototype.project = function(arg) {
      const fields = {};
      if (typeof arg === "object" && !Array.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
          fields[field] = arg[field];
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const include = field[0] === "-" ? 0 : 1;
          if (include === 0) {
            field = field.substring(1);
          }
          fields[field] = include;
        });
      } else {
        throw new Error("Invalid project() argument. Must be string or object");
      }
      return this.append({ $project: fields });
    };
    Aggregate.prototype.near = function(arg) {
      const op = {};
      op.$geoNear = arg;
      return this.append(op);
    };
    "group match skip limit out densify fill".split(" ").forEach(function($operator) {
      Aggregate.prototype[$operator] = function(arg) {
        const op = {};
        op["$" + $operator] = arg;
        return this.append(op);
      };
    });
    Aggregate.prototype.unwind = function() {
      const args = [...arguments];
      const res = [];
      for (const arg of args) {
        if (arg && typeof arg === "object") {
          res.push({ $unwind: arg });
        } else if (typeof arg === "string") {
          res.push({
            $unwind: arg[0] === "$" ? arg : "$" + arg
          });
        } else {
          throw new Error('Invalid arg "' + arg + '" to unwind(), must be string or object');
        }
      }
      return this.append.apply(this, res);
    };
    Aggregate.prototype.replaceRoot = function(newRoot) {
      let ret;
      if (typeof newRoot === "string") {
        ret = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
      } else {
        ret = newRoot;
      }
      return this.append({
        $replaceRoot: {
          newRoot: ret
        }
      });
    };
    Aggregate.prototype.count = function(fieldName) {
      return this.append({ $count: fieldName });
    };
    Aggregate.prototype.sortByCount = function(arg) {
      if (arg && typeof arg === "object") {
        return this.append({ $sortByCount: arg });
      } else if (typeof arg === "string") {
        return this.append({
          $sortByCount: arg[0] === "$" ? arg : "$" + arg
        });
      } else {
        throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), must be string or object');
      }
    };
    Aggregate.prototype.lookup = function(options) {
      return this.append({ $lookup: options });
    };
    Aggregate.prototype.graphLookup = function(options) {
      const cloneOptions = {};
      if (options) {
        if (!utils.isObject(options)) {
          throw new TypeError("Invalid graphLookup() argument. Must be an object.");
        }
        utils.mergeClone(cloneOptions, options);
        const startWith = cloneOptions.startWith;
        if (startWith && typeof startWith === "string") {
          cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
        }
      }
      return this.append({ $graphLookup: cloneOptions });
    };
    Aggregate.prototype.sample = function(size) {
      return this.append({ $sample: { size } });
    };
    Aggregate.prototype.sort = function(arg) {
      const sort = {};
      if (getConstructorName(arg) === "Object") {
        const desc = ["desc", "descending", -1];
        Object.keys(arg).forEach(function(field) {
          if (arg[field] instanceof Object && arg[field].$meta) {
            sort[field] = arg[field];
            return;
          }
          sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const ascend = field[0] === "-" ? -1 : 1;
          if (ascend === -1) {
            field = field.substring(1);
          }
          sort[field] = ascend;
        });
      } else {
        throw new TypeError("Invalid sort() argument. Must be a string or object.");
      }
      return this.append({ $sort: sort });
    };
    Aggregate.prototype.unionWith = function(options) {
      return this.append({ $unionWith: options });
    };
    Aggregate.prototype.read = function(pref, tags) {
      read.call(this, pref, tags);
      return this;
    };
    Aggregate.prototype.readConcern = function(level) {
      readConcern.call(this, level);
      return this;
    };
    Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
      if (arguments.length === 3) {
        if (typeof thenExpr === "string" && !validRedactStringValues.has(thenExpr) || typeof elseExpr === "string" && !validRedactStringValues.has(elseExpr)) {
          throw new Error("If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP");
        }
        expression = {
          $cond: {
            if: expression,
            then: thenExpr,
            else: elseExpr
          }
        };
      } else if (arguments.length !== 1) {
        throw new TypeError("Invalid arguments");
      }
      return this.append({ $redact: expression });
    };
    Aggregate.prototype.explain = function(verbosity, callback) {
      const model = this._model;
      if (typeof verbosity === "function") {
        callback = verbosity;
        verbosity = null;
      }
      return promiseOrCallback(callback, (cb) => {
        if (!this._pipeline.length) {
          const err = new Error("Aggregate has empty pipeline");
          return cb(err);
        }
        prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
        model.hooks.execPre("aggregate", this, (error) => {
          if (error) {
            const _opts = { error };
            return model.hooks.execPost("aggregate", this, [null], _opts, (error2) => {
              cb(error2);
            });
          }
          model.collection.aggregate(this._pipeline, this.options, (error2, cursor) => {
            if (error2 != null) {
              const _opts = { error: error2 };
              return model.hooks.execPost("aggregate", this, [null], _opts, (error3) => {
                cb(error3);
              });
            }
            if (verbosity != null) {
              cursor.explain(verbosity, (error3, result) => {
                const _opts = { error: error3 };
                return model.hooks.execPost("aggregate", this, [result], _opts, (error4) => {
                  if (error4) {
                    return cb(error4);
                  }
                  return cb(null, result);
                });
              });
            } else {
              cursor.explain((error3, result) => {
                const _opts = { error: error3 };
                return model.hooks.execPost("aggregate", this, [result], _opts, (error4) => {
                  if (error4) {
                    return cb(error4);
                  }
                  return cb(null, result);
                });
              });
            }
          });
        });
      }, model.events);
    };
    Aggregate.prototype.allowDiskUse = function(value) {
      this.options.allowDiskUse = value;
      return this;
    };
    Aggregate.prototype.hint = function(value) {
      this.options.hint = value;
      return this;
    };
    Aggregate.prototype.session = function(session) {
      if (session == null) {
        delete this.options.session;
      } else {
        this.options.session = session;
      }
      return this;
    };
    Aggregate.prototype.option = function(value) {
      for (const key in value) {
        this.options[key] = value[key];
      }
      return this;
    };
    Aggregate.prototype.cursor = function(options) {
      this.options.cursor = options || {};
      return new AggregationCursor(this);
    };
    Aggregate.prototype.collation = function(collation) {
      this.options.collation = collation;
      return this;
    };
    Aggregate.prototype.facet = function(options) {
      return this.append({ $facet: options });
    };
    Aggregate.prototype.search = function(options) {
      return this.append({ $search: options });
    };
    Aggregate.prototype.pipeline = function() {
      return this._pipeline;
    };
    Aggregate.prototype.exec = function(callback) {
      if (!this._model) {
        throw new Error("Aggregate not bound to any Model");
      }
      const model = this._model;
      const collection = this._model.collection;
      applyGlobalMaxTimeMS(this.options, model);
      applyGlobalDiskUse(this.options, model);
      if (this.options && this.options.cursor) {
        return new AggregationCursor(this);
      }
      return promiseOrCallback(callback, (cb) => {
        prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
        stringifyFunctionOperators(this._pipeline);
        model.hooks.execPre("aggregate", this, (error) => {
          if (error) {
            const _opts = { error };
            return model.hooks.execPost("aggregate", this, [null], _opts, (error2) => {
              cb(error2);
            });
          }
          if (!this._pipeline.length) {
            return cb(new Error("Aggregate has empty pipeline"));
          }
          const options = utils.clone(this.options || {});
          collection.aggregate(this._pipeline, options, (err, cursor) => {
            if (err != null) {
              return cb(err);
            }
            cursor.toArray((error2, result) => {
              const _opts = { error: error2 };
              model.hooks.execPost("aggregate", this, [result], _opts, (error3, result2) => {
                if (error3) {
                  return cb(error3);
                }
                cb(null, result2);
              });
            });
          });
        });
      }, model.events);
    };
    Aggregate.prototype.then = function(resolve, reject) {
      return this.exec().then(resolve, reject);
    };
    Aggregate.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    if (Symbol.asyncIterator != null) {
      Aggregate.prototype[Symbol.asyncIterator] = function() {
        return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();
      };
    }
    function isOperator(obj) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      const k = Object.keys(obj);
      return k.length === 1 && k[0][0] === "$";
    }
    Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
    module2.exports = Aggregate;
  }
});

// asset-input/node_modules/mongoose/lib/error/bulkWriteError.js
var require_bulkWriteError = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/bulkWriteError.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var MongooseBulkWriteError = class extends MongooseError {
      constructor(validationErrors, results, rawResult, operation) {
        let preview = validationErrors.map((e) => e.message).join(", ");
        if (preview.length > 200) {
          preview = preview.slice(0, 200) + "...";
        }
        super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);
        this.validationErrors = validationErrors;
        this.results = results;
        this.rawResult = rawResult;
        this.operation = operation;
      }
    };
    Object.defineProperty(MongooseBulkWriteError.prototype, "name", {
      value: "MongooseBulkWriteError"
    });
    module2.exports = MongooseBulkWriteError;
  }
});

// asset-input/node_modules/mongoose/lib/options/removeOptions.js
var require_removeOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/removeOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var RemoveOptions = class {
      constructor(obj) {
        if (obj == null) {
          return;
        }
        Object.assign(this, clone(obj));
      }
    };
    module2.exports = RemoveOptions;
  }
});

// asset-input/node_modules/mongoose/lib/options/saveOptions.js
var require_saveOptions = __commonJS({
  "asset-input/node_modules/mongoose/lib/options/saveOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var SaveOptions = class {
      constructor(obj) {
        if (obj == null) {
          return;
        }
        Object.assign(this, clone(obj));
      }
    };
    module2.exports = SaveOptions;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js
var require_applyDefaultsToPOJO = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js"(exports2, module2) {
    "use strict";
    module2.exports = function applyDefaultsToPOJO(doc, schema) {
      const paths = Object.keys(schema.paths);
      const plen = paths.length;
      for (let i = 0; i < plen; ++i) {
        let curPath = "";
        const p = paths[i];
        const type = schema.paths[p];
        const path = type.splitPath();
        const len = path.length;
        let doc_ = doc;
        for (let j = 0; j < len; ++j) {
          if (doc_ == null) {
            break;
          }
          const piece = path[j];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (j === len - 1) {
            if (typeof doc_[piece] !== "undefined") {
              if (type.$isSingleNested) {
                applyDefaultsToPOJO(doc_[piece], type.caster.schema);
              } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {
                doc_[piece].forEach((el) => applyDefaultsToPOJO(el, type.schema));
              }
              break;
            }
            const def = type.getDefault(doc, false, { skipCast: true });
            if (typeof def !== "undefined") {
              doc_[piece] = def;
              if (type.$isSingleNested) {
                applyDefaultsToPOJO(def, type.caster.schema);
              } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {
                def.forEach((el) => applyDefaultsToPOJO(el, type.schema));
              }
            }
          } else {
            if (doc_[piece] == null) {
              doc_[piece] = {};
            }
            doc_ = doc_[piece];
          }
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/applyMethods.js
var require_applyMethods = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/applyMethods.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var utils = require_utils6();
    module2.exports = function applyMethods(model, schema) {
      const Model = require_model();
      function apply(method, schema2) {
        Object.defineProperty(model.prototype, method, {
          get: function() {
            const h = {};
            for (const k in schema2.methods[method]) {
              h[k] = schema2.methods[method][k].bind(this);
            }
            return h;
          },
          configurable: true
        });
      }
      for (const method of Object.keys(schema.methods)) {
        const fn = schema.methods[method];
        if (schema.tree.hasOwnProperty(method)) {
          throw new Error('You have a method and a property in your schema both named "' + method + '"');
        }
        if (typeof fn === "function" && Model.prototype[method] === fn) {
          delete schema.methods[method];
          continue;
        }
        if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {
          utils.warn(`mongoose: the method name "${method}" is used by mongoose internally, overwriting it may cause bugs. If you're sure you know what you're doing, you can suppress this error by using \`schema.method('${method}', fn, { suppressWarning: true })\`.`);
        }
        if (typeof fn === "function") {
          model.prototype[method] = fn;
        } else {
          apply(method, schema);
        }
      }
      model.$appliedMethods = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        if (type.$isSingleNested && !type.caster.$appliedMethods) {
          applyMethods(type.caster, type.schema);
        }
        if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
          applyMethods(type.Constructor, type.schema);
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/applyProjection.js
var require_applyProjection = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/applyProjection.js"(exports2, module2) {
    "use strict";
    var hasIncludedChildren = require_hasIncludedChildren();
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    var isPOJO = require_utils6().isPOJO;
    module2.exports = function applyProjection(doc, projection, _hasIncludedChildren) {
      if (projection == null) {
        return doc;
      }
      if (doc == null) {
        return doc;
      }
      let exclude = null;
      if (isInclusive(projection)) {
        exclude = false;
      } else if (isExclusive(projection)) {
        exclude = true;
      }
      if (exclude == null) {
        return doc;
      } else if (exclude) {
        _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
        return applyExclusiveProjection(doc, projection, _hasIncludedChildren);
      } else {
        _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
        return applyInclusiveProjection(doc, projection, _hasIncludedChildren);
      }
    };
    function applyExclusiveProjection(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
      if (doc == null || typeof doc !== "object") {
        return doc;
      }
      const ret = { ...doc };
      projectionLimb = prefix ? projectionLimb || {} : projection;
      for (const key of Object.keys(ret)) {
        const fullPath = prefix ? prefix + "." + key : key;
        if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
          if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
            ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
          } else {
            delete ret[key];
          }
        } else if (hasIncludedChildren2[fullPath]) {
          ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        }
      }
      return ret;
    }
    function applyInclusiveProjection(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
      if (doc == null || typeof doc !== "object") {
        return doc;
      }
      const ret = { ...doc };
      projectionLimb = prefix ? projectionLimb || {} : projection;
      for (const key of Object.keys(ret)) {
        const fullPath = prefix ? prefix + "." + key : key;
        if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
          if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
            ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
          }
          continue;
        } else if (hasIncludedChildren2[fullPath]) {
          ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        } else {
          delete ret[key];
        }
      }
      return ret;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js
var require_isTextIndex = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js"(exports2, module2) {
    "use strict";
    module2.exports = function isTextIndex(indexKeys) {
      let isTextIndex2 = false;
      for (const key of Object.keys(indexKeys)) {
        if (indexKeys[key] === "text") {
          isTextIndex2 = true;
        }
      }
      return isTextIndex2;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js
var require_applySchemaCollation = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js"(exports2, module2) {
    "use strict";
    var isTextIndex = require_isTextIndex();
    module2.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {
      if (isTextIndex(indexKeys)) {
        return;
      }
      if (schemaOptions.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation")) {
        indexOptions.collation = schemaOptions.collation;
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js
var require_applyStaticHooks = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js"(exports2, module2) {
    "use strict";
    var middlewareFunctions = require_applyQueryMiddleware().middlewareFunctions;
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function applyStaticHooks(model, hooks, statics) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1
      };
      hooks = hooks.filter((hook) => {
        if (middlewareFunctions.indexOf(hook.name) !== -1) {
          return !!hook.model;
        }
        return hook.model !== false;
      });
      model.$__insertMany = hooks.createWrapper(
        "insertMany",
        model.$__insertMany,
        model,
        kareemOptions
      );
      for (const key of Object.keys(statics)) {
        if (hooks.hasHooks(key)) {
          const original = model[key];
          model[key] = function() {
            const numArgs = arguments.length;
            const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
            const cb = typeof lastArg === "function" ? lastArg : null;
            const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
            return promiseOrCallback(cb, (callback) => {
              hooks.execPre(key, model, args, function(err) {
                if (err != null) {
                  return callback(err);
                }
                let postCalled = 0;
                const ret = original.apply(model, args.concat(post));
                if (ret != null && typeof ret.then === "function") {
                  ret.then((res) => post(null, res), (err2) => post(err2));
                }
                function post(error, res) {
                  if (postCalled++ > 0) {
                    return;
                  }
                  if (error != null) {
                    return callback(error);
                  }
                  hooks.execPost(key, model, [res], function(error2) {
                    if (error2 != null) {
                      return callback(error2);
                    }
                    callback(null, res);
                  });
                }
              });
            }, model.events);
          };
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/applyStatics.js
var require_applyStatics = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/applyStatics.js"(exports2, module2) {
    "use strict";
    module2.exports = function applyStatics(model, schema) {
      for (const i in schema.statics) {
        model[i] = schema.statics[i];
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js
var require_SkipPopulateValue = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js"(exports2, module2) {
    "use strict";
    module2.exports = function SkipPopulateValue(val) {
      if (!(this instanceof SkipPopulateValue)) {
        return new SkipPopulateValue(val);
      }
      this.val = val;
      return this;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js
var require_leanPopulateMap = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ new WeakMap();
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js
var require_assignRawDocsToIdStructure = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"(exports2, module2) {
    "use strict";
    var leanPopulateMap = require_leanPopulateMap();
    var modelSymbol = require_symbols().modelSymbol;
    var utils = require_utils6();
    module2.exports = assignRawDocsToIdStructure;
    var kHasArray = Symbol("assignRawDocsToIdStructure.hasArray");
    function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {
      const newOrder = [];
      const sorting = options.sort && rawIds.length > 1;
      const nullIfNotFound = options.$nullIfNotFound;
      let doc;
      let sid;
      let id;
      if (utils.isMongooseArray(rawIds)) {
        rawIds = rawIds.__array;
      }
      let i = 0;
      const len = rawIds.length;
      if (sorting && recursed && options[kHasArray] === void 0) {
        options[kHasArray] = false;
        for (const key in resultOrder) {
          if (Array.isArray(resultOrder[key])) {
            options[kHasArray] = true;
            break;
          }
        }
      }
      for (i = 0; i < len; ++i) {
        id = rawIds[i];
        if (Array.isArray(id)) {
          assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
          newOrder.push(id);
          continue;
        }
        if (id === null && sorting === false) {
          newOrder.push(id);
          continue;
        }
        sid = String(id);
        doc = resultDocs[sid];
        if (options.clone && doc != null) {
          if (options.lean) {
            const _model = leanPopulateMap.get(doc);
            doc = utils.clone(doc);
            leanPopulateMap.set(doc, _model);
          } else {
            doc = doc.constructor.hydrate(doc._doc);
          }
        }
        if (recursed) {
          if (doc) {
            if (sorting) {
              const _resultOrder = resultOrder[sid];
              if (options[kHasArray]) {
                newOrder.push(doc);
              } else {
                newOrder[_resultOrder] = doc;
              }
            } else {
              newOrder.push(doc);
            }
          } else if (id != null && id[modelSymbol] != null) {
            newOrder.push(id);
          } else {
            newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);
          }
        } else {
          newOrder[i] = doc || null;
        }
      }
      rawIds.length = 0;
      if (newOrder.length) {
        newOrder.forEach(function(doc2, i2) {
          rawIds[i2] = doc2;
        });
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/getVirtual.js
var require_getVirtual = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/getVirtual.js"(exports2, module2) {
    "use strict";
    module2.exports = getVirtual;
    function getVirtual(schema, name) {
      if (schema.virtuals[name]) {
        return { virtual: schema.virtuals[name], path: void 0 };
      }
      const parts = name.split(".");
      let cur = "";
      let nestedSchemaPath = "";
      for (let i = 0; i < parts.length; ++i) {
        cur += (cur.length > 0 ? "." : "") + parts[i];
        if (schema.virtuals[cur]) {
          if (i === parts.length - 1) {
            return { virtual: schema.virtuals[cur], path: nestedSchemaPath };
          }
          continue;
        }
        if (schema.nested[cur]) {
          continue;
        }
        if (schema.paths[cur] && schema.paths[cur].schema) {
          schema = schema.paths[cur].schema;
          const rest = parts.slice(i + 1).join(".");
          if (schema.virtuals[rest]) {
            if (i === parts.length - 2) {
              return {
                virtual: schema.virtuals[rest],
                nestedSchemaPath: [nestedSchemaPath, cur].filter((v) => !!v).join(".")
              };
            }
            continue;
          }
          if (i + 1 < parts.length && schema.discriminators) {
            for (const key of Object.keys(schema.discriminators)) {
              const res = getVirtual(schema.discriminators[key], rest);
              if (res != null) {
                const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].filter((v) => !!v).join(".");
                return {
                  virtual: res.virtual,
                  nestedSchemaPath: _path
                };
              }
            }
          }
          nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
          cur = "";
          continue;
        }
        if (schema.discriminators) {
          for (const discriminatorKey of Object.keys(schema.discriminators)) {
            const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
            if (virtualFromDiscriminator) return virtualFromDiscriminator;
          }
        }
        return null;
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js
var require_lookupLocalFields = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js"(exports2, module2) {
    "use strict";
    module2.exports = function lookupLocalFields(cur, path, val) {
      if (cur == null) {
        return cur;
      }
      if (cur._doc != null) {
        cur = cur._doc;
      }
      if (arguments.length >= 3) {
        if (typeof cur !== "object") {
          return void 0;
        }
        if (val === void 0) {
          return void 0;
        }
        if (cur instanceof Map) {
          cur.set(path, val);
        } else {
          cur[path] = val;
        }
        return val;
      }
      if (path === "$*") {
        return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key) => cur[key]);
      }
      if (cur instanceof Map) {
        return cur.get(path);
      }
      return cur[path];
    };
  }
});

// asset-input/node_modules/sift/lib/index.js
var require_lib5 = __commonJS({
  "asset-input/node_modules/sift/lib/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.sift = {}));
    })(exports2, function(exports3) {
      "use strict";
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var typeChecker = function(type) {
        var typeString = "[object " + type + "]";
        return function(value) {
          return getClassName(value) === typeString;
        };
      };
      var getClassName = function(value) {
        return Object.prototype.toString.call(value);
      };
      var comparable = function(value) {
        if (value instanceof Date) {
          return value.getTime();
        } else if (isArray(value)) {
          return value.map(comparable);
        } else if (value && typeof value.toJSON === "function") {
          return value.toJSON();
        }
        return value;
      };
      var isArray = typeChecker("Array");
      var isObject = typeChecker("Object");
      var isFunction = typeChecker("Function");
      var isVanillaObject = function(value) {
        return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
      };
      var equals = function(a, b) {
        if (a == null && a == b) {
          return true;
        }
        if (a === b) {
          return true;
        }
        if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {
          return false;
        }
        if (isArray(a)) {
          if (a.length !== b.length) {
            return false;
          }
          for (var i = 0, length_1 = a.length; i < length_1; i++) {
            if (!equals(a[i], b[i]))
              return false;
          }
          return true;
        } else if (isObject(a)) {
          if (Object.keys(a).length !== Object.keys(b).length) {
            return false;
          }
          for (var key in a) {
            if (!equals(a[key], b[key]))
              return false;
          }
          return true;
        }
        return false;
      };
      var walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
        var currentKey = keyPath[depth];
        if (isArray(item) && isNaN(Number(currentKey))) {
          for (var i = 0, length_1 = item.length; i < length_1; i++) {
            if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
              return false;
            }
          }
        }
        if (depth === keyPath.length || item == null) {
          return next(item, key, owner, depth === 0);
        }
        return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
      };
      var BaseOperation = (
        /** @class */
        function() {
          function BaseOperation2(params, owneryQuery, options, name) {
            this.params = params;
            this.owneryQuery = owneryQuery;
            this.options = options;
            this.name = name;
            this.init();
          }
          BaseOperation2.prototype.init = function() {
          };
          BaseOperation2.prototype.reset = function() {
            this.done = false;
            this.keep = false;
          };
          return BaseOperation2;
        }()
      );
      var GroupOperation = (
        /** @class */
        function(_super) {
          __extends(GroupOperation2, _super);
          function GroupOperation2(params, owneryQuery, options, children) {
            var _this = _super.call(this, params, owneryQuery, options) || this;
            _this.children = children;
            return _this;
          }
          GroupOperation2.prototype.reset = function() {
            this.keep = false;
            this.done = false;
            for (var i = 0, length_2 = this.children.length; i < length_2; i++) {
              this.children[i].reset();
            }
          };
          GroupOperation2.prototype.childrenNext = function(item, key, owner, root) {
            var done = true;
            var keep = true;
            for (var i = 0, length_3 = this.children.length; i < length_3; i++) {
              var childOperation = this.children[i];
              if (!childOperation.done) {
                childOperation.next(item, key, owner, root);
              }
              if (!childOperation.keep) {
                keep = false;
              }
              if (childOperation.done) {
                if (!childOperation.keep) {
                  break;
                }
              } else {
                done = false;
              }
            }
            this.done = done;
            this.keep = keep;
          };
          return GroupOperation2;
        }(BaseOperation)
      );
      var NamedGroupOperation = (
        /** @class */
        function(_super) {
          __extends(NamedGroupOperation2, _super);
          function NamedGroupOperation2(params, owneryQuery, options, children, name) {
            var _this = _super.call(this, params, owneryQuery, options, children) || this;
            _this.name = name;
            return _this;
          }
          return NamedGroupOperation2;
        }(GroupOperation)
      );
      var QueryOperation = (
        /** @class */
        function(_super) {
          __extends(QueryOperation2, _super);
          function QueryOperation2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          QueryOperation2.prototype.next = function(item, key, parent, root) {
            this.childrenNext(item, key, parent, root);
          };
          return QueryOperation2;
        }(GroupOperation)
      );
      var NestedOperation = (
        /** @class */
        function(_super) {
          __extends(NestedOperation2, _super);
          function NestedOperation2(keyPath, params, owneryQuery, options, children) {
            var _this = _super.call(this, params, owneryQuery, options, children) || this;
            _this.keyPath = keyPath;
            _this.propop = true;
            _this._nextNestedValue = function(value, key, owner, root) {
              _this.childrenNext(value, key, owner, root);
              return !_this.done;
            };
            return _this;
          }
          NestedOperation2.prototype.next = function(item, key, parent) {
            walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
          };
          return NestedOperation2;
        }(GroupOperation)
      );
      var createTester = function(a, compare) {
        if (a instanceof Function) {
          return a;
        }
        if (a instanceof RegExp) {
          return function(b) {
            var result = typeof b === "string" && a.test(b);
            a.lastIndex = 0;
            return result;
          };
        }
        var comparableA = comparable(a);
        return function(b) {
          return compare(comparableA, comparable(b));
        };
      };
      var EqualsOperation = (
        /** @class */
        function(_super) {
          __extends(EqualsOperation2, _super);
          function EqualsOperation2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          EqualsOperation2.prototype.init = function() {
            this._test = createTester(this.params, this.options.compare);
          };
          EqualsOperation2.prototype.next = function(item, key, parent) {
            if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
              if (this._test(item, key, parent)) {
                this.done = true;
                this.keep = true;
              }
            }
          };
          return EqualsOperation2;
        }(BaseOperation)
      );
      var createEqualsOperation = function(params, owneryQuery, options) {
        return new EqualsOperation(params, owneryQuery, options);
      };
      var NopeOperation = (
        /** @class */
        function(_super) {
          __extends(NopeOperation2, _super);
          function NopeOperation2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          NopeOperation2.prototype.next = function() {
            this.done = true;
            this.keep = false;
          };
          return NopeOperation2;
        }(BaseOperation)
      );
      var numericalOperationCreator = function(createNumericalOperation) {
        return function(params, owneryQuery, options, name) {
          if (params == null) {
            return new NopeOperation(params, owneryQuery, options, name);
          }
          return createNumericalOperation(params, owneryQuery, options, name);
        };
      };
      var numericalOperation = function(createTester2) {
        return numericalOperationCreator(function(params, owneryQuery, options, name) {
          var typeofParams = typeof comparable(params);
          var test = createTester2(params);
          return new EqualsOperation(function(b) {
            return typeof comparable(b) === typeofParams && test(b);
          }, owneryQuery, options, name);
        });
      };
      var createNamedOperation = function(name, params, parentQuery, options) {
        var operationCreator = options.operations[name];
        if (!operationCreator) {
          throwUnsupportedOperation(name);
        }
        return operationCreator(params, parentQuery, options, name);
      };
      var throwUnsupportedOperation = function(name) {
        throw new Error("Unsupported operation: " + name);
      };
      var containsOperation = function(query, options) {
        for (var key in query) {
          if (options.operations.hasOwnProperty(key) || key.charAt(0) === "$")
            return true;
        }
        return false;
      };
      var createNestedOperation = function(keyPath, nestedQuery, parentKey, owneryQuery, options) {
        if (containsOperation(nestedQuery, options)) {
          var _a = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a[0], nestedOperations = _a[1];
          if (nestedOperations.length) {
            throw new Error("Property queries must contain only operations, or exact objects.");
          }
          return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [
          new EqualsOperation(nestedQuery, owneryQuery, options)
        ]);
      };
      var createQueryOperation = function(query, owneryQuery, _a) {
        if (owneryQuery === void 0) {
          owneryQuery = null;
        }
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        var options = {
          compare: compare || equals,
          operations: Object.assign({}, operations || {})
        };
        var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];
        var ops = [];
        if (selfOperations.length) {
          ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));
        }
        ops.push.apply(ops, nestedOperations);
        if (ops.length === 1) {
          return ops[0];
        }
        return new QueryOperation(query, owneryQuery, options, ops);
      };
      var createQueryOperations = function(query, parentKey, options) {
        var selfOperations = [];
        var nestedOperations = [];
        if (!isVanillaObject(query)) {
          selfOperations.push(new EqualsOperation(query, query, options));
          return [selfOperations, nestedOperations];
        }
        for (var key in query) {
          if (options.operations.hasOwnProperty(key)) {
            var op = createNamedOperation(key, query[key], query, options);
            if (op) {
              if (!op.propop && parentKey && !options.operations[parentKey]) {
                throw new Error("Malformed query. " + key + " cannot be matched against property.");
              }
            }
            if (op != null) {
              selfOperations.push(op);
            }
          } else if (key.charAt(0) === "$") {
            throwUnsupportedOperation(key);
          } else {
            nestedOperations.push(createNestedOperation(key.split("."), query[key], key, query, options));
          }
        }
        return [selfOperations, nestedOperations];
      };
      var createOperationTester = function(operation) {
        return function(item, key, owner) {
          operation.reset();
          operation.next(item, key, owner);
          return operation.keep;
        };
      };
      var createQueryTester = function(query, options) {
        if (options === void 0) {
          options = {};
        }
        return createOperationTester(createQueryOperation(query, null, options));
      };
      var $Ne = (
        /** @class */
        function(_super) {
          __extends($Ne2, _super);
          function $Ne2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          $Ne2.prototype.init = function() {
            this._test = createTester(this.params, this.options.compare);
          };
          $Ne2.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this.keep = true;
          };
          $Ne2.prototype.next = function(item) {
            if (this._test(item)) {
              this.done = true;
              this.keep = false;
            }
          };
          return $Ne2;
        }(BaseOperation)
      );
      var $ElemMatch = (
        /** @class */
        function(_super) {
          __extends($ElemMatch2, _super);
          function $ElemMatch2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          $ElemMatch2.prototype.init = function() {
            if (!this.params || typeof this.params !== "object") {
              throw new Error("Malformed query. $elemMatch must by an object.");
            }
            this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
          };
          $ElemMatch2.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this._queryOperation.reset();
          };
          $ElemMatch2.prototype.next = function(item) {
            if (isArray(item)) {
              for (var i = 0, length_1 = item.length; i < length_1; i++) {
                this._queryOperation.reset();
                var child = item[i];
                this._queryOperation.next(child, i, item, false);
                this.keep = this.keep || this._queryOperation.keep;
              }
              this.done = true;
            } else {
              this.done = false;
              this.keep = false;
            }
          };
          return $ElemMatch2;
        }(BaseOperation)
      );
      var $Not = (
        /** @class */
        function(_super) {
          __extends($Not2, _super);
          function $Not2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          $Not2.prototype.init = function() {
            this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
          };
          $Not2.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this._queryOperation.reset();
          };
          $Not2.prototype.next = function(item, key, owner, root) {
            this._queryOperation.next(item, key, owner, root);
            this.done = this._queryOperation.done;
            this.keep = !this._queryOperation.keep;
          };
          return $Not2;
        }(BaseOperation)
      );
      var $Size = (
        /** @class */
        function(_super) {
          __extends($Size2, _super);
          function $Size2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          $Size2.prototype.init = function() {
          };
          $Size2.prototype.next = function(item) {
            if (isArray(item) && item.length === this.params) {
              this.done = true;
              this.keep = true;
            }
          };
          return $Size2;
        }(BaseOperation)
      );
      var assertGroupNotEmpty = function(values) {
        if (values.length === 0) {
          throw new Error("$and/$or/$nor must be a nonempty array");
        }
      };
      var $Or = (
        /** @class */
        function(_super) {
          __extends($Or2, _super);
          function $Or2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = false;
            return _this;
          }
          $Or2.prototype.init = function() {
            var _this = this;
            assertGroupNotEmpty(this.params);
            this._ops = this.params.map(function(op) {
              return createQueryOperation(op, null, _this.options);
            });
          };
          $Or2.prototype.reset = function() {
            this.done = false;
            this.keep = false;
            for (var i = 0, length_2 = this._ops.length; i < length_2; i++) {
              this._ops[i].reset();
            }
          };
          $Or2.prototype.next = function(item, key, owner) {
            var done = false;
            var success = false;
            for (var i = 0, length_3 = this._ops.length; i < length_3; i++) {
              var op = this._ops[i];
              op.next(item, key, owner);
              if (op.keep) {
                done = true;
                success = op.keep;
                break;
              }
            }
            this.keep = success;
            this.done = done;
          };
          return $Or2;
        }(BaseOperation)
      );
      var $Nor = (
        /** @class */
        function(_super) {
          __extends($Nor2, _super);
          function $Nor2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = false;
            return _this;
          }
          $Nor2.prototype.next = function(item, key, owner) {
            _super.prototype.next.call(this, item, key, owner);
            this.keep = !this.keep;
          };
          return $Nor2;
        }($Or)
      );
      var $In = (
        /** @class */
        function(_super) {
          __extends($In2, _super);
          function $In2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          $In2.prototype.init = function() {
            var _this = this;
            this._testers = this.params.map(function(value) {
              if (containsOperation(value, _this.options)) {
                throw new Error("cannot nest $ under " + _this.name.toLowerCase());
              }
              return createTester(value, _this.options.compare);
            });
          };
          $In2.prototype.next = function(item, key, owner) {
            var done = false;
            var success = false;
            for (var i = 0, length_4 = this._testers.length; i < length_4; i++) {
              var test = this._testers[i];
              if (test(item)) {
                done = true;
                success = true;
                break;
              }
            }
            this.keep = success;
            this.done = done;
          };
          return $In2;
        }(BaseOperation)
      );
      var $Nin = (
        /** @class */
        function(_super) {
          __extends($Nin2, _super);
          function $Nin2(params, ownerQuery, options, name) {
            var _this = _super.call(this, params, ownerQuery, options, name) || this;
            _this.propop = true;
            _this._in = new $In(params, ownerQuery, options, name);
            return _this;
          }
          $Nin2.prototype.next = function(item, key, owner, root) {
            this._in.next(item, key, owner);
            if (isArray(owner) && !root) {
              if (this._in.keep) {
                this.keep = false;
                this.done = true;
              } else if (key == owner.length - 1) {
                this.keep = true;
                this.done = true;
              }
            } else {
              this.keep = !this._in.keep;
              this.done = true;
            }
          };
          $Nin2.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this._in.reset();
          };
          return $Nin2;
        }(BaseOperation)
      );
      var $Exists = (
        /** @class */
        function(_super) {
          __extends($Exists2, _super);
          function $Exists2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
          }
          $Exists2.prototype.next = function(item, key, owner) {
            if (owner.hasOwnProperty(key) === this.params) {
              this.done = true;
              this.keep = true;
            }
          };
          return $Exists2;
        }(BaseOperation)
      );
      var $And = (
        /** @class */
        function(_super) {
          __extends($And2, _super);
          function $And2(params, owneryQuery, options, name) {
            var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
              return createQueryOperation(query, owneryQuery, options);
            }), name) || this;
            _this.propop = false;
            assertGroupNotEmpty(params);
            return _this;
          }
          $And2.prototype.next = function(item, key, owner, root) {
            this.childrenNext(item, key, owner, root);
          };
          return $And2;
        }(NamedGroupOperation)
      );
      var $All = (
        /** @class */
        function(_super) {
          __extends($All2, _super);
          function $All2(params, owneryQuery, options, name) {
            var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
              return createQueryOperation(query, owneryQuery, options);
            }), name) || this;
            _this.propop = true;
            return _this;
          }
          $All2.prototype.next = function(item, key, owner, root) {
            this.childrenNext(item, key, owner, root);
          };
          return $All2;
        }(NamedGroupOperation)
      );
      var $eq = function(params, owneryQuery, options) {
        return new EqualsOperation(params, owneryQuery, options);
      };
      var $ne = function(params, owneryQuery, options, name) {
        return new $Ne(params, owneryQuery, options, name);
      };
      var $or = function(params, owneryQuery, options, name) {
        return new $Or(params, owneryQuery, options, name);
      };
      var $nor = function(params, owneryQuery, options, name) {
        return new $Nor(params, owneryQuery, options, name);
      };
      var $elemMatch = function(params, owneryQuery, options, name) {
        return new $ElemMatch(params, owneryQuery, options, name);
      };
      var $nin = function(params, owneryQuery, options, name) {
        return new $Nin(params, owneryQuery, options, name);
      };
      var $in = function(params, owneryQuery, options, name) {
        return new $In(params, owneryQuery, options, name);
      };
      var $lt = numericalOperation(function(params) {
        return function(b) {
          return b < params;
        };
      });
      var $lte = numericalOperation(function(params) {
        return function(b) {
          return b <= params;
        };
      });
      var $gt = numericalOperation(function(params) {
        return function(b) {
          return b > params;
        };
      });
      var $gte = numericalOperation(function(params) {
        return function(b) {
          return b >= params;
        };
      });
      var $mod = function(_a, owneryQuery, options) {
        var mod = _a[0], equalsValue = _a[1];
        return new EqualsOperation(function(b) {
          return comparable(b) % mod === equalsValue;
        }, owneryQuery, options);
      };
      var $exists = function(params, owneryQuery, options, name) {
        return new $Exists(params, owneryQuery, options, name);
      };
      var $regex = function(pattern, owneryQuery, options) {
        return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);
      };
      var $not = function(params, owneryQuery, options, name) {
        return new $Not(params, owneryQuery, options, name);
      };
      var typeAliases = {
        number: function(v) {
          return typeof v === "number";
        },
        string: function(v) {
          return typeof v === "string";
        },
        bool: function(v) {
          return typeof v === "boolean";
        },
        array: function(v) {
          return Array.isArray(v);
        },
        null: function(v) {
          return v === null;
        },
        timestamp: function(v) {
          return v instanceof Date;
        }
      };
      var $type = function(clazz, owneryQuery, options) {
        return new EqualsOperation(function(b) {
          if (typeof clazz === "string") {
            if (!typeAliases[clazz]) {
              throw new Error("Type alias does not exist");
            }
            return typeAliases[clazz](b);
          }
          return b != null ? b instanceof clazz || b.constructor === clazz : false;
        }, owneryQuery, options);
      };
      var $and = function(params, ownerQuery, options, name) {
        return new $And(params, ownerQuery, options, name);
      };
      var $all = function(params, ownerQuery, options, name) {
        return new $All(params, ownerQuery, options, name);
      };
      var $size = function(params, ownerQuery, options) {
        return new $Size(params, ownerQuery, options, "$size");
      };
      var $options = function() {
        return null;
      };
      var $where = function(params, ownerQuery, options) {
        var test;
        if (isFunction(params)) {
          test = params;
        } else if (!process.env.CSP_ENABLED) {
          test = new Function("obj", "return " + params);
        } else {
          throw new Error('In CSP mode, sift does not support strings in "$where" condition');
        }
        return new EqualsOperation(function(b) {
          return test.bind(b)(b);
        }, ownerQuery, options);
      };
      var defaultOperations = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        $Size,
        $eq,
        $ne,
        $or,
        $nor,
        $elemMatch,
        $nin,
        $in,
        $lt,
        $lte,
        $gt,
        $gte,
        $mod,
        $exists,
        $regex,
        $not,
        $type,
        $and,
        $all,
        $size,
        $options,
        $where
      });
      var createDefaultQueryOperation = function(query, ownerQuery, _a) {
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        return createQueryOperation(query, ownerQuery, {
          compare,
          operations: Object.assign({}, defaultOperations, operations || {})
        });
      };
      var createDefaultQueryTester = function(query, options) {
        if (options === void 0) {
          options = {};
        }
        var op = createDefaultQueryOperation(query, null, options);
        return createOperationTester(op);
      };
      exports3.$Size = $Size;
      exports3.$all = $all;
      exports3.$and = $and;
      exports3.$elemMatch = $elemMatch;
      exports3.$eq = $eq;
      exports3.$exists = $exists;
      exports3.$gt = $gt;
      exports3.$gte = $gte;
      exports3.$in = $in;
      exports3.$lt = $lt;
      exports3.$lte = $lte;
      exports3.$mod = $mod;
      exports3.$ne = $ne;
      exports3.$nin = $nin;
      exports3.$nor = $nor;
      exports3.$not = $not;
      exports3.$options = $options;
      exports3.$or = $or;
      exports3.$regex = $regex;
      exports3.$size = $size;
      exports3.$type = $type;
      exports3.$where = $where;
      exports3.EqualsOperation = EqualsOperation;
      exports3.createDefaultQueryOperation = createDefaultQueryOperation;
      exports3.createEqualsOperation = createEqualsOperation;
      exports3.createOperationTester = createOperationTester;
      exports3.createQueryOperation = createQueryOperation;
      exports3.createQueryTester = createQueryTester;
      exports3.default = createDefaultQueryTester;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// asset-input/node_modules/sift/index.js
var require_sift = __commonJS({
  "asset-input/node_modules/sift/index.js"(exports2, module2) {
    var lib = require_lib5();
    module2.exports = lib.default;
    Object.assign(module2.exports, lib);
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/assignVals.js
var require_assignVals = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/assignVals.js"(exports2, module2) {
    "use strict";
    var MongooseMap = require_map2();
    var SkipPopulateValue = require_SkipPopulateValue();
    var assignRawDocsToIdStructure = require_assignRawDocsToIdStructure();
    var get = require_get();
    var getVirtual = require_getVirtual();
    var leanPopulateMap = require_leanPopulateMap();
    var lookupLocalFields = require_lookupLocalFields();
    var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
    var mpath = require_mpath();
    var sift = require_sift().default;
    var utils = require_utils6();
    var { populateModelSymbol } = require_symbols();
    module2.exports = function assignVals(o) {
      const userOptions = Object.assign({}, get(o, "allOptions.options.options"), get(o, "allOptions.options"));
      const populateOptions = Object.assign({}, o.options, userOptions, {
        justOne: o.justOne
      });
      populateOptions.$nullIfNotFound = o.isVirtual;
      const populatedModel = o.populatedModel;
      const originalIds = [].concat(o.rawIds);
      o.allIds = [].concat(o.allIds);
      assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
      const docs = o.docs;
      const rawIds = o.rawIds;
      const options = o.options;
      const count = o.count && o.isVirtual;
      let i;
      function setValue(val) {
        if (count) {
          return val;
        }
        if (val instanceof SkipPopulateValue) {
          return val.val;
        }
        if (val === void 0) {
          return val;
        }
        const _allIds = o.allIds[i];
        if (o.path.endsWith(".$*")) {
          return valueFilter(val, options, populateOptions, _allIds);
        }
        if (o.justOne === true && Array.isArray(val)) {
          const ret = [];
          for (const doc of val) {
            const _docPopulatedModel = leanPopulateMap.get(doc);
            if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
              ret.push(doc);
            }
          }
          while (val.length > ret.length) {
            Array.prototype.pop.apply(val, []);
          }
          for (let i2 = 0; i2 < ret.length; ++i2) {
            val[i2] = ret[i2];
          }
          return valueFilter(val[0], options, populateOptions, _allIds);
        } else if (o.justOne === false && !Array.isArray(val)) {
          return valueFilter([val], options, populateOptions, _allIds);
        }
        return valueFilter(val, options, populateOptions, _allIds);
      }
      for (i = 0; i < docs.length; ++i) {
        const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
        const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
        if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
          continue;
        }
        let valueToSet;
        if (count) {
          valueToSet = numDocs(rawIds[i]);
        } else if (Array.isArray(o.match)) {
          valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];
        } else {
          valueToSet = rawIds[i];
        }
        const originalSchema = o.originalModel.schema;
        const isDoc = get(docs[i], "$__", null) != null;
        let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);
        isMap = isMap && get(originalSchema._getSchema(_path), "$isSchemaMap");
        if (!o.isVirtual && isMap) {
          const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
          valueToSet = valueToSet.reduce((cur2, v, i2) => {
            cur2.set(_keys[i2], v);
            return cur2;
          }, /* @__PURE__ */ new Map());
        }
        if (isDoc && Array.isArray(valueToSet)) {
          for (const val of valueToSet) {
            if (val != null && val.$__ != null) {
              val.$__.parent = docs[i];
            }
          }
        } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
          valueToSet.$__.parent = docs[i];
        }
        if (o.isVirtual && isDoc) {
          docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
          if (Array.isArray(valueToSet)) {
            valueToSet = valueToSet.map((v) => v == null ? void 0 : v);
          }
          mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);
          continue;
        }
        const parts = _path.split(".");
        let cur = docs[i];
        const curPath = parts[0];
        for (let j = 0; j < parts.length - 1; ++j) {
          if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {
            break;
          }
          if (parts[j] === "$*") {
            break;
          }
          if (cur[parts[j]] == null) {
            const schematype = originalSchema._getSchema(curPath);
            if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
              break;
            }
            cur[parts[j]] = {};
          }
          cur = cur[parts[j]];
          if (typeof cur !== "object") {
            break;
          }
        }
        if (docs[i].$__) {
          o.allOptions.options[populateModelSymbol] = o.allOptions.model;
          docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);
          if (valueToSet != null && valueToSet.$__ != null) {
            valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };
          }
          if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {
            valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);
          }
        }
        mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
        if (docs[i].$__) {
          markArraySubdocsPopulated(docs[i], [o.allOptions.options]);
        }
      }
    };
    function numDocs(v) {
      if (Array.isArray(v)) {
        if (v.some((el) => Array.isArray(el) || el === null)) {
          return v.map((el) => {
            if (el == null) {
              return 0;
            }
            if (Array.isArray(el)) {
              return el.filter((el2) => el2 != null).length;
            }
            return 1;
          });
        }
        return v.filter((el) => el != null).length;
      }
      return v == null ? 0 : 1;
    }
    function valueFilter(val, assignmentOpts, populateOptions, allIds) {
      const userSpecifiedTransform = typeof populateOptions.transform === "function";
      const transform = userSpecifiedTransform ? populateOptions.transform : noop;
      if (Array.isArray(val)) {
        const ret = [];
        const numValues = val.length;
        for (let i2 = 0; i2 < numValues; ++i2) {
          let subdoc = val[i2];
          const _allIds = Array.isArray(allIds) ? allIds[i2] : allIds;
          if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
            continue;
          } else if (!populateOptions.retainNullValues && subdoc == null) {
            continue;
          } else if (userSpecifiedTransform) {
            subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
          }
          maybeRemoveId(subdoc, assignmentOpts);
          ret.push(subdoc);
          if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {
            break;
          }
        }
        const rLen = ret.length;
        while (val.length > rLen) {
          Array.prototype.pop.apply(val, []);
        }
        let i = 0;
        if (utils.isMongooseArray(val)) {
          for (i = 0; i < rLen; ++i) {
            val.set(i, ret[i], true);
          }
        } else {
          for (i = 0; i < rLen; ++i) {
            val[i] = ret[i];
          }
        }
        return val;
      }
      if (isPopulatedObject(val) || utils.isPOJO(val)) {
        maybeRemoveId(val, assignmentOpts);
        return transform(val, allIds);
      }
      if (val instanceof Map) {
        return val;
      }
      if (populateOptions.justOne === false) {
        return [];
      }
      return val == null ? transform(val, allIds) : transform(null, allIds);
    }
    function maybeRemoveId(subdoc, assignmentOpts) {
      if (subdoc != null && assignmentOpts.excludeId) {
        if (typeof subdoc.$__setValue === "function") {
          delete subdoc._doc._id;
        } else {
          delete subdoc._id;
        }
      }
    }
    function isPopulatedObject(obj) {
      if (obj == null) {
        return false;
      }
      return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);
    }
    function noop(v) {
      return v;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/castBulkWrite.js
var require_castBulkWrite = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/castBulkWrite.js"(exports2, module2) {
    "use strict";
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var cast = require_cast2();
    var castUpdate = require_castUpdate();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    module2.exports = function castBulkWrite(originalModel, op, options) {
      const now = originalModel.base.now();
      if (op["insertOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["insertOne"]["document"]);
          const doc = new model(op["insertOne"]["document"]);
          if (model.schema.options.timestamps && options.timestamps !== false) {
            doc.initializeTimestamps();
          }
          if (options.session != null) {
            doc.$session(options.session);
          }
          op["insertOne"]["document"] = doc;
          if (options.skipValidation || op["insertOne"].skipValidation) {
            callback(null);
            return;
          }
          op["insertOne"]["document"].$validate({ __noPromise: true }, function(error) {
            if (error) {
              return callback(error, null);
            }
            callback(null);
          });
        };
      } else if (op["updateOne"]) {
        return (callback) => {
          try {
            if (!op["updateOne"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateOne"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model = decideModelByObject(originalModel, op["updateOne"]["filter"]);
            const schema = model.schema;
            const strict = options.strict != null ? options.strict : model.schema.options.strict;
            _addDiscriminatorToObject(schema, op["updateOne"]["filter"]);
            if (model.schema.$timestamps != null && op["updateOne"].timestamps !== false) {
              const createdAt = model.schema.$timestamps.createdAt;
              const updatedAt = model.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateOne"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateOne"]["update"], model.schema);
            if (op["updateOne"].setDefaultsOnInsert !== false) {
              setDefaultsOnInsert(op["updateOne"]["filter"], model.schema, op["updateOne"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateOne"].upsert
              });
            }
            op["updateOne"]["filter"] = cast(model.schema, op["updateOne"]["filter"], {
              strict,
              upsert: op["updateOne"].upsert
            });
            op["updateOne"]["update"] = castUpdate(model.schema, op["updateOne"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateOne"].upsert
            }, model, op["updateOne"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["updateMany"]) {
        return (callback) => {
          try {
            if (!op["updateMany"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateMany"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model = decideModelByObject(originalModel, op["updateMany"]["filter"]);
            const schema = model.schema;
            const strict = options.strict != null ? options.strict : model.schema.options.strict;
            if (op["updateMany"].setDefaultsOnInsert !== false) {
              setDefaultsOnInsert(op["updateMany"]["filter"], model.schema, op["updateMany"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateMany"].upsert
              });
            }
            if (model.schema.$timestamps != null && op["updateMany"].timestamps !== false) {
              const createdAt = model.schema.$timestamps.createdAt;
              const updatedAt = model.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateMany"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateMany"]["update"], model.schema);
            _addDiscriminatorToObject(schema, op["updateMany"]["filter"]);
            op["updateMany"]["filter"] = cast(model.schema, op["updateMany"]["filter"], {
              strict,
              upsert: op["updateMany"].upsert
            });
            op["updateMany"]["update"] = castUpdate(model.schema, op["updateMany"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateMany"].upsert
            }, model, op["updateMany"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["replaceOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["replaceOne"]["filter"]);
          const schema = model.schema;
          const strict = options.strict != null ? options.strict : model.schema.options.strict;
          _addDiscriminatorToObject(schema, op["replaceOne"]["filter"]);
          try {
            op["replaceOne"]["filter"] = cast(model.schema, op["replaceOne"]["filter"], {
              strict,
              upsert: op["replaceOne"].upsert
            });
          } catch (error) {
            return callback(error, null);
          }
          const doc = new model(op["replaceOne"]["replacement"], strict, true);
          if (model.schema.options.timestamps) {
            doc.initializeTimestamps();
          }
          if (options.session != null) {
            doc.$session(options.session);
          }
          op["replaceOne"]["replacement"] = doc;
          if (options.skipValidation || op["replaceOne"].skipValidation) {
            op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
            callback(null);
            return;
          }
          op["replaceOne"]["replacement"].$validate({ __noPromise: true }, function(error) {
            if (error) {
              return callback(error, null);
            }
            op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
            callback(null);
          });
        };
      } else if (op["deleteOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["deleteOne"]["filter"]);
          const schema = model.schema;
          _addDiscriminatorToObject(schema, op["deleteOne"]["filter"]);
          try {
            op["deleteOne"]["filter"] = cast(
              model.schema,
              op["deleteOne"]["filter"]
            );
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["deleteMany"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["deleteMany"]["filter"]);
          const schema = model.schema;
          _addDiscriminatorToObject(schema, op["deleteMany"]["filter"]);
          try {
            op["deleteMany"]["filter"] = cast(
              model.schema,
              op["deleteMany"]["filter"]
            );
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else {
        return (callback) => {
          callback(new Error("Invalid op passed to `bulkWrite()`"), null);
        };
      }
    };
    function _addDiscriminatorToObject(schema, obj) {
      if (schema == null) {
        return;
      }
      if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    function decideModelByObject(model, object) {
      const discriminatorKey = model.schema.options.discriminatorKey;
      if (object != null && object.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;
      }
      return model;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js
var require_createPopulateQueryFilter = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js"(exports2, module2) {
    "use strict";
    var SkipPopulateValue = require_SkipPopulateValue();
    var parentPaths = require_parentPaths();
    var { trusted } = require_trusted();
    var hasDollarKeys = require_hasDollarKeys();
    module2.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
      const match = _formatMatch(_match);
      if (_foreignField.size === 1) {
        const foreignField = Array.from(_foreignField)[0];
        const foreignSchemaType = model.schema.path(foreignField);
        if (foreignField !== "_id" || !match["_id"]) {
          ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
          match[foreignField] = trusted({ $in: ids });
        } else if (foreignField === "_id" && match["_id"]) {
          const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
          match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
        }
        const _parentPaths = parentPaths(foreignField);
        for (let i = 0; i < _parentPaths.length - 1; ++i) {
          const cur = _parentPaths[i];
          if (match[cur] != null && match[cur].$elemMatch != null) {
            match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });
            delete match[foreignField];
            break;
          }
        }
      } else {
        const $or = [];
        if (Array.isArray(match.$or)) {
          match.$and = [{ $or: match.$or }, { $or }];
          delete match.$or;
        } else {
          match.$or = $or;
        }
        for (const foreignField of _foreignField) {
          if (foreignField !== "_id" || !match["_id"]) {
            const foreignSchemaType = model.schema.path(foreignField);
            ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
            $or.push({ [foreignField]: { $in: ids } });
          } else if (foreignField === "_id" && match["_id"]) {
            const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
            match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
          }
        }
      }
      return match;
    };
    function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
      ids = ids.filter((v) => !(v instanceof SkipPopulateValue));
      if (!skipInvalidIds) {
        return ids;
      }
      return ids.filter((id) => {
        try {
          foreignSchemaType.cast(id);
          return true;
        } catch (err) {
          return false;
        }
      });
    }
    function _formatMatch(match) {
      if (Array.isArray(match)) {
        if (match.length > 1) {
          return { $or: [].concat(match.map((m) => Object.assign({}, m))) };
        }
        return Object.assign({}, match[0]);
      }
      return Object.assign({}, match);
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js
var require_getDefaultBulkwriteResult = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js"(exports2, module2) {
    "use strict";
    function getDefaultBulkwriteResult() {
      return {
        result: {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        },
        insertedCount: 0,
        matchedCount: 0,
        modifiedCount: 0,
        deletedCount: 0,
        upsertedCount: 0,
        upsertedIds: {},
        insertedIds: {},
        n: 0
      };
    }
    module2.exports = getDefaultBulkwriteResult;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/firstKey.js
var require_firstKey = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/firstKey.js"(exports2, module2) {
    "use strict";
    module2.exports = function firstKey(obj) {
      if (obj == null) {
        return null;
      }
      return Object.keys(obj)[0];
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js
var require_getSchemaTypes = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"(exports2, module2) {
    "use strict";
    var Mixed = require_mixed();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var leanPopulateMap = require_leanPopulateMap();
    var mpath = require_mpath();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    module2.exports = function getSchemaTypes(model, schema, doc, path) {
      const pathschema = schema.path(path);
      const topLevelDoc = doc;
      if (pathschema) {
        return pathschema;
      }
      const discriminatorKey = schema.discriminatorMapping && schema.discriminatorMapping.key;
      if (discriminatorKey && model != null) {
        if (doc != null && doc[discriminatorKey] != null) {
          const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
          schema = discriminator ? discriminator.schema : schema;
        } else if (model.discriminators != null) {
          return Object.keys(model.discriminators).reduce((arr, name) => {
            const disc = model.discriminators[name];
            return arr.concat(getSchemaTypes(disc, disc.schema, null, path));
          }, []);
        }
      }
      function search(parts2, schema2, subdoc, nestedPath) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema2.path(trypath);
          if (foundschema == null) {
            continue;
          }
          if (foundschema.caster) {
            if (foundschema.caster instanceof Mixed) {
              return foundschema.caster;
            }
            let schemas = null;
            if (foundschema.schema != null && foundschema.schema.discriminators != null) {
              const discriminators = foundschema.schema.discriminators;
              const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
              const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
              schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
                const tiedValue = discriminators[discriminator].discriminatorMapping.value;
                if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                  cur.push(discriminators[discriminator]);
                }
                return cur;
              }, []);
            }
            if (p !== parts2.length && foundschema.schema) {
              let ret;
              if (parts2[p] === "$") {
                if (p + 1 === parts2.length) {
                  return foundschema;
                }
                ret = search(
                  parts2.slice(p + 1),
                  schema2,
                  subdoc ? mpath.get(trypath, subdoc) : null,
                  nestedPath.concat(parts2.slice(0, p))
                );
                if (ret) {
                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret;
              }
              if (schemas != null && schemas.length > 0) {
                ret = [];
                for (const schema3 of schemas) {
                  const _ret = search(
                    parts2.slice(p),
                    schema3,
                    subdoc ? mpath.get(trypath, subdoc) : null,
                    nestedPath.concat(parts2.slice(0, p))
                  );
                  if (_ret != null) {
                    _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    if (_ret.$isUnderneathDocArray) {
                      ret.$isUnderneathDocArray = true;
                    }
                    ret.push(_ret);
                  }
                }
                return ret;
              } else {
                ret = search(
                  parts2.slice(p),
                  foundschema.schema,
                  subdoc ? mpath.get(trypath, subdoc) : null,
                  nestedPath.concat(parts2.slice(0, p))
                );
                if (ret) {
                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret;
              }
            } else if (p !== parts2.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
              let type = foundschema;
              while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
                type = type.casterConstructor;
              }
              const ret = search(
                parts2.slice(p),
                type.schema,
                null,
                nestedPath.concat(parts2.slice(0, p))
              );
              if (ret != null) {
                return ret;
              }
              if (type.schema.discriminators) {
                const discriminatorPaths = [];
                for (const discriminatorName of Object.keys(type.schema.discriminators)) {
                  const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                  const ret2 = search(parts2.slice(p), _schema, null, nestedPath.concat(parts2.slice(0, p)));
                  if (ret2 != null) {
                    discriminatorPaths.push(ret2);
                  }
                }
                if (discriminatorPaths.length > 0) {
                  return discriminatorPaths;
                }
              }
            }
          } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {
            return foundschema.$__schemaType;
          }
          const fullPath = nestedPath.concat([trypath]).join(".");
          if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts2.length) {
            const model2 = doc.$__.populated[fullPath].options[populateModelSymbol];
            if (model2 != null) {
              const ret = search(
                parts2.slice(p),
                model2.schema,
                subdoc ? mpath.get(trypath, subdoc) : null,
                nestedPath.concat(parts2.slice(0, p))
              );
              if (ret) {
                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !model2.schema.$isSingleNested;
              }
              return ret;
            }
          }
          const _val = get(topLevelDoc, trypath);
          if (_val != null) {
            const model2 = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
            const schema3 = model2 != null ? model2.schema : null;
            if (schema3 != null) {
              const ret = search(
                parts2.slice(p),
                schema3,
                subdoc ? mpath.get(trypath, subdoc) : null,
                nestedPath.concat(parts2.slice(0, p))
              );
              if (ret != null) {
                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !schema3.$isSingleNested;
                return ret;
              }
            }
          }
          return foundschema;
        }
      }
      const parts = path.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$") {
          parts[i] = "0";
        }
      }
      return search(parts, schema, doc, []);
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js
var require_isPathExcluded = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js"(exports2, module2) {
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isPathExcluded(projection, path) {
      if (projection == null) {
        return false;
      }
      if (path === "_id") {
        return projection._id === 0;
      }
      const paths = Object.keys(projection);
      let type = null;
      for (const _path of paths) {
        if (isDefiningProjection(projection[_path])) {
          type = projection[path] === 1 ? "inclusive" : "exclusive";
          break;
        }
      }
      if (type === "inclusive") {
        return projection[path] !== 1;
      }
      if (type === "exclusive") {
        return projection[path] === 0;
      }
      return false;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js
var require_modelNamesFromRefPath = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var isPathExcluded = require_isPathExcluded();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var util2 = require("util");
    var utils = require_utils6();
    var hasNumericPropRE = /(\.\d+$|\.\d+\.)/g;
    module2.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {
      if (refPath == null) {
        return [];
      }
      if (typeof refPath === "string" && queryProjection != null && isPathExcluded(queryProjection, refPath)) {
        throw new MongooseError("refPath `" + refPath + "` must not be excluded in projection, got " + util2.inspect(queryProjection));
      }
      if (hasNumericPropRE.test(populatedPath)) {
        const chunks = populatedPath.split(hasNumericPropRE);
        if (chunks[chunks.length - 1] === "") {
          throw new Error("Can't populate individual element in an array");
        }
        let _refPath = "";
        let _remaining = refPath;
        for (let i = 0; i < chunks.length; i += 2) {
          const chunk = chunks[i];
          if (_remaining.startsWith(chunk + ".")) {
            _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];
            _remaining = _remaining.substring(chunk.length + 1);
          } else if (i === chunks.length - 1) {
            _refPath += _remaining;
            _remaining = "";
            break;
          } else {
            throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
          }
        }
        const refValue2 = mpath.get(_refPath, doc, lookupLocalFields);
        let modelNames2 = Array.isArray(refValue2) ? refValue2 : [refValue2];
        modelNames2 = utils.array.flatten(modelNames2);
        return modelNames2;
      }
      const refValue = mpath.get(refPath, doc, lookupLocalFields);
      let modelNames;
      if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {
        modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];
      } else {
        modelNames = Array.isArray(refValue) ? refValue : [refValue];
      }
      modelNames = utils.array.flatten(modelNames);
      return modelNames;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js
var require_getModelsMapForPopulate = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SkipPopulateValue = require_SkipPopulateValue();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var getConstructorName = require_getConstructorName();
    var getSchemaTypes = require_getSchemaTypes();
    var getVirtual = require_getVirtual();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var modelNamesFromRefPath = require_modelNamesFromRefPath();
    var utils = require_utils6();
    var modelSymbol = require_symbols().modelSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var StrictPopulate = require_strictPopulate();
    module2.exports = function getModelsMapForPopulate(model, docs, options) {
      let doc;
      const len = docs.length;
      const map = [];
      const modelNameFromQuery = options.model && options.model.modelName || options.model;
      let schema;
      let refPath;
      let modelNames;
      const available = {};
      const modelSchema = model.schema;
      if (options._localModel != null && options._localModel.schema.nested[options.path]) {
        return [];
      }
      const _virtualRes = getVirtual(model.schema, options.path);
      const virtual = _virtualRes == null ? null : _virtualRes.virtual;
      if (virtual != null) {
        return _virtualPopulate(model, docs, options, _virtualRes);
      }
      let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);
      allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter((v) => v != null);
      if (allSchemaTypes.length === 0 && options.strictPopulate !== false && options._localModel != null) {
        return new StrictPopulate(options._fullPath || options.path);
      }
      for (let i = 0; i < len; i++) {
        doc = docs[i];
        let justOne = null;
        const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;
        schema = getSchemaTypes(model, docSchema, doc, options.path);
        if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
          continue;
        }
        const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;
        if (isUnderneathDocArray && get(options, "options.sort") != null) {
          return new MongooseError("Cannot populate with `sort` on path " + options.path + " because it is a subproperty of a document array");
        }
        modelNames = null;
        let isRefPath = false;
        let normalizedRefPath = null;
        let schemaOptions = null;
        let modelNamesInOrder = null;
        if (schema != null && schema.instance === "Embedded") {
          if (schema.options.ref) {
            const data2 = {
              localField: options.path + "._id",
              foreignField: "_id",
              justOne: true
            };
            const res = _getModelNames(doc, schema, modelNameFromQuery, model);
            const unpopulatedValue = mpath.get(options.path, doc);
            const id2 = mpath.get("_id", unpopulatedValue);
            addModelNamesToMap(model, map, available, res.modelNames, options, data2, id2, doc, schemaOptions, unpopulatedValue);
          }
          continue;
        }
        if (Array.isArray(schema)) {
          const schemasArray = schema;
          for (const _schema of schemasArray) {
            let _modelNames;
            let res;
            try {
              res = _getModelNames(doc, _schema, modelNameFromQuery, model);
              _modelNames = res.modelNames;
              isRefPath = isRefPath || res.isRefPath;
              normalizedRefPath = normalizedRefPath || res.refPath;
              justOne = res.justOne;
            } catch (error) {
              return error;
            }
            if (isRefPath && !res.isRefPath) {
              continue;
            }
            if (!_modelNames) {
              continue;
            }
            modelNames = modelNames || [];
            for (const modelName of _modelNames) {
              if (modelNames.indexOf(modelName) === -1) {
                modelNames.push(modelName);
              }
            }
          }
        } else {
          try {
            const res = _getModelNames(doc, schema, modelNameFromQuery, model);
            modelNames = res.modelNames;
            isRefPath = res.isRefPath;
            normalizedRefPath = normalizedRefPath || res.refPath;
            justOne = res.justOne;
            schemaOptions = get(schema, "options.populate", null);
            if (isRefPath) {
              modelNamesInOrder = modelNames;
              modelNames = Array.from(new Set(modelNames));
            }
          } catch (error) {
            return error;
          }
          if (!modelNames) {
            continue;
          }
        }
        const data = {};
        const localField = options.path;
        const foreignField = "_id";
        if ("justOne" in options && options.justOne !== void 0) {
          justOne = options.justOne;
        } else if (schema && !schema[schemaMixedSymbol]) {
          if (options.path.endsWith("." + schema.path) || options.path === schema.path) {
            justOne = Array.isArray(schema) ? schema.every((schema2) => !schema2.$isMongooseArray) : !schema.$isMongooseArray;
          }
        }
        if (!modelNames) {
          continue;
        }
        data.isVirtual = false;
        data.justOne = justOne;
        data.localField = localField;
        data.foreignField = foreignField;
        const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);
        const id = String(utils.getValue(foreignField, doc));
        options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
        let match = get(options, "match", null);
        const hasMatchFunction = typeof match === "function";
        if (hasMatchFunction) {
          match = match.call(doc, doc);
        }
        data.match = match;
        data.hasMatchFunction = hasMatchFunction;
        data.isRefPath = isRefPath;
        data.modelNamesInOrder = modelNamesInOrder;
        if (isRefPath) {
          const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(
            doc,
            modelSchema,
            data,
            options,
            normalizedRefPath,
            ret
          );
          modelNames = embeddedDiscriminatorModelNames || modelNames;
        }
        try {
          addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);
        } catch (err) {
          return err;
        }
      }
      return map;
      function _getModelNames(doc2, schema2, modelNameFromQuery2, model2) {
        let modelNames2;
        let isRefPath = false;
        let justOne = null;
        const originalSchema = schema2;
        if (schema2 && schema2.instance === "Array") {
          schema2 = schema2.caster;
        }
        if (schema2 && schema2.$isSchemaMap) {
          schema2 = schema2.$__schemaType;
        }
        const ref = schema2 && schema2.options && schema2.options.ref;
        refPath = schema2 && schema2.options && schema2.options.refPath;
        if (schema2 != null && schema2[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery2) {
          return { modelNames: null };
        }
        if (modelNameFromQuery2) {
          modelNames2 = [modelNameFromQuery2];
        } else if (refPath != null) {
          if (typeof refPath === "function") {
            const subdocPath = options.path.slice(0, options.path.length - schema2.path.length - 1);
            const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
            const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
            modelNames2 = /* @__PURE__ */ new Set();
            for (const subdoc of subdocsBeingPopulated) {
              refPath = refPath.call(subdoc, subdoc, options.path);
              modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
            }
            modelNames2 = Array.from(modelNames2);
          } else {
            modelNames2 = modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection);
          }
          isRefPath = true;
        } else {
          let ref2;
          let refPath2;
          let schemaForCurrentDoc;
          let discriminatorValue;
          let modelForCurrentDoc = model2;
          const discriminatorKey = model2.schema.options.discriminatorKey;
          if (!schema2 && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc2))) {
            const discriminatorModel = getDiscriminatorByValue(model2.discriminators, discriminatorValue) || model2;
            if (discriminatorModel != null) {
              modelForCurrentDoc = discriminatorModel;
            } else {
              try {
                modelForCurrentDoc = _getModelFromConn(model2.db, discriminatorValue);
              } catch (error) {
                return error;
              }
            }
            schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
            if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
              schemaForCurrentDoc = schemaForCurrentDoc.caster;
            }
          } else {
            schemaForCurrentDoc = schema2;
          }
          if (originalSchema && originalSchema.path.endsWith(".$*")) {
            justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;
          } else if (schemaForCurrentDoc != null) {
            justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
          }
          if ((ref2 = get(schemaForCurrentDoc, "options.ref")) != null) {
            if (schemaForCurrentDoc != null && typeof ref2 === "function" && options.path.endsWith("." + schemaForCurrentDoc.path)) {
              modelNames2 = /* @__PURE__ */ new Set();
              const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
              const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
              const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
              for (const subdoc of subdocsBeingPopulated) {
                modelNames2.add(handleRefFunction(ref2, subdoc));
              }
              if (subdocsBeingPopulated.length === 0) {
                modelNames2 = [handleRefFunction(ref2, doc2)];
              } else {
                modelNames2 = Array.from(modelNames2);
              }
            } else {
              ref2 = handleRefFunction(ref2, doc2);
              modelNames2 = [ref2];
            }
          } else if ((schemaForCurrentDoc = get(schema2, "options.refPath")) != null) {
            isRefPath = true;
            if (typeof refPath2 === "function") {
              const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
              const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
              const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
              modelNames2 = /* @__PURE__ */ new Set();
              for (const subdoc of subdocsBeingPopulated) {
                refPath2 = refPath2.call(subdoc, subdoc, options.path);
                modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
              }
              modelNames2 = Array.from(modelNames2);
            } else {
              modelNames2 = modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection);
            }
          }
        }
        if (!modelNames2) {
          if (options._localModel == null) {
            modelNames2 = [model2.modelName];
          } else {
            return { modelNames: modelNames2, justOne, isRefPath, refPath };
          }
        }
        if (!Array.isArray(modelNames2)) {
          modelNames2 = [modelNames2];
        }
        return { modelNames: modelNames2, justOne, isRefPath, refPath };
      }
    };
    function _virtualPopulate(model, docs, options, _virtualRes) {
      const map = [];
      const available = {};
      const virtual = _virtualRes.virtual;
      for (const doc of docs) {
        let modelNames = null;
        const data = {};
        let localField;
        const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
        if (typeof options.localField === "string") {
          localField = options.localField;
        } else if (typeof virtual.options.localField === "function") {
          localField = virtualPrefix + virtual.options.localField.call(doc, doc);
        } else if (Array.isArray(virtual.options.localField)) {
          localField = virtual.options.localField.map((field) => virtualPrefix + field);
        } else {
          localField = virtualPrefix + virtual.options.localField;
        }
        data.count = virtual.options.count;
        if (virtual.options.skip != null && !options.hasOwnProperty("skip")) {
          options.skip = virtual.options.skip;
        }
        if (virtual.options.limit != null && !options.hasOwnProperty("limit")) {
          options.limit = virtual.options.limit;
        }
        if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty("perDocumentLimit")) {
          options.perDocumentLimit = virtual.options.perDocumentLimit;
        }
        let foreignField = virtual.options.foreignField;
        if (!localField || !foreignField) {
          return new MongooseError("If you are populating a virtual, you must set the localField and foreignField options");
        }
        if (typeof localField === "function") {
          localField = localField.call(doc, doc);
        }
        if (typeof foreignField === "function") {
          foreignField = foreignField.call(doc, doc);
        }
        data.isRefPath = false;
        let justOne = null;
        if ("justOne" in options && options.justOne !== void 0) {
          justOne = options.justOne;
        }
        if (virtual.options.refPath) {
          modelNames = modelNamesFromRefPath(virtual.options.refPath, doc, options.path);
          justOne = !!virtual.options.justOne;
          data.isRefPath = true;
        } else if (virtual.options.ref) {
          let normalizedRef;
          if (typeof virtual.options.ref === "function" && !virtual.options.ref[modelSymbol]) {
            normalizedRef = virtual.options.ref.call(doc, doc);
          } else {
            normalizedRef = virtual.options.ref;
          }
          justOne = !!virtual.options.justOne;
          if (Array.isArray(normalizedRef)) {
            modelNames = normalizedRef;
          } else {
            modelNames = [normalizedRef];
          }
        }
        data.isVirtual = true;
        data.virtual = virtual;
        data.justOne = justOne;
        let match = get(options, "match", null) || get(data, "virtual.options.match", null) || get(data, "virtual.options.options.match", null);
        let hasMatchFunction = typeof match === "function";
        if (hasMatchFunction) {
          match = match.call(doc, doc);
        }
        if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
          match = Object.assign({}, match);
          for (let i = 1; i < localField.length; ++i) {
            match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);
            hasMatchFunction = true;
          }
          localField = localField[0];
          foreignField = foreignField[0];
        }
        data.localField = localField;
        data.foreignField = foreignField;
        data.match = match;
        data.hasMatchFunction = hasMatchFunction;
        const ret = _getLocalFieldValues(doc, localField, model, options, virtual);
        try {
          addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);
        } catch (err) {
          return err;
        }
      }
      return map;
    }
    function addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {
      const connection = options.connection != null ? options.connection : model.db;
      unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;
      if (Array.isArray(unpopulatedValue)) {
        unpopulatedValue = utils.cloneArrays(unpopulatedValue);
      }
      if (modelNames == null) {
        return;
      }
      let k = modelNames.length;
      while (k--) {
        const modelName = modelNames[k];
        if (modelName == null) {
          continue;
        }
        let Model;
        if (options.model && options.model[modelSymbol]) {
          Model = options.model;
        } else if (modelName[modelSymbol]) {
          Model = modelName;
        } else {
          try {
            Model = _getModelFromConn(connection, modelName);
          } catch (err) {
            if (ret !== void 0) {
              throw err;
            }
            Model = null;
          }
        }
        let ids = ret;
        const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];
        const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;
        if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {
          ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);
        }
        const perDocumentLimit = options.perDocumentLimit == null ? get(options, "options.perDocumentLimit", null) : options.perDocumentLimit;
        if (!available[modelName] || perDocumentLimit != null) {
          const currentOptions = {
            model: Model
          };
          if (data.isVirtual && get(data.virtual, "options.options")) {
            currentOptions.options = utils.clone(data.virtual.options.options);
          } else if (schemaOptions != null) {
            currentOptions.options = Object.assign({}, schemaOptions);
          }
          utils.merge(currentOptions, options);
          options[populateModelSymbol] = Model;
          available[modelName] = {
            model: Model,
            options: currentOptions,
            match: data.hasMatchFunction ? [data.match] : data.match,
            docs: [doc],
            ids: [ids],
            allIds: [ret],
            unpopulatedValues: [unpopulatedValue],
            localField: /* @__PURE__ */ new Set([data.localField]),
            foreignField: /* @__PURE__ */ new Set([data.foreignField]),
            justOne: data.justOne,
            isVirtual: data.isVirtual,
            virtual: data.virtual,
            count: data.count,
            [populateModelSymbol]: Model
          };
          map.push(available[modelName]);
        } else {
          available[modelName].localField.add(data.localField);
          available[modelName].foreignField.add(data.foreignField);
          available[modelName].docs.push(doc);
          available[modelName].ids.push(ids);
          available[modelName].allIds.push(ret);
          available[modelName].unpopulatedValues.push(unpopulatedValue);
          if (data.hasMatchFunction) {
            available[modelName].match.push(data.match);
          }
        }
      }
    }
    function _getModelFromConn(conn, modelName) {
      if (conn.models[modelName] == null && conn._parent != null) {
        return _getModelFromConn(conn._parent, modelName);
      }
      return conn.model(modelName);
    }
    function handleRefFunction(ref, doc) {
      if (typeof ref === "function" && !ref[modelSymbol]) {
        return ref.call(doc, doc);
      }
      return ref;
    }
    function _getLocalFieldValues(doc, localField, model, options, virtual, schema) {
      const localFieldPathType = model.schema._getPathType(localField);
      const localFieldPath = localFieldPathType === "real" ? model.schema.path(localField) : localFieldPathType.schema;
      const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
      localField = localFieldPath != null && localFieldPath.instance === "Embedded" ? localField + "._id" : localField;
      const _populateOptions = get(options, "options", {});
      const getters = "getters" in _populateOptions ? _populateOptions.getters : get(virtual, "options.getters", false);
      if (localFieldGetters.length !== 0 && getters) {
        const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
        const localFieldValue = utils.getValue(localField, doc);
        if (Array.isArray(localFieldValue)) {
          const localFieldHydratedValue = utils.getValue(localField.split(".").slice(0, -1), hydratedDoc);
          return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
        } else {
          return localFieldPath.applyGetters(localFieldValue, hydratedDoc);
        }
      } else {
        return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
      }
    }
    function convertTo_id(val, schema) {
      if (val != null && val.$__ != null) {
        return val._id;
      }
      if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
        return val._id;
      }
      if (Array.isArray(val)) {
        const rawVal = val.__array != null ? val.__array : val;
        for (let i = 0; i < rawVal.length; ++i) {
          if (rawVal[i] != null && rawVal[i].$__ != null) {
            rawVal[i] = rawVal[i]._id;
          }
        }
        if (utils.isMongooseArray(val) && val.$schema()) {
          return val.$schema()._castForPopulate(val, val.$parent());
        }
        return [].concat(val);
      }
      if (getConstructorName(val) === "Object" && // The intent here is we should only flatten the object if we expect
      // to get a Map in the end. Avoid doing this for mixed types.
      (schema == null || schema[schemaMixedSymbol] == null)) {
        const ret = [];
        for (const key of Object.keys(val)) {
          ret.push(val[key]);
        }
        return ret;
      }
      if (val instanceof Map) {
        return Array.from(val.values());
      }
      return val;
    }
    function _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {
      if (!data.isRefPath || normalizedRefPath == null) {
        return;
      }
      const pieces = normalizedRefPath.split(".");
      let cur = "";
      let modelNames = void 0;
      for (let i = 0; i < pieces.length; ++i) {
        const piece = pieces[i];
        cur = cur + (cur.length === 0 ? "" : ".") + piece;
        const schematype = modelSchema.path(cur);
        if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {
          const subdocs = utils.getValue(cur, doc);
          const remnant = options.path.substring(cur.length + 1);
          const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
          modelNames = [];
          for (const subdoc of subdocs) {
            const discriminatorName = utils.getValue(discriminatorKey, subdoc);
            const discriminator = schematype.caster.discriminators[discriminatorName];
            const discriminatorSchema = discriminator && discriminator.schema;
            if (discriminatorSchema == null) {
              continue;
            }
            const _path = discriminatorSchema.path(remnant);
            if (_path == null || _path.options.refPath == null) {
              const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);
              ret.forEach((v, i2) => {
                if (v === docValue) {
                  ret[i2] = SkipPopulateValue(v);
                }
              });
              continue;
            }
            const modelName = utils.getValue(pieces.slice(i + 1).join("."), subdoc);
            modelNames.push(modelName);
          }
        }
      }
      return modelNames;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js
var require_isDefaultIdIndex = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function isDefaultIdIndex(index) {
      if (Array.isArray(index)) {
        const keys = Object.keys(index[0]);
        return keys.length === 1 && keys[0] === "_id" && index[0]._id !== "hashed";
      }
      if (typeof index !== "object") {
        return false;
      }
      const key = get(index, "key", {});
      return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js
var require_isIndexEqual = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var utils = require_utils6();
    module2.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {
      if (dbIndex.textIndexVersion != null) {
        delete dbIndex.key._fts;
        delete dbIndex.key._ftsx;
        const weights = { ...dbIndex.weights, ...dbIndex.key };
        if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {
          return false;
        }
        for (const prop of Object.keys(weights)) {
          if (!(prop in schemaIndexKeysObject)) {
            return false;
          }
          const weight = weights[prop];
          if (weight !== get(options, "weights." + prop) && !(weight === 1 && get(options, "weights." + prop) == null)) {
            return false;
          }
        }
        if (options["default_language"] !== dbIndex["default_language"]) {
          return dbIndex["default_language"] === "english" && options["default_language"] == null;
        }
        return true;
      }
      const optionKeys = [
        "unique",
        "partialFilterExpression",
        "sparse",
        "expireAfterSeconds",
        "collation"
      ];
      for (const key of optionKeys) {
        if (!(key in options) && !(key in dbIndex)) {
          continue;
        }
        if (key === "collation") {
          if (options[key] == null || dbIndex[key] == null) {
            return options[key] == null && dbIndex[key] == null;
          }
          const definedKeys = Object.keys(options.collation);
          const schemaCollation = options.collation;
          const dbCollation = dbIndex.collation;
          for (const opt of definedKeys) {
            if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
              return false;
            }
          }
        } else if (!utils.deepEqual(options[key], dbIndex[key])) {
          return false;
        }
      }
      const schemaIndexKeys = Object.keys(schemaIndexKeysObject);
      const dbIndexKeys = Object.keys(dbIndex.key);
      if (schemaIndexKeys.length !== dbIndexKeys.length) {
        return false;
      }
      for (let i = 0; i < schemaIndexKeys.length; ++i) {
        if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
          return false;
        }
        if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
          return false;
        }
      }
      return true;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js
var require_getRelatedIndexes = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js"(exports2, module2) {
    "use strict";
    function getRelatedSchemaIndexes(model, schemaIndexes) {
      return getRelatedIndexes({
        baseModelName: model.baseModelName,
        discriminatorMapping: model.schema.discriminatorMapping,
        indexes: schemaIndexes,
        indexesType: "schema"
      });
    }
    function getRelatedDBIndexes(model, dbIndexes) {
      return getRelatedIndexes({
        baseModelName: model.baseModelName,
        discriminatorMapping: model.schema.discriminatorMapping,
        indexes: dbIndexes,
        indexesType: "db"
      });
    }
    module2.exports = {
      getRelatedSchemaIndexes,
      getRelatedDBIndexes
    };
    function getRelatedIndexes({
      baseModelName,
      discriminatorMapping,
      indexes,
      indexesType
    }) {
      const discriminatorKey = discriminatorMapping && discriminatorMapping.key;
      const discriminatorValue = discriminatorMapping && discriminatorMapping.value;
      if (!discriminatorKey) {
        return indexes;
      }
      const isChildDiscriminatorModel = Boolean(baseModelName);
      if (isChildDiscriminatorModel) {
        return indexes.filter((index) => {
          const partialFilterExpression = getPartialFilterExpression(index, indexesType);
          return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;
        });
      }
      return indexes.filter((index) => {
        const partialFilterExpression = getPartialFilterExpression(index, indexesType);
        return !partialFilterExpression || !partialFilterExpression[discriminatorKey];
      });
    }
    function getPartialFilterExpression(index, indexesType) {
      if (indexesType === "schema") {
        const options = index[1];
        return options && options.partialFilterExpression;
      }
      return index.partialFilterExpression;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js
var require_isPathSelectedInclusive = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js"(exports2, module2) {
    "use strict";
    module2.exports = function isPathSelectedInclusive(fields, path) {
      const chunks = path.split(".");
      let cur = "";
      let j;
      let keys;
      let numKeys;
      for (let i = 0; i < chunks.length; ++i) {
        cur += cur.length ? "." : "" + chunks[i];
        if (fields[cur]) {
          keys = Object.keys(fields);
          numKeys = keys.length;
          for (j = 0; j < numKeys; ++j) {
            if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path) !== 0) {
              continue;
            }
          }
          return true;
        }
      }
      return false;
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/parallelLimit.js
var require_parallelLimit = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/parallelLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = parallelLimit;
    function parallelLimit(fns, limit, callback) {
      let numInProgress = 0;
      let numFinished = 0;
      let error = null;
      if (limit <= 0) {
        throw new Error("Limit must be positive");
      }
      if (fns.length === 0) {
        return callback(null, []);
      }
      for (let i = 0; i < fns.length && i < limit; ++i) {
        _start();
      }
      function _start() {
        fns[numFinished + numInProgress](_done(numFinished + numInProgress));
        ++numInProgress;
      }
      const results = [];
      function _done(index) {
        return (err, res) => {
          --numInProgress;
          ++numFinished;
          if (error != null) {
            return;
          }
          if (err != null) {
            error = err;
            return callback(error);
          }
          results[index] = res;
          if (numFinished === fns.length) {
            return callback(null, results);
          } else if (numFinished + numInProgress < fns.length) {
            _start();
          }
        };
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js
var require_pushNestedArrayPaths = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js"(exports2, module2) {
    "use strict";
    module2.exports = function pushNestedArrayPaths(paths, nestedArray, path) {
      if (nestedArray == null) {
        return;
      }
      for (let i = 0; i < nestedArray.length; ++i) {
        if (Array.isArray(nestedArray[i])) {
          pushNestedArrayPaths(paths, nestedArray[i], path + "." + i);
        } else {
          paths.push(path + "." + i);
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js
var require_removeDeselectedForeignField = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var mpath = require_mpath();
    var parseProjection = require_parseProjection();
    module2.exports = function removeDeselectedForeignField(foreignFields, options, docs) {
      const projection = parseProjection(get(options, "select", null), true) || parseProjection(get(options, "options.select", null), true);
      if (projection == null) {
        return;
      }
      for (const foreignField of foreignFields) {
        if (!projection.hasOwnProperty("-" + foreignField)) {
          continue;
        }
        for (const val of docs) {
          if (val.$__ != null) {
            mpath.unset(foreignField, val._doc);
          } else {
            mpath.unset(foreignField, val);
          }
        }
      }
    };
  }
});

// asset-input/node_modules/mongoose/lib/model.js
var require_model = __commonJS({
  "asset-input/node_modules/mongoose/lib/model.js"(exports2, module2) {
    "use strict";
    var Aggregate = require_aggregate2();
    var ChangeStream = require_ChangeStream();
    var Document = require_document();
    var DocumentNotFoundError = require_notFound();
    var DivergentArrayError = require_divergentArray();
    var EventEmitter = require("events").EventEmitter;
    var MongooseBulkWriteError = require_bulkWriteError();
    var MongooseBuffer = require_buffer();
    var MongooseError = require_error3();
    var OverwriteModelError = require_overwriteModel();
    var PromiseProvider = require_promise_provider2();
    var Query = require_query();
    var RemoveOptions = require_removeOptions();
    var SaveOptions = require_saveOptions();
    var Schema = require_schema2();
    var ServerSelectionError = require_serverSelection();
    var ValidationError2 = require_validation();
    var VersionError = require_version();
    var ParallelSaveError = require_parallelSave();
    var applyDefaultsHelper = require_applyDefaults();
    var applyDefaultsToPOJO = require_applyDefaultsToPOJO();
    var applyQueryMiddleware = require_applyQueryMiddleware();
    var applyHooks = require_applyHooks();
    var applyMethods = require_applyMethods();
    var applyProjection = require_applyProjection();
    var applySchemaCollation = require_applySchemaCollation();
    var applyStaticHooks = require_applyStaticHooks();
    var applyStatics = require_applyStatics();
    var applyWriteConcern = require_applyWriteConcern();
    var assignVals = require_assignVals();
    var castBulkWrite = require_castBulkWrite();
    var createPopulateQueryFilter = require_createPopulateQueryFilter();
    var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
    var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
    var discriminator = require_discriminator();
    var firstKey = require_firstKey();
    var each = require_each();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var getModelsMapForPopulate = require_getModelsMapForPopulate();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var isDefaultIdIndex = require_isDefaultIdIndex();
    var isIndexEqual = require_isIndexEqual();
    var {
      getRelatedDBIndexes,
      getRelatedSchemaIndexes
    } = require_getRelatedIndexes();
    var isPathExcluded = require_isPathExcluded();
    var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
    var isPathSelectedInclusive = require_isPathSelectedInclusive();
    var leanPopulateMap = require_leanPopulateMap();
    var modifiedPaths = require_modifiedPaths();
    var parallelLimit = require_parallelLimit();
    var parentPaths = require_parentPaths();
    var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
    var pushNestedArrayPaths = require_pushNestedArrayPaths();
    var removeDeselectedForeignField = require_removeDeselectedForeignField();
    var setDottedPath = require_setDottedPath();
    var STATES = require_connectionstate();
    var util2 = require("util");
    var utils = require_utils6();
    var VERSION_WHERE = 1;
    var VERSION_INC = 2;
    var VERSION_ALL = VERSION_WHERE | VERSION_INC;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var modelCollectionSymbol = Symbol("mongoose#Model#collection");
    var modelDbSymbol = Symbol("mongoose#Model#db");
    var modelSymbol = require_symbols().modelSymbol;
    var subclassedSymbol = Symbol("mongoose#Model#subclassed");
    var saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
      bson: true
    });
    function Model(doc, fields, skipId) {
      if (fields instanceof Schema) {
        throw new TypeError("2nd argument to `Model` must be a POJO or string, **not** a schema. Make sure you're calling `mongoose.model()`, not `mongoose.Model()`.");
      }
      Document.call(this, doc, fields, skipId);
    }
    Object.setPrototypeOf(Model.prototype, Document.prototype);
    Model.prototype.$isMongooseModelPrototype = true;
    Model.prototype.db;
    Model.prototype.collection;
    Model.prototype.$__collection;
    Model.prototype.modelName;
    Model.prototype.$where;
    Model.prototype.baseModelName;
    Model.events;
    Model._middleware;
    function _applyCustomWhere(doc, where) {
      if (doc.$where == null) {
        return;
      }
      for (const key of Object.keys(doc.$where)) {
        where[key] = doc.$where[key];
      }
    }
    Model.prototype.$__handleSave = function(options, callback) {
      const saveOptions = {};
      applyWriteConcern(this.$__schema, options);
      if (typeof options.writeConcern !== "undefined") {
        saveOptions.writeConcern = {};
        if ("w" in options.writeConcern) {
          saveOptions.writeConcern.w = options.writeConcern.w;
        }
        if ("j" in options.writeConcern) {
          saveOptions.writeConcern.j = options.writeConcern.j;
        }
        if ("wtimeout" in options.writeConcern) {
          saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
        }
      } else {
        if ("w" in options) {
          saveOptions.w = options.w;
        }
        if ("j" in options) {
          saveOptions.j = options.j;
        }
        if ("wtimeout" in options) {
          saveOptions.wtimeout = options.wtimeout;
        }
      }
      if ("checkKeys" in options) {
        saveOptions.checkKeys = options.checkKeys;
      }
      const session = this.$session();
      if (!saveOptions.hasOwnProperty("session") && session != null) {
        saveOptions.session = session;
      }
      if (this.$isNew) {
        const obj = this.toObject(saveToObjectOptions);
        if ((obj || {})._id === void 0) {
          immediate(function() {
            callback(new MongooseError("document must have an _id before saving"));
          });
          return;
        }
        this.$__version(true, obj);
        this[modelCollectionSymbol].insertOne(obj, saveOptions, (err, ret) => {
          if (err) {
            _setIsNew(this, true);
            callback(err, null);
            return;
          }
          callback(null, ret);
        });
        this.$__reset();
        _setIsNew(this, false);
        this.$__.inserting = true;
        return;
      }
      this.$__.inserting = false;
      const delta = this.$__delta();
      if (delta) {
        if (delta instanceof MongooseError) {
          callback(delta);
          return;
        }
        const where = this.$__where(delta[0]);
        if (where instanceof MongooseError) {
          callback(where);
          return;
        }
        _applyCustomWhere(this, where);
        this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, (err, ret) => {
          if (err) {
            this.$__undoReset();
            callback(err);
            return;
          }
          ret.$where = where;
          callback(null, ret);
        });
      } else {
        const optionsWithCustomValues = Object.assign({}, options, saveOptions);
        const where = this.$__where();
        const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
        if (optimisticConcurrency) {
          const key = this.$__schema.options.versionKey;
          const val = this.$__getValue(key);
          if (val != null) {
            where[key] = val;
          }
        }
        this.constructor.exists(where, optionsWithCustomValues).then((documentExists) => {
          const matchedCount = !documentExists ? 0 : 1;
          callback(null, { $where: where, matchedCount });
        }).catch(callback);
        return;
      }
      this.$__.modifiedPaths = this.modifiedPaths();
      this.$__reset();
      _setIsNew(this, false);
    };
    Model.prototype.$__save = function(options, callback) {
      this.$__handleSave(options, (error, result) => {
        if (error) {
          const hooks = this.$__schema.s.hooks;
          return hooks.execPost("save:error", this, [this], { error }, (error2) => {
            callback(error2, this);
          });
        }
        let numAffected = 0;
        const writeConcern = options != null ? options.writeConcern != null ? options.writeConcern.w : options.w : 0;
        if (writeConcern !== 0) {
          if (result != null) {
            if (Array.isArray(result)) {
              numAffected = result.length;
            } else if (result.matchedCount != null) {
              numAffected = result.matchedCount;
            } else {
              numAffected = result;
            }
          }
          const versionBump = this.$__.version;
          if (versionBump && !this.$__.inserting) {
            const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
            this.$__.version = void 0;
            const key = this.$__schema.options.versionKey;
            const version = this.$__getValue(key) || 0;
            if (numAffected <= 0) {
              this.$__undoReset();
              const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
              return callback(err);
            }
            if (doIncrement) {
              this.$__setValue(key, version + 1);
            }
          }
          if (result != null && numAffected <= 0) {
            this.$__undoReset();
            error = new DocumentNotFoundError(
              result.$where,
              this.constructor.modelName,
              numAffected,
              result
            );
            const hooks = this.$__schema.s.hooks;
            return hooks.execPost("save:error", this, [this], { error }, (error2) => {
              callback(error2, this);
            });
          }
        }
        this.$__.saving = void 0;
        this.$__.savedState = {};
        this.$emit("save", this, numAffected);
        this.constructor.emit("save", this, numAffected);
        callback(null, this);
      });
    };
    function generateVersionError(doc, modifiedPaths2) {
      const key = doc.$__schema.options.versionKey;
      if (!key) {
        return null;
      }
      const version = doc.$__getValue(key) || 0;
      return new VersionError(doc, version, modifiedPaths2);
    }
    Model.prototype.save = function(options, fn) {
      let parallelSave;
      this.$op = "save";
      if (this.$__.saving) {
        parallelSave = new ParallelSaveError(this);
      } else {
        this.$__.saving = new ParallelSaveError(this);
      }
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      options = new SaveOptions(options);
      if (options.hasOwnProperty("session")) {
        this.$session(options.session);
      }
      if (this.$__.timestamps != null) {
        options.timestamps = this.$__.timestamps;
      }
      this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        if (parallelSave) {
          this.$__handleReject(parallelSave);
          return cb(parallelSave);
        }
        this.$__.saveOptions = options;
        this.$__save(options, (error) => {
          this.$__.saving = null;
          this.$__.saveOptions = null;
          this.$__.$versionError = null;
          this.$op = null;
          if (error) {
            this.$__handleReject(error);
            return cb(error);
          }
          cb(null, this);
        });
      }, this.constructor.events);
    };
    Model.prototype.$save = Model.prototype.save;
    function shouldSkipVersioning(self2, path) {
      const skipVersioning = self2.$__schema.options.skipVersioning;
      if (!skipVersioning) return false;
      path = path.replace(/\.\d+\./, ".");
      return skipVersioning[path];
    }
    function operand(self2, where, delta, data, val, op) {
      op || (op = "$set");
      if (!delta[op]) delta[op] = {};
      delta[op][data.path] = val;
      if (self2.$__schema.options.versionKey === false) return;
      if (shouldSkipVersioning(self2, data.path)) return;
      if (VERSION_ALL === (VERSION_ALL & self2.$__.version)) return;
      if (self2.$__schema.options.optimisticConcurrency) {
        return;
      }
      switch (op) {
        case "$set":
        case "$unset":
        case "$pop":
        case "$pull":
        case "$pullAll":
        case "$push":
        case "$addToSet":
        case "$inc":
          break;
        default:
          return;
      }
      if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
        if (/\.\d+\.|\.\d+$/.test(data.path)) {
          increment.call(self2);
        } else {
          self2.$__.version = VERSION_INC;
        }
      } else if (/^\$p/.test(op)) {
        increment.call(self2);
      } else if (Array.isArray(val)) {
        increment.call(self2);
      } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
        self2.$__.version = VERSION_WHERE;
      }
    }
    function handleAtomics(self2, where, delta, data, value) {
      if (delta.$set && delta.$set[data.path]) {
        return;
      }
      if (typeof value.$__getAtomics === "function") {
        value.$__getAtomics().forEach(function(atomic) {
          const op2 = atomic[0];
          const val2 = atomic[1];
          operand(self2, where, delta, data, val2, op2);
        });
        return;
      }
      const atomics = value[arrayAtomicsSymbol];
      const ops = Object.keys(atomics);
      let i = ops.length;
      let val;
      let op;
      if (i === 0) {
        if (utils.isMongooseObject(value)) {
          value = value.toObject({ depopulate: 1, _isNested: true });
        } else if (value.valueOf) {
          value = value.valueOf();
        }
        return operand(self2, where, delta, data, value);
      }
      function iter(mem) {
        return utils.isMongooseObject(mem) ? mem.toObject({ depopulate: 1, _isNested: true }) : mem;
      }
      while (i--) {
        op = ops[i];
        val = atomics[op];
        if (utils.isMongooseObject(val)) {
          val = val.toObject({ depopulate: true, transform: false, _isNested: true });
        } else if (Array.isArray(val)) {
          val = val.map(iter);
        } else if (val.valueOf) {
          val = val.valueOf();
        }
        if (op === "$addToSet") {
          val = { $each: val };
        }
        operand(self2, where, delta, data, val, op);
      }
    }
    Model.prototype.$__delta = function() {
      const dirty = this.$__dirty();
      const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
      if (optimisticConcurrency) {
        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
      }
      if (!dirty.length && VERSION_ALL !== this.$__.version) {
        return;
      }
      const where = {};
      const delta = {};
      const len = dirty.length;
      const divergent = [];
      let d = 0;
      where._id = this._doc._id;
      if ((where && where._id && where._id.$__ || null) != null) {
        where._id = where._id.toObject({ transform: false, depopulate: true });
      }
      for (; d < len; ++d) {
        const data = dirty[d];
        let value = data.value;
        const match = checkDivergentArray(this, data.path, value);
        if (match) {
          divergent.push(match);
          continue;
        }
        const pop = this.$populated(data.path, true);
        if (!pop && this.$__.selected) {
          const pathSplit = data.path.split(".");
          const top = pathSplit[0];
          if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
            if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
              where[top] = this.$__.selected[top];
              pathSplit[1] = "$";
              data.path = pathSplit.join(".");
            } else {
              divergent.push(data.path);
              continue;
            }
          }
        }
        if (this.$isDefault(data.path) && this.$__.selected) {
          if (data.path.indexOf(".") === -1 && isPathExcluded(this.$__.selected, data.path)) {
            continue;
          }
          const pathsToCheck = parentPaths(data.path);
          if (pathsToCheck.find((path) => isPathExcluded(this.$__.isSelected, path))) {
            continue;
          }
        }
        if (divergent.length) continue;
        if (value === void 0) {
          operand(this, where, delta, data, 1, "$unset");
        } else if (value === null) {
          operand(this, where, delta, data, null);
        } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {
          handleAtomics(this, where, delta, data, value);
        } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
          value = value.toObject();
          operand(this, where, delta, data, value);
        } else {
          if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {
            const val = this.$__.primitiveAtomics[data.path];
            const op = firstKey(val);
            operand(this, where, delta, data, val[op], op);
          } else {
            value = utils.clone(value, {
              depopulate: true,
              transform: false,
              virtuals: false,
              getters: false,
              omitUndefined: true,
              _isNested: true
            });
            operand(this, where, delta, data, value);
          }
        }
      }
      if (divergent.length) {
        return new DivergentArrayError(divergent);
      }
      if (this.$__.version) {
        this.$__version(where, delta);
      }
      if (Object.keys(delta).length === 0) {
        return [where, null];
      }
      return [where, delta];
    };
    function checkDivergentArray(doc, path, array) {
      const pop = doc.$populated(path, true);
      if (!pop && doc.$__.selected) {
        const top = path.split(".")[0];
        if (doc.$__.selected[top + ".$"]) {
          return top;
        }
      }
      if (!(pop && utils.isMongooseArray(array))) return;
      const check = pop.options.match || pop.options.options && utils.object.hasOwnProperty(pop.options.options, "limit") || // 0 is not permitted
      pop.options.options && pop.options.options.skip || // 0 is permitted
      pop.options.select && // deselected _id?
      (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
      if (check) {
        const atomics = array[arrayAtomicsSymbol];
        if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
          return path;
        }
      }
    }
    Model.prototype.$__version = function(where, delta) {
      const key = this.$__schema.options.versionKey;
      if (where === true) {
        if (key) {
          setDottedPath(delta, key, 0);
          this.$__setValue(key, 0);
        }
        return;
      }
      if (key === false) {
        return;
      }
      if (!this.$__isSelected(key)) {
        return;
      }
      if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
        const value = this.$__getValue(key);
        if (value != null) where[key] = value;
      }
      if (VERSION_INC === (VERSION_INC & this.$__.version)) {
        if (get(delta.$set, key, null) != null) {
          ++delta.$set[key];
        } else {
          delta.$inc = delta.$inc || {};
          delta.$inc[key] = 1;
        }
      }
    };
    function increment() {
      this.$__.version = VERSION_ALL;
      return this;
    }
    Model.prototype.increment = increment;
    Model.prototype.$__where = function _where(where) {
      where || (where = {});
      if (!where._id) {
        where._id = this._doc._id;
      }
      if (this._doc._id === void 0) {
        return new MongooseError("No _id found on document!");
      }
      return where;
    };
    Model.prototype.remove = function remove(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      options = new RemoveOptions(options);
      if (options.hasOwnProperty("session")) {
        this.$session(options.session);
      }
      this.$op = "remove";
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__remove(options, (err, res) => {
          this.$op = null;
          cb(err, res);
        });
      }, this.constructor.events);
    };
    Model.prototype.$remove = Model.prototype.remove;
    Model.prototype.delete = Model.prototype.remove;
    Model.prototype.deleteOne = function deleteOne(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      if (!options) {
        options = {};
      }
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__deleteOne(options, cb);
      }, this.constructor.events);
    };
    Model.prototype.$__remove = function $__remove(options, cb) {
      if (this.$__.isDeleted) {
        return immediate(() => cb(null, this));
      }
      const where = this.$__where();
      if (where instanceof MongooseError) {
        return cb(where);
      }
      _applyCustomWhere(this, where);
      const session = this.$session();
      if (!options.hasOwnProperty("session")) {
        options.session = session;
      }
      this[modelCollectionSymbol].deleteOne(where, options, (err) => {
        if (!err) {
          this.$__.isDeleted = true;
          this.$emit("remove", this);
          this.constructor.emit("remove", this);
          return cb(null, this);
        }
        this.$__.isDeleted = false;
        cb(err);
      });
    };
    Model.prototype.$__deleteOne = Model.prototype.$__remove;
    Model.prototype.model = function model(name) {
      return this[modelDbSymbol].model(name);
    };
    Model.prototype.$model = function $model(name) {
      return this[modelDbSymbol].model(name);
    };
    Model.exists = function exists(filter, options, callback) {
      _checkContext(this, "exists");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const query = this.findOne(filter).select({ _id: 1 }).lean().setOptions(options);
      if (typeof callback === "function") {
        return query.exec(callback);
      }
      return query;
    };
    Model.discriminator = function(name, schema, options) {
      let model;
      if (typeof name === "function") {
        model = name;
        name = utils.getFunctionName(model);
        if (!(model.prototype instanceof Model)) {
          throw new MongooseError("The provided class " + name + " must extend Model");
        }
      }
      options = options || {};
      const value = utils.isPOJO(options) ? options.value : options;
      const clone = typeof options.clone === "boolean" ? options.clone : true;
      const mergePlugins = typeof options.mergePlugins === "boolean" ? options.mergePlugins : true;
      _checkContext(this, "discriminator");
      if (utils.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema(schema);
      }
      if (schema instanceof Schema && clone) {
        schema = schema.clone();
      }
      schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);
      if (this.db.models[name] && !schema.options.overwriteModels) {
        throw new OverwriteModelError(name);
      }
      schema.$isRootDiscriminator = true;
      schema.$globalPluginsApplied = true;
      model = this.db.model(model || name, schema, this.$__collection.name);
      this.discriminators[name] = model;
      const d = this.discriminators[name];
      Object.setPrototypeOf(d.prototype, this.prototype);
      Object.defineProperty(d, "baseModelName", {
        value: this.modelName,
        configurable: true,
        writable: false
      });
      applyMethods(d, schema);
      applyStatics(d, schema);
      if (this[subclassedSymbol] != null) {
        for (const submodel of this[subclassedSymbol]) {
          submodel.discriminators = submodel.discriminators || {};
          submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);
        }
      }
      return d;
    };
    function _checkContext(ctx, fnName) {
      if (ctx == null || ctx === global) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are calling `MyModel." + fnName + "()` where `MyModel` is a Mongoose model.");
      } else if (ctx[modelSymbol] == null) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are not calling `new Model." + fnName + "()`");
      }
    }
    for (const i in EventEmitter.prototype) {
      Model[i] = EventEmitter.prototype[i];
    }
    Model.init = function init(callback) {
      _checkContext(this, "init");
      this.schema.emit("init", this);
      if (this.$init != null) {
        if (callback) {
          this.$init.then(() => callback(), (err) => callback(err));
          return null;
        }
        return this.$init;
      }
      const Promise2 = PromiseProvider.get();
      const model = this;
      const _ensureIndexes2 = function(cb) {
        const autoIndex = utils.getOption(
          "autoIndex",
          model.schema.options,
          model.db.config,
          model.db.base.options
        );
        if (autoIndex) model.ensureIndexes({ _automatic: true }, cb);
        else cb();
      };
      const _createCollection = function(cb) {
        const conn = model.db;
        if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {
          conn._queue.push({ fn: _createCollection, ctx: conn, args: [cb] });
        } else {
          try {
            const autoCreate = utils.getOption(
              "autoCreate",
              model.schema.options,
              model.db.config,
              model.db.base.options
            );
            if (autoCreate) model.createCollection({}, cb);
            else cb();
          } catch (err) {
            return cb(err);
          }
        }
      };
      this.$init = new Promise2((resolve, reject) => {
        _createCollection((error) => {
          if (error) {
            return reject(error);
          }
          _ensureIndexes2((error2) => {
            if (error2) {
              return reject(error2);
            }
            resolve(this);
          });
        });
      });
      if (callback) {
        this.$init.then(() => callback(), (err) => callback(err));
        this.$caught = true;
        return null;
      } else {
        const _catch = this.$init.catch;
        const _this = this;
        this.$init.catch = function() {
          this.$caught = true;
          return _catch.apply(_this.$init, arguments);
        };
      }
      return this.$init;
    };
    Model.createCollection = function createCollection(options, callback) {
      _checkContext(this, "createCollection");
      if (typeof options === "string") {
        throw new MongooseError("You can't specify a new collection name in Model.createCollection.This is not like Connection.createCollection. Only options are accepted here.");
      } else if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      const schemaCollation = this && this.schema && this.schema.options && this.schema.options.collation;
      if (schemaCollation != null) {
        options = Object.assign({ collation: schemaCollation }, options);
      }
      const capped = this && this.schema && this.schema.options && this.schema.options.capped;
      if (capped != null) {
        if (typeof capped === "number") {
          options = Object.assign({ capped: true, size: capped }, options);
        } else if (typeof capped === "object") {
          options = Object.assign({ capped: true }, capped, options);
        }
      }
      const timeseries = this && this.schema && this.schema.options && this.schema.options.timeseries;
      if (timeseries != null) {
        options = Object.assign({ timeseries }, options);
        if (options.expireAfterSeconds != null) {
        } else if (options.expires != null) {
          utils.expires(options);
        } else if (this.schema.options.expireAfterSeconds != null) {
          options.expireAfterSeconds = this.schema.options.expireAfterSeconds;
        } else if (this.schema.options.expires != null) {
          options.expires = this.schema.options.expires;
          utils.expires(options);
        }
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.db.createCollection(this.$__collection.collectionName, options, utils.tick((err) => {
          if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
            return cb(err);
          }
          this.$__collection = this.db.collection(this.$__collection.collectionName, options);
          cb(null, this.$__collection);
        }));
      }, this.events);
    };
    Model.syncIndexes = function syncIndexes(options, callback) {
      _checkContext(this, "syncIndexes");
      const model = this;
      callback = model.$handleCallbackError(callback);
      return model.db.base._promiseOrCallback(callback, (cb) => {
        cb = model.$wrapCallback(cb);
        model.createCollection((err) => {
          if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
            return cb(err);
          }
          model.diffIndexes(err, (err2, diffIndexesResult) => {
            if (err2 != null) {
              return cb(err2);
            }
            model.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop }, (err3, dropped) => {
              if (err3 != null) {
                return cb(err3);
              }
              model.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate }, (err4) => {
                if (err4 != null) {
                  return cb(err4);
                }
                cb(null, dropped);
              });
            });
          });
        });
      }, this.events);
    };
    Model.diffIndexes = function diffIndexes(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const model = this;
      callback = model.$handleCallbackError(callback);
      return model.db.base._promiseOrCallback(callback, (cb) => {
        cb = model.$wrapCallback(cb);
        model.listIndexes((err, dbIndexes) => {
          if (dbIndexes === void 0) {
            dbIndexes = [];
          }
          dbIndexes = getRelatedDBIndexes(model, dbIndexes);
          const schema = model.schema;
          const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());
          const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);
          const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);
          cb(null, { toDrop, toCreate });
        });
      });
    };
    function getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {
      const toCreate = [];
      for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
        let found = false;
        const options = decorateDiscriminatorIndexOptions(schema, utils.clone(schemaIndexOptions));
        for (const index of dbIndexes) {
          if (isDefaultIdIndex(index)) {
            continue;
          }
          if (isIndexEqual(schemaIndexKeysObject, options, index) && !toDrop.includes(index.name)) {
            found = true;
            break;
          }
        }
        if (!found) {
          toCreate.push(schemaIndexKeysObject);
        }
      }
      return toCreate;
    }
    function getIndexesToDrop(schema, schemaIndexes, dbIndexes) {
      const toDrop = [];
      for (const dbIndex of dbIndexes) {
        let found = false;
        if (isDefaultIdIndex(dbIndex)) {
          continue;
        }
        for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
          const options = decorateDiscriminatorIndexOptions(schema, utils.clone(schemaIndexOptions));
          applySchemaCollation(schemaIndexKeysObject, options, schema.options);
          if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {
            found = true;
            break;
          }
        }
        if (!found) {
          toDrop.push(dbIndex.name);
        }
      }
      return toDrop;
    }
    Model.cleanIndexes = function cleanIndexes(options, callback) {
      _checkContext(this, "cleanIndexes");
      const model = this;
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      callback = model.$handleCallbackError(callback);
      return model.db.base._promiseOrCallback(callback, (cb) => {
        const collection = model.$__collection;
        if (Array.isArray(options && options.toDrop)) {
          _dropIndexes(options.toDrop, collection, cb);
          return;
        }
        return model.diffIndexes((err, res) => {
          if (err != null) {
            return cb(err);
          }
          const toDrop = res.toDrop;
          _dropIndexes(toDrop, collection, cb);
        });
      });
    };
    function _dropIndexes(toDrop, collection, cb) {
      if (toDrop.length === 0) {
        return cb(null, []);
      }
      let remaining = toDrop.length;
      let error = false;
      toDrop.forEach((indexName) => {
        collection.dropIndex(indexName, (err) => {
          if (err != null) {
            error = true;
            return cb(err);
          }
          if (!error) {
            --remaining || cb(null, toDrop);
          }
        });
      });
    }
    Model.listIndexes = function init(callback) {
      _checkContext(this, "listIndexes");
      const _listIndexes = (cb) => {
        this.$__collection.listIndexes().toArray(cb);
      };
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(_listIndexes, [cb]);
        } else {
          _listIndexes(cb);
        }
      }, this.events);
    };
    Model.ensureIndexes = function ensureIndexes(options, callback) {
      _checkContext(this, "ensureIndexes");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _ensureIndexes(this, options || {}, (error) => {
          if (error) {
            return cb(error);
          }
          cb(null);
        });
      }, this.events);
    };
    Model.createIndexes = function createIndexes(options, callback) {
      _checkContext(this, "createIndexes");
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      callback = this.$handleCallbackError(callback);
      options = options || {};
      return this.ensureIndexes(options, callback);
    };
    function _ensureIndexes(model, options, callback) {
      const indexes = model.schema.indexes();
      let indexError;
      options = options || {};
      const done = function(err) {
        if (err && !model.$caught) {
          model.emit("error", err);
        }
        model.emit("index", err || indexError);
        callback && callback(err || indexError);
      };
      for (const index of indexes) {
        if (isDefaultIdIndex(index)) {
          utils.warn('mongoose: Cannot specify a custom index on `_id` for model name "' + model.modelName + '", MongoDB does not allow overwriting the default `_id` index. See https://bit.ly/mongodb-id-index');
        }
      }
      if (!indexes.length) {
        immediate(function() {
          done();
        });
        return;
      }
      const indexSingleDone = function(err, fields, options2, name) {
        model.emit("index-single-done", err, fields, options2, name);
      };
      const indexSingleStart = function(fields, options2) {
        model.emit("index-single-start", fields, options2);
      };
      const baseSchema = model.schema._baseSchema;
      const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
      immediate(function() {
        if (options._automatic && !model.collection.collection) {
          model.collection.addQueue(create, []);
        } else {
          create();
        }
      });
      function create() {
        if (options._automatic) {
          if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {
            return done();
          }
        }
        const index = indexes.shift();
        if (!index) {
          return done();
        }
        if (options._automatic && index[1]._autoIndex === false) {
          return create();
        }
        if (baseSchemaIndexes.find((i) => utils.deepEqual(i, index))) {
          return create();
        }
        const indexFields = utils.clone(index[0]);
        const indexOptions = utils.clone(index[1]);
        delete indexOptions._autoIndex;
        decorateDiscriminatorIndexOptions(model.schema, indexOptions);
        applyWriteConcern(model.schema, indexOptions);
        applySchemaCollation(indexFields, indexOptions, model.schema.options);
        indexSingleStart(indexFields, options);
        if ("background" in options) {
          indexOptions.background = options.background;
        }
        if ("toCreate" in options) {
          if (options.toCreate.length === 0) {
            return done();
          }
        }
        model.collection.createIndex(indexFields, indexOptions, utils.tick(function(err, name) {
          indexSingleDone(err, indexFields, indexOptions, name);
          if (err) {
            if (!indexError) {
              indexError = err;
            }
            if (!model.$caught) {
              model.emit("error", err);
            }
          }
          create();
        }));
      }
    }
    Model.schema;
    Model.db;
    Model.collection;
    Model.$__collection;
    Model.base;
    Model.discriminators;
    Model.translateAliases = function translateAliases(fields) {
      _checkContext(this, "translateAliases");
      const translate = (key, value) => {
        let alias;
        const translated = [];
        const fieldKeys = key.split(".");
        let currentSchema = this.schema;
        for (const i in fieldKeys) {
          const name = fieldKeys[i];
          if (currentSchema && currentSchema.aliases[name]) {
            alias = currentSchema.aliases[name];
            translated.push(alias);
          } else {
            alias = name;
            translated.push(name);
          }
          if (currentSchema && currentSchema.paths[alias]) {
            currentSchema = currentSchema.paths[alias].schema;
          } else
            currentSchema = null;
        }
        const translatedKey = translated.join(".");
        if (fields instanceof Map)
          fields.set(translatedKey, value);
        else
          fields[translatedKey] = value;
        if (translatedKey !== key) {
          if (fields instanceof Map) {
            fields.delete(key);
          } else {
            delete fields[key];
          }
        }
        return fields;
      };
      if (typeof fields === "object") {
        if (fields instanceof Map) {
          for (const field of new Map(fields)) {
            fields = translate(field[0], field[1]);
          }
        } else {
          for (const key of Object.keys(fields)) {
            fields = translate(key, fields[key]);
            if (key[0] === "$") {
              if (Array.isArray(fields[key])) {
                for (const i in fields[key]) {
                  fields[key][i] = this.translateAliases(fields[key][i]);
                }
              }
            }
          }
        }
        return fields;
      } else {
        return fields;
      }
    };
    Model.remove = function remove(conditions, options, callback) {
      _checkContext(this, "remove");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.remove(conditions, callback);
    };
    Model.deleteOne = function deleteOne(conditions, options, callback) {
      _checkContext(this, "deleteOne");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.deleteOne(conditions, callback);
    };
    Model.deleteMany = function deleteMany(conditions, options, callback) {
      _checkContext(this, "deleteMany");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.deleteMany(conditions, callback);
    };
    Model.find = function find(conditions, projection, options, callback) {
      _checkContext(this, "find");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.find(conditions, callback);
    };
    Model.findById = function findById(id, projection, options, callback) {
      _checkContext(this, "findById");
      if (typeof id === "undefined") {
        id = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.findOne({ _id: id }, projection, options, callback);
    };
    Model.findOne = function findOne(conditions, projection, options, callback) {
      _checkContext(this, "findOne");
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.findOne(conditions, callback);
    };
    Model.estimatedDocumentCount = function estimatedDocumentCount(options, callback) {
      _checkContext(this, "estimatedDocumentCount");
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.estimatedDocumentCount(options, callback);
    };
    Model.countDocuments = function countDocuments(conditions, options, callback) {
      _checkContext(this, "countDocuments");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      if (options != null) {
        mq.setOptions(options);
      }
      callback = this.$handleCallbackError(callback);
      return mq.countDocuments(conditions, callback);
    };
    Model.count = function count(conditions, callback) {
      _checkContext(this, "count");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.count(conditions, callback);
    };
    Model.distinct = function distinct(field, conditions, callback) {
      _checkContext(this, "distinct");
      const mq = new this.Query({}, {}, this, this.$__collection);
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      callback = this.$handleCallbackError(callback);
      return mq.distinct(field, conditions, callback);
    };
    Model.where = function where(path, val) {
      _checkContext(this, "where");
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.where.apply(mq, arguments);
    };
    Model.$where = function $where() {
      _checkContext(this, "$where");
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.$where.apply(mq, arguments);
    };
    Model.findOneAndUpdate = function(conditions, update, options, callback) {
      _checkContext(this, "findOneAndUpdate");
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (arguments.length === 1) {
        if (typeof conditions === "function") {
          const msg = "Model.findOneAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options, callback)\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options)\n  " + this.modelName + ".findOneAndUpdate(conditions, update)\n  " + this.modelName + ".findOneAndUpdate(update)\n  " + this.modelName + ".findOneAndUpdate()\n";
          throw new TypeError(msg);
        }
        update = conditions;
        conditions = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.fields || options.projection;
      }
      update = utils.clone(update, {
        depopulate: true,
        _isNested: true
      });
      _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndUpdate(conditions, update, options, callback);
    };
    function _decorateUpdateWithVersionKey(update, options, versionKey) {
      if (!versionKey || !(options && options.upsert || false)) {
        return;
      }
      const updatedPaths = modifiedPaths(update);
      if (!updatedPaths[versionKey]) {
        if (options.overwrite) {
          update[versionKey] = 0;
        } else {
          if (!update.$setOnInsert) {
            update.$setOnInsert = {};
          }
          update.$setOnInsert[versionKey] = 0;
        }
      }
    }
    Model.findByIdAndUpdate = function(id, update, options, callback) {
      _checkContext(this, "findByIdAndUpdate");
      callback = this.$handleCallbackError(callback);
      if (arguments.length === 1) {
        if (typeof id === "function") {
          const msg = "Model.findByIdAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndUpdate(id, callback)\n  " + this.modelName + ".findByIdAndUpdate(id)\n  " + this.modelName + ".findByIdAndUpdate()\n";
          throw new TypeError(msg);
        }
        return this.findOneAndUpdate({ _id: id }, void 0);
      }
      if (id instanceof Document) {
        id = id._id;
      }
      return this.findOneAndUpdate.call(this, { _id: id }, update, options, callback);
    };
    Model.findOneAndDelete = function(conditions, options, callback) {
      _checkContext(this, "findOneAndDelete");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndDelete(conditions, callback)\n  " + this.modelName + ".findOneAndDelete(conditions)\n  " + this.modelName + ".findOneAndDelete()\n";
        throw new TypeError(msg);
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndDelete(conditions, options, callback);
    };
    Model.findByIdAndDelete = function(id, options, callback) {
      _checkContext(this, "findByIdAndDelete");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndDelete(id, callback)\n  " + this.modelName + ".findByIdAndDelete(id)\n  " + this.modelName + ".findByIdAndDelete()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndDelete({ _id: id }, options, callback);
    };
    Model.findOneAndReplace = function(filter, replacement, options, callback) {
      _checkContext(this, "findOneAndReplace");
      if (arguments.length === 1 && typeof filter === "function") {
        const msg = "Model.findOneAndReplace(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndReplace(filter, replacement, options, callback)\n  " + this.modelName + ".findOneAndReplace(filter, replacement, callback)\n  " + this.modelName + ".findOneAndReplace(filter, replacement)\n  " + this.modelName + ".findOneAndReplace(filter, callback)\n  " + this.modelName + ".findOneAndReplace()\n";
        throw new TypeError(msg);
      }
      if (arguments.length === 3 && typeof options === "function") {
        callback = options;
        options = replacement;
        replacement = void 0;
      }
      if (arguments.length === 2 && typeof replacement === "function") {
        callback = replacement;
        replacement = void 0;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndReplace(filter, replacement, options, callback);
    };
    Model.findOneAndRemove = function(conditions, options, callback) {
      _checkContext(this, "findOneAndRemove");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndRemove(conditions, callback)\n  " + this.modelName + ".findOneAndRemove(conditions)\n  " + this.modelName + ".findOneAndRemove()\n";
        throw new TypeError(msg);
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndRemove(conditions, options, callback);
    };
    Model.findByIdAndRemove = function(id, options, callback) {
      _checkContext(this, "findByIdAndRemove");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndRemove(id, callback)\n  " + this.modelName + ".findByIdAndRemove(id)\n  " + this.modelName + ".findByIdAndRemove()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndRemove({ _id: id }, options, callback);
    };
    Model.create = function create(doc, options, callback) {
      _checkContext(this, "create");
      let args;
      let cb;
      const discriminatorKey = this.schema.options.discriminatorKey;
      if (Array.isArray(doc)) {
        args = doc;
        cb = typeof options === "function" ? options : callback;
        options = options != null && typeof options === "object" ? options : {};
      } else {
        const last = arguments[arguments.length - 1];
        options = {};
        if (typeof last === "function" || arguments.length > 1 && !last) {
          args = [...arguments];
          cb = args.pop();
        } else {
          args = [...arguments];
        }
        if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && getConstructorName(last.session) === "ClientSession" && !this.schema.path("session")) {
          utils.warn("WARNING: to pass a `session` to `Model.create()` in Mongoose, you **must** pass an array as the first argument. See: https://mongoosejs.com/docs/api/model.html#model_Model-create");
        }
      }
      return this.db.base._promiseOrCallback(cb, (cb2) => {
        cb2 = this.$wrapCallback(cb2);
        if (args.length === 0) {
          if (Array.isArray(doc)) {
            return cb2(null, []);
          } else {
            return cb2(null);
          }
        }
        const toExecute = [];
        let firstError;
        args.forEach((doc2) => {
          toExecute.push((callback2) => {
            const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
            if (Model2 == null) {
              throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not found for model "${this.modelName}"`);
            }
            let toSave = doc2;
            const callbackWrapper = (error, doc3) => {
              if (error) {
                if (!firstError) {
                  firstError = error;
                }
                return callback2(null, { error });
              }
              callback2(null, { doc: doc3 });
            };
            if (!(toSave instanceof Model2)) {
              try {
                toSave = new Model2(toSave);
              } catch (error) {
                return callbackWrapper(error);
              }
            }
            toSave.$save(options, callbackWrapper);
          });
        });
        let numFns = toExecute.length;
        if (numFns === 0) {
          return cb2(null, []);
        }
        const _done = (error, res) => {
          const savedDocs = [];
          for (const val of res) {
            if (val.doc) {
              savedDocs.push(val.doc);
            }
          }
          if (firstError) {
            return cb2(firstError, savedDocs);
          }
          if (Array.isArray(doc)) {
            cb2(null, savedDocs);
          } else {
            cb2.apply(this, [null].concat(savedDocs));
          }
        };
        const _res = [];
        toExecute.forEach((fn, i) => {
          fn((err, res) => {
            _res[i] = res;
            if (--numFns <= 0) {
              return _done(null, _res);
            }
          });
        });
      }, this.events);
    };
    Model.watch = function(pipeline2, options) {
      _checkContext(this, "watch");
      const changeStreamThunk = (cb) => {
        pipeline2 = pipeline2 || [];
        prepareDiscriminatorPipeline(pipeline2, this.schema, "fullDocument");
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(() => {
            if (this.closed) {
              return;
            }
            const driverChangeStream = this.$__collection.watch(pipeline2, options);
            cb(null, driverChangeStream);
          });
        } else {
          const driverChangeStream = this.$__collection.watch(pipeline2, options);
          cb(null, driverChangeStream);
        }
      };
      options = options || {};
      options.model = this;
      return new ChangeStream(changeStreamThunk, pipeline2, options);
    };
    Model.startSession = function() {
      _checkContext(this, "startSession");
      return this.db.startSession.apply(this.db, arguments);
    };
    Model.insertMany = function(arr, options, callback) {
      _checkContext(this, "insertMany");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        this.$__insertMany(arr, options, cb);
      }, this.events);
    };
    Model.$__insertMany = function(arr, options, callback) {
      const _this = this;
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (callback) {
        callback = this.$handleCallbackError(callback);
        callback = this.$wrapCallback(callback);
      }
      callback = callback || utils.noop;
      options = options || {};
      const limit = options.limit || 1e3;
      const rawResult = !!options.rawResult;
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const throwOnValidationError = typeof options.throwOnValidationError === "boolean" ? options.throwOnValidationError : false;
      const lean = !!options.lean;
      if (!Array.isArray(arr)) {
        arr = [arr];
      }
      const validationErrors = [];
      const validationErrorsToOriginalOrder = /* @__PURE__ */ new Map();
      const results = ordered ? null : new Array(arr.length);
      const toExecute = arr.map((doc, index) => (callback2) => {
        if (lean) {
          return immediate(() => callback2(null, doc));
        }
        if (!(doc instanceof _this)) {
          try {
            doc = new _this(doc);
          } catch (err) {
            return callback2(err);
          }
        }
        if (options.session != null) {
          doc.$session(options.session);
        }
        doc.$validate({ __noPromise: true }, function(error) {
          if (error) {
            if (ordered === false) {
              validationErrors.push(error);
              validationErrorsToOriginalOrder.set(error, index);
              results[index] = error;
              return callback2(null, null);
            }
            return callback2(error);
          }
          callback2(null, doc);
        });
      });
      parallelLimit(toExecute, limit, function(error, docs) {
        if (error) {
          callback(error, null);
          return;
        }
        const originalDocIndex = /* @__PURE__ */ new Map();
        const validDocIndexToOriginalIndex = /* @__PURE__ */ new Map();
        for (let i = 0; i < docs.length; ++i) {
          originalDocIndex.set(docs[i], i);
        }
        const docAttributes = docs.filter(function(doc) {
          return doc != null;
        });
        for (let i = 0; i < docAttributes.length; ++i) {
          validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));
        }
        if (validationErrors.length > 0) {
          validationErrors.sort((err1, err2) => {
            return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);
          });
        }
        if (docAttributes.length === 0) {
          if (throwOnValidationError) {
            return callback(new MongooseBulkWriteError(
              validationErrors,
              results,
              null,
              "insertMany"
            ));
          }
          if (rawResult) {
            const res = {
              acknowledged: true,
              insertedCount: 0,
              insertedIds: {},
              mongoose: {
                validationErrors
              }
            };
            return callback(null, res);
          }
          callback(null, []);
          return;
        }
        const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {
          if (doc.$__schema.options.versionKey) {
            doc[doc.$__schema.options.versionKey] = 0;
          }
          const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);
          if (shouldSetTimestamps) {
            return doc.initializeTimestamps().toObject(internalToObjectOptions);
          }
          return doc.toObject(internalToObjectOptions);
        });
        _this.$__collection.insertMany(docObjects, options, function(error2, res) {
          if (error2) {
            if (error2.writeErrors == null && (error2.result && error2.result.result && error2.result.result.writeErrors) != null) {
              error2.writeErrors = error2.result.result.writeErrors;
            }
            const erroredIndexes = new Set((error2 && error2.writeErrors || []).map((err) => err.index));
            for (let i = 0; i < error2.writeErrors.length; ++i) {
              const originalIndex = validDocIndexToOriginalIndex.get(error2.writeErrors[i].index);
              error2.writeErrors[i] = {
                ...error2.writeErrors[i],
                index: originalIndex
              };
              if (!ordered) {
                results[originalIndex] = error2.writeErrors[i];
              }
            }
            if (!ordered) {
              for (let i = 0; i < results.length; ++i) {
                if (results[i] === void 0) {
                  results[i] = docs[i];
                }
              }
              error2.results = results;
            }
            let firstErroredIndex = -1;
            error2.insertedDocs = docAttributes.filter((doc, i) => {
              const isErrored = erroredIndexes.has(i);
              if (ordered) {
                if (firstErroredIndex > -1) {
                  return i < firstErroredIndex;
                }
                if (isErrored) {
                  firstErroredIndex = i;
                }
              }
              return !isErrored;
            }).map(function setIsNewForInsertedDoc(doc) {
              if (lean) {
                return doc;
              }
              doc.$__reset();
              _setIsNew(doc, false);
              return doc;
            });
            if (rawResult && ordered === false) {
              error2.mongoose = {
                validationErrors,
                results
              };
            }
            callback(error2, null);
            return;
          }
          if (!lean) {
            for (const attribute of docAttributes) {
              attribute.$__reset();
              _setIsNew(attribute, false);
            }
          }
          if (ordered === false && throwOnValidationError && validationErrors.length > 0) {
            for (let i = 0; i < results.length; ++i) {
              if (results[i] === void 0) {
                results[i] = docs[i];
              }
            }
            return callback(new MongooseBulkWriteError(
              validationErrors,
              results,
              res,
              "insertMany"
            ));
          }
          if (rawResult) {
            if (ordered === false) {
              for (let i = 0; i < results.length; ++i) {
                if (results[i] === void 0) {
                  results[i] = docs[i];
                }
              }
              res.mongoose = {
                validationErrors,
                results
              };
            }
            return callback(null, res);
          }
          if (options.populate != null) {
            return _this.populate(docAttributes, options.populate, (err) => {
              if (err != null) {
                error2.insertedDocs = docAttributes;
                return callback(err);
              }
              callback(null, docs);
            });
          }
          callback(null, docAttributes);
        });
      });
    };
    function _setIsNew(doc, val) {
      doc.$isNew = val;
      doc.$emit("isNew", val);
      doc.constructor.emit("isNew", val);
      const subdocs = doc.$getAllSubdocs();
      for (const subdoc of subdocs) {
        subdoc.$isNew = val;
        subdoc.$emit("isNew", val);
      }
    }
    Model.bulkWrite = function(ops, options, callback) {
      _checkContext(this, "bulkWrite");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      options = options || {};
      const ordered = options.ordered == null ? true : options.ordered;
      const validations = ops.map((op) => castBulkWrite(this, op, options));
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (ordered) {
          each(validations, (fn, cb2) => fn(cb2), (error) => {
            if (error) {
              return cb(error);
            }
            if (ops.length === 0) {
              return cb(null, getDefaultBulkwriteResult());
            }
            try {
              this.$__collection.bulkWrite(ops, options, (error2, res) => {
                if (error2) {
                  return cb(error2);
                }
                cb(null, res);
              });
            } catch (err) {
              return cb(err);
            }
          });
          return;
        }
        let remaining = validations.length;
        let validOps = [];
        let validationErrors = [];
        const results = [];
        if (remaining === 0) {
          completeUnorderedValidation.call(this);
        } else {
          for (let i = 0; i < validations.length; ++i) {
            validations[i]((err) => {
              if (err == null) {
                validOps.push(i);
              } else {
                validationErrors.push({ index: i, error: err });
                results[i] = err;
              }
              if (--remaining <= 0) {
                completeUnorderedValidation.call(this);
              }
            });
          }
        }
        validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map((v) => v.error);
        function completeUnorderedValidation() {
          const validOpIndexes = validOps;
          validOps = validOps.sort().map((index) => ops[index]);
          if (validOps.length === 0) {
            if ("throwOnValidationError" in options && options.throwOnValidationError && validationErrors.length > 0) {
              return cb(new MongooseBulkWriteError(
                validationErrors.map((err) => err.error),
                results,
                getDefaultBulkwriteResult(),
                "bulkWrite"
              ));
            }
            return cb(null, getDefaultBulkwriteResult());
          }
          this.$__collection.bulkWrite(validOps, options, (error, res) => {
            for (let i = 0; i < validOpIndexes.length; ++i) {
              results[validOpIndexes[i]] = null;
            }
            if (error) {
              if (validationErrors.length > 0) {
                error.mongoose = error.mongoose || {};
                error.mongoose.validationErrors = validationErrors;
              }
              return cb(error);
            }
            if (validationErrors.length > 0) {
              if ("throwOnValidationError" in options && options.throwOnValidationError) {
                return cb(new MongooseBulkWriteError(
                  validationErrors,
                  results,
                  res,
                  "bulkWrite"
                ));
              }
              res.mongoose = res.mongoose || {};
              res.mongoose.validationErrors = validationErrors;
            }
            cb(null, res);
          });
        }
      }, this.events);
    };
    Model.bulkSave = async function(documents, options) {
      options = options || {};
      const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });
      if (options.timestamps != null) {
        for (const document2 of documents) {
          document2.$__.saveOptions = document2.$__.saveOptions || {};
          document2.$__.saveOptions.timestamps = options.timestamps;
        }
      } else {
        for (const document2 of documents) {
          if (document2.$__.timestamps != null) {
            document2.$__.saveOptions = document2.$__.saveOptions || {};
            document2.$__.saveOptions.timestamps = document2.$__.timestamps;
          }
        }
      }
      await Promise.all(documents.map(buildPreSavePromise));
      const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, options).then(
        (res) => ({ bulkWriteResult: res, bulkWriteError: null }),
        (err) => ({ bulkWriteResult: null, bulkWriteError: err })
      );
      await Promise.all(
        documents.map(async (document2) => {
          const documentError = bulkWriteError && bulkWriteError.writeErrors.find((writeError) => {
            const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
            return writeErrorDocumentId.toString() === document2._id.toString();
          });
          if (documentError == null) {
            await handleSuccessfulWrite(document2);
          }
        })
      );
      if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {
        throw bulkWriteError;
      }
      return bulkWriteResult;
    };
    function buildPreSavePromise(document2) {
      return new Promise((resolve, reject) => {
        document2.schema.s.hooks.execPre("save", document2, (err) => {
          if (err) {
            reject(err);
            return;
          }
          resolve();
        });
      });
    }
    function handleSuccessfulWrite(document2) {
      return new Promise((resolve, reject) => {
        if (document2.$isNew) {
          _setIsNew(document2, false);
        }
        document2.$__reset();
        document2.schema.s.hooks.execPost("save", document2, [document2], {}, (err) => {
          if (err) {
            reject(err);
            return;
          }
          resolve();
        });
      });
    }
    Model.applyDefaults = function applyDefaults(doc) {
      if (doc.$__ != null) {
        applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);
        for (const subdoc of doc.$getAllSubdocs()) {
          applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);
        }
        return doc;
      }
      applyDefaultsToPOJO(doc, this.schema);
      return doc;
    };
    Model.castObject = function castObject(obj, options) {
      options = options || {};
      const ret = {};
      const schema = this.schema;
      const paths = Object.keys(schema.paths);
      for (const path of paths) {
        const schemaType = schema.path(path);
        if (!schemaType || !schemaType.$isMongooseArray) {
          continue;
        }
        const val = get(obj, path);
        pushNestedArrayPaths(paths, val, path);
      }
      let error = null;
      for (const path of paths) {
        const schemaType = schema.path(path);
        if (schemaType == null) {
          continue;
        }
        let val = get(obj, path, void 0);
        if (val == null) {
          continue;
        }
        const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
        let cur = ret;
        for (let i = 0; i < pieces.length - 1; ++i) {
          if (cur[pieces[i]] == null) {
            cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];
          }
          cur = cur[pieces[i]];
        }
        if (schemaType.$isMongooseDocumentArray) {
          continue;
        }
        if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {
          try {
            val = Model.castObject.call(schemaType.caster, val);
          } catch (err) {
            if (!options.ignoreCastErrors) {
              error = error || new ValidationError2();
              error.addError(path, err);
            }
            continue;
          }
          cur[pieces[pieces.length - 1]] = val;
          continue;
        }
        try {
          val = schemaType.cast(val);
          cur[pieces[pieces.length - 1]] = val;
        } catch (err) {
          if (!options.ignoreCastErrors) {
            error = error || new ValidationError2();
            error.addError(path, err);
          }
          continue;
        }
      }
      if (error != null) {
        throw error;
      }
      return ret;
    };
    Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
      if (!Array.isArray(documents)) {
        throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
      }
      setDefaultOptions();
      const writeOperations = documents.reduce((accumulator, document2, i) => {
        if (!options.skipValidation) {
          if (!(document2 instanceof Document)) {
            throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
          }
          const validationError = document2.validateSync();
          if (validationError) {
            throw validationError;
          }
        }
        const isANewDocument = document2.isNew;
        if (isANewDocument) {
          const writeOperation = { insertOne: { document: document2 } };
          utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);
          accumulator.push(writeOperation);
          return accumulator;
        }
        const delta = document2.$__delta();
        const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);
        if (isDocumentWithChanges) {
          const where = document2.$__where(delta[0]);
          const changes = delta[1];
          _applyCustomWhere(document2, where);
          document2.$__version(where, delta);
          const writeOperation = { updateOne: { filter: where, update: changes } };
          utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);
          accumulator.push(writeOperation);
          return accumulator;
        }
        return accumulator;
      }, []);
      return writeOperations;
      function setDefaultOptions() {
        options = options || {};
        if (options.skipValidation == null) {
          options.skipValidation = false;
        }
      }
    };
    Model.hydrate = function(obj, projection, options) {
      _checkContext(this, "hydrate");
      if (projection != null) {
        if (obj != null && obj.$__ != null) {
          obj = obj.toObject(internalToObjectOptions);
        }
        obj = applyProjection(obj, projection);
      }
      const document2 = require_queryhelpers().createModel(this, obj, projection);
      document2.$init(obj, options);
      return document2;
    };
    Model.update = function update(conditions, doc, options, callback) {
      _checkContext(this, "update");
      return _update(this, "update", conditions, doc, options, callback);
    };
    Model.updateMany = function updateMany(conditions, doc, options, callback) {
      _checkContext(this, "updateMany");
      return _update(this, "updateMany", conditions, doc, options, callback);
    };
    Model.updateOne = function updateOne(conditions, doc, options, callback) {
      _checkContext(this, "updateOne");
      return _update(this, "updateOne", conditions, doc, options, callback);
    };
    Model.replaceOne = function replaceOne(conditions, doc, options, callback) {
      _checkContext(this, "replaceOne");
      const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;
      if (versionKey && !doc[versionKey]) {
        doc[versionKey] = 0;
      }
      return _update(this, "replaceOne", conditions, doc, options, callback);
    };
    function _update(model, op, conditions, doc, options, callback) {
      const mq = new model.Query({}, {}, model, model.collection);
      callback = model.$handleCallbackError(callback);
      if (conditions instanceof Document) {
        conditions = conditions.toObject();
      } else {
        conditions = utils.clone(conditions);
      }
      options = typeof options === "function" ? options : utils.clone(options);
      const versionKey = model && model.schema && model.schema.options && model.schema.options.versionKey || null;
      _decorateUpdateWithVersionKey(doc, options, versionKey);
      return mq[op](conditions, doc, options, callback);
    }
    Model.mapReduce = function mapReduce(opts, callback) {
      _checkContext(this, "mapReduce");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (!Model.mapReduce.schema) {
          const opts2 = { _id: false, id: false, strict: false };
          Model.mapReduce.schema = new Schema({}, opts2);
        }
        if (!opts.out) opts.out = { inline: 1 };
        if (opts.verbose !== false) opts.verbose = true;
        opts.map = String(opts.map);
        opts.reduce = String(opts.reduce);
        if (opts.query) {
          let q = new this.Query(opts.query);
          q.cast(this);
          opts.query = q._conditions;
          q = void 0;
        }
        this.$__collection.mapReduce(null, null, opts, (err, res) => {
          if (err) {
            return cb(err);
          }
          if (res.collection) {
            const model = Model.compile(
              "_mapreduce_" + res.collection.collectionName,
              Model.mapReduce.schema,
              res.collection.collectionName,
              this.db,
              this.base
            );
            model._mapreduce = true;
            res.model = model;
            return cb(null, res);
          }
          cb(null, res);
        });
      }, this.events);
    };
    Model.aggregate = function aggregate(pipeline2, options, callback) {
      _checkContext(this, "aggregate");
      if (arguments.length > 3 || (pipeline2 && pipeline2.constructor && pipeline2.constructor.name) === "Object") {
        throw new MongooseError("Mongoose 5.x disallows passing a spread of operators to `Model.aggregate()`. Instead of `Model.aggregate({ $match }, { $skip })`, do `Model.aggregate([{ $match }, { $skip }])`");
      }
      if (typeof pipeline2 === "function") {
        callback = pipeline2;
        pipeline2 = [];
      }
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const aggregate2 = new Aggregate(pipeline2 || []);
      aggregate2.model(this);
      if (options != null) {
        aggregate2.option(options);
      }
      if (typeof callback === "undefined") {
        return aggregate2;
      }
      callback = this.$handleCallbackError(callback);
      callback = this.$wrapCallback(callback);
      aggregate2.exec(callback);
      return aggregate2;
    };
    Model.validate = function validate2(obj, pathsToValidate, context, callback) {
      if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
        context = obj;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        let schema = this.schema;
        const discriminatorKey = schema.options.discriminatorKey;
        if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
          schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
        }
        let paths = Object.keys(schema.paths);
        if (pathsToValidate != null) {
          const _pathsToValidate = typeof pathsToValidate === "string" ? new Set(pathsToValidate.split(" ")) : new Set(pathsToValidate);
          paths = paths.filter((p) => {
            const pieces = p.split(".");
            let cur = pieces[0];
            for (const piece of pieces) {
              if (_pathsToValidate.has(cur)) {
                return true;
              }
              cur += "." + piece;
            }
            return _pathsToValidate.has(p);
          });
        }
        for (const path of paths) {
          const schemaType = schema.path(path);
          if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {
            continue;
          }
          const val = get(obj, path);
          pushNestedArrayPaths(paths, val, path);
        }
        let remaining = paths.length;
        let error = null;
        for (const path of paths) {
          const schemaType = schema.path(path);
          if (schemaType == null) {
            _checkDone();
            continue;
          }
          const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
          let cur = obj;
          for (let i = 0; i < pieces.length - 1; ++i) {
            cur = cur[pieces[i]];
          }
          let val = get(obj, path, void 0);
          if (val != null) {
            try {
              val = schemaType.cast(val);
              cur[pieces[pieces.length - 1]] = val;
            } catch (err) {
              error = error || new ValidationError2();
              error.addError(path, err);
              _checkDone();
              continue;
            }
          }
          schemaType.doValidate(val, (err) => {
            if (err) {
              error = error || new ValidationError2();
              error.addError(path, err);
            }
            _checkDone();
          }, context, { path });
        }
        function _checkDone() {
          if (--remaining <= 0) {
            return cb(error);
          }
        }
      });
    };
    Model.populate = function(docs, paths, callback) {
      _checkContext(this, "populate");
      const _this = this;
      paths = utils.populate(paths);
      const cache = {};
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _populate(_this, docs, paths, cache, cb);
      }, this.events);
    };
    function _populate(model, docs, paths, cache, callback) {
      let pending = paths.length;
      if (paths.length === 0) {
        return callback(null, docs);
      }
      for (const path of paths) {
        populate(model, docs, path, next);
      }
      function next(err) {
        if (err) {
          return callback(err, null);
        }
        if (--pending) {
          return;
        }
        callback(null, docs);
      }
    }
    var excludeIdReg = /\s?-_id\s?/;
    var excludeIdRegGlobal = /\s?-_id\s?/g;
    function populate(model, docs, options, callback) {
      const populateOptions = { ...options };
      if (options.strictPopulate == null) {
        if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {
          populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;
        } else if (options._localModel != null && model.base.options.strictPopulate != null) {
          populateOptions.strictPopulate = model.base.options.strictPopulate;
        } else if (model.base.options.strictPopulate != null) {
          populateOptions.strictPopulate = model.base.options.strictPopulate;
        }
      }
      if (!Array.isArray(docs)) {
        docs = [docs];
      }
      if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
        return callback();
      }
      const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);
      if (modelsMap instanceof MongooseError) {
        return immediate(function() {
          callback(modelsMap);
        });
      }
      const len = modelsMap.length;
      let vals = [];
      function flatten(item) {
        return void 0 !== item;
      }
      let _remaining = len;
      let hasOne = false;
      const params = [];
      for (let i = 0; i < len; ++i) {
        const mod = modelsMap[i];
        let select = mod.options.select;
        let ids = utils.array.flatten(mod.ids, flatten);
        ids = utils.array.unique(ids);
        const assignmentOpts = {};
        assignmentOpts.sort = mod && mod.options && mod.options.options && mod.options.options.sort || void 0;
        assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
        if (mod.options && mod.options.options && mod.options.options.lean && mod.options.options.lean.transform) {
          mod.options.options._leanTransform = mod.options.options.lean.transform;
          mod.options.options.lean = true;
        }
        if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
          --_remaining;
          _assign(model, [], mod, assignmentOpts);
          continue;
        }
        hasOne = true;
        if (typeof populateOptions.foreignField === "string") {
          mod.foreignField.clear();
          mod.foreignField.add(populateOptions.foreignField);
        }
        const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
        if (assignmentOpts.excludeId) {
          if (typeof select === "string") {
            select = select.replace(excludeIdRegGlobal, " ");
          } else {
            select = utils.object.shallowCopy(select);
            delete select._id;
          }
        }
        if (mod.options.options && mod.options.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.options.limit;
        } else if (mod.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.limit;
        }
        params.push([mod, match, select, assignmentOpts, _next]);
      }
      if (!hasOne) {
        if (modelsMap.length !== 0) {
          return callback();
        }
        if (populateOptions.populate != null) {
          const opts = utils.populate(populateOptions.populate).map((pop) => Object.assign({}, pop, {
            path: populateOptions.path + "." + pop.path
          }));
          return model.populate(docs, opts, callback);
        }
        return callback();
      }
      for (const arr of params) {
        _execPopulateQuery.apply(null, arr);
      }
      function _next(err, valsFromDb) {
        if (err != null) {
          return callback(err, null);
        }
        vals = vals.concat(valsFromDb);
        if (--_remaining === 0) {
          _done();
        }
      }
      function _done() {
        for (const arr of params) {
          const mod = arr[0];
          const assignmentOpts = arr[3];
          for (const val of vals) {
            mod.options._childDocs.push(val);
          }
          try {
            _assign(model, vals, mod, assignmentOpts);
          } catch (err) {
            return callback(err);
          }
        }
        for (const arr of params) {
          removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
        }
        for (const arr of params) {
          const mod = arr[0];
          if (mod.options && mod.options.options && mod.options.options._leanTransform) {
            for (const doc of vals) {
              mod.options.options._leanTransform(doc);
            }
          }
        }
        callback();
      }
    }
    function _execPopulateQuery(mod, match, select, assignmentOpts, callback) {
      let subPopulate = utils.clone(mod.options.populate);
      const queryOptions = Object.assign({
        skip: mod.options.skip,
        limit: mod.options.limit,
        perDocumentLimit: mod.options.perDocumentLimit
      }, mod.options.options);
      if (mod.count) {
        delete queryOptions.skip;
      }
      if (queryOptions.perDocumentLimit != null) {
        queryOptions.limit = queryOptions.perDocumentLimit;
        delete queryOptions.perDocumentLimit;
      } else if (queryOptions.limit != null) {
        queryOptions.limit = queryOptions.limit * mod.ids.length;
      }
      const query = mod.model.find(match, select, queryOptions);
      for (const foreignField of mod.foreignField) {
        if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
          query.select(foreignField);
        }
      }
      if (mod.count) {
        for (const foreignField of mod.foreignField) {
          query.select(foreignField);
        }
      }
      if (subPopulate) {
        if (mod.model.baseModelName != null) {
          if (Array.isArray(subPopulate)) {
            subPopulate.forEach((pop) => {
              pop.strictPopulate = false;
            });
          } else if (typeof subPopulate === "string") {
            subPopulate = { path: subPopulate, strictPopulate: false };
          } else {
            subPopulate.strictPopulate = false;
          }
        }
        const basePath = mod.options._fullPath || mod.options.path;
        if (Array.isArray(subPopulate)) {
          for (const pop of subPopulate) {
            pop._fullPath = basePath + "." + pop.path;
          }
        } else if (typeof subPopulate === "object") {
          subPopulate._fullPath = basePath + "." + subPopulate.path;
        }
        query.populate(subPopulate);
      }
      query.exec((err, docs) => {
        if (err != null) {
          return callback(err);
        }
        for (const val of docs) {
          leanPopulateMap.set(val, mod.model);
        }
        callback(null, docs);
      });
    }
    function _assign(model, vals, mod, assignmentOpts) {
      const options = mod.options;
      const isVirtual = mod.isVirtual;
      const justOne = mod.justOne;
      let _val;
      const lean = options && options.options && options.options.lean || false;
      const len = vals.length;
      const rawOrder = {};
      const rawDocs = {};
      let key;
      let val;
      const allIds = utils.clone(mod.allIds);
      for (let i = 0; i < len; i++) {
        val = vals[i];
        if (val == null) {
          continue;
        }
        for (const foreignField of mod.foreignField) {
          _val = utils.getValue(foreignField, val);
          if (Array.isArray(_val)) {
            _val = utils.array.unique(utils.array.flatten(_val));
            for (let __val of _val) {
              if (__val instanceof Document) {
                __val = __val._id;
              }
              key = String(__val);
              if (rawDocs[key]) {
                if (Array.isArray(rawDocs[key])) {
                  rawDocs[key].push(val);
                  rawOrder[key].push(i);
                } else {
                  rawDocs[key] = [rawDocs[key], val];
                  rawOrder[key] = [rawOrder[key], i];
                }
              } else {
                if (isVirtual && !justOne) {
                  rawDocs[key] = [val];
                  rawOrder[key] = [i];
                } else {
                  rawDocs[key] = val;
                  rawOrder[key] = i;
                }
              }
            }
          } else {
            if (_val instanceof Document) {
              _val = _val._id;
            }
            key = String(_val);
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else if (isVirtual || rawDocs[key].constructor !== val.constructor || String(rawDocs[key]._id) !== String(val._id)) {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              rawDocs[key] = val;
              rawOrder[key] = i;
            }
          }
          if (!lean) {
            val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };
          }
        }
      }
      assignVals({
        originalModel: model,
        // If virtual, make sure to not mutate original field
        rawIds: mod.isVirtual ? allIds : mod.allIds,
        allIds,
        unpopulatedValues: mod.unpopulatedValues,
        foreignField: mod.foreignField,
        rawDocs,
        rawOrder,
        docs: mod.docs,
        path: options.path,
        options: assignmentOpts,
        justOne: mod.justOne,
        isVirtual: mod.isVirtual,
        allOptions: mod,
        populatedModel: mod.model,
        lean,
        virtual: mod.virtual,
        count: mod.count,
        match: mod.match
      });
    }
    Model.compile = function compile(name, schema, collectionName, connection, base) {
      const versioningEnabled = schema.options.versionKey !== false;
      if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
        const o = {};
        o[schema.options.versionKey] = Number;
        schema.add(o);
      }
      let model;
      if (typeof name === "function" && name.prototype instanceof Model) {
        model = name;
        name = model.name;
        schema.loadClass(model, false);
        model.prototype.$isMongooseModelPrototype = true;
      } else {
        model = function model2(doc, fields, skipId) {
          model2.hooks.execPreSync("createModel", doc);
          if (!(this instanceof model2)) {
            return new model2(doc, fields, skipId);
          }
          const discriminatorKey = model2.schema.options.discriminatorKey;
          if (model2.discriminators == null || doc == null || doc[discriminatorKey] == null) {
            Model.call(this, doc, fields, skipId);
            return;
          }
          const Discriminator = model2.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model2.discriminators, doc[discriminatorKey]);
          if (Discriminator != null) {
            return new Discriminator(doc, fields, skipId);
          }
          Model.call(this, doc, fields, skipId);
        };
      }
      model.hooks = schema.s.hooks.clone();
      model.base = base;
      model.modelName = name;
      if (!(model.prototype instanceof Model)) {
        Object.setPrototypeOf(model, Model);
        Object.setPrototypeOf(model.prototype, Model.prototype);
      }
      model.model = function model2(name2) {
        return this.db.model(name2);
      };
      model.db = connection;
      model.prototype.db = connection;
      model.prototype[modelDbSymbol] = connection;
      model.discriminators = model.prototype.discriminators = void 0;
      model[modelSymbol] = true;
      model.events = new EventEmitter();
      schema._preCompile();
      model.prototype.$__setSchema(schema);
      const _userProvidedOptions = schema._userProvidedOptions || {};
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: schema.options.capped,
        Promise: model.base.Promise,
        modelName: name
      };
      if (schema.options.autoCreate !== void 0) {
        collectionOptions.autoCreate = schema.options.autoCreate;
      }
      model.prototype.collection = connection.collection(
        collectionName,
        collectionOptions
      );
      model.prototype.$collection = model.prototype.collection;
      model.prototype[modelCollectionSymbol] = model.prototype.collection;
      applyMethods(model, schema);
      applyStatics(model, schema);
      applyHooks(model, schema);
      applyStaticHooks(model, schema.s.hooks, schema.statics);
      model.schema = model.prototype.$__schema;
      model.collection = model.prototype.collection;
      model.$__collection = model.collection;
      model.Query = function() {
        Query.apply(this, arguments);
      };
      Object.setPrototypeOf(model.Query.prototype, Query.prototype);
      model.Query.base = Query.base;
      model.Query.prototype.constructor = Query;
      applyQueryMiddleware(model.Query, model);
      applyQueryMethods(model, schema.query);
      return model;
    };
    function applyQueryMethods(model, methods) {
      for (const i in methods) {
        model.Query.prototype[i] = methods[i];
      }
    }
    Model.__subclass = function subclass(conn, schema, collection) {
      const _this = this;
      const Model2 = function Model3(doc, fields, skipId) {
        if (!(this instanceof Model3)) {
          return new Model3(doc, fields, skipId);
        }
        _this.call(this, doc, fields, skipId);
      };
      Object.setPrototypeOf(Model2, _this);
      Object.setPrototypeOf(Model2.prototype, _this.prototype);
      Model2.db = conn;
      Model2.prototype.db = conn;
      Model2.prototype[modelDbSymbol] = conn;
      _this[subclassedSymbol] = _this[subclassedSymbol] || [];
      _this[subclassedSymbol].push(Model2);
      if (_this.discriminators != null) {
        Model2.discriminators = {};
        for (const key of Object.keys(_this.discriminators)) {
          Model2.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
        }
      }
      const s = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
      const options = s.options || {};
      const _userProvidedOptions = s._userProvidedOptions || {};
      if (!collection) {
        collection = _this.prototype.$__schema.get("collection") || utils.toCollectionName(_this.modelName, this.base.pluralize());
      }
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: s && options.capped
      };
      Model2.prototype.collection = conn.collection(collection, collectionOptions);
      Model2.prototype.$collection = Model2.prototype.collection;
      Model2.prototype[modelCollectionSymbol] = Model2.prototype.collection;
      Model2.collection = Model2.prototype.collection;
      Model2.$__collection = Model2.collection;
      Model2.init(() => {
      });
      return Model2;
    };
    Model.$handleCallbackError = function(callback) {
      if (callback == null) {
        return callback;
      }
      if (typeof callback !== "function") {
        throw new MongooseError("Callback must be a function, got " + callback);
      }
      const _this = this;
      return function() {
        immediate(() => {
          try {
            callback.apply(null, arguments);
          } catch (error) {
            _this.emit("error", error);
          }
        });
      };
    };
    Model.$wrapCallback = function(callback) {
      const serverSelectionError = new ServerSelectionError();
      const _this = this;
      return function(err) {
        if (err != null && err.name === "MongoServerSelectionError") {
          arguments[0] = serverSelectionError.assimilateError(err);
        }
        if (err != null && err.name === "MongoNetworkTimeoutError" && err.message.endsWith("timed out")) {
          _this.db.emit("timeout");
        }
        return callback.apply(null, arguments);
      };
    };
    Model.inspect = function() {
      return `Model { ${this.modelName} }`;
    };
    if (util2.inspect.custom) {
      Model[util2.inspect.custom] = Model.inspect;
    }
    module2.exports = exports2 = Model;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/pluralize.js
var require_pluralize = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/pluralize.js"(exports2, module2) {
    "use strict";
    module2.exports = pluralize;
    exports2.pluralization = [
      [/(m)an$/gi, "$1en"],
      [/(pe)rson$/gi, "$1ople"],
      [/(child)$/gi, "$1ren"],
      [/^(ox)$/gi, "$1en"],
      [/(ax|test)is$/gi, "$1es"],
      [/(octop|vir)us$/gi, "$1i"],
      [/(alias|status)$/gi, "$1es"],
      [/(bu)s$/gi, "$1ses"],
      [/(buffal|tomat|potat)o$/gi, "$1oes"],
      [/([ti])um$/gi, "$1a"],
      [/sis$/gi, "ses"],
      [/(?:([^f])fe|([lr])f)$/gi, "$1$2ves"],
      [/(hive)$/gi, "$1s"],
      [/([^aeiouy]|qu)y$/gi, "$1ies"],
      [/(x|ch|ss|sh)$/gi, "$1es"],
      [/(matr|vert|ind)ix|ex$/gi, "$1ices"],
      [/([m|l])ouse$/gi, "$1ice"],
      [/(kn|w|l)ife$/gi, "$1ives"],
      [/(quiz)$/gi, "$1zes"],
      [/^goose$/i, "geese"],
      [/s$/gi, "s"],
      [/([^a-z])$/, "$1"],
      [/$/gi, "s"]
    ];
    var rules = exports2.pluralization;
    exports2.uncountables = [
      "advice",
      "energy",
      "excretion",
      "digestion",
      "cooperation",
      "health",
      "justice",
      "labour",
      "machinery",
      "equipment",
      "information",
      "pollution",
      "sewage",
      "paper",
      "money",
      "species",
      "series",
      "rain",
      "rice",
      "fish",
      "sheep",
      "moose",
      "deer",
      "news",
      "expertise",
      "status",
      "media"
    ];
    var uncountables = exports2.uncountables;
    function pluralize(str) {
      let found;
      str = str.toLowerCase();
      if (!~uncountables.indexOf(str)) {
        found = rules.filter(function(rule) {
          return str.match(rule[0]);
        });
        if (found[0]) {
          return str.replace(found[0][0], found[0][1]);
        }
      }
      return str;
    }
  }
});

// asset-input/node_modules/mongoose/lib/helpers/printStrictQueryWarning.js
var require_printStrictQueryWarning = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/printStrictQueryWarning.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    module2.exports = util2.deprecate(
      function() {
      },
      "Mongoose: the `strictQuery` option will be switched back to `false` by default in Mongoose 7. Use `mongoose.set('strictQuery', false);` if you want to prepare for this change. Or use `mongoose.set('strictQuery', true);` to suppress this warning.",
      "MONGOOSE"
    );
  }
});

// asset-input/node_modules/mongoose/lib/error/setOptionError.js
var require_setOptionError = __commonJS({
  "asset-input/node_modules/mongoose/lib/error/setOptionError.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var util2 = require("util");
    var combinePathErrors = require_combinePathErrors();
    var SetOptionError = class _SetOptionError extends MongooseError {
      /**
       * Mongoose.set Error
       *
       * @api private
       * @inherits MongooseError
       */
      constructor() {
        super("");
        this.errors = {};
      }
      /**
       * Console.log helper
       */
      toString() {
        return combinePathErrors(this);
      }
      /**
       * inspect helper
       * @api private
       */
      inspect() {
        return Object.assign(new Error(this.message), this);
      }
      /**
      * add message
      * @param {String} key
      * @param {String|Error} error
      * @api private
      */
      addError(key, error) {
        if (error instanceof _SetOptionError) {
          const { errors } = error;
          for (const optionKey of Object.keys(errors)) {
            this.addError(optionKey, errors[optionKey]);
          }
          return;
        }
        this.errors[key] = error;
        this.message = combinePathErrors(this);
      }
    };
    if (util2.inspect.custom) {
      SetOptionError.prototype[util2.inspect.custom] = SetOptionError.prototype.inspect;
    }
    Object.defineProperty(SetOptionError.prototype, "toJSON", {
      enumerable: false,
      writable: false,
      configurable: true,
      value: function() {
        return Object.assign({}, this, { name: this.name, message: this.message });
      }
    });
    Object.defineProperty(SetOptionError.prototype, "name", {
      value: "SetOptionError"
    });
    var SetOptionInnerError = class extends MongooseError {
      /**
       * Error for the "errors" array in "SetOptionError" with consistent message
       * @param {String} key
       */
      constructor(key) {
        super(`"${key}" is not a valid option to set`);
      }
    };
    SetOptionError.SetOptionInnerError = SetOptionInnerError;
    module2.exports = SetOptionError;
  }
});

// asset-input/node_modules/mongoose/lib/helpers/printJestWarning.js
var require_printJestWarning = __commonJS({
  "asset-input/node_modules/mongoose/lib/helpers/printJestWarning.js"() {
    "use strict";
    var utils = require_utils6();
    if (typeof jest !== "undefined" && !process.env.SUPPRESS_JEST_WARNINGS) {
      if (typeof window !== "undefined") {
        utils.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's default jsdom test environment. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true to hide this warning.");
      }
      if (setTimeout.clock != null && typeof setTimeout.clock.Date === "function") {
        utils.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's mock timers enabled. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true to hide this warning.");
      }
    }
  }
});

// asset-input/node_modules/mongoose/lib/browserDocument.js
var require_browserDocument = __commonJS({
  "asset-input/node_modules/mongoose/lib/browserDocument.js"(exports2, module2) {
    "use strict";
    var NodeJSDocument = require_document();
    var EventEmitter = require("events").EventEmitter;
    var MongooseError = require_error3();
    var Schema = require_schema2();
    var ObjectId2 = require_objectid3();
    var ValidationError2 = MongooseError.ValidationError;
    var applyHooks = require_applyHooks();
    var isObject = require_isObject();
    function Document(obj, schema, fields, skipId, skipInit) {
      if (!(this instanceof Document)) {
        return new Document(obj, schema, fields, skipId, skipInit);
      }
      if (isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema(schema);
      }
      schema = this.schema || schema;
      if (!this.schema && schema.options._id) {
        obj = obj || {};
        if (obj._id === void 0) {
          obj._id = new ObjectId2();
        }
      }
      if (!schema) {
        throw new MongooseError.MissingSchemaError();
      }
      this.$__setSchema(schema);
      NodeJSDocument.call(this, obj, fields, skipId, skipInit);
      applyHooks(this, schema, { decorateDoc: true });
      for (const m in schema.methods) {
        this[m] = schema.methods[m];
      }
      for (const s in schema.statics) {
        this[s] = schema.statics[s];
      }
    }
    Document.prototype = Object.create(NodeJSDocument.prototype);
    Document.prototype.constructor = Document;
    Document.events = new EventEmitter();
    Document.$emitter = new EventEmitter();
    [
      "on",
      "once",
      "emit",
      "listeners",
      "removeListener",
      "setMaxListeners",
      "removeAllListeners",
      "addListener"
    ].forEach(function(emitterFn) {
      Document[emitterFn] = function() {
        return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
      };
    });
    Document.ValidationError = ValidationError2;
    module2.exports = exports2 = Document;
  }
});

// asset-input/node_modules/mongoose/lib/document_provider.js
var require_document_provider = __commonJS({
  "asset-input/node_modules/mongoose/lib/document_provider.js"(exports2, module2) {
    "use strict";
    var Document = require_document();
    var BrowserDocument = require_browserDocument();
    var isBrowser = false;
    module2.exports = function() {
      if (isBrowser) {
        return BrowserDocument;
      }
      return Document;
    };
    module2.exports.setBrowser = function(flag) {
      isBrowser = flag;
    };
  }
});

// asset-input/node_modules/mongoose/lib/index.js
var require_lib6 = __commonJS({
  "asset-input/node_modules/mongoose/lib/index.js"(exports2, module2) {
    "use strict";
    require_driver().set(require_node_mongodb_native());
    var Document = require_document();
    var EventEmitter = require("events").EventEmitter;
    var Kareem = require_kareem();
    var Schema = require_schema2();
    var SchemaType = require_schematype();
    var SchemaTypes = require_schema();
    var VirtualType = require_virtualtype();
    var STATES = require_connectionstate();
    var VALID_OPTIONS = require_validoptions();
    var Types = require_types();
    var Query = require_query();
    var Model = require_model();
    var applyPlugins = require_applyPlugins();
    var builtinPlugins = require_plugins();
    var driver = require_driver();
    var promiseOrCallback = require_promiseOrCallback();
    var legacyPluralize = require_pluralize();
    var utils = require_utils6();
    var pkg = require_package2();
    var cast = require_cast2();
    var Aggregate = require_aggregate2();
    var PromiseProvider = require_promise_provider2();
    var printStrictQueryWarning = require_printStrictQueryWarning();
    var trusted = require_trusted().trusted;
    var sanitizeFilter = require_sanitizeFilter();
    var isBsonType = require_isBsonType();
    var MongooseError = require_mongooseError();
    var SetOptionError = require_setOptionError();
    var defaultMongooseSymbol = Symbol.for("mongoose:default");
    require_printJestWarning();
    var objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;
    function Mongoose(options) {
      this.connections = [];
      this.nextConnectionId = 0;
      this.models = {};
      this.events = new EventEmitter();
      this.__driver = driver.get();
      this.options = Object.assign({
        pluralization: true,
        autoIndex: true,
        autoCreate: true
      }, options);
      const createInitialConnection = utils.getOption("createInitialConnection", this.options);
      if (createInitialConnection == null || createInitialConnection) {
        const conn = this.createConnection();
        conn.models = this.models;
      }
      if (this.options.pluralization) {
        this._pluralize = legacyPluralize;
      }
      if (!options || !options[defaultMongooseSymbol]) {
        const _this = this;
        this.Schema = function() {
          this.base = _this;
          return Schema.apply(this, arguments);
        };
        this.Schema.prototype = Object.create(Schema.prototype);
        Object.assign(this.Schema, Schema);
        this.Schema.base = this;
        this.Schema.Types = Object.assign({}, Schema.Types);
      } else {
        for (const key of ["Schema", "model"]) {
          this[key] = Mongoose.prototype[key];
        }
      }
      this.Schema.prototype.base = this;
      Object.defineProperty(this, "plugins", {
        configurable: false,
        enumerable: true,
        writable: false,
        value: Object.values(builtinPlugins).map((plugin) => [plugin, { deduplicate: true }])
      });
    }
    Mongoose.prototype.cast = cast;
    Mongoose.prototype.STATES = STATES;
    Mongoose.prototype.ConnectionStates = STATES;
    Mongoose.prototype.driver = driver;
    Mongoose.prototype.setDriver = function setDriver(driver2) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      if (_mongoose.__driver === driver2) {
        return _mongoose;
      }
      const openConnection = _mongoose.connections && _mongoose.connections.find((conn) => conn.readyState !== STATES.disconnected);
      if (openConnection) {
        const msg = "Cannot modify Mongoose driver if a connection is already open. Call `mongoose.disconnect()` before modifying the driver";
        throw new MongooseError(msg);
      }
      _mongoose.__driver = driver2;
      const Connection = driver2.getConnection();
      _mongoose.connections = [new Connection(_mongoose)];
      _mongoose.connections[0].models = _mongoose.models;
      return _mongoose;
    };
    Mongoose.prototype.set = function(key, value) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      if (arguments.length === 1 && typeof key !== "object") {
        if (VALID_OPTIONS.indexOf(key) === -1) {
          const error2 = new SetOptionError();
          error2.addError(key, new SetOptionError.SetOptionInnerError(key));
          throw error2;
        }
        return _mongoose.options[key];
      }
      let options = {};
      if (arguments.length === 2) {
        options = { [key]: value };
      }
      if (arguments.length === 1 && typeof key === "object") {
        options = key;
      }
      let error = void 0;
      for (const [optionKey, optionValue] of Object.entries(options)) {
        if (VALID_OPTIONS.indexOf(optionKey) === -1) {
          if (!error) {
            error = new SetOptionError();
          }
          error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));
          continue;
        }
        _mongoose.options[optionKey] = optionValue;
        if (optionKey === "objectIdGetter") {
          if (optionValue) {
            Object.defineProperty(mongoose4.Types.ObjectId.prototype, "_id", {
              enumerable: false,
              configurable: true,
              get: function() {
                return this;
              }
            });
          } else {
            delete mongoose4.Types.ObjectId.prototype._id;
          }
        }
      }
      if (error) {
        throw error;
      }
      return _mongoose;
    };
    Mongoose.prototype.get = Mongoose.prototype.set;
    Mongoose.prototype.createConnection = function(uri, options, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      const Connection = _mongoose.__driver.getConnection();
      const conn = new Connection(_mongoose);
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      _mongoose.connections.push(conn);
      _mongoose.nextConnectionId++;
      _mongoose.events.emit("createConnection", conn);
      if (arguments.length > 0) {
        conn.openUri(uri, options, callback);
      }
      return conn;
    };
    Mongoose.prototype.connect = function(uri, options, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      const conn = _mongoose.connection;
      if (_mongoose.options.strictQuery === void 0) {
        printStrictQueryWarning();
      }
      return _mongoose._promiseOrCallback(callback, (cb) => {
        conn.openUri(uri, options, (err) => {
          if (err != null) {
            return cb(err);
          }
          return cb(null, _mongoose);
        });
      });
    };
    Mongoose.prototype.disconnect = function(callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      return _mongoose._promiseOrCallback(callback, (cb) => {
        let remaining = _mongoose.connections.length;
        if (remaining <= 0) {
          return cb(null);
        }
        _mongoose.connections.forEach((conn) => {
          conn.close(function(error) {
            if (error) {
              return cb(error);
            }
            if (!--remaining) {
              cb(null);
            }
          });
        });
      });
    };
    Mongoose.prototype.startSession = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
    };
    Mongoose.prototype.pluralize = function(fn) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      if (arguments.length > 0) {
        _mongoose._pluralize = fn;
      }
      return _mongoose._pluralize;
    };
    Mongoose.prototype.model = function(name, schema, collection, options) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (arguments.length === 1) {
        const model2 = _mongoose.models[name];
        if (!model2) {
          throw new MongooseError.MissingSchemaError(name);
        }
        return model2;
      }
      if (utils.isObject(schema) && !(schema instanceof Schema)) {
        schema = new Schema(schema);
      }
      if (schema && !(schema instanceof Schema)) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      options = options || {};
      const originalSchema = schema;
      if (schema) {
        if (_mongoose.get("cloneSchemas")) {
          schema = schema.clone();
        }
        _mongoose._applyPlugins(schema);
      }
      const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options.overwriteModels;
      if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {
        if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
          throw new _mongoose.Error.OverwriteModelError(name);
        }
        if (collection && collection !== _mongoose.models[name].collection.name) {
          const model2 = _mongoose.models[name];
          schema = model2.prototype.schema;
          const sub = model2.__subclass(_mongoose.connection, schema, collection);
          return sub;
        }
        return _mongoose.models[name];
      }
      if (schema == null) {
        throw new _mongoose.Error.MissingSchemaError(name);
      }
      const model = _mongoose._model(name, schema, collection, options);
      _mongoose.connection.models[name] = model;
      _mongoose.models[name] = model;
      return model;
    };
    Mongoose.prototype._model = function(name, schema, collection, options) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      let model;
      if (typeof name === "function") {
        model = name;
        name = model.name;
        if (!(model.prototype instanceof Model)) {
          throw new _mongoose.Error("The provided class " + name + " must extend Model");
        }
      }
      if (schema) {
        if (_mongoose.get("cloneSchemas")) {
          schema = schema.clone();
        }
        _mongoose._applyPlugins(schema);
      }
      if (schema == null || !("pluralization" in schema.options)) {
        schema.options.pluralization = _mongoose.options.pluralization;
      }
      if (!collection) {
        collection = schema.get("collection") || utils.toCollectionName(name, _mongoose.pluralize());
      }
      const connection = options.connection || _mongoose.connection;
      model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
      model.init(function $modelInitNoop() {
      });
      connection.emit("model", model);
      if (schema._applyDiscriminators != null) {
        for (const disc of Object.keys(schema._applyDiscriminators)) {
          model.discriminator(disc, schema._applyDiscriminators[disc]);
        }
      }
      return model;
    };
    Mongoose.prototype.deleteModel = function(name) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      _mongoose.connection.deleteModel(name);
      delete _mongoose.models[name];
      return _mongoose;
    };
    Mongoose.prototype.modelNames = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      const names = Object.keys(_mongoose.models);
      return names;
    };
    Mongoose.prototype._applyPlugins = function(schema, options) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      options = options || {};
      options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;
      options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === "boolean" ? _mongoose.options.applyPluginsToChildSchemas : true;
      applyPlugins(schema, _mongoose.plugins, options, "$globalPluginsApplied");
    };
    Mongoose.prototype.plugin = function(fn, opts) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      _mongoose.plugins.push([fn, opts]);
      return _mongoose;
    };
    Mongoose.prototype.__defineGetter__("connection", function() {
      return this.connections[0];
    });
    Mongoose.prototype.__defineSetter__("connection", function(v) {
      if (v instanceof this.__driver.getConnection()) {
        this.connections[0] = v;
        this.models = v.models;
      }
    });
    Mongoose.prototype.connections;
    Mongoose.prototype.nextConnectionId;
    Mongoose.prototype.Aggregate = Aggregate;
    Object.defineProperty(Mongoose.prototype, "Collection", {
      get: function() {
        return this.__driver.Collection;
      },
      set: function(Collection) {
        this.__driver.Collection = Collection;
      }
    });
    Object.defineProperty(Mongoose.prototype, "Connection", {
      get: function() {
        return this.__driver.getConnection();
      },
      set: function(Connection) {
        if (Connection === this.__driver.getConnection()) {
          return;
        }
        this.__driver.getConnection = () => Connection;
      }
    });
    Mongoose.prototype.version = pkg.version;
    Mongoose.prototype.Mongoose = Mongoose;
    Mongoose.prototype.Schema = Schema;
    Mongoose.prototype.SchemaType = SchemaType;
    Mongoose.prototype.SchemaTypes = Schema.Types;
    Mongoose.prototype.VirtualType = VirtualType;
    Mongoose.prototype.Types = Types;
    Mongoose.prototype.Query = Query;
    Object.defineProperty(Mongoose.prototype, "Promise", {
      get: function() {
        return PromiseProvider.get();
      },
      set: function(lib) {
        PromiseProvider.set(lib);
      }
    });
    Mongoose.prototype.PromiseProvider = PromiseProvider;
    Mongoose.prototype.Model = Model;
    Mongoose.prototype.Document = Document;
    Mongoose.prototype.DocumentProvider = require_document_provider();
    Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
    Mongoose.prototype.isValidObjectId = function(v) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      return _mongoose.Types.ObjectId.isValid(v);
    };
    Mongoose.prototype.isObjectIdOrHexString = function(v) {
      return isBsonType(v, "ObjectID") || typeof v === "string" && objectIdHexRegexp.test(v);
    };
    Mongoose.prototype.syncIndexes = function(options) {
      const _mongoose = this instanceof Mongoose ? this : mongoose4;
      return _mongoose.connection.syncIndexes(options);
    };
    Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
    Mongoose.prototype.Mixed = SchemaTypes.Mixed;
    Mongoose.prototype.Date = SchemaTypes.Date;
    Mongoose.prototype.Number = SchemaTypes.Number;
    Mongoose.prototype.Error = require_error3();
    Mongoose.prototype.now = function now() {
      return /* @__PURE__ */ new Date();
    };
    Mongoose.prototype.CastError = require_cast();
    Mongoose.prototype.SchemaTypeOptions = require_SchemaTypeOptions();
    Mongoose.prototype.mongo = require_lib3();
    Mongoose.prototype.mquery = require_mquery();
    Mongoose.prototype.sanitizeFilter = sanitizeFilter;
    Mongoose.prototype.trusted = trusted;
    Mongoose.prototype._promiseOrCallback = function(callback, fn, ee) {
      return promiseOrCallback(callback, fn, ee, this.Promise);
    };
    Mongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;
    Mongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;
    var mongoose4 = module2.exports = exports2 = new Mongoose({
      [defaultMongooseSymbol]: true
    });
  }
});

// asset-input/node_modules/mongoose/index.js
var require_mongoose = __commonJS({
  "asset-input/node_modules/mongoose/index.js"(exports2, module2) {
    "use strict";
    var mongoose4 = require_lib6();
    module2.exports = mongoose4;
    module2.exports.default = mongoose4;
    module2.exports.mongoose = mongoose4;
    module2.exports.cast = mongoose4.cast;
    module2.exports.STATES = mongoose4.STATES;
    module2.exports.setDriver = mongoose4.setDriver;
    module2.exports.set = mongoose4.set;
    module2.exports.get = mongoose4.get;
    module2.exports.createConnection = mongoose4.createConnection;
    module2.exports.connect = mongoose4.connect;
    module2.exports.disconnect = mongoose4.disconnect;
    module2.exports.startSession = mongoose4.startSession;
    module2.exports.pluralize = mongoose4.pluralize;
    module2.exports.model = mongoose4.model;
    module2.exports.deleteModel = mongoose4.deleteModel;
    module2.exports.modelNames = mongoose4.modelNames;
    module2.exports.plugin = mongoose4.plugin;
    module2.exports.connections = mongoose4.connections;
    module2.exports.version = mongoose4.version;
    module2.exports.Mongoose = mongoose4.Mongoose;
    module2.exports.Schema = mongoose4.Schema;
    module2.exports.SchemaType = mongoose4.SchemaType;
    module2.exports.SchemaTypes = mongoose4.SchemaTypes;
    module2.exports.VirtualType = mongoose4.VirtualType;
    module2.exports.Types = mongoose4.Types;
    module2.exports.Query = mongoose4.Query;
    module2.exports.Promise = mongoose4.Promise;
    module2.exports.Model = mongoose4.Model;
    module2.exports.Document = mongoose4.Document;
    module2.exports.ObjectId = mongoose4.ObjectId;
    module2.exports.isValidObjectId = mongoose4.isValidObjectId;
    module2.exports.isObjectIdOrHexString = mongoose4.isObjectIdOrHexString;
    module2.exports.syncIndexes = mongoose4.syncIndexes;
    module2.exports.Decimal128 = mongoose4.Decimal128;
    module2.exports.Mixed = mongoose4.Mixed;
    module2.exports.Date = mongoose4.Date;
    module2.exports.Number = mongoose4.Number;
    module2.exports.Error = mongoose4.Error;
    module2.exports.now = mongoose4.now;
    module2.exports.CastError = mongoose4.CastError;
    module2.exports.SchemaTypeOptions = mongoose4.SchemaTypeOptions;
    module2.exports.mongo = mongoose4.mongo;
    module2.exports.mquery = mongoose4.mquery;
    module2.exports.sanitizeFilter = mongoose4.sanitizeFilter;
    module2.exports.trusted = mongoose4.trusted;
    module2.exports.skipMiddlewareFunction = mongoose4.skipMiddlewareFunction;
    module2.exports.overwriteMiddlewareResult = mongoose4.overwriteMiddlewareResult;
  }
});

// asset-input/node_modules/class-transformer/cjs/enums/transformation-type.enum.js
var require_transformation_type_enum = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/enums/transformation-type.enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformationType = void 0;
    var TransformationType;
    (function(TransformationType2) {
      TransformationType2[TransformationType2["PLAIN_TO_CLASS"] = 0] = "PLAIN_TO_CLASS";
      TransformationType2[TransformationType2["CLASS_TO_PLAIN"] = 1] = "CLASS_TO_PLAIN";
      TransformationType2[TransformationType2["CLASS_TO_CLASS"] = 2] = "CLASS_TO_CLASS";
    })(TransformationType = exports2.TransformationType || (exports2.TransformationType = {}));
  }
});

// asset-input/node_modules/class-transformer/cjs/enums/index.js
var require_enums = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/enums/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_transformation_type_enum(), exports2);
  }
});

// asset-input/node_modules/class-transformer/cjs/MetadataStorage.js
var require_MetadataStorage = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/MetadataStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataStorage = void 0;
    var enums_1 = require_enums();
    var MetadataStorage = class {
      constructor() {
        this._typeMetadatas = /* @__PURE__ */ new Map();
        this._transformMetadatas = /* @__PURE__ */ new Map();
        this._exposeMetadatas = /* @__PURE__ */ new Map();
        this._excludeMetadatas = /* @__PURE__ */ new Map();
        this._ancestorsMap = /* @__PURE__ */ new Map();
      }
      // -------------------------------------------------------------------------
      // Adder Methods
      // -------------------------------------------------------------------------
      addTypeMetadata(metadata) {
        if (!this._typeMetadatas.has(metadata.target)) {
          this._typeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      }
      addTransformMetadata(metadata) {
        if (!this._transformMetadatas.has(metadata.target)) {
          this._transformMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
          this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
        }
        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
      }
      addExposeMetadata(metadata) {
        if (!this._exposeMetadatas.has(metadata.target)) {
          this._exposeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      }
      addExcludeMetadata(metadata) {
        if (!this._excludeMetadatas.has(metadata.target)) {
          this._excludeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      findTransformMetadatas(target, propertyName, transformationType) {
        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter((metadata) => {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_CLASS || transformationType === enums_1.TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        });
      }
      findExcludeMetadata(target, propertyName) {
        return this.findMetadata(this._excludeMetadatas, target, propertyName);
      }
      findExposeMetadata(target, propertyName) {
        return this.findMetadata(this._exposeMetadatas, target, propertyName);
      }
      findExposeMetadataByCustomName(target, name) {
        return this.getExposedMetadatas(target).find((metadata) => {
          return metadata.options && metadata.options.name === name;
        });
      }
      findTypeMetadata(target, propertyName) {
        return this.findMetadata(this._typeMetadatas, target, propertyName);
      }
      getStrategy(target) {
        const excludeMap = this._excludeMetadatas.get(target);
        const exclude = excludeMap && excludeMap.get(void 0);
        const exposeMap = this._exposeMetadatas.get(target);
        const expose = exposeMap && exposeMap.get(void 0);
        if (exclude && expose || !exclude && !expose)
          return "none";
        return exclude ? "excludeAll" : "exposeAll";
      }
      getExposedMetadatas(target) {
        return this.getMetadata(this._exposeMetadatas, target);
      }
      getExcludedMetadatas(target) {
        return this.getMetadata(this._excludeMetadatas, target);
      }
      getExposedProperties(target, transformationType) {
        return this.getExposedMetadatas(target).filter((metadata) => {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_CLASS || transformationType === enums_1.TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map((metadata) => metadata.propertyName);
      }
      getExcludedProperties(target, transformationType) {
        return this.getExcludedMetadatas(target).filter((metadata) => {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_CLASS || transformationType === enums_1.TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map((metadata) => metadata.propertyName);
      }
      clear() {
        this._typeMetadatas.clear();
        this._exposeMetadatas.clear();
        this._excludeMetadatas.clear();
        this._ancestorsMap.clear();
      }
      // -------------------------------------------------------------------------
      // Private Methods
      // -------------------------------------------------------------------------
      getMetadata(metadatas, target) {
        const metadataFromTargetMap = metadatas.get(target);
        let metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter((meta) => meta.propertyName !== void 0);
        }
        const metadataFromAncestors = [];
        for (const ancestor of this.getAncestors(target)) {
          const ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter((meta) => meta.propertyName !== void 0);
            metadataFromAncestors.push(...metadataFromAncestor);
          }
        }
        return metadataFromAncestors.concat(metadataFromTarget || []);
      }
      findMetadata(metadatas, target, propertyName) {
        const metadataFromTargetMap = metadatas.get(target);
        if (metadataFromTargetMap) {
          const metadataFromTarget = metadataFromTargetMap.get(propertyName);
          if (metadataFromTarget) {
            return metadataFromTarget;
          }
        }
        for (const ancestor of this.getAncestors(target)) {
          const ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            const ancestorResult = ancestorMetadataMap.get(propertyName);
            if (ancestorResult) {
              return ancestorResult;
            }
          }
        }
        return void 0;
      }
      findMetadatas(metadatas, target, propertyName) {
        const metadataFromTargetMap = metadatas.get(target);
        let metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = metadataFromTargetMap.get(propertyName);
        }
        const metadataFromAncestorsTarget = [];
        for (const ancestor of this.getAncestors(target)) {
          const ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            if (ancestorMetadataMap.has(propertyName)) {
              metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));
            }
          }
        }
        return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());
      }
      getAncestors(target) {
        if (!target)
          return [];
        if (!this._ancestorsMap.has(target)) {
          const ancestors = [];
          for (let baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== "undefined"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
            ancestors.push(baseClass);
          }
          this._ancestorsMap.set(target, ancestors);
        }
        return this._ancestorsMap.get(target);
      }
    };
    exports2.MetadataStorage = MetadataStorage;
  }
});

// asset-input/node_modules/class-transformer/cjs/storage.js
var require_storage = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/storage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultMetadataStorage = void 0;
    var MetadataStorage_1 = require_MetadataStorage();
    exports2.defaultMetadataStorage = new MetadataStorage_1.MetadataStorage();
  }
});

// asset-input/node_modules/class-transformer/cjs/utils/get-global.util.js
var require_get_global_util = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/utils/get-global.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGlobal = void 0;
    function getGlobal() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof self !== "undefined") {
        return self;
      }
    }
    exports2.getGlobal = getGlobal;
  }
});

// asset-input/node_modules/class-transformer/cjs/utils/is-promise.util.js
var require_is_promise_util = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/utils/is-promise.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromise = void 0;
    function isPromise(p) {
      return p !== null && typeof p === "object" && typeof p.then === "function";
    }
    exports2.isPromise = isPromise;
  }
});

// asset-input/node_modules/class-transformer/cjs/utils/index.js
var require_utils7 = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/utils/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_get_global_util(), exports2);
    __exportStar(require_is_promise_util(), exports2);
  }
});

// asset-input/node_modules/class-transformer/cjs/TransformOperationExecutor.js
var require_TransformOperationExecutor = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/TransformOperationExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformOperationExecutor = void 0;
    var storage_1 = require_storage();
    var enums_1 = require_enums();
    var utils_1 = require_utils7();
    function instantiateArrayType(arrayType) {
      const array = new arrayType();
      if (!(array instanceof Set) && !("push" in array)) {
        return [];
      }
      return array;
    }
    var TransformOperationExecutor = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(transformationType, options) {
        this.transformationType = transformationType;
        this.options = options;
        this.recursionStack = /* @__PURE__ */ new Set();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      transform(source, value, targetType, arrayType, isMap, level = 0) {
        if (Array.isArray(value) || value instanceof Set) {
          const newValue = arrayType && this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];
          value.forEach((subValue, index) => {
            const subSource = source ? source[index] : void 0;
            if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
              let realTargetType;
              if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
                if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                  realTargetType = targetType.options.discriminator.subTypes.find((subType) => subType.name === subValue[targetType.options.discriminator.property]);
                  const options = { newObject: newValue, object: subValue, property: void 0 };
                  const newType = targetType.typeFunction(options);
                  realTargetType === void 0 ? realTargetType = newType : realTargetType = realTargetType.value;
                  if (!targetType.options.keepDiscriminatorProperty)
                    delete subValue[targetType.options.discriminator.property];
                }
                if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
                  realTargetType = subValue.constructor;
                }
                if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN) {
                  subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
                }
              } else {
                realTargetType = targetType;
              }
              const value2 = this.transform(subSource, subValue, realTargetType, void 0, subValue instanceof Map, level + 1);
              if (newValue instanceof Set) {
                newValue.add(value2);
              } else {
                newValue.push(value2);
              }
            } else if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
              if (newValue instanceof Set) {
                newValue.add(subValue);
              } else {
                newValue.push(subValue);
              }
            }
          });
          return newValue;
        } else if (targetType === String && !isMap) {
          if (value === null || value === void 0)
            return value;
          return String(value);
        } else if (targetType === Number && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Number(value);
        } else if (targetType === Boolean && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Boolean(value);
        } else if ((targetType === Date || value instanceof Date) && !isMap) {
          if (value instanceof Date) {
            return new Date(value.valueOf());
          }
          if (value === null || value === void 0)
            return value;
          return new Date(value);
        } else if (!!(0, utils_1.getGlobal)().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Buffer.from(value);
        } else if ((0, utils_1.isPromise)(value) && !isMap) {
          return new Promise((resolve, reject) => {
            value.then((data) => resolve(this.transform(void 0, data, targetType, void 0, void 0, level + 1)), reject);
          });
        } else if (!isMap && value !== null && typeof value === "object" && typeof value.then === "function") {
          return value;
        } else if (typeof value === "object" && value !== null) {
          if (!targetType && value.constructor !== Object)
            if (!Array.isArray(value) && value.constructor === Array) {
            } else {
              targetType = value.constructor;
            }
          if (!targetType && source)
            targetType = source.constructor;
          if (this.options.enableCircularCheck) {
            this.recursionStack.add(value);
          }
          const keys = this.getKeys(targetType, value, isMap);
          let newValue = source ? source : {};
          if (!source && (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS || this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS)) {
            if (isMap) {
              newValue = /* @__PURE__ */ new Map();
            } else if (targetType) {
              newValue = new targetType();
            } else {
              newValue = {};
            }
          }
          for (const key of keys) {
            if (key === "__proto__" || key === "constructor") {
              continue;
            }
            const valueKey = key;
            let newValueKey = key, propertyName = key;
            if (!this.options.ignoreDecorators && targetType) {
              if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);
                if (exposeMetadata) {
                  propertyName = exposeMetadata.propertyName;
                  newValueKey = exposeMetadata.propertyName;
                }
              } else if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN || this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
                const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(targetType, key);
                if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                  newValueKey = exposeMetadata.options.name;
                }
              }
            }
            let subValue = void 0;
            if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
              subValue = value[valueKey];
            } else {
              if (value instanceof Map) {
                subValue = value.get(valueKey);
              } else if (value[valueKey] instanceof Function) {
                subValue = value[valueKey]();
              } else {
                subValue = value[valueKey];
              }
            }
            let type = void 0, isSubValueMap = subValue instanceof Map;
            if (targetType && isMap) {
              type = targetType;
            } else if (targetType) {
              const metadata = storage_1.defaultMetadataStorage.findTypeMetadata(targetType, propertyName);
              if (metadata) {
                const options = { newObject: newValue, object: value, property: propertyName };
                const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;
                if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {
                  if (!(value[valueKey] instanceof Array)) {
                    if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                      type = metadata.options.discriminator.subTypes.find((subType) => {
                        if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {
                          return subType.name === subValue[metadata.options.discriminator.property];
                        }
                      });
                      type === void 0 ? type = newType : type = type.value;
                      if (!metadata.options.keepDiscriminatorProperty) {
                        if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {
                          delete subValue[metadata.options.discriminator.property];
                        }
                      }
                    }
                    if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
                      type = subValue.constructor;
                    }
                    if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN) {
                      if (subValue) {
                        subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
                      }
                    }
                  } else {
                    type = metadata;
                  }
                } else {
                  type = newType;
                }
                isSubValueMap = isSubValueMap || metadata.reflectedType === Map;
              } else if (this.options.targetMaps) {
                this.options.targetMaps.filter((map) => map.target === targetType && !!map.properties[propertyName]).forEach((map) => type = map.properties[propertyName]);
              } else if (this.options.enableImplicitConversion && this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                const reflectedType = Reflect.getMetadata("design:type", targetType.prototype, propertyName);
                if (reflectedType) {
                  type = reflectedType;
                }
              }
            }
            const arrayType2 = Array.isArray(value[valueKey]) ? this.getReflectedType(targetType, propertyName) : void 0;
            const subSource = source ? source[valueKey] : void 0;
            if (newValue.constructor.prototype) {
              const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
              if ((this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS || this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) && // eslint-disable-next-line @typescript-eslint/unbound-method
              (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))
                continue;
            }
            if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
              const transformKey = this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS ? newValueKey : key;
              let finalValue;
              if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN) {
                finalValue = value[transformKey];
                finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);
                finalValue = value[transformKey] === finalValue ? subValue : finalValue;
                finalValue = this.transform(subSource, finalValue, type, arrayType2, isSubValueMap, level + 1);
              } else {
                if (subValue === void 0 && this.options.exposeDefaultValues) {
                  finalValue = newValue[newValueKey];
                } else {
                  finalValue = this.transform(subSource, subValue, type, arrayType2, isSubValueMap, level + 1);
                  finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);
                }
              }
              if (finalValue !== void 0 || this.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            } else if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
              let finalValue = subValue;
              finalValue = this.applyCustomTransformations(finalValue, targetType, key, value, this.transformationType);
              if (finalValue !== void 0 || this.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            }
          }
          if (this.options.enableCircularCheck) {
            this.recursionStack.delete(value);
          }
          return newValue;
        } else {
          return value;
        }
      }
      applyCustomTransformations(value, target, key, obj, transformationType) {
        let metadatas = storage_1.defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
        if (this.options.version !== void 0) {
          metadatas = metadatas.filter((metadata) => {
            if (!metadata.options)
              return true;
            return this.checkVersion(metadata.options.since, metadata.options.until);
          });
        }
        if (this.options.groups && this.options.groups.length) {
          metadatas = metadatas.filter((metadata) => {
            if (!metadata.options)
              return true;
            return this.checkGroups(metadata.options.groups);
          });
        } else {
          metadatas = metadatas.filter((metadata) => {
            return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
          });
        }
        metadatas.forEach((metadata) => {
          value = metadata.transformFn({ value, key, obj, type: transformationType, options: this.options });
        });
        return value;
      }
      // preventing circular references
      isCircular(object) {
        return this.recursionStack.has(object);
      }
      getReflectedType(target, propertyName) {
        if (!target)
          return void 0;
        const meta = storage_1.defaultMetadataStorage.findTypeMetadata(target, propertyName);
        return meta ? meta.reflectedType : void 0;
      }
      getKeys(target, object, isMap) {
        let strategy = storage_1.defaultMetadataStorage.getStrategy(target);
        if (strategy === "none")
          strategy = this.options.strategy || "exposeAll";
        let keys = [];
        if (strategy === "exposeAll" || isMap) {
          if (object instanceof Map) {
            keys = Array.from(object.keys());
          } else {
            keys = Object.keys(object);
          }
        }
        if (isMap) {
          return keys;
        }
        if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {
          const exposedProperties = storage_1.defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          const excludedProperties = storage_1.defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          keys = [...exposedProperties, ...excludedProperties];
        }
        if (!this.options.ignoreDecorators && target) {
          let exposedProperties = storage_1.defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
            exposedProperties = exposedProperties.map((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                return exposeMetadata.options.name;
              }
              return key;
            });
          }
          if (this.options.excludeExtraneousValues) {
            keys = exposedProperties;
          } else {
            keys = keys.concat(exposedProperties);
          }
          const excludedProperties = storage_1.defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          if (excludedProperties.length > 0) {
            keys = keys.filter((key) => {
              return !excludedProperties.includes(key);
            });
          }
          if (this.options.version !== void 0) {
            keys = keys.filter((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
            });
          }
          if (this.options.groups && this.options.groups.length) {
            keys = keys.filter((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return this.checkGroups(exposeMetadata.options.groups);
            });
          } else {
            keys = keys.filter((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
            });
          }
        }
        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
          keys = keys.filter((key) => this.options.excludePrefixes.every((prefix) => {
            return key.substr(0, prefix.length) !== prefix;
          }));
        }
        keys = keys.filter((key, index, self2) => {
          return self2.indexOf(key) === index;
        });
        return keys;
      }
      checkVersion(since, until) {
        let decision = true;
        if (decision && since)
          decision = this.options.version >= since;
        if (decision && until)
          decision = this.options.version < until;
        return decision;
      }
      checkGroups(groups) {
        if (!groups)
          return true;
        return this.options.groups.some((optionGroup) => groups.includes(optionGroup));
      }
    };
    exports2.TransformOperationExecutor = TransformOperationExecutor;
  }
});

// asset-input/node_modules/class-transformer/cjs/constants/default-options.constant.js
var require_default_options_constant = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/constants/default-options.constant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultOptions = void 0;
    exports2.defaultOptions = {
      enableCircularCheck: false,
      enableImplicitConversion: false,
      excludeExtraneousValues: false,
      excludePrefixes: void 0,
      exposeDefaultValues: false,
      exposeUnsetFields: true,
      groups: void 0,
      ignoreDecorators: false,
      strategy: void 0,
      targetMaps: void 0,
      version: void 0
    };
  }
});

// asset-input/node_modules/class-transformer/cjs/ClassTransformer.js
var require_ClassTransformer = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/ClassTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClassTransformer = void 0;
    var TransformOperationExecutor_1 = require_TransformOperationExecutor();
    var enums_1 = require_enums();
    var default_options_constant_1 = require_default_options_constant();
    var ClassTransformer = class {
      instanceToPlain(object, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_PLAIN, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      }
      classToPlainFromExist(object, plainObject, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_PLAIN, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(plainObject, object, void 0, void 0, void 0, void 0);
      }
      plainToInstance(cls, plain, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.PLAIN_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(void 0, plain, cls, void 0, void 0, void 0);
      }
      plainToClassFromExist(clsObject, plain, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.PLAIN_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(clsObject, plain, void 0, void 0, void 0, void 0);
      }
      instanceToInstance(object, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      }
      classToClassFromExist(object, fromObject, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(fromObject, object, void 0, void 0, void 0, void 0);
      }
      serialize(object, options) {
        return JSON.stringify(this.instanceToPlain(object, options));
      }
      /**
       * Deserializes given JSON string to a object of the given class.
       */
      deserialize(cls, json, options) {
        const jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      }
      /**
       * Deserializes given JSON string to an array of objects of the given class.
       */
      deserializeArray(cls, json, options) {
        const jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      }
    };
    exports2.ClassTransformer = ClassTransformer;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/exclude.decorator.js
var require_exclude_decorator = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/exclude.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Exclude = void 0;
    var storage_1 = require_storage();
    function Exclude(options = {}) {
      return function(object, propertyName) {
        storage_1.defaultMetadataStorage.addExcludeMetadata({
          target: object instanceof Function ? object : object.constructor,
          propertyName,
          options
        });
      };
    }
    exports2.Exclude = Exclude;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/expose.decorator.js
var require_expose_decorator = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/expose.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Expose = void 0;
    var storage_1 = require_storage();
    function Expose(options = {}) {
      return function(object, propertyName) {
        storage_1.defaultMetadataStorage.addExposeMetadata({
          target: object instanceof Function ? object : object.constructor,
          propertyName,
          options
        });
      };
    }
    exports2.Expose = Expose;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/transform-instance-to-instance.decorator.js
var require_transform_instance_to_instance_decorator = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/transform-instance-to-instance.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformInstanceToInstance = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    function TransformInstanceToInstance(params) {
      return function(target, propertyKey, descriptor) {
        const classTransformer = new ClassTransformer_1.ClassTransformer();
        const originalMethod = descriptor.value;
        descriptor.value = function(...args) {
          const result = originalMethod.apply(this, args);
          const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
          return isPromise ? result.then((data) => classTransformer.instanceToInstance(data, params)) : classTransformer.instanceToInstance(result, params);
        };
      };
    }
    exports2.TransformInstanceToInstance = TransformInstanceToInstance;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/transform-instance-to-plain.decorator.js
var require_transform_instance_to_plain_decorator = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/transform-instance-to-plain.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformInstanceToPlain = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    function TransformInstanceToPlain(params) {
      return function(target, propertyKey, descriptor) {
        const classTransformer = new ClassTransformer_1.ClassTransformer();
        const originalMethod = descriptor.value;
        descriptor.value = function(...args) {
          const result = originalMethod.apply(this, args);
          const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
          return isPromise ? result.then((data) => classTransformer.instanceToPlain(data, params)) : classTransformer.instanceToPlain(result, params);
        };
      };
    }
    exports2.TransformInstanceToPlain = TransformInstanceToPlain;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/transform-plain-to-instance.decorator.js
var require_transform_plain_to_instance_decorator = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/transform-plain-to-instance.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformPlainToInstance = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    function TransformPlainToInstance(classType, params) {
      return function(target, propertyKey, descriptor) {
        const classTransformer = new ClassTransformer_1.ClassTransformer();
        const originalMethod = descriptor.value;
        descriptor.value = function(...args) {
          const result = originalMethod.apply(this, args);
          const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
          return isPromise ? result.then((data) => classTransformer.plainToInstance(classType, data, params)) : classTransformer.plainToInstance(classType, result, params);
        };
      };
    }
    exports2.TransformPlainToInstance = TransformPlainToInstance;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/transform.decorator.js
var require_transform_decorator = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/transform.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transform = void 0;
    var storage_1 = require_storage();
    function Transform(transformFn, options = {}) {
      return function(target, propertyName) {
        storage_1.defaultMetadataStorage.addTransformMetadata({
          target: target.constructor,
          propertyName,
          transformFn,
          options
        });
      };
    }
    exports2.Transform = Transform;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/type.decorator.js
var require_type_decorator = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/type.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Type = void 0;
    var storage_1 = require_storage();
    function Type(typeFunction, options = {}) {
      return function(target, propertyName) {
        const reflectedType = Reflect.getMetadata("design:type", target, propertyName);
        storage_1.defaultMetadataStorage.addTypeMetadata({
          target: target.constructor,
          propertyName,
          reflectedType,
          typeFunction,
          options
        });
      };
    }
    exports2.Type = Type;
  }
});

// asset-input/node_modules/class-transformer/cjs/decorators/index.js
var require_decorators = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/decorators/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_exclude_decorator(), exports2);
    __exportStar(require_expose_decorator(), exports2);
    __exportStar(require_transform_instance_to_instance_decorator(), exports2);
    __exportStar(require_transform_instance_to_plain_decorator(), exports2);
    __exportStar(require_transform_plain_to_instance_decorator(), exports2);
    __exportStar(require_transform_decorator(), exports2);
    __exportStar(require_type_decorator(), exports2);
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/expose-options.interface.js
var require_expose_options_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/expose-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/exclude-options.interface.js
var require_exclude_options_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/exclude-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/transform-options.interface.js
var require_transform_options_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/transform-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/type-discriminator-descriptor.interface.js
var require_type_discriminator_descriptor_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/type-discriminator-descriptor.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/type-options.interface.js
var require_type_options_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/decorator-options/type-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/metadata/exclude-metadata.interface.js
var require_exclude_metadata_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/metadata/exclude-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/metadata/expose-metadata.interface.js
var require_expose_metadata_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/metadata/expose-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/metadata/transform-metadata.interface.js
var require_transform_metadata_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/metadata/transform-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/metadata/transform-fn-params.interface.js
var require_transform_fn_params_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/metadata/transform-fn-params.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/metadata/type-metadata.interface.js
var require_type_metadata_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/metadata/type-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/class-constructor.type.js
var require_class_constructor_type = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/class-constructor.type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/class-transformer-options.interface.js
var require_class_transformer_options_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/class-transformer-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/target-map.interface.js
var require_target_map_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/target-map.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/type-help-options.interface.js
var require_type_help_options_interface = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/type-help-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-transformer/cjs/interfaces/index.js
var require_interfaces = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/interfaces/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_expose_options_interface(), exports2);
    __exportStar(require_exclude_options_interface(), exports2);
    __exportStar(require_transform_options_interface(), exports2);
    __exportStar(require_type_discriminator_descriptor_interface(), exports2);
    __exportStar(require_type_options_interface(), exports2);
    __exportStar(require_exclude_metadata_interface(), exports2);
    __exportStar(require_expose_metadata_interface(), exports2);
    __exportStar(require_transform_metadata_interface(), exports2);
    __exportStar(require_transform_fn_params_interface(), exports2);
    __exportStar(require_type_metadata_interface(), exports2);
    __exportStar(require_class_constructor_type(), exports2);
    __exportStar(require_class_transformer_options_interface(), exports2);
    __exportStar(require_target_map_interface(), exports2);
    __exportStar(require_type_help_options_interface(), exports2);
  }
});

// asset-input/node_modules/class-transformer/cjs/index.js
var require_cjs = __commonJS({
  "asset-input/node_modules/class-transformer/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserializeArray = exports2.deserialize = exports2.serialize = exports2.classToClassFromExist = exports2.instanceToInstance = exports2.plainToClassFromExist = exports2.plainToInstance = exports2.plainToClass = exports2.classToPlainFromExist = exports2.instanceToPlain = exports2.classToPlain = exports2.ClassTransformer = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    var ClassTransformer_2 = require_ClassTransformer();
    Object.defineProperty(exports2, "ClassTransformer", { enumerable: true, get: function() {
      return ClassTransformer_2.ClassTransformer;
    } });
    __exportStar(require_decorators(), exports2);
    __exportStar(require_interfaces(), exports2);
    __exportStar(require_enums(), exports2);
    var classTransformer = new ClassTransformer_1.ClassTransformer();
    function classToPlain(object, options) {
      return classTransformer.instanceToPlain(object, options);
    }
    exports2.classToPlain = classToPlain;
    function instanceToPlain(object, options) {
      return classTransformer.instanceToPlain(object, options);
    }
    exports2.instanceToPlain = instanceToPlain;
    function classToPlainFromExist(object, plainObject, options) {
      return classTransformer.classToPlainFromExist(object, plainObject, options);
    }
    exports2.classToPlainFromExist = classToPlainFromExist;
    function plainToClass2(cls, plain, options) {
      return classTransformer.plainToInstance(cls, plain, options);
    }
    exports2.plainToClass = plainToClass2;
    function plainToInstance(cls, plain, options) {
      return classTransformer.plainToInstance(cls, plain, options);
    }
    exports2.plainToInstance = plainToInstance;
    function plainToClassFromExist(clsObject, plain, options) {
      return classTransformer.plainToClassFromExist(clsObject, plain, options);
    }
    exports2.plainToClassFromExist = plainToClassFromExist;
    function instanceToInstance(object, options) {
      return classTransformer.instanceToInstance(object, options);
    }
    exports2.instanceToInstance = instanceToInstance;
    function classToClassFromExist(object, fromObject, options) {
      return classTransformer.classToClassFromExist(object, fromObject, options);
    }
    exports2.classToClassFromExist = classToClassFromExist;
    function serialize(object, options) {
      return classTransformer.serialize(object, options);
    }
    exports2.serialize = serialize;
    function deserialize(cls, json, options) {
      return classTransformer.deserialize(cls, json, options);
    }
    exports2.deserialize = deserialize;
    function deserializeArray(cls, json, options) {
      return classTransformer.deserializeArray(cls, json, options);
    }
    exports2.deserializeArray = deserializeArray;
  }
});

// asset-input/node_modules/class-validator/cjs/metadata/ValidationMetadata.js
var require_ValidationMetadata = __commonJS({
  "asset-input/node_modules/class-validator/cjs/metadata/ValidationMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationMetadata = void 0;
    var ValidationMetadata = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(args) {
        this.groups = [];
        this.each = false;
        this.context = void 0;
        this.type = args.type;
        this.name = args.name;
        this.target = args.target;
        this.propertyName = args.propertyName;
        this.constraints = args === null || args === void 0 ? void 0 : args.constraints;
        this.constraintCls = args.constraintCls;
        this.validationTypeOptions = args.validationTypeOptions;
        if (args.validationOptions) {
          this.message = args.validationOptions.message;
          this.groups = args.validationOptions.groups;
          this.always = args.validationOptions.always;
          this.each = args.validationOptions.each;
          this.context = args.validationOptions.context;
        }
      }
    };
    exports2.ValidationMetadata = ValidationMetadata;
  }
});

// asset-input/node_modules/class-validator/cjs/validation-schema/ValidationSchemaToMetadataTransformer.js
var require_ValidationSchemaToMetadataTransformer = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation-schema/ValidationSchemaToMetadataTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationSchemaToMetadataTransformer = void 0;
    var ValidationMetadata_1 = require_ValidationMetadata();
    var ValidationSchemaToMetadataTransformer = class {
      transform(schema) {
        const metadatas = [];
        Object.keys(schema.properties).forEach((property) => {
          schema.properties[property].forEach((validation) => {
            const validationOptions = {
              message: validation.message,
              groups: validation.groups,
              always: validation.always,
              each: validation.each
            };
            const args = {
              type: validation.type,
              name: validation.name,
              target: schema.name,
              propertyName: property,
              constraints: validation.constraints,
              validationTypeOptions: validation.options,
              validationOptions
            };
            metadatas.push(new ValidationMetadata_1.ValidationMetadata(args));
          });
        });
        return metadatas;
      }
    };
    exports2.ValidationSchemaToMetadataTransformer = ValidationSchemaToMetadataTransformer;
  }
});

// asset-input/node_modules/class-validator/cjs/utils/convert-to-array.util.js
var require_convert_to_array_util = __commonJS({
  "asset-input/node_modules/class-validator/cjs/utils/convert-to-array.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertToArray = void 0;
    function convertToArray(val) {
      if (val instanceof Map) {
        return Array.from(val.values());
      }
      return Array.isArray(val) ? val : Array.from(val);
    }
    exports2.convertToArray = convertToArray;
  }
});

// asset-input/node_modules/class-validator/cjs/utils/get-global.util.js
var require_get_global_util2 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/utils/get-global.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGlobal = void 0;
    function getGlobal() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof self !== "undefined") {
        return self;
      }
    }
    exports2.getGlobal = getGlobal;
  }
});

// asset-input/node_modules/class-validator/cjs/utils/is-promise.util.js
var require_is_promise_util2 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/utils/is-promise.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromise = void 0;
    function isPromise(p) {
      return p !== null && typeof p === "object" && typeof p.then === "function";
    }
    exports2.isPromise = isPromise;
  }
});

// asset-input/node_modules/class-validator/cjs/utils/index.js
var require_utils8 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/utils/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_convert_to_array_util(), exports2);
    __exportStar(require_get_global_util2(), exports2);
    __exportStar(require_is_promise_util2(), exports2);
  }
});

// asset-input/node_modules/class-validator/cjs/metadata/MetadataStorage.js
var require_MetadataStorage2 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/metadata/MetadataStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMetadataStorage = exports2.MetadataStorage = void 0;
    var ValidationSchemaToMetadataTransformer_1 = require_ValidationSchemaToMetadataTransformer();
    var utils_1 = require_utils8();
    var MetadataStorage = class {
      constructor() {
        this.validationMetadatas = /* @__PURE__ */ new Map();
        this.constraintMetadatas = /* @__PURE__ */ new Map();
      }
      get hasValidationMetaData() {
        return !!this.validationMetadatas.size;
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      /**
       * Adds a new validation metadata.
       */
      addValidationSchema(schema) {
        const validationMetadatas = new ValidationSchemaToMetadataTransformer_1.ValidationSchemaToMetadataTransformer().transform(schema);
        validationMetadatas.forEach((validationMetadata) => this.addValidationMetadata(validationMetadata));
      }
      /**
       * Adds a new validation metadata.
       */
      addValidationMetadata(metadata) {
        const existingMetadata = this.validationMetadatas.get(metadata.target);
        if (existingMetadata) {
          existingMetadata.push(metadata);
        } else {
          this.validationMetadatas.set(metadata.target, [metadata]);
        }
      }
      /**
       * Adds a new constraint metadata.
       */
      addConstraintMetadata(metadata) {
        const existingMetadata = this.constraintMetadatas.get(metadata.target);
        if (existingMetadata) {
          existingMetadata.push(metadata);
        } else {
          this.constraintMetadatas.set(metadata.target, [metadata]);
        }
      }
      /**
       * Groups metadata by their property names.
       */
      groupByPropertyName(metadata) {
        const grouped = {};
        metadata.forEach((metadata2) => {
          if (!grouped[metadata2.propertyName])
            grouped[metadata2.propertyName] = [];
          grouped[metadata2.propertyName].push(metadata2);
        });
        return grouped;
      }
      /**
       * Gets all validation metadatas for the given object with the given groups.
       */
      getTargetValidationMetadatas(targetConstructor, targetSchema, always, strictGroups, groups) {
        const includeMetadataBecauseOfAlwaysOption = (metadata) => {
          if (typeof metadata.always !== "undefined")
            return metadata.always;
          if (metadata.groups && metadata.groups.length)
            return false;
          return always;
        };
        const excludeMetadataBecauseOfStrictGroupsOption = (metadata) => {
          if (strictGroups) {
            if (!groups || !groups.length) {
              if (metadata.groups && metadata.groups.length)
                return true;
            }
          }
          return false;
        };
        const filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];
        const originalMetadatas = filteredForOriginalMetadatasSearch.filter((metadata) => {
          if (metadata.target !== targetConstructor && metadata.target !== targetSchema)
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find((group) => groups.indexOf(group) !== -1);
          return true;
        });
        const filteredForInheritedMetadatasSearch = [];
        for (const [key, value] of this.validationMetadatas.entries()) {
          if (targetConstructor.prototype instanceof key) {
            filteredForInheritedMetadatasSearch.push(...value);
          }
        }
        const inheritedMetadatas = filteredForInheritedMetadatasSearch.filter((metadata) => {
          if (typeof metadata.target === "string")
            return false;
          if (metadata.target === targetConstructor)
            return false;
          if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))
            return false;
          if (includeMetadataBecauseOfAlwaysOption(metadata))
            return true;
          if (excludeMetadataBecauseOfStrictGroupsOption(metadata))
            return false;
          if (groups && groups.length > 0)
            return metadata.groups && !!metadata.groups.find((group) => groups.indexOf(group) !== -1);
          return true;
        });
        const uniqueInheritedMetadatas = inheritedMetadatas.filter((inheritedMetadata) => {
          return !originalMetadatas.find((originalMetadata) => {
            return originalMetadata.propertyName === inheritedMetadata.propertyName && originalMetadata.type === inheritedMetadata.type;
          });
        });
        return originalMetadatas.concat(uniqueInheritedMetadatas);
      }
      /**
       * Gets all validator constraints for the given object.
       */
      getTargetValidatorConstraints(target) {
        return this.constraintMetadatas.get(target) || [];
      }
    };
    exports2.MetadataStorage = MetadataStorage;
    function getMetadataStorage() {
      const global2 = (0, utils_1.getGlobal)();
      if (!global2.classValidatorMetadataStorage) {
        global2.classValidatorMetadataStorage = new MetadataStorage();
      }
      return global2.classValidatorMetadataStorage;
    }
    exports2.getMetadataStorage = getMetadataStorage;
  }
});

// asset-input/node_modules/class-validator/cjs/validation/ValidationError.js
var require_ValidationError = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/ValidationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationError = void 0;
    var ValidationError2 = class {
      /**
       *
       * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability
       * @param hasParent true when the error is a child of an another one
       * @param parentPath path as string to the parent of this property
       * @param showConstraintMessages show constraint messages instead of constraint names
       */
      toString(shouldDecorate = false, hasParent = false, parentPath = ``, showConstraintMessages = false) {
        const boldStart = shouldDecorate ? `\x1B[1m` : ``;
        const boldEnd = shouldDecorate ? `\x1B[22m` : ``;
        const constraintsToString = () => {
          var _a;
          return (showConstraintMessages ? Object.values : Object.keys)((_a = this.constraints) !== null && _a !== void 0 ? _a : {}).join(`, `);
        };
        const propConstraintFailed = (propertyName) => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${constraintsToString()}${boldEnd} 
`;
        if (!hasParent) {
          return `An instance of ${boldStart}${this.target ? this.target.constructor.name : "an object"}${boldEnd} has failed the validation:
` + (this.constraints ? propConstraintFailed(this.property) : ``) + (this.children ? this.children.map((childError) => childError.toString(shouldDecorate, true, this.property, showConstraintMessages)).join(``) : ``);
        } else {
          const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;
          if (this.constraints) {
            return propConstraintFailed(formattedProperty);
          } else {
            return this.children ? this.children.map((childError) => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, showConstraintMessages)).join(``) : ``;
          }
        }
      }
    };
    exports2.ValidationError = ValidationError2;
  }
});

// asset-input/node_modules/class-validator/cjs/validation/ValidationTypes.js
var require_ValidationTypes = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/ValidationTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationTypes = void 0;
    var ValidationTypes = class {
      /**
       * Checks if validation type is valid.
       */
      static isValid(type) {
        return type !== "isValid" && type !== "getMessage" && Object.keys(this).map((key) => this[key]).indexOf(type) !== -1;
      }
    };
    exports2.ValidationTypes = ValidationTypes;
    ValidationTypes.CUSTOM_VALIDATION = "customValidation";
    ValidationTypes.NESTED_VALIDATION = "nestedValidation";
    ValidationTypes.PROMISE_VALIDATION = "promiseValidation";
    ValidationTypes.CONDITIONAL_VALIDATION = "conditionalValidation";
    ValidationTypes.WHITELIST = "whitelistValidation";
    ValidationTypes.IS_DEFINED = "isDefined";
  }
});

// asset-input/node_modules/class-validator/cjs/validation/ValidationUtils.js
var require_ValidationUtils = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/ValidationUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationUtils = exports2.constraintToString = void 0;
    function constraintToString(constraint) {
      if (Array.isArray(constraint)) {
        return constraint.join(", ");
      }
      if (typeof constraint === "symbol") {
        constraint = constraint.description;
      }
      return `${constraint}`;
    }
    exports2.constraintToString = constraintToString;
    var ValidationUtils = class {
      static replaceMessageSpecialTokens(message, validationArguments) {
        let messageString;
        if (message instanceof Function) {
          messageString = message(validationArguments);
        } else if (typeof message === "string") {
          messageString = message;
        }
        if (messageString && Array.isArray(validationArguments.constraints)) {
          validationArguments.constraints.forEach((constraint, index) => {
            messageString = messageString.replace(new RegExp(`\\$constraint${index + 1}`, "g"), constraintToString(constraint));
          });
        }
        if (messageString && validationArguments.value !== void 0 && validationArguments.value !== null && ["string", "boolean", "number"].includes(typeof validationArguments.value))
          messageString = messageString.replace(/\$value/g, validationArguments.value);
        if (messageString)
          messageString = messageString.replace(/\$property/g, validationArguments.property);
        if (messageString)
          messageString = messageString.replace(/\$target/g, validationArguments.targetName);
        return messageString;
      }
    };
    exports2.ValidationUtils = ValidationUtils;
  }
});

// asset-input/node_modules/class-validator/cjs/validation/ValidationExecutor.js
var require_ValidationExecutor = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/ValidationExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationExecutor = void 0;
    var ValidationError_1 = require_ValidationError();
    var ValidationTypes_1 = require_ValidationTypes();
    var ValidationUtils_1 = require_ValidationUtils();
    var utils_1 = require_utils8();
    var MetadataStorage_1 = require_MetadataStorage2();
    var ValidationExecutor = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(validator, validatorOptions) {
        this.validator = validator;
        this.validatorOptions = validatorOptions;
        this.awaitingPromises = [];
        this.ignoreAsyncValidations = false;
        this.metadataStorage = (0, MetadataStorage_1.getMetadataStorage)();
      }
      // -------------------------------------------------------------------------
      // Public Methods
      // -------------------------------------------------------------------------
      execute(object, targetSchema, validationErrors) {
        var _a, _b;
        if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {
          console.warn(`No validation metadata found. No validation will be  performed. There are multiple possible reasons:
  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.
  - This validation runs before any file with validation decorator was parsed by NodeJS.`);
        }
        const groups = this.validatorOptions ? this.validatorOptions.groups : void 0;
        const strictGroups = this.validatorOptions && this.validatorOptions.strictGroups || false;
        const always = this.validatorOptions && this.validatorOptions.always || false;
        const forbidUnknownValues = ((_b = this.validatorOptions) === null || _b === void 0 ? void 0 : _b.forbidUnknownValues) === void 0 || this.validatorOptions.forbidUnknownValues !== false;
        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);
        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);
        if (this.validatorOptions && forbidUnknownValues && !targetMetadatas.length) {
          const validationError = new ValidationError_1.ValidationError();
          if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
            validationError.target = object;
          validationError.value = void 0;
          validationError.property = void 0;
          validationError.children = [];
          validationError.constraints = { unknownValue: "an unknown value was passed to the validate function" };
          validationErrors.push(validationError);
          return;
        }
        if (this.validatorOptions && this.validatorOptions.whitelist)
          this.whitelist(object, groupedMetadatas, validationErrors);
        Object.keys(groupedMetadatas).forEach((propertyName) => {
          const value = object[propertyName];
          const definedMetadatas = groupedMetadatas[propertyName].filter((metadata) => metadata.type === ValidationTypes_1.ValidationTypes.IS_DEFINED);
          const metadatas = groupedMetadatas[propertyName].filter((metadata) => metadata.type !== ValidationTypes_1.ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes_1.ValidationTypes.WHITELIST);
          if (value instanceof Promise && metadatas.find((metadata) => metadata.type === ValidationTypes_1.ValidationTypes.PROMISE_VALIDATION)) {
            this.awaitingPromises.push(value.then((resolvedValue) => {
              this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);
            }));
          } else {
            this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);
          }
        });
      }
      whitelist(object, groupedMetadatas, validationErrors) {
        const notAllowedProperties = [];
        Object.keys(object).forEach((propertyName) => {
          if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)
            notAllowedProperties.push(propertyName);
        });
        if (notAllowedProperties.length > 0) {
          if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {
            notAllowedProperties.forEach((property) => {
              const validationError = this.generateValidationError(object, object[property], property);
              validationError.constraints = { [ValidationTypes_1.ValidationTypes.WHITELIST]: `property ${property} should not exist` };
              validationError.children = void 0;
              validationErrors.push(validationError);
            });
          } else {
            notAllowedProperties.forEach((property) => delete object[property]);
          }
        }
      }
      stripEmptyErrors(errors) {
        return errors.filter((error) => {
          if (error.children) {
            error.children = this.stripEmptyErrors(error.children);
          }
          if (Object.keys(error.constraints).length === 0) {
            if (error.children.length === 0) {
              return false;
            } else {
              delete error.constraints;
            }
          }
          return true;
        });
      }
      // -------------------------------------------------------------------------
      // Private Methods
      // -------------------------------------------------------------------------
      performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors) {
        const customValidationMetadatas = metadatas.filter((metadata) => metadata.type === ValidationTypes_1.ValidationTypes.CUSTOM_VALIDATION);
        const nestedValidationMetadatas = metadatas.filter((metadata) => metadata.type === ValidationTypes_1.ValidationTypes.NESTED_VALIDATION);
        const conditionalValidationMetadatas = metadatas.filter((metadata) => metadata.type === ValidationTypes_1.ValidationTypes.CONDITIONAL_VALIDATION);
        const validationError = this.generateValidationError(object, value, propertyName);
        validationErrors.push(validationError);
        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);
        if (!canValidate) {
          return;
        }
        this.customValidations(object, value, definedMetadatas, validationError);
        this.mapContexts(object, value, definedMetadatas, validationError);
        if (value === void 0 && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {
          return;
        }
        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {
          return;
        }
        if ((value === null || value === void 0) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {
          return;
        }
        this.customValidations(object, value, customValidationMetadatas, validationError);
        this.nestedValidations(value, nestedValidationMetadatas, validationError);
        this.mapContexts(object, value, metadatas, validationError);
        this.mapContexts(object, value, customValidationMetadatas, validationError);
      }
      generateValidationError(object, value, propertyName) {
        const validationError = new ValidationError_1.ValidationError();
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === true)
          validationError.target = object;
        if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === void 0 || this.validatorOptions.validationError.value === true)
          validationError.value = value;
        validationError.property = propertyName;
        validationError.children = [];
        validationError.constraints = {};
        return validationError;
      }
      conditionalValidations(object, value, metadatas) {
        return metadatas.map((metadata) => metadata.constraints[0](object, value)).reduce((resultA, resultB) => resultA && resultB, true);
      }
      customValidations(object, value, metadatas, error) {
        metadatas.forEach((metadata) => {
          this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach((customConstraintMetadata) => {
            if (customConstraintMetadata.async && this.ignoreAsyncValidations)
              return;
            if (this.validatorOptions && this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0)
              return;
            const validationArguments = {
              targetName: object.constructor ? object.constructor.name : void 0,
              property: metadata.propertyName,
              object,
              value,
              constraints: metadata.constraints
            };
            if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {
              const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);
              if ((0, utils_1.isPromise)(validatedValue)) {
                const promise = validatedValue.then((isValid) => {
                  if (!isValid) {
                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
                    error.constraints[type] = message;
                    if (metadata.context) {
                      if (!error.contexts) {
                        error.contexts = {};
                      }
                      error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);
                    }
                  }
                });
                this.awaitingPromises.push(promise);
              } else {
                if (!validatedValue) {
                  const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
                  error.constraints[type] = message;
                }
              }
              return;
            }
            const arrayValue = (0, utils_1.convertToArray)(value);
            const validatedSubValues = arrayValue.map((subValue) => customConstraintMetadata.instance.validate(subValue, validationArguments));
            const validationIsAsync = validatedSubValues.some((validatedSubValue) => (0, utils_1.isPromise)(validatedSubValue));
            if (validationIsAsync) {
              const asyncValidatedSubValues = validatedSubValues.map((validatedSubValue) => (0, utils_1.isPromise)(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));
              const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then((flatValidatedValues) => {
                const validationResult2 = flatValidatedValues.every((isValid) => isValid);
                if (!validationResult2) {
                  const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
                  error.constraints[type] = message;
                  if (metadata.context) {
                    if (!error.contexts) {
                      error.contexts = {};
                    }
                    error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);
                  }
                }
              });
              this.awaitingPromises.push(asyncValidationIsFinishedPromise);
              return;
            }
            const validationResult = validatedSubValues.every((isValid) => isValid);
            if (!validationResult) {
              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);
              error.constraints[type] = message;
            }
          });
        });
      }
      nestedValidations(value, metadatas, error) {
        if (value === void 0) {
          return;
        }
        metadatas.forEach((metadata) => {
          if (metadata.type !== ValidationTypes_1.ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes_1.ValidationTypes.PROMISE_VALIDATION) {
            return;
          } else if (this.validatorOptions && this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) {
            return;
          }
          if (Array.isArray(value) || value instanceof Set || value instanceof Map) {
            const arrayLikeValue = value instanceof Set ? Array.from(value) : value;
            arrayLikeValue.forEach((subValue, index) => {
              this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);
            });
          } else if (value instanceof Object) {
            const targetSchema = typeof metadata.target === "string" ? metadata.target : metadata.target.name;
            this.execute(value, targetSchema, error.children);
          } else {
            const [type, message] = this.createValidationError(metadata.target, value, metadata);
            error.constraints[type] = message;
          }
        });
      }
      mapContexts(object, value, metadatas, error) {
        return metadatas.forEach((metadata) => {
          if (metadata.context) {
            let customConstraint;
            if (metadata.type === ValidationTypes_1.ValidationTypes.CUSTOM_VALIDATION) {
              const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);
              customConstraint = customConstraints[0];
            }
            const type = this.getConstraintType(metadata, customConstraint);
            if (error.constraints[type]) {
              if (!error.contexts) {
                error.contexts = {};
              }
              error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);
            }
          }
        });
      }
      createValidationError(object, value, metadata, customValidatorMetadata) {
        const targetName = object.constructor ? object.constructor.name : void 0;
        const type = this.getConstraintType(metadata, customValidatorMetadata);
        const validationArguments = {
          targetName,
          property: metadata.propertyName,
          object,
          value,
          constraints: metadata.constraints
        };
        let message = metadata.message || "";
        if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {
          if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {
            message = customValidatorMetadata.instance.defaultMessage(validationArguments);
          }
        }
        const messageString = ValidationUtils_1.ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);
        return [type, messageString];
      }
      getConstraintType(metadata, customValidatorMetadata) {
        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;
        return type;
      }
    };
    exports2.ValidationExecutor = ValidationExecutor;
  }
});

// asset-input/node_modules/class-validator/cjs/validation/Validator.js
var require_Validator = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/Validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Validator = void 0;
    var ValidationExecutor_1 = require_ValidationExecutor();
    var Validator = class {
      /**
       * Performs validation of the given object based on decorators or validation schema.
       */
      validate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);
      }
      /**
       * Performs validation of the given object based on decorators or validation schema and reject on error.
       */
      async validateOrReject(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);
        if (errors.length)
          return Promise.reject(errors);
      }
      /**
       * Performs validation of the given object based on decorators or validation schema.
       */
      validateSync(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        const object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        const options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        const schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        const executor = new ValidationExecutor_1.ValidationExecutor(this, options);
        executor.ignoreAsyncValidations = true;
        const validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return executor.stripEmptyErrors(validationErrors);
      }
      // -------------------------------------------------------------------------
      // Private Properties
      // -------------------------------------------------------------------------
      /**
       * Performs validation of the given object based on decorators or validation schema.
       * Common method for `validateOrReject` and `validate` methods.
       */
      coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions) {
        const object = typeof objectOrSchemaName === "string" ? objectOrValidationOptions : objectOrSchemaName;
        const options = typeof objectOrSchemaName === "string" ? maybeValidatorOptions : objectOrValidationOptions;
        const schema = typeof objectOrSchemaName === "string" ? objectOrSchemaName : void 0;
        const executor = new ValidationExecutor_1.ValidationExecutor(this, options);
        const validationErrors = [];
        executor.execute(object, schema, validationErrors);
        return Promise.all(executor.awaitingPromises).then(() => {
          return executor.stripEmptyErrors(validationErrors);
        });
      }
    };
    exports2.Validator = Validator;
  }
});

// asset-input/node_modules/class-validator/cjs/container.js
var require_container = __commonJS({
  "asset-input/node_modules/class-validator/cjs/container.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFromContainer = exports2.useContainer = void 0;
    var defaultContainer = new class {
      constructor() {
        this.instances = [];
      }
      get(someClass) {
        let instance = this.instances.find((instance2) => instance2.type === someClass);
        if (!instance) {
          instance = { type: someClass, object: new someClass() };
          this.instances.push(instance);
        }
        return instance.object;
      }
    }();
    var userContainer;
    var userContainerOptions;
    function useContainer(iocContainer, options) {
      userContainer = iocContainer;
      userContainerOptions = options;
    }
    exports2.useContainer = useContainer;
    function getFromContainer(someClass) {
      if (userContainer) {
        try {
          const instance = userContainer.get(someClass);
          if (instance)
            return instance;
          if (!userContainerOptions || !userContainerOptions.fallback)
            return instance;
        } catch (error) {
          if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
            throw error;
        }
      }
      return defaultContainer.get(someClass);
    }
    exports2.getFromContainer = getFromContainer;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/Allow.js
var require_Allow = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/Allow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Allow = void 0;
    var ValidationTypes_1 = require_ValidationTypes();
    var ValidationMetadata_1 = require_ValidationMetadata();
    var MetadataStorage_1 = require_MetadataStorage2();
    function Allow(validationOptions) {
      return function(object, propertyName) {
        const args = {
          type: ValidationTypes_1.ValidationTypes.WHITELIST,
          target: object.constructor,
          propertyName,
          validationOptions
        };
        (0, MetadataStorage_1.getMetadataStorage)().addValidationMetadata(new ValidationMetadata_1.ValidationMetadata(args));
      };
    }
    exports2.Allow = Allow;
  }
});

// asset-input/node_modules/class-validator/cjs/metadata/ConstraintMetadata.js
var require_ConstraintMetadata = __commonJS({
  "asset-input/node_modules/class-validator/cjs/metadata/ConstraintMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConstraintMetadata = void 0;
    var container_1 = require_container();
    var ConstraintMetadata = class {
      // -------------------------------------------------------------------------
      // Constructor
      // -------------------------------------------------------------------------
      constructor(target, name, async = false) {
        this.target = target;
        this.name = name;
        this.async = async;
      }
      // -------------------------------------------------------------------------
      // Accessors
      // -------------------------------------------------------------------------
      /**
       * Instance of the target custom validation class which performs validation.
       */
      get instance() {
        return (0, container_1.getFromContainer)(this.target);
      }
    };
    exports2.ConstraintMetadata = ConstraintMetadata;
  }
});

// asset-input/node_modules/class-validator/cjs/register-decorator.js
var require_register_decorator = __commonJS({
  "asset-input/node_modules/class-validator/cjs/register-decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerDecorator = void 0;
    var ConstraintMetadata_1 = require_ConstraintMetadata();
    var ValidationMetadata_1 = require_ValidationMetadata();
    var ValidationTypes_1 = require_ValidationTypes();
    var container_1 = require_container();
    var MetadataStorage_1 = require_MetadataStorage2();
    function registerDecorator(options) {
      let constraintCls;
      if (options.validator instanceof Function) {
        constraintCls = options.validator;
        const constraintClasses = (0, container_1.getFromContainer)(MetadataStorage_1.MetadataStorage).getTargetValidatorConstraints(options.validator);
        if (constraintClasses.length > 1) {
          throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;
        }
      } else {
        const validator = options.validator;
        constraintCls = class CustomConstraint {
          validate(value, validationArguments) {
            return validator.validate(value, validationArguments);
          }
          defaultMessage(validationArguments) {
            if (validator.defaultMessage) {
              return validator.defaultMessage(validationArguments);
            }
            return "";
          }
        };
        (0, MetadataStorage_1.getMetadataStorage)().addConstraintMetadata(new ConstraintMetadata_1.ConstraintMetadata(constraintCls, options.name, options.async));
      }
      const validationMetadataArgs = {
        type: options.name && ValidationTypes_1.ValidationTypes.isValid(options.name) ? options.name : ValidationTypes_1.ValidationTypes.CUSTOM_VALIDATION,
        name: options.name,
        target: options.target,
        propertyName: options.propertyName,
        validationOptions: options.options,
        constraintCls,
        constraints: options.constraints
      };
      (0, MetadataStorage_1.getMetadataStorage)().addValidationMetadata(new ValidationMetadata_1.ValidationMetadata(validationMetadataArgs));
    }
    exports2.registerDecorator = registerDecorator;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/ValidateBy.js
var require_ValidateBy = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/ValidateBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidateBy = exports2.buildMessage = void 0;
    var register_decorator_1 = require_register_decorator();
    function buildMessage(impl, validationOptions) {
      return (validationArguments) => {
        const eachPrefix = validationOptions && validationOptions.each ? "each value in " : "";
        return impl(eachPrefix, validationArguments);
      };
    }
    exports2.buildMessage = buildMessage;
    function ValidateBy(options, validationOptions) {
      return function(object, propertyName) {
        (0, register_decorator_1.registerDecorator)({
          name: options.name,
          target: object.constructor,
          propertyName,
          options: validationOptions,
          constraints: options.constraints,
          validator: options.validator
        });
      };
    }
    exports2.ValidateBy = ValidateBy;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsDefined.js
var require_IsDefined = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsDefined.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsDefined = exports2.isDefined = exports2.IS_DEFINED = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var ValidationTypes_1 = require_ValidationTypes();
    exports2.IS_DEFINED = ValidationTypes_1.ValidationTypes.IS_DEFINED;
    function isDefined(value) {
      return value !== void 0 && value !== null;
    }
    exports2.isDefined = isDefined;
    function IsDefined(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_DEFINED,
        validator: {
          validate: (value) => isDefined(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property should not be null or undefined", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsDefined = IsDefined;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsOptional.js
var require_IsOptional = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsOptional.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsOptional = void 0;
    var ValidationTypes_1 = require_ValidationTypes();
    var ValidationMetadata_1 = require_ValidationMetadata();
    var MetadataStorage_1 = require_MetadataStorage2();
    function IsOptional(validationOptions) {
      return function(object, propertyName) {
        const args = {
          type: ValidationTypes_1.ValidationTypes.CONDITIONAL_VALIDATION,
          target: object.constructor,
          propertyName,
          constraints: [
            (object2, value) => {
              return object2[propertyName] !== null && object2[propertyName] !== void 0;
            }
          ],
          validationOptions
        };
        (0, MetadataStorage_1.getMetadataStorage)().addValidationMetadata(new ValidationMetadata_1.ValidationMetadata(args));
      };
    }
    exports2.IsOptional = IsOptional;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/Validate.js
var require_Validate = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/Validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Validate = exports2.ValidatorConstraint = void 0;
    var ValidationMetadata_1 = require_ValidationMetadata();
    var MetadataStorage_1 = require_MetadataStorage2();
    var ValidationTypes_1 = require_ValidationTypes();
    var ConstraintMetadata_1 = require_ConstraintMetadata();
    function ValidatorConstraint(options) {
      return function(target) {
        const isAsync = options && options.async;
        let name = options && options.name ? options.name : "";
        if (!name) {
          name = target.name;
          if (!name)
            name = name.replace(/\.?([A-Z]+)/g, (x, y) => "_" + y.toLowerCase()).replace(/^_/, "");
        }
        const metadata = new ConstraintMetadata_1.ConstraintMetadata(target, name, isAsync);
        (0, MetadataStorage_1.getMetadataStorage)().addConstraintMetadata(metadata);
      };
    }
    exports2.ValidatorConstraint = ValidatorConstraint;
    function Validate(constraintClass, constraintsOrValidationOptions, maybeValidationOptions) {
      return function(object, propertyName) {
        const args = {
          type: ValidationTypes_1.ValidationTypes.CUSTOM_VALIDATION,
          target: object.constructor,
          propertyName,
          constraintCls: constraintClass,
          constraints: Array.isArray(constraintsOrValidationOptions) ? constraintsOrValidationOptions : void 0,
          validationOptions: !Array.isArray(constraintsOrValidationOptions) ? constraintsOrValidationOptions : maybeValidationOptions
        };
        (0, MetadataStorage_1.getMetadataStorage)().addValidationMetadata(new ValidationMetadata_1.ValidationMetadata(args));
      };
    }
    exports2.Validate = Validate;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/ValidateIf.js
var require_ValidateIf = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/ValidateIf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidateIf = void 0;
    var ValidationTypes_1 = require_ValidationTypes();
    var ValidationMetadata_1 = require_ValidationMetadata();
    var MetadataStorage_1 = require_MetadataStorage2();
    function ValidateIf(condition, validationOptions) {
      return function(object, propertyName) {
        const args = {
          type: ValidationTypes_1.ValidationTypes.CONDITIONAL_VALIDATION,
          target: object.constructor,
          propertyName,
          constraints: [condition],
          validationOptions
        };
        (0, MetadataStorage_1.getMetadataStorage)().addValidationMetadata(new ValidationMetadata_1.ValidationMetadata(args));
      };
    }
    exports2.ValidateIf = ValidateIf;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/ValidateNested.js
var require_ValidateNested = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/ValidateNested.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidateNested = void 0;
    var ValidationTypes_1 = require_ValidationTypes();
    var ValidationMetadata_1 = require_ValidationMetadata();
    var MetadataStorage_1 = require_MetadataStorage2();
    function ValidateNested(validationOptions) {
      const opts = { ...validationOptions };
      const eachPrefix = opts.each ? "each value in " : "";
      opts.message = opts.message || eachPrefix + "nested property $property must be either object or array";
      return function(object, propertyName) {
        const args = {
          type: ValidationTypes_1.ValidationTypes.NESTED_VALIDATION,
          target: object.constructor,
          propertyName,
          validationOptions: opts
        };
        (0, MetadataStorage_1.getMetadataStorage)().addValidationMetadata(new ValidationMetadata_1.ValidationMetadata(args));
      };
    }
    exports2.ValidateNested = ValidateNested;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/ValidatePromise.js
var require_ValidatePromise = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/ValidatePromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidatePromise = void 0;
    var ValidationTypes_1 = require_ValidationTypes();
    var ValidationMetadata_1 = require_ValidationMetadata();
    var MetadataStorage_1 = require_MetadataStorage2();
    function ValidatePromise(validationOptions) {
      return function(object, propertyName) {
        const args = {
          type: ValidationTypes_1.ValidationTypes.PROMISE_VALIDATION,
          target: object.constructor,
          propertyName,
          validationOptions
        };
        (0, MetadataStorage_1.getMetadataStorage)().addValidationMetadata(new ValidationMetadata_1.ValidationMetadata(args));
      };
    }
    exports2.ValidatePromise = ValidatePromise;
  }
});

// asset-input/node_modules/validator/lib/util/assertString.js
var require_assertString = __commonJS({
  "asset-input/node_modules/validator/lib/util/assertString.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = assertString;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function assertString(input) {
      var isString = typeof input === "string" || input instanceof String;
      if (!isString) {
        var invalidType = _typeof(input);
        if (input === null) invalidType = "null";
        else if (invalidType === "object") invalidType = input.constructor.name;
        throw new TypeError("Expected a string but received a ".concat(invalidType));
      }
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/util/merge.js
var require_merge2 = __commonJS({
  "asset-input/node_modules/validator/lib/util/merge.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = merge;
    function merge() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults2 = arguments.length > 1 ? arguments[1] : void 0;
      for (var key in defaults2) {
        if (typeof obj[key] === "undefined") {
          obj[key] = defaults2[key];
        }
      }
      return obj;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isLatLong.js
var require_isLatLong = __commonJS({
  "asset-input/node_modules/validator/lib/isLatLong.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLatLong;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
    var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
    var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
    var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
    var defaultLatLongOptions = {
      checkDMS: false
    };
    function isLatLong(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultLatLongOptions);
      if (!str.includes(",")) return false;
      var pair = str.split(",");
      if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("(")) return false;
      if (options.checkDMS) {
        return latDMS.test(pair[0]) && longDMS.test(pair[1]);
      }
      return lat.test(pair[0]) && long.test(pair[1]);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsLatLong.js
var require_IsLatLong = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsLatLong.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsLatLong = exports2.isLatLong = exports2.IS_LATLONG = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isLatLong_1 = __importDefault(require_isLatLong());
    exports2.IS_LATLONG = "isLatLong";
    function isLatLong(value) {
      return typeof value === "string" && (0, isLatLong_1.default)(value);
    }
    exports2.isLatLong = isLatLong;
    function IsLatLong(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_LATLONG,
        validator: {
          validate: (value, args) => isLatLong(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a latitude,longitude string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsLatLong = IsLatLong;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsLatitude.js
var require_IsLatitude = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsLatitude.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsLatitude = exports2.isLatitude = exports2.IS_LATITUDE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var IsLatLong_1 = require_IsLatLong();
    exports2.IS_LATITUDE = "isLatitude";
    function isLatitude(value) {
      return (typeof value === "number" || typeof value === "string") && (0, IsLatLong_1.isLatLong)(`${value},0`);
    }
    exports2.isLatitude = isLatitude;
    function IsLatitude(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_LATITUDE,
        validator: {
          validate: (value, args) => isLatitude(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a latitude string or number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsLatitude = IsLatitude;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsLongitude.js
var require_IsLongitude = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsLongitude.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsLongitude = exports2.isLongitude = exports2.IS_LONGITUDE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var IsLatLong_1 = require_IsLatLong();
    exports2.IS_LONGITUDE = "isLongitude";
    function isLongitude(value) {
      return (typeof value === "number" || typeof value === "string") && (0, IsLatLong_1.isLatLong)(`0,${value}`);
    }
    exports2.isLongitude = isLongitude;
    function IsLongitude(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_LONGITUDE,
        validator: {
          validate: (value, args) => isLongitude(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a longitude string or number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsLongitude = IsLongitude;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/Equals.js
var require_Equals = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/Equals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Equals = exports2.equals = exports2.EQUALS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.EQUALS = "equals";
    function equals(value, comparison) {
      return value === comparison;
    }
    exports2.equals = equals;
    function Equals(comparison, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.EQUALS,
        constraints: [comparison],
        validator: {
          validate: (value, args) => equals(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be equal to $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.Equals = Equals;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/NotEquals.js
var require_NotEquals = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/NotEquals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotEquals = exports2.notEquals = exports2.NOT_EQUALS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.NOT_EQUALS = "notEquals";
    function notEquals(value, comparison) {
      return value !== comparison;
    }
    exports2.notEquals = notEquals;
    function NotEquals(comparison, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.NOT_EQUALS,
        constraints: [comparison],
        validator: {
          validate: (value, args) => notEquals(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property should not be equal to $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.NotEquals = NotEquals;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsEmpty.js
var require_IsEmpty = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsEmpty = exports2.isEmpty = exports2.IS_EMPTY = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_EMPTY = "isEmpty";
    function isEmpty(value) {
      return value === "" || value === null || value === void 0;
    }
    exports2.isEmpty = isEmpty;
    function IsEmpty(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_EMPTY,
        validator: {
          validate: (value, args) => isEmpty(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be empty", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsEmpty = IsEmpty;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsNotEmpty.js
var require_IsNotEmpty = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsNotEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsNotEmpty = exports2.isNotEmpty = exports2.IS_NOT_EMPTY = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_NOT_EMPTY = "isNotEmpty";
    function isNotEmpty(value) {
      return value !== "" && value !== null && value !== void 0;
    }
    exports2.isNotEmpty = isNotEmpty;
    function IsNotEmpty(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_NOT_EMPTY,
        validator: {
          validate: (value, args) => isNotEmpty(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property should not be empty", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsNotEmpty = IsNotEmpty;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsIn.js
var require_IsIn = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsIn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsIn = exports2.isIn = exports2.IS_IN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_IN = "isIn";
    function isIn(value, possibleValues) {
      return Array.isArray(possibleValues) && possibleValues.some((possibleValue) => possibleValue === value);
    }
    exports2.isIn = isIn;
    function IsIn(values, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_IN,
        constraints: [values],
        validator: {
          validate: (value, args) => isIn(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be one of the following values: $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsIn = IsIn;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/common/IsNotIn.js
var require_IsNotIn = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/common/IsNotIn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsNotIn = exports2.isNotIn = exports2.IS_NOT_IN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_NOT_IN = "isNotIn";
    function isNotIn(value, possibleValues) {
      return !Array.isArray(possibleValues) || !possibleValues.some((possibleValue) => possibleValue === value);
    }
    exports2.isNotIn = isNotIn;
    function IsNotIn(values, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_NOT_IN,
        constraints: [values],
        validator: {
          validate: (value, args) => isNotIn(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property should not be one of the following values: $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsNotIn = IsNotIn;
  }
});

// asset-input/node_modules/validator/lib/alpha.js
var require_alpha = __commonJS({
  "asset-input/node_modules/validator/lib/alpha.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.farsiLocales = exports2.englishLocales = exports2.dotDecimal = exports2.decimal = exports2.commaDecimal = exports2.bengaliLocales = exports2.arabicLocales = exports2.alphanumeric = exports2.alpha = void 0;
    var alpha = exports2.alpha = {
      "en-US": /^[A-Z]+$/i,
      "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[А-Я]+$/i,
      "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[A-ZÆØÅ]+$/i,
      "de-DE": /^[A-ZÄÖÜß]+$/i,
      "el-GR": /^[Α-ώ]+$/i,
      "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
      "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
      "fi-FI": /^[A-ZÅÄÖ]+$/i,
      "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "nb-NO": /^[A-ZÆØÅ]+$/i,
      "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[A-ZÆØÅ]+$/i,
      "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[А-ЯЁ]+$/i,
      "kk-KZ": /^[А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
      "sl-SI": /^[A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๐\s]+$/i,
      "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i,
      "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      "ko-KR": /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[א-ת]+$/,
      fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      eo: /^[ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
      "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
      "si-LK": /^[\u0D80-\u0DFF]+$/
    };
    var alphanumeric = exports2.alphanumeric = {
      "en-US": /^[0-9A-Z]+$/i,
      "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[0-9А-Я]+$/i,
      "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[0-9A-ZÆØÅ]+$/i,
      "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
      "el-GR": /^[0-9Α-ω]+$/i,
      "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
      "fi-FI": /^[0-9A-ZÅÄÖ]+$/i,
      "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "nb-NO": /^[0-9A-ZÆØÅ]+$/i,
      "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[0-9A-ZÆØÅ]+$/i,
      "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[0-9А-ЯЁ]+$/i,
      "kk-KZ": /^[0-9А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
      "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[0-9A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๙\s]+$/i,
      "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
      "ko-KR": /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[0-9א-ת]+$/,
      fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      eo: /^[0-9ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
      "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
      "si-LK": /^[0-9\u0D80-\u0DFF]+$/
    };
    var decimal = exports2.decimal = {
      "en-US": ".",
      ar: "\u066B"
    };
    var englishLocales = exports2.englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
    for (i = 0; i < englishLocales.length; i++) {
      locale = "en-".concat(englishLocales[i]);
      alpha[locale] = alpha["en-US"];
      alphanumeric[locale] = alphanumeric["en-US"];
      decimal[locale] = decimal["en-US"];
    }
    var locale;
    var i;
    var arabicLocales = exports2.arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
    for (_i = 0; _i < arabicLocales.length; _i++) {
      _locale = "ar-".concat(arabicLocales[_i]);
      alpha[_locale] = alpha.ar;
      alphanumeric[_locale] = alphanumeric.ar;
      decimal[_locale] = decimal.ar;
    }
    var _locale;
    var _i;
    var farsiLocales = exports2.farsiLocales = ["IR", "AF"];
    for (_i2 = 0; _i2 < farsiLocales.length; _i2++) {
      _locale2 = "fa-".concat(farsiLocales[_i2]);
      alphanumeric[_locale2] = alphanumeric.fa;
      decimal[_locale2] = decimal.ar;
    }
    var _locale2;
    var _i2;
    var bengaliLocales = exports2.bengaliLocales = ["BD", "IN"];
    for (_i3 = 0; _i3 < bengaliLocales.length; _i3++) {
      _locale3 = "bn-".concat(bengaliLocales[_i3]);
      alpha[_locale3] = alpha.bn;
      alphanumeric[_locale3] = alphanumeric.bn;
      decimal[_locale3] = decimal["en-US"];
    }
    var _locale3;
    var _i3;
    var dotDecimal = exports2.dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
    var commaDecimal = exports2.commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
    for (_i4 = 0; _i4 < dotDecimal.length; _i4++) {
      decimal[dotDecimal[_i4]] = decimal["en-US"];
    }
    var _i4;
    for (_i5 = 0; _i5 < commaDecimal.length; _i5++) {
      decimal[commaDecimal[_i5]] = ",";
    }
    var _i5;
    alpha["fr-CA"] = alpha["fr-FR"];
    alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
    alpha["pt-BR"] = alpha["pt-PT"];
    alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
    decimal["pt-BR"] = decimal["pt-PT"];
    alpha["pl-Pl"] = alpha["pl-PL"];
    alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
    decimal["pl-Pl"] = decimal["pl-PL"];
    alpha["fa-AF"] = alpha.fa;
  }
});

// asset-input/node_modules/validator/lib/isFloat.js
var require_isFloat = __commonJS({
  "asset-input/node_modules/validator/lib/isFloat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isFloat;
    exports2.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isFloat(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
      if (str === "" || str === "." || str === "," || str === "-" || str === "+") {
        return false;
      }
      var value = parseFloat(str.replace(",", "."));
      return float.test(str) && (!options.hasOwnProperty("min") || value >= options.min) && (!options.hasOwnProperty("max") || value <= options.max) && (!options.hasOwnProperty("lt") || value < options.lt) && (!options.hasOwnProperty("gt") || value > options.gt);
    }
    var locales = exports2.locales = Object.keys(_alpha.decimal);
  }
});

// asset-input/node_modules/validator/lib/toFloat.js
var require_toFloat = __commonJS({
  "asset-input/node_modules/validator/lib/toFloat.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toFloat;
    var _isFloat = _interopRequireDefault(require_isFloat());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toFloat(str) {
      if (!(0, _isFloat.default)(str)) return NaN;
      return parseFloat(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isDivisibleBy.js
var require_isDivisibleBy = __commonJS({
  "asset-input/node_modules/validator/lib/isDivisibleBy.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isDivisibleBy;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toFloat = _interopRequireDefault(require_toFloat());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isDivisibleBy(str, num) {
      (0, _assertString.default)(str);
      return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/number/IsDivisibleBy.js
var require_IsDivisibleBy = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/number/IsDivisibleBy.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsDivisibleBy = exports2.isDivisibleBy = exports2.IS_DIVISIBLE_BY = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isDivisibleBy_1 = __importDefault(require_isDivisibleBy());
    exports2.IS_DIVISIBLE_BY = "isDivisibleBy";
    function isDivisibleBy(value, num) {
      return typeof value === "number" && typeof num === "number" && (0, isDivisibleBy_1.default)(String(value), num);
    }
    exports2.isDivisibleBy = isDivisibleBy;
    function IsDivisibleBy(num, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_DIVISIBLE_BY,
        constraints: [num],
        validator: {
          validate: (value, args) => isDivisibleBy(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be divisible by $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsDivisibleBy = IsDivisibleBy;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/number/IsPositive.js
var require_IsPositive = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/number/IsPositive.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsPositive = exports2.isPositive = exports2.IS_POSITIVE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_POSITIVE = "isPositive";
    function isPositive(value) {
      return typeof value === "number" && value > 0;
    }
    exports2.isPositive = isPositive;
    function IsPositive(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_POSITIVE,
        validator: {
          validate: (value, args) => isPositive(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a positive number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsPositive = IsPositive;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/number/IsNegative.js
var require_IsNegative = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/number/IsNegative.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsNegative = exports2.isNegative = exports2.IS_NEGATIVE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_NEGATIVE = "isNegative";
    function isNegative(value) {
      return typeof value === "number" && value < 0;
    }
    exports2.isNegative = isNegative;
    function IsNegative(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_NEGATIVE,
        validator: {
          validate: (value, args) => isNegative(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a negative number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsNegative = IsNegative;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/number/Max.js
var require_Max = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/number/Max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Max = exports2.max = exports2.MAX = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.MAX = "max";
    function max(num, max2) {
      return typeof num === "number" && typeof max2 === "number" && num <= max2;
    }
    exports2.max = max;
    function Max(maxValue, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.MAX,
        constraints: [maxValue],
        validator: {
          validate: (value, args) => max(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must not be greater than $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.Max = Max;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/number/Min.js
var require_Min = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/number/Min.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Min = exports2.min = exports2.MIN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.MIN = "min";
    function min(num, min2) {
      return typeof num === "number" && typeof min2 === "number" && num >= min2;
    }
    exports2.min = min;
    function Min(minValue, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.MIN,
        constraints: [minValue],
        validator: {
          validate: (value, args) => min(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must not be less than $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.Min = Min;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/date/MinDate.js
var require_MinDate = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/date/MinDate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MinDate = exports2.minDate = exports2.MIN_DATE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.MIN_DATE = "minDate";
    function minDate(date, minDate2) {
      return date instanceof Date && date.getTime() >= (minDate2 instanceof Date ? minDate2 : minDate2()).getTime();
    }
    exports2.minDate = minDate;
    function MinDate(date, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.MIN_DATE,
        constraints: [date],
        validator: {
          validate: (value, args) => minDate(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => "minimal allowed date for " + eachPrefix + "$property is $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.MinDate = MinDate;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/date/MaxDate.js
var require_MaxDate = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/date/MaxDate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxDate = exports2.maxDate = exports2.MAX_DATE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.MAX_DATE = "maxDate";
    function maxDate(date, maxDate2) {
      return date instanceof Date && date.getTime() <= (maxDate2 instanceof Date ? maxDate2 : maxDate2()).getTime();
    }
    exports2.maxDate = maxDate;
    function MaxDate(date, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.MAX_DATE,
        constraints: [date],
        validator: {
          validate: (value, args) => maxDate(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => "maximal allowed date for " + eachPrefix + "$property is $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.MaxDate = MaxDate;
  }
});

// asset-input/node_modules/validator/lib/util/toString.js
var require_toString = __commonJS({
  "asset-input/node_modules/validator/lib/util/toString.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toString2;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function toString2(input) {
      if (_typeof(input) === "object" && input !== null) {
        if (typeof input.toString === "function") {
          input = input.toString();
        } else {
          input = "[object Object]";
        }
      } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
        input = "";
      }
      return String(input);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/contains.js
var require_contains = __commonJS({
  "asset-input/node_modules/validator/lib/contains.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = contains;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toString = _interopRequireDefault(require_toString());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var defaulContainsOptions = {
      ignoreCase: false,
      minOccurrences: 1
    };
    function contains(str, elem, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaulContainsOptions);
      if (options.ignoreCase) {
        return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
      }
      return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/Contains.js
var require_Contains = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/Contains.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Contains = exports2.contains = exports2.CONTAINS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var contains_1 = __importDefault(require_contains());
    exports2.CONTAINS = "contains";
    function contains(value, seed) {
      return typeof value === "string" && (0, contains_1.default)(value, seed);
    }
    exports2.contains = contains;
    function Contains(seed, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.CONTAINS,
        constraints: [seed],
        validator: {
          validate: (value, args) => contains(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain a $constraint1 string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.Contains = Contains;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/NotContains.js
var require_NotContains = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/NotContains.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotContains = exports2.notContains = exports2.NOT_CONTAINS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var contains_1 = __importDefault(require_contains());
    exports2.NOT_CONTAINS = "notContains";
    function notContains(value, seed) {
      return typeof value === "string" && !(0, contains_1.default)(value, seed);
    }
    exports2.notContains = notContains;
    function NotContains(seed, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.NOT_CONTAINS,
        constraints: [seed],
        validator: {
          validate: (value, args) => notContains(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property should not contain a $constraint1 string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.NotContains = NotContains;
  }
});

// asset-input/node_modules/validator/lib/isAlpha.js
var require_isAlpha = __commonJS({
  "asset-input/node_modules/validator/lib/isAlpha.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isAlpha;
    exports2.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAlpha(_str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      (0, _assertString.default)(_str);
      var str = _str;
      var ignore = options.ignore;
      if (ignore) {
        if (ignore instanceof RegExp) {
          str = str.replace(ignore, "");
        } else if (typeof ignore === "string") {
          str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
        } else {
          throw new Error("ignore should be instance of a String or RegExp");
        }
      }
      if (locale in _alpha.alpha) {
        return _alpha.alpha[locale].test(str);
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = exports2.locales = Object.keys(_alpha.alpha);
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsAlpha.js
var require_IsAlpha = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsAlpha.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsAlpha = exports2.isAlpha = exports2.IS_ALPHA = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isAlpha_1 = __importDefault(require_isAlpha());
    exports2.IS_ALPHA = "isAlpha";
    function isAlpha(value, locale) {
      return typeof value === "string" && (0, isAlpha_1.default)(value, locale);
    }
    exports2.isAlpha = isAlpha;
    function IsAlpha(locale, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ALPHA,
        constraints: [locale],
        validator: {
          validate: (value, args) => isAlpha(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain only letters (a-zA-Z)", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsAlpha = IsAlpha;
  }
});

// asset-input/node_modules/validator/lib/isAlphanumeric.js
var require_isAlphanumeric = __commonJS({
  "asset-input/node_modules/validator/lib/isAlphanumeric.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isAlphanumeric;
    exports2.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAlphanumeric(_str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      (0, _assertString.default)(_str);
      var str = _str;
      var ignore = options.ignore;
      if (ignore) {
        if (ignore instanceof RegExp) {
          str = str.replace(ignore, "");
        } else if (typeof ignore === "string") {
          str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
        } else {
          throw new Error("ignore should be instance of a String or RegExp");
        }
      }
      if (locale in _alpha.alphanumeric) {
        return _alpha.alphanumeric[locale].test(str);
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = exports2.locales = Object.keys(_alpha.alphanumeric);
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsAlphanumeric.js
var require_IsAlphanumeric = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsAlphanumeric.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsAlphanumeric = exports2.isAlphanumeric = exports2.IS_ALPHANUMERIC = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isAlphanumeric_1 = __importDefault(require_isAlphanumeric());
    exports2.IS_ALPHANUMERIC = "isAlphanumeric";
    function isAlphanumeric(value, locale) {
      return typeof value === "string" && (0, isAlphanumeric_1.default)(value, locale);
    }
    exports2.isAlphanumeric = isAlphanumeric;
    function IsAlphanumeric(locale, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ALPHANUMERIC,
        constraints: [locale],
        validator: {
          validate: (value, args) => isAlphanumeric(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain only letters and numbers", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsAlphanumeric = IsAlphanumeric;
  }
});

// asset-input/node_modules/validator/lib/util/includes.js
var require_includes = __commonJS({
  "asset-input/node_modules/validator/lib/util/includes.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var includes = function includes2(arr, val) {
      return arr.some(function(arrVal) {
        return val === arrVal;
      });
    };
    var _default = exports2.default = includes;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isDecimal.js
var require_isDecimal = __commonJS({
  "asset-input/node_modules/validator/lib/isDecimal.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isDecimal;
    var _merge = _interopRequireDefault(require_merge2());
    var _assertString = _interopRequireDefault(require_assertString());
    var _includes = _interopRequireDefault(require_includes());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function decimalRegExp(options) {
      var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
      return regExp;
    }
    var default_decimal_options = {
      force_decimal: false,
      decimal_digits: "1,",
      locale: "en-US"
    };
    var blacklist = ["", "-", "+"];
    function isDecimal(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_decimal_options);
      if (options.locale in _alpha.decimal) {
        return !(0, _includes.default)(blacklist, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
      }
      throw new Error("Invalid locale '".concat(options.locale, "'"));
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsDecimal.js
var require_IsDecimal = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsDecimal.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsDecimal = exports2.isDecimal = exports2.IS_DECIMAL = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isDecimal_1 = __importDefault(require_isDecimal());
    exports2.IS_DECIMAL = "isDecimal";
    function isDecimal(value, options) {
      return typeof value === "string" && (0, isDecimal_1.default)(value, options);
    }
    exports2.isDecimal = isDecimal;
    function IsDecimal(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_DECIMAL,
        constraints: [options],
        validator: {
          validate: (value, args) => isDecimal(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property is not a valid decimal number.", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsDecimal = IsDecimal;
  }
});

// asset-input/node_modules/validator/lib/isAscii.js
var require_isAscii = __commonJS({
  "asset-input/node_modules/validator/lib/isAscii.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isAscii;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ascii = /^[\x00-\x7F]+$/;
    function isAscii(str) {
      (0, _assertString.default)(str);
      return ascii.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsAscii.js
var require_IsAscii = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsAscii.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsAscii = exports2.isAscii = exports2.IS_ASCII = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isAscii_1 = __importDefault(require_isAscii());
    exports2.IS_ASCII = "isAscii";
    function isAscii(value) {
      return typeof value === "string" && (0, isAscii_1.default)(value);
    }
    exports2.isAscii = isAscii;
    function IsAscii(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ASCII,
        validator: {
          validate: (value, args) => isAscii(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain only ASCII characters", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsAscii = IsAscii;
  }
});

// asset-input/node_modules/validator/lib/isBase64.js
var require_isBase64 = __commonJS({
  "asset-input/node_modules/validator/lib/isBase64.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBase64;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var notBase64 = /[^A-Z0-9+\/=]/i;
    var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
    var defaultBase64Options = {
      urlSafe: false
    };
    function isBase64(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase64Options);
      var len = str.length;
      if (options.urlSafe) {
        return urlSafeBase64.test(str);
      }
      if (len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }
      var firstPaddingChar = str.indexOf("=");
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsBase64.js
var require_IsBase64 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsBase64.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsBase64 = exports2.isBase64 = exports2.IS_BASE64 = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isBase64_1 = __importDefault(require_isBase64());
    exports2.IS_BASE64 = "isBase64";
    function isBase64(value, options) {
      return typeof value === "string" && (0, isBase64_1.default)(value, options);
    }
    exports2.isBase64 = isBase64;
    function IsBase64(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BASE64,
        constraints: [options],
        validator: {
          validate: (value, args) => isBase64(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be base64 encoded", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsBase64 = IsBase64;
  }
});

// asset-input/node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS({
  "asset-input/node_modules/validator/lib/isByteLength.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isByteLength;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function isByteLength(str, options) {
      (0, _assertString.default)(str);
      var min;
      var max;
      if (_typeof(options) === "object") {
        min = options.min || 0;
        max = options.max;
      } else {
        min = arguments[1];
        max = arguments[2];
      }
      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min && (typeof max === "undefined" || len <= max);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsByteLength.js
var require_IsByteLength = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsByteLength.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsByteLength = exports2.isByteLength = exports2.IS_BYTE_LENGTH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isByteLength_1 = __importDefault(require_isByteLength());
    exports2.IS_BYTE_LENGTH = "isByteLength";
    function isByteLength(value, min, max) {
      return typeof value === "string" && (0, isByteLength_1.default)(value, { min, max });
    }
    exports2.isByteLength = isByteLength;
    function IsByteLength(min, max, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BYTE_LENGTH,
        constraints: [min, max],
        validator: {
          validate: (value, args) => isByteLength(value, args === null || args === void 0 ? void 0 : args.constraints[0], args === null || args === void 0 ? void 0 : args.constraints[1]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property's byte length must fall into ($constraint1, $constraint2) range", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsByteLength = IsByteLength;
  }
});

// asset-input/node_modules/validator/lib/isLuhnNumber.js
var require_isLuhnNumber = __commonJS({
  "asset-input/node_modules/validator/lib/isLuhnNumber.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLuhnNumber;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isLuhnNumber(str) {
      (0, _assertString.default)(str);
      var sanitized = str.replace(/[- ]+/g, "");
      var sum = 0;
      var digit;
      var tmpNum;
      var shouldDouble;
      for (var i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, i + 1);
        tmpNum = parseInt(digit, 10);
        if (shouldDouble) {
          tmpNum *= 2;
          if (tmpNum >= 10) {
            sum += tmpNum % 10 + 1;
          } else {
            sum += tmpNum;
          }
        } else {
          sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
      }
      return !!(sum % 10 === 0 ? sanitized : false);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isCreditCard.js
var require_isCreditCard = __commonJS({
  "asset-input/node_modules/validator/lib/isCreditCard.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isCreditCard;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var cards = {
      amex: /^3[47][0-9]{13}$/,
      dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
      discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
      jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
      mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
      // /^[25][1-7][0-9]{14}$/;
      unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
      visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
    };
    var allCards = function() {
      var tmpCardsArray = [];
      for (var cardProvider in cards) {
        if (cards.hasOwnProperty(cardProvider)) {
          tmpCardsArray.push(cards[cardProvider]);
        }
      }
      return tmpCardsArray;
    }();
    function isCreditCard(card) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(card);
      var provider = options.provider;
      var sanitized = card.replace(/[- ]+/g, "");
      if (provider && provider.toLowerCase() in cards) {
        if (!cards[provider.toLowerCase()].test(sanitized)) {
          return false;
        }
      } else if (provider && !(provider.toLowerCase() in cards)) {
        throw new Error("".concat(provider, " is not a valid credit card provider."));
      } else if (!allCards.some(function(cardProvider) {
        return cardProvider.test(sanitized);
      })) {
        return false;
      }
      return (0, _isLuhnNumber.default)(card);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsCreditCard.js
var require_IsCreditCard = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsCreditCard.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsCreditCard = exports2.isCreditCard = exports2.IS_CREDIT_CARD = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isCreditCard_1 = __importDefault(require_isCreditCard());
    exports2.IS_CREDIT_CARD = "isCreditCard";
    function isCreditCard(value) {
      return typeof value === "string" && (0, isCreditCard_1.default)(value);
    }
    exports2.isCreditCard = isCreditCard;
    function IsCreditCard(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_CREDIT_CARD,
        validator: {
          validate: (value, args) => isCreditCard(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a credit card", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsCreditCard = IsCreditCard;
  }
});

// asset-input/node_modules/validator/lib/isCurrency.js
var require_isCurrency = __commonJS({
  "asset-input/node_modules/validator/lib/isCurrency.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isCurrency;
    var _merge = _interopRequireDefault(require_merge2());
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function currencyRegex(options) {
      var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
      options.digits_after_decimal.forEach(function(digit, index) {
        if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
      });
      var symbol = "(".concat(options.symbol.replace(/\W/, function(m) {
        return "\\".concat(m);
      }), ")").concat(options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"), valid_whole_dollar_amounts = ["0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep], whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join("|"), ")?"), decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? "" : "?");
      var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : "");
      if (options.allow_negatives && !options.parens_for_negatives) {
        if (options.negative_sign_after_digits) {
          pattern += negative;
        } else if (options.negative_sign_before_digits) {
          pattern = negative + pattern;
        }
      }
      if (options.allow_negative_sign_placeholder) {
        pattern = "( (?!\\-))?".concat(pattern);
      } else if (options.allow_space_after_symbol) {
        pattern = " ?".concat(pattern);
      } else if (options.allow_space_after_digits) {
        pattern += "( (?!$))?";
      }
      if (options.symbol_after_digits) {
        pattern += symbol;
      } else {
        pattern = symbol + pattern;
      }
      if (options.allow_negatives) {
        if (options.parens_for_negatives) {
          pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
        } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
          pattern = negative + pattern;
        }
      }
      return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
    }
    var default_currency_options = {
      symbol: "$",
      require_symbol: false,
      allow_space_after_symbol: false,
      symbol_after_digits: false,
      allow_negatives: true,
      parens_for_negatives: false,
      negative_sign_before_digits: false,
      negative_sign_after_digits: false,
      allow_negative_sign_placeholder: false,
      thousands_separator: ",",
      decimal_separator: ".",
      allow_decimal: true,
      require_decimal: false,
      digits_after_decimal: [2],
      allow_space_after_digits: false
    };
    function isCurrency(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_currency_options);
      return currencyRegex(options).test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsCurrency.js
var require_IsCurrency = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsCurrency.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsCurrency = exports2.isCurrency = exports2.IS_CURRENCY = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isCurrency_1 = __importDefault(require_isCurrency());
    exports2.IS_CURRENCY = "isCurrency";
    function isCurrency(value, options) {
      return typeof value === "string" && (0, isCurrency_1.default)(value, options);
    }
    exports2.isCurrency = isCurrency;
    function IsCurrency(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_CURRENCY,
        constraints: [options],
        validator: {
          validate: (value, args) => isCurrency(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a currency", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsCurrency = IsCurrency;
  }
});

// asset-input/node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS({
  "asset-input/node_modules/validator/lib/isFQDN.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isFQDN;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_numeric_tld: false,
      allow_wildcard: false,
      ignore_max_length: false
    };
    function isFQDN(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_fqdn_options);
      if (options.allow_trailing_dot && str[str.length - 1] === ".") {
        str = str.substring(0, str.length - 1);
      }
      if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
        str = str.substring(2);
      }
      var parts = str.split(".");
      var tld = parts[parts.length - 1];
      if (options.require_tld) {
        if (parts.length < 2) {
          return false;
        }
        if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        }
        if (/\s/.test(tld)) {
          return false;
        }
      }
      if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
        return false;
      }
      return parts.every(function(part) {
        if (part.length > 63 && !options.ignore_max_length) {
          return false;
        }
        if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        }
        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }
        if (/^-|-$/.test(part)) {
          return false;
        }
        if (!options.allow_underscores && /_/.test(part)) {
          return false;
        }
        return true;
      });
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isIP.js
var require_isIP = __commonJS({
  "asset-input/node_modules/validator/lib/isIP.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isIP;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
    var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
    var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
    var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
    function isIP(str) {
      var version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (0, _assertString.default)(str);
      version = String(version);
      if (!version) {
        return isIP(str, 4) || isIP(str, 6);
      }
      if (version === "4") {
        return IPv4AddressRegExp.test(str);
      }
      if (version === "6") {
        return IPv6AddressRegExp.test(str);
      }
      return false;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS({
  "asset-input/node_modules/validator/lib/isEmail.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isEmail;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isByteLength = _interopRequireDefault(require_isByteLength());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_email_options = {
      allow_display_name: false,
      allow_underscores: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true,
      blacklisted_chars: "",
      ignore_max_length: false,
      host_blacklist: [],
      host_whitelist: []
    };
    var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    var defaultMaxEmailLength = 254;
    function validateDisplayName(display_name) {
      var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
      if (!display_name_without_quotes.trim()) {
        return false;
      }
      var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
      if (contains_illegal) {
        if (display_name_without_quotes === display_name) {
          return false;
        }
        var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
        if (!all_start_with_back_slash) {
          return false;
        }
      }
      return true;
    }
    function isEmail(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_email_options);
      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(splitNameAddress);
        if (display_email) {
          var display_name = display_email[1];
          str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
          if (display_name.endsWith(" ")) {
            display_name = display_name.slice(0, -1);
          }
          if (!validateDisplayName(display_name)) {
            return false;
          }
        } else if (options.require_display_name) {
          return false;
        }
      }
      if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
        return false;
      }
      var parts = str.split("@");
      var domain = parts.pop();
      var lower_domain = domain.toLowerCase();
      if (options.host_blacklist.includes(lower_domain)) {
        return false;
      }
      if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
        return false;
      }
      var user = parts.join("@");
      if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
        user = user.toLowerCase();
        var username = user.split("+")[0];
        if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
          min: 6,
          max: 30
        })) {
          return false;
        }
        var _user_parts = username.split(".");
        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }
      if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
        max: 64
      }) || !(0, _isByteLength.default)(domain, {
        max: 254
      }))) {
        return false;
      }
      if (!(0, _isFQDN.default)(domain, {
        require_tld: options.require_tld,
        ignore_max_length: options.ignore_max_length,
        allow_underscores: options.allow_underscores
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }
        if (!(0, _isIP.default)(domain)) {
          if (!domain.startsWith("[") || !domain.endsWith("]")) {
            return false;
          }
          var noBracketdomain = domain.slice(1, -1);
          if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
            return false;
          }
        }
      }
      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }
      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split(".");
      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }
      if (options.blacklisted_chars) {
        if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1) return false;
      }
      return true;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsEmail.js
var require_IsEmail = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsEmail.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsEmail = exports2.isEmail = exports2.IS_EMAIL = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isEmail_1 = __importDefault(require_isEmail());
    exports2.IS_EMAIL = "isEmail";
    function isEmail(value, options) {
      return typeof value === "string" && (0, isEmail_1.default)(value, options);
    }
    exports2.isEmail = isEmail;
    function IsEmail(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_EMAIL,
        constraints: [options],
        validator: {
          validate: (value, args) => isEmail(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an email", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsEmail = IsEmail;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsFQDN.js
var require_IsFQDN = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsFQDN.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsFQDN = exports2.isFQDN = exports2.IS_FQDN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isFQDN_1 = __importDefault(require_isFQDN());
    exports2.IS_FQDN = "isFqdn";
    function isFQDN(value, options) {
      return typeof value === "string" && (0, isFQDN_1.default)(value, options);
    }
    exports2.isFQDN = isFQDN;
    function IsFQDN(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_FQDN,
        constraints: [options],
        validator: {
          validate: (value, args) => isFQDN(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid domain name", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsFQDN = IsFQDN;
  }
});

// asset-input/node_modules/validator/lib/isFullWidth.js
var require_isFullWidth = __commonJS({
  "asset-input/node_modules/validator/lib/isFullWidth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isFullWidth;
    exports2.fullWidth = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var fullWidth = exports2.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function isFullWidth(str) {
      (0, _assertString.default)(str);
      return fullWidth.test(str);
    }
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsFullWidth.js
var require_IsFullWidth = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsFullWidth.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsFullWidth = exports2.isFullWidth = exports2.IS_FULL_WIDTH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isFullWidth_1 = __importDefault(require_isFullWidth());
    exports2.IS_FULL_WIDTH = "isFullWidth";
    function isFullWidth(value) {
      return typeof value === "string" && (0, isFullWidth_1.default)(value);
    }
    exports2.isFullWidth = isFullWidth;
    function IsFullWidth(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_FULL_WIDTH,
        validator: {
          validate: (value, args) => isFullWidth(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain a full-width characters", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsFullWidth = IsFullWidth;
  }
});

// asset-input/node_modules/validator/lib/isHalfWidth.js
var require_isHalfWidth = __commonJS({
  "asset-input/node_modules/validator/lib/isHalfWidth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isHalfWidth;
    exports2.halfWidth = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var halfWidth = exports2.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function isHalfWidth(str) {
      (0, _assertString.default)(str);
      return halfWidth.test(str);
    }
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsHalfWidth.js
var require_IsHalfWidth = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsHalfWidth.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsHalfWidth = exports2.isHalfWidth = exports2.IS_HALF_WIDTH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isHalfWidth_1 = __importDefault(require_isHalfWidth());
    exports2.IS_HALF_WIDTH = "isHalfWidth";
    function isHalfWidth(value) {
      return typeof value === "string" && (0, isHalfWidth_1.default)(value);
    }
    exports2.isHalfWidth = isHalfWidth;
    function IsHalfWidth(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_HALF_WIDTH,
        validator: {
          validate: (value, args) => isHalfWidth(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain a half-width characters", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsHalfWidth = IsHalfWidth;
  }
});

// asset-input/node_modules/validator/lib/isVariableWidth.js
var require_isVariableWidth = __commonJS({
  "asset-input/node_modules/validator/lib/isVariableWidth.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isVariableWidth;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isFullWidth = require_isFullWidth();
    var _isHalfWidth = require_isHalfWidth();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isVariableWidth(str) {
      (0, _assertString.default)(str);
      return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsVariableWidth.js
var require_IsVariableWidth = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsVariableWidth.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsVariableWidth = exports2.isVariableWidth = exports2.IS_VARIABLE_WIDTH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isVariableWidth_1 = __importDefault(require_isVariableWidth());
    exports2.IS_VARIABLE_WIDTH = "isVariableWidth";
    function isVariableWidth(value) {
      return typeof value === "string" && (0, isVariableWidth_1.default)(value);
    }
    exports2.isVariableWidth = isVariableWidth;
    function IsVariableWidth(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_VARIABLE_WIDTH,
        validator: {
          validate: (value, args) => isVariableWidth(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain a full-width and half-width characters", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsVariableWidth = IsVariableWidth;
  }
});

// asset-input/node_modules/validator/lib/isHexColor.js
var require_isHexColor = __commonJS({
  "asset-input/node_modules/validator/lib/isHexColor.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isHexColor;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
    function isHexColor(str) {
      (0, _assertString.default)(str);
      return hexcolor.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsHexColor.js
var require_IsHexColor = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsHexColor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsHexColor = exports2.isHexColor = exports2.IS_HEX_COLOR = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isHexColor_1 = __importDefault(require_isHexColor());
    exports2.IS_HEX_COLOR = "isHexColor";
    function isHexColor(value) {
      return typeof value === "string" && (0, isHexColor_1.default)(value);
    }
    exports2.isHexColor = isHexColor;
    function IsHexColor(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_HEX_COLOR,
        validator: {
          validate: (value, args) => isHexColor(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a hexadecimal color", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsHexColor = IsHexColor;
  }
});

// asset-input/node_modules/validator/lib/isHexadecimal.js
var require_isHexadecimal = __commonJS({
  "asset-input/node_modules/validator/lib/isHexadecimal.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isHexadecimal;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
    function isHexadecimal(str) {
      (0, _assertString.default)(str);
      return hexadecimal.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsHexadecimal.js
var require_IsHexadecimal = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsHexadecimal.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsHexadecimal = exports2.isHexadecimal = exports2.IS_HEXADECIMAL = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isHexadecimal_1 = __importDefault(require_isHexadecimal());
    exports2.IS_HEXADECIMAL = "isHexadecimal";
    function isHexadecimal(value) {
      return typeof value === "string" && (0, isHexadecimal_1.default)(value);
    }
    exports2.isHexadecimal = isHexadecimal;
    function IsHexadecimal(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_HEXADECIMAL,
        validator: {
          validate: (value, args) => isHexadecimal(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a hexadecimal number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsHexadecimal = IsHexadecimal;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/ValidationOptions.js
var require_ValidationOptions = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/ValidationOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidationOptions = void 0;
    function isValidationOptions(val) {
      if (!val) {
        return false;
      }
      return "each" in val || "message" in val || "groups" in val || "always" in val || "context" in val;
    }
    exports2.isValidationOptions = isValidationOptions;
  }
});

// asset-input/node_modules/validator/lib/isMACAddress.js
var require_isMACAddress = __commonJS({
  "asset-input/node_modules/validator/lib/isMACAddress.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMACAddress;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
    var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
    var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
    var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
    var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
    var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
    function isMACAddress(str, options) {
      (0, _assertString.default)(str);
      if (options !== null && options !== void 0 && options.eui) {
        options.eui = String(options.eui);
      }
      if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
        if (options.eui === "48") {
          return macAddress48NoSeparators.test(str);
        }
        if (options.eui === "64") {
          return macAddress64NoSeparators.test(str);
        }
        return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
      }
      if ((options === null || options === void 0 ? void 0 : options.eui) === "48") {
        return macAddress48.test(str) || macAddress48WithDots.test(str);
      }
      if ((options === null || options === void 0 ? void 0 : options.eui) === "64") {
        return macAddress64.test(str) || macAddress64WithDots.test(str);
      }
      return isMACAddress(str, {
        eui: "48"
      }) || isMACAddress(str, {
        eui: "64"
      });
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsMacAddress.js
var require_IsMacAddress = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsMacAddress.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsMACAddress = exports2.isMACAddress = exports2.IS_MAC_ADDRESS = void 0;
    var ValidationOptions_1 = require_ValidationOptions();
    var ValidateBy_1 = require_ValidateBy();
    var isMACAddress_1 = __importDefault(require_isMACAddress());
    exports2.IS_MAC_ADDRESS = "isMacAddress";
    function isMACAddress(value, options) {
      return typeof value === "string" && (0, isMACAddress_1.default)(value, options);
    }
    exports2.isMACAddress = isMACAddress;
    function IsMACAddress(optionsOrValidationOptionsArg, validationOptionsArg) {
      const options = !(0, ValidationOptions_1.isValidationOptions)(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : void 0;
      const validationOptions = (0, ValidationOptions_1.isValidationOptions)(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_MAC_ADDRESS,
        constraints: [options],
        validator: {
          validate: (value, args) => isMACAddress(value, options),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a MAC Address", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsMACAddress = IsMACAddress;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsIP.js
var require_IsIP = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsIP.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsIP = exports2.isIP = exports2.IS_IP = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isIP_1 = __importDefault(require_isIP());
    exports2.IS_IP = "isIp";
    function isIP(value, version) {
      const versionStr = version ? `${version}` : void 0;
      return typeof value === "string" && (0, isIP_1.default)(value, versionStr);
    }
    exports2.isIP = isIP;
    function IsIP(version, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_IP,
        constraints: [version],
        validator: {
          validate: (value, args) => isIP(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an ip address", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsIP = IsIP;
  }
});

// asset-input/node_modules/validator/lib/isInt.js
var require_isInt = __commonJS({
  "asset-input/node_modules/validator/lib/isInt.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isInt;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
    var intLeadingZeroes = /^[-+]?[0-9]+$/;
    function isInt(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var regex = options.allow_leading_zeroes === false ? int : intLeadingZeroes;
      var minCheckPassed = !options.hasOwnProperty("min") || str >= options.min;
      var maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max;
      var ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt;
      var gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
      return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isPort.js
var require_isPort = __commonJS({
  "asset-input/node_modules/validator/lib/isPort.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isPort;
    var _isInt = _interopRequireDefault(require_isInt());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isPort(str) {
      return (0, _isInt.default)(str, {
        allow_leading_zeroes: false,
        min: 0,
        max: 65535
      });
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsPort.js
var require_IsPort = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsPort.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsPort = exports2.isPort = exports2.IS_PORT = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isPort_1 = __importDefault(require_isPort());
    exports2.IS_PORT = "isPort";
    function isPort(value) {
      return typeof value === "string" && (0, isPort_1.default)(value);
    }
    exports2.isPort = isPort;
    function IsPort(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_PORT,
        validator: {
          validate: (value, args) => isPort(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a port", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsPort = IsPort;
  }
});

// asset-input/node_modules/validator/lib/isISBN.js
var require_isISBN = __commonJS({
  "asset-input/node_modules/validator/lib/isISBN.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISBN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
    var possibleIsbn13 = /^(?:[0-9]{13})$/;
    var factor = [1, 3];
    function isISBN(isbn, options) {
      (0, _assertString.default)(isbn);
      var version = String((options === null || options === void 0 ? void 0 : options.version) || options);
      if (!(options !== null && options !== void 0 && options.version || options)) {
        return isISBN(isbn, {
          version: 10
        }) || isISBN(isbn, {
          version: 13
        });
      }
      var sanitizedIsbn = isbn.replace(/[\s-]+/g, "");
      var checksum = 0;
      if (version === "10") {
        if (!possibleIsbn10.test(sanitizedIsbn)) {
          return false;
        }
        for (var i = 0; i < version - 1; i++) {
          checksum += (i + 1) * sanitizedIsbn.charAt(i);
        }
        if (sanitizedIsbn.charAt(9) === "X") {
          checksum += 10 * 10;
        } else {
          checksum += 10 * sanitizedIsbn.charAt(9);
        }
        if (checksum % 11 === 0) {
          return true;
        }
      } else if (version === "13") {
        if (!possibleIsbn13.test(sanitizedIsbn)) {
          return false;
        }
        for (var _i = 0; _i < 12; _i++) {
          checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);
        }
        if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {
          return true;
        }
      }
      return false;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsISBN.js
var require_IsISBN = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsISBN.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISBN = exports2.isISBN = exports2.IS_ISBN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISBN_1 = __importDefault(require_isISBN());
    exports2.IS_ISBN = "isIsbn";
    function isISBN(value, version) {
      const versionStr = version ? `${version}` : void 0;
      return typeof value === "string" && (0, isISBN_1.default)(value, versionStr);
    }
    exports2.isISBN = isISBN;
    function IsISBN(version, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISBN,
        constraints: [version],
        validator: {
          validate: (value, args) => isISBN(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an ISBN", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISBN = IsISBN;
  }
});

// asset-input/node_modules/validator/lib/isISIN.js
var require_isISIN = __commonJS({
  "asset-input/node_modules/validator/lib/isISIN.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISIN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
    function isISIN(str) {
      (0, _assertString.default)(str);
      if (!isin.test(str)) {
        return false;
      }
      var double = true;
      var sum = 0;
      for (var i = str.length - 2; i >= 0; i--) {
        if (str[i] >= "A" && str[i] <= "Z") {
          var value = str[i].charCodeAt(0) - 55;
          var lo = value % 10;
          var hi = Math.trunc(value / 10);
          for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {
            var digit = _arr[_i];
            if (double) {
              if (digit >= 5) {
                sum += 1 + (digit - 5) * 2;
              } else {
                sum += digit * 2;
              }
            } else {
              sum += digit;
            }
            double = !double;
          }
        } else {
          var _digit = str[i].charCodeAt(0) - "0".charCodeAt(0);
          if (double) {
            if (_digit >= 5) {
              sum += 1 + (_digit - 5) * 2;
            } else {
              sum += _digit * 2;
            }
          } else {
            sum += _digit;
          }
          double = !double;
        }
      }
      var check = Math.trunc((sum + 9) / 10) * 10 - sum;
      return +str[str.length - 1] === check;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsISIN.js
var require_IsISIN = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsISIN.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISIN = exports2.isISIN = exports2.IS_ISIN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISIN_1 = __importDefault(require_isISIN());
    exports2.IS_ISIN = "isIsin";
    function isISIN(value) {
      return typeof value === "string" && (0, isISIN_1.default)(value);
    }
    exports2.isISIN = isISIN;
    function IsISIN(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISIN,
        validator: {
          validate: (value, args) => isISIN(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an ISIN (stock/security identifier)", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISIN = IsISIN;
  }
});

// asset-input/node_modules/validator/lib/isISO8601.js
var require_isISO8601 = __commonJS({
  "asset-input/node_modules/validator/lib/isISO8601.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISO8601;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var isValidDate = function isValidDate2(str) {
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]);
        if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;
        return oDay <= 365;
      }
      var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match[1];
      var month = match[2];
      var day = match[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day;
      var d = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
      if (month && day) {
        return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
      }
      return true;
    };
    function isISO8601(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
      if (check && options.strict) return isValidDate(str);
      return check;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsISO8601.js
var require_IsISO8601 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsISO8601.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISO8601 = exports2.isISO8601 = exports2.IS_ISO8601 = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISO8601_1 = __importDefault(require_isISO8601());
    exports2.IS_ISO8601 = "isIso8601";
    function isISO8601(value, options) {
      return typeof value === "string" && (0, isISO8601_1.default)(value, options);
    }
    exports2.isISO8601 = isISO8601;
    function IsISO8601(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISO8601,
        constraints: [options],
        validator: {
          validate: (value, args) => isISO8601(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid ISO 8601 date string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISO8601 = IsISO8601;
  }
});

// asset-input/node_modules/validator/lib/isJSON.js
var require_isJSON = __commonJS({
  "asset-input/node_modules/validator/lib/isJSON.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isJSON;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var default_json_options = {
      allow_primitives: false
    };
    function isJSON(str, options) {
      (0, _assertString.default)(str);
      try {
        options = (0, _merge.default)(options, default_json_options);
        var primitives = [];
        if (options.allow_primitives) {
          primitives = [null, false, true];
        }
        var obj = JSON.parse(str);
        return primitives.includes(obj) || !!obj && _typeof(obj) === "object";
      } catch (e) {
      }
      return false;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsJSON.js
var require_IsJSON = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsJSON.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsJSON = exports2.isJSON = exports2.IS_JSON = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isJSON_1 = __importDefault(require_isJSON());
    exports2.IS_JSON = "isJson";
    function isJSON(value) {
      return typeof value === "string" && (0, isJSON_1.default)(value);
    }
    exports2.isJSON = isJSON;
    function IsJSON(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_JSON,
        validator: {
          validate: (value, args) => isJSON(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a json string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsJSON = IsJSON;
  }
});

// asset-input/node_modules/validator/lib/isJWT.js
var require_isJWT = __commonJS({
  "asset-input/node_modules/validator/lib/isJWT.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isJWT;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isBase = _interopRequireDefault(require_isBase64());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isJWT(str) {
      (0, _assertString.default)(str);
      var dotSplit = str.split(".");
      var len = dotSplit.length;
      if (len !== 3) {
        return false;
      }
      return dotSplit.reduce(function(acc, currElem) {
        return acc && (0, _isBase.default)(currElem, {
          urlSafe: true
        });
      }, true);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsJWT.js
var require_IsJWT = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsJWT.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsJWT = exports2.isJWT = exports2.IS_JWT = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isJWT_1 = __importDefault(require_isJWT());
    exports2.IS_JWT = "isJwt";
    function isJWT(value) {
      return typeof value === "string" && (0, isJWT_1.default)(value);
    }
    exports2.isJWT = isJWT;
    function IsJWT(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_JWT,
        validator: {
          validate: (value, args) => isJWT(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a jwt string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsJWT = IsJWT;
  }
});

// asset-input/node_modules/validator/lib/isLowercase.js
var require_isLowercase = __commonJS({
  "asset-input/node_modules/validator/lib/isLowercase.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLowercase;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isLowercase(str) {
      (0, _assertString.default)(str);
      return str === str.toLowerCase();
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsLowercase.js
var require_IsLowercase = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsLowercase.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsLowercase = exports2.isLowercase = exports2.IS_LOWERCASE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isLowercase_1 = __importDefault(require_isLowercase());
    exports2.IS_LOWERCASE = "isLowercase";
    function isLowercase(value) {
      return typeof value === "string" && (0, isLowercase_1.default)(value);
    }
    exports2.isLowercase = isLowercase;
    function IsLowercase(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_LOWERCASE,
        validator: {
          validate: (value, args) => isLowercase(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a lowercase string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsLowercase = IsLowercase;
  }
});

// asset-input/node_modules/validator/lib/isMobilePhone.js
var require_isMobilePhone = __commonJS({
  "asset-input/node_modules/validator/lib/isMobilePhone.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMobilePhone;
    exports2.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var phones = {
      "am-AM": /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
      "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
      "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
      "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
      "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
      "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
      "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
      "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
      "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
      "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
      "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
      "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
      "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
      "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
      "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
      "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
      "ar-TN": /^(\+?216)?[2459]\d{7}$/,
      "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
      "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
      "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
      "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
      "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
      "ca-AD": /^(\+376)?[346]\d{5}$/,
      "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
      "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
      "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
      "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
      "de-LU": /^(\+352)?((6\d1)\d{6})$/,
      "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
      "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
      "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
      "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
      "en-AU": /^(\+?61|0)4\d{8}$/,
      "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
      "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
      "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
      "en-GB": /^(\+?44|0)7\d{9}$/,
      "en-GG": /^(\+?44|0)1481\d{6}$/,
      "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
      "en-GY": /^(\+592|0)6\d{6}$/,
      "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
      "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
      "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
      "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
      "en-JM": /^(\+?876)?\d{7}$/,
      "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
      "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
      "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
      "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
      "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
      "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
      "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
      "en-MU": /^(\+?230|0)?\d{8}$/,
      "en-MW": /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
      "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
      "en-NG": /^(\+?234|0)?[789]\d{9}$/,
      "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
      "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
      "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
      "en-PH": /^(09|\+639)\d{9}$/,
      "en-RW": /^(\+?250|0)?[7]\d{8}$/,
      "en-SG": /^(\+65)?[3689]\d{7}$/,
      "en-SL": /^(\+?232|0)\d{8}$/,
      "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
      "en-UG": /^(\+?256|0)?[7]\d{8}$/,
      "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
      "en-ZA": /^(\+?27|0)\d{9}$/,
      "en-ZM": /^(\+?26)?09[567]\d{7}$/,
      "en-ZW": /^(\+263)[0-9]{9}$/,
      "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
      "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
      "es-BO": /^(\+?591)?(6|7)\d{7}$/,
      "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
      "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
      "es-CR": /^(\+506)?[2-8]\d{7}$/,
      "es-CU": /^(\+53|0053)?5\d{7}$/,
      "es-DO": /^(\+?1)?8[024]9\d{7}$/,
      "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
      "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
      "es-ES": /^(\+?34)?[6|7]\d{8}$/,
      "es-PE": /^(\+?51)?9\d{8}$/,
      "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
      "es-NI": /^(\+?505)\d{7,8}$/,
      "es-PA": /^(\+?507)\d{7,8}$/,
      "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
      "es-SV": /^(\+?503)?[67]\d{7}$/,
      "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
      "es-VE": /^(\+?58)?(2|4)\d{9}$/,
      "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
      "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
      "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
      "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
      "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "fr-BF": /^(\+226|0)[67]\d{7}$/,
      "fr-BJ": /^(\+229)\d{8}$/,
      "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
      "fr-CM": /^(\+?237)6[0-9]{8}$/,
      "fr-FR": /^(\+?33|0)[67]\d{8}$/,
      "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
      "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
      "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
      "fr-PF": /^(\+?689)?8[789]\d{6}$/,
      "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
      "fr-WF": /^(\+681)?\d{6}$/,
      "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
      "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
      "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
      "ir-IR": /^(\+98|0)?9\d{9}$/,
      "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
      "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
      "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
      "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
      "kk-KZ": /^(\+?7|8)?7\d{9}$/,
      "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
      "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
      "lt-LT": /^(\+370|8)\d{8}$/,
      "lv-LV": /^(\+?371)2\d{7}$/,
      "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
      "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
      "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
      "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
      "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
      "nb-NO": /^(\+?47)?[49]\d{7}$/,
      "ne-NP": /^(\+?977)?9[78]\d{8}$/,
      "nl-BE": /^(\+?32|0)4\d{8}$/,
      "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
      "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
      "nn-NO": /^(\+?47)?[49]\d{7}$/,
      "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
      "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
      "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
      "pt-AO": /^(\+244)\d{9}$/,
      "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
      "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
      "ru-RU": /^(\+?7|8)?9\d{9}$/,
      "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
      "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
      "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
      "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
      "sq-AL": /^(\+355|0)6[789]\d{6}$/,
      "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
      "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
      "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
      "th-TH": /^(\+66|66|0)\d{9}$/,
      "tr-TR": /^(\+?90|0)?5\d{9}$/,
      "tk-TM": /^(\+993|993|8)\d{8}$/,
      "uk-UA": /^(\+?38|8)?0\d{9}$/,
      "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
      "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
      "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
      "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
      "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
      "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
      "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
      "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
    };
    phones["en-CA"] = phones["en-US"];
    phones["fr-CA"] = phones["en-CA"];
    phones["fr-BE"] = phones["nl-BE"];
    phones["zh-HK"] = phones["en-HK"];
    phones["zh-MO"] = phones["en-MO"];
    phones["ga-IE"] = phones["en-IE"];
    phones["fr-CH"] = phones["de-CH"];
    phones["it-CH"] = phones["fr-CH"];
    function isMobilePhone(str, locale, options) {
      (0, _assertString.default)(str);
      if (options && options.strictMode && !str.startsWith("+")) {
        return false;
      }
      if (Array.isArray(locale)) {
        return locale.some(function(key2) {
          if (phones.hasOwnProperty(key2)) {
            var phone2 = phones[key2];
            if (phone2.test(str)) {
              return true;
            }
          }
          return false;
        });
      } else if (locale in phones) {
        return phones[locale].test(str);
      } else if (!locale || locale === "any") {
        for (var key in phones) {
          if (phones.hasOwnProperty(key)) {
            var phone = phones[key];
            if (phone.test(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = exports2.locales = Object.keys(phones);
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsMobilePhone.js
var require_IsMobilePhone = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsMobilePhone.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsMobilePhone = exports2.isMobilePhone = exports2.IS_MOBILE_PHONE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isMobilePhone_1 = __importDefault(require_isMobilePhone());
    exports2.IS_MOBILE_PHONE = "isMobilePhone";
    function isMobilePhone(value, locale, options) {
      return typeof value === "string" && (0, isMobilePhone_1.default)(value, locale, options);
    }
    exports2.isMobilePhone = isMobilePhone;
    function IsMobilePhone(locale, options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_MOBILE_PHONE,
        constraints: [locale, options],
        validator: {
          validate: (value, args) => isMobilePhone(value, args === null || args === void 0 ? void 0 : args.constraints[0], args === null || args === void 0 ? void 0 : args.constraints[1]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a phone number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsMobilePhone = IsMobilePhone;
  }
});

// asset-input/node_modules/validator/lib/isISO31661Alpha2.js
var require_isISO31661Alpha2 = __commonJS({
  "asset-input/node_modules/validator/lib/isISO31661Alpha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CountryCodes = void 0;
    exports2.default = isISO31661Alpha2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO31661Alpha2CountriesCodes = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
    function isISO31661Alpha2(str) {
      (0, _assertString.default)(str);
      return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
    }
    var CountryCodes = exports2.CountryCodes = validISO31661Alpha2CountriesCodes;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsISO31661Alpha2.js
var require_IsISO31661Alpha2 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsISO31661Alpha2.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISO31661Alpha2 = exports2.isISO31661Alpha2 = exports2.IS_ISO31661_ALPHA_2 = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISO31661Alpha2_1 = __importDefault(require_isISO31661Alpha2());
    exports2.IS_ISO31661_ALPHA_2 = "isISO31661Alpha2";
    function isISO31661Alpha2(value) {
      return typeof value === "string" && (0, isISO31661Alpha2_1.default)(value);
    }
    exports2.isISO31661Alpha2 = isISO31661Alpha2;
    function IsISO31661Alpha2(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISO31661_ALPHA_2,
        validator: {
          validate: (value, args) => isISO31661Alpha2(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid ISO31661 Alpha2 code", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISO31661Alpha2 = IsISO31661Alpha2;
  }
});

// asset-input/node_modules/validator/lib/isISO31661Alpha3.js
var require_isISO31661Alpha3 = __commonJS({
  "asset-input/node_modules/validator/lib/isISO31661Alpha3.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISO31661Alpha3;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO31661Alpha3CountriesCodes = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
    function isISO31661Alpha3(str) {
      (0, _assertString.default)(str);
      return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsISO31661Alpha3.js
var require_IsISO31661Alpha3 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsISO31661Alpha3.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISO31661Alpha3 = exports2.isISO31661Alpha3 = exports2.IS_ISO31661_ALPHA_3 = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISO31661Alpha3_1 = __importDefault(require_isISO31661Alpha3());
    exports2.IS_ISO31661_ALPHA_3 = "isISO31661Alpha3";
    function isISO31661Alpha3(value) {
      return typeof value === "string" && (0, isISO31661Alpha3_1.default)(value);
    }
    exports2.isISO31661Alpha3 = isISO31661Alpha3;
    function IsISO31661Alpha3(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISO31661_ALPHA_3,
        validator: {
          validate: (value, args) => isISO31661Alpha3(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid ISO31661 Alpha3 code", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISO31661Alpha3 = IsISO31661Alpha3;
  }
});

// asset-input/node_modules/validator/lib/isMongoId.js
var require_isMongoId = __commonJS({
  "asset-input/node_modules/validator/lib/isMongoId.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMongoId;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isMongoId(str) {
      (0, _assertString.default)(str);
      return (0, _isHexadecimal.default)(str) && str.length === 24;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsMongoId.js
var require_IsMongoId = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsMongoId.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsMongoId = exports2.isMongoId = exports2.IS_MONGO_ID = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isMongoId_1 = __importDefault(require_isMongoId());
    exports2.IS_MONGO_ID = "isMongoId";
    function isMongoId(value) {
      return typeof value === "string" && (0, isMongoId_1.default)(value);
    }
    exports2.isMongoId = isMongoId;
    function IsMongoId(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_MONGO_ID,
        validator: {
          validate: (value, args) => isMongoId(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a mongodb id", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsMongoId = IsMongoId;
  }
});

// asset-input/node_modules/validator/lib/isMultibyte.js
var require_isMultibyte = __commonJS({
  "asset-input/node_modules/validator/lib/isMultibyte.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMultibyte;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var multibyte = /[^\x00-\x7F]/;
    function isMultibyte(str) {
      (0, _assertString.default)(str);
      return multibyte.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsMultibyte.js
var require_IsMultibyte = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsMultibyte.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsMultibyte = exports2.isMultibyte = exports2.IS_MULTIBYTE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isMultibyte_1 = __importDefault(require_isMultibyte());
    exports2.IS_MULTIBYTE = "isMultibyte";
    function isMultibyte(value) {
      return typeof value === "string" && (0, isMultibyte_1.default)(value);
    }
    exports2.isMultibyte = isMultibyte;
    function IsMultibyte(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_MULTIBYTE,
        validator: {
          validate: (value, args) => isMultibyte(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain one or more multibyte chars", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsMultibyte = IsMultibyte;
  }
});

// asset-input/node_modules/validator/lib/isSurrogatePair.js
var require_isSurrogatePair = __commonJS({
  "asset-input/node_modules/validator/lib/isSurrogatePair.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isSurrogatePair;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    function isSurrogatePair(str) {
      (0, _assertString.default)(str);
      return surrogatePair.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsSurrogatePair.js
var require_IsSurrogatePair = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsSurrogatePair.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsSurrogatePair = exports2.isSurrogatePair = exports2.IS_SURROGATE_PAIR = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isSurrogatePair_1 = __importDefault(require_isSurrogatePair());
    exports2.IS_SURROGATE_PAIR = "isSurrogatePair";
    function isSurrogatePair(value) {
      return typeof value === "string" && (0, isSurrogatePair_1.default)(value);
    }
    exports2.isSurrogatePair = isSurrogatePair;
    function IsSurrogatePair(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_SURROGATE_PAIR,
        validator: {
          validate: (value, args) => isSurrogatePair(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain any surrogate pairs chars", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsSurrogatePair = IsSurrogatePair;
  }
});

// asset-input/node_modules/validator/lib/isURL.js
var require_isURL = __commonJS({
  "asset-input/node_modules/validator/lib/isURL.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isURL;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var default_url_options = {
      protocols: ["http", "https", "ftp"],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_port: false,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false,
      allow_fragments: true,
      allow_query_components: true,
      validate_length: true
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
    function isRegExp(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function checkHost(host, matches) {
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (host === match || isRegExp(match) && match.test(host)) {
          return true;
        }
      }
      return false;
    }
    function isURL(url, options) {
      (0, _assertString.default)(url);
      if (!url || /[\s<>]/.test(url)) {
        return false;
      }
      if (url.indexOf("mailto:") === 0) {
        return false;
      }
      options = (0, _merge.default)(options, default_url_options);
      if (options.validate_length && url.length >= 2083) {
        return false;
      }
      if (!options.allow_fragments && url.includes("#")) {
        return false;
      }
      if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
        return false;
      }
      var protocol, auth, host, hostname, port, port_str, split, ipv6;
      split = url.split("#");
      url = split.shift();
      split = url.split("?");
      url = split.shift();
      split = url.split("://");
      if (split.length > 1) {
        protocol = split.shift().toLowerCase();
        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
          return false;
        }
      } else if (options.require_protocol) {
        return false;
      } else if (url.slice(0, 2) === "//") {
        if (!options.allow_protocol_relative_urls) {
          return false;
        }
        split[0] = url.slice(2);
      }
      url = split.join("://");
      if (url === "") {
        return false;
      }
      split = url.split("/");
      url = split.shift();
      if (url === "" && !options.require_host) {
        return true;
      }
      split = url.split("@");
      if (split.length > 1) {
        if (options.disallow_auth) {
          return false;
        }
        if (split[0] === "") {
          return false;
        }
        auth = split.shift();
        if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
          return false;
        }
        var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
        if (user === "" && password === "") {
          return false;
        }
      }
      hostname = split.join("@");
      port_str = null;
      ipv6 = null;
      var ipv6_match = hostname.match(wrapped_ipv6);
      if (ipv6_match) {
        host = "";
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
      } else {
        split = hostname.split(":");
        host = split.shift();
        if (split.length) {
          port_str = split.join(":");
        }
      }
      if (port_str !== null && port_str.length > 0) {
        port = parseInt(port_str, 10);
        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
          return false;
        }
      } else if (options.require_port) {
        return false;
      }
      if (options.host_whitelist) {
        return checkHost(host, options.host_whitelist);
      }
      if (host === "" && !options.require_host) {
        return true;
      }
      if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
        return false;
      }
      host = host || ipv6;
      if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
      }
      return true;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsUrl.js
var require_IsUrl = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsUrl.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsUrl = exports2.isURL = exports2.IS_URL = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isURL_1 = __importDefault(require_isURL());
    exports2.IS_URL = "isUrl";
    function isURL(value, options) {
      return typeof value === "string" && (0, isURL_1.default)(value, options);
    }
    exports2.isURL = isURL;
    function IsUrl(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_URL,
        constraints: [options],
        validator: {
          validate: (value, args) => isURL(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a URL address", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsUrl = IsUrl;
  }
});

// asset-input/node_modules/validator/lib/isUUID.js
var require_isUUID = __commonJS({
  "asset-input/node_modules/validator/lib/isUUID.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isUUID;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var uuid = {
      1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };
    function isUUID(str, version) {
      (0, _assertString.default)(str);
      var pattern = uuid[![void 0, null].includes(version) ? version : "all"];
      return !!pattern && pattern.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsUUID.js
var require_IsUUID = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsUUID.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsUUID = exports2.isUUID = exports2.IS_UUID = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isUUID_1 = __importDefault(require_isUUID());
    exports2.IS_UUID = "isUuid";
    function isUUID(value, version) {
      return typeof value === "string" && (0, isUUID_1.default)(value, version);
    }
    exports2.isUUID = isUUID;
    function IsUUID(version, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_UUID,
        constraints: [version],
        validator: {
          validate: (value, args) => isUUID(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a UUID", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsUUID = IsUUID;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsFirebasePushId.js
var require_IsFirebasePushId = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsFirebasePushId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsFirebasePushId = exports2.isFirebasePushId = exports2.IS_FIREBASE_PUSH_ID = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_FIREBASE_PUSH_ID = "IsFirebasePushId";
    function isFirebasePushId(value) {
      const webSafeRegex = /^[a-zA-Z0-9_-]*$/;
      return typeof value === "string" && value.length === 20 && webSafeRegex.test(value);
    }
    exports2.isFirebasePushId = isFirebasePushId;
    function IsFirebasePushId(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_FIREBASE_PUSH_ID,
        validator: {
          validate: (value, args) => isFirebasePushId(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a Firebase Push Id", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsFirebasePushId = IsFirebasePushId;
  }
});

// asset-input/node_modules/validator/lib/isUppercase.js
var require_isUppercase = __commonJS({
  "asset-input/node_modules/validator/lib/isUppercase.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isUppercase;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isUppercase(str) {
      (0, _assertString.default)(str);
      return str === str.toUpperCase();
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsUppercase.js
var require_IsUppercase = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsUppercase.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsUppercase = exports2.isUppercase = exports2.IS_UPPERCASE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isUppercase_1 = __importDefault(require_isUppercase());
    exports2.IS_UPPERCASE = "isUppercase";
    function isUppercase(value) {
      return typeof value === "string" && (0, isUppercase_1.default)(value);
    }
    exports2.isUppercase = isUppercase;
    function IsUppercase(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_UPPERCASE,
        validator: {
          validate: (value, args) => isUppercase(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be uppercase", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsUppercase = IsUppercase;
  }
});

// asset-input/node_modules/validator/lib/isLength.js
var require_isLength = __commonJS({
  "asset-input/node_modules/validator/lib/isLength.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLength;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function isLength(str, options) {
      (0, _assertString.default)(str);
      var min;
      var max;
      if (_typeof(options) === "object") {
        min = options.min || 0;
        max = options.max;
      } else {
        min = arguments[1] || 0;
        max = arguments[2];
      }
      var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
      var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
      var len = str.length - presentationSequences.length - surrogatePairs.length;
      return len >= min && (typeof max === "undefined" || len <= max);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/Length.js
var require_Length = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/Length.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Length = exports2.length = exports2.IS_LENGTH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isLength_1 = __importDefault(require_isLength());
    exports2.IS_LENGTH = "isLength";
    function length(value, min, max) {
      return typeof value === "string" && (0, isLength_1.default)(value, { min, max });
    }
    exports2.length = length;
    function Length2(min, max, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_LENGTH,
        constraints: [min, max],
        validator: {
          validate: (value, args) => length(value, args === null || args === void 0 ? void 0 : args.constraints[0], args === null || args === void 0 ? void 0 : args.constraints[1]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix, args) => {
            const isMinLength = (args === null || args === void 0 ? void 0 : args.constraints[0]) !== null && (args === null || args === void 0 ? void 0 : args.constraints[0]) !== void 0;
            const isMaxLength = (args === null || args === void 0 ? void 0 : args.constraints[1]) !== null && (args === null || args === void 0 ? void 0 : args.constraints[1]) !== void 0;
            if (isMinLength && (!args.value || args.value.length < (args === null || args === void 0 ? void 0 : args.constraints[0]))) {
              return eachPrefix + "$property must be longer than or equal to $constraint1 characters";
            } else if (isMaxLength && args.value.length > (args === null || args === void 0 ? void 0 : args.constraints[1])) {
              return eachPrefix + "$property must be shorter than or equal to $constraint2 characters";
            }
            return eachPrefix + "$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters";
          }, validationOptions)
        }
      }, validationOptions);
    }
    exports2.Length = Length2;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/MaxLength.js
var require_MaxLength = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/MaxLength.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxLength = exports2.maxLength = exports2.MAX_LENGTH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isLength_1 = __importDefault(require_isLength());
    exports2.MAX_LENGTH = "maxLength";
    function maxLength(value, max) {
      return typeof value === "string" && (0, isLength_1.default)(value, { min: 0, max });
    }
    exports2.maxLength = maxLength;
    function MaxLength(max, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.MAX_LENGTH,
        constraints: [max],
        validator: {
          validate: (value, args) => maxLength(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be shorter than or equal to $constraint1 characters", validationOptions)
        }
      }, validationOptions);
    }
    exports2.MaxLength = MaxLength;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/MinLength.js
var require_MinLength = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/MinLength.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MinLength = exports2.minLength = exports2.MIN_LENGTH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isLength_1 = __importDefault(require_isLength());
    exports2.MIN_LENGTH = "minLength";
    function minLength(value, min) {
      return typeof value === "string" && (0, isLength_1.default)(value, { min });
    }
    exports2.minLength = minLength;
    function MinLength(min, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.MIN_LENGTH,
        constraints: [min],
        validator: {
          validate: (value, args) => minLength(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be longer than or equal to $constraint1 characters", validationOptions)
        }
      }, validationOptions);
    }
    exports2.MinLength = MinLength;
  }
});

// asset-input/node_modules/validator/lib/matches.js
var require_matches = __commonJS({
  "asset-input/node_modules/validator/lib/matches.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = matches;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function matches(str, pattern, modifiers) {
      (0, _assertString.default)(str);
      if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
        pattern = new RegExp(pattern, modifiers);
      }
      return !!str.match(pattern);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/Matches.js
var require_Matches = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/Matches.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Matches = exports2.matches = exports2.MATCHES = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var matches_1 = __importDefault(require_matches());
    exports2.MATCHES = "matches";
    function matches(value, pattern, modifiers) {
      return typeof value === "string" && (0, matches_1.default)(value, pattern, modifiers);
    }
    exports2.matches = matches;
    function Matches(pattern, modifiersOrAnnotationOptions, validationOptions) {
      let modifiers;
      if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {
        validationOptions = modifiersOrAnnotationOptions;
      } else {
        modifiers = modifiersOrAnnotationOptions;
      }
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.MATCHES,
        constraints: [pattern, modifiers],
        validator: {
          validate: (value, args) => matches(value, args === null || args === void 0 ? void 0 : args.constraints[0], args === null || args === void 0 ? void 0 : args.constraints[1]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix, args) => eachPrefix + "$property must match $constraint1 regular expression", validationOptions)
        }
      }, validationOptions);
    }
    exports2.Matches = Matches;
  }
});

// asset-input/node_modules/libphonenumber-js/metadata.max.json
var require_metadata_max = __commonJS({
  "asset-input/node_modules/libphonenumber-js/metadata.max.json"(exports2, module2) {
    module2.exports = { version: 4, country_calling_codes: { "1": ["US", "AG", "AI", "AS", "BB", "BM", "BS", "CA", "DM", "DO", "GD", "GU", "JM", "KN", "KY", "LC", "MP", "MS", "PR", "SX", "TC", "TT", "VC", "VG", "VI"], "7": ["RU", "KZ"], "20": ["EG"], "27": ["ZA"], "30": ["GR"], "31": ["NL"], "32": ["BE"], "33": ["FR"], "34": ["ES"], "36": ["HU"], "39": ["IT", "VA"], "40": ["RO"], "41": ["CH"], "43": ["AT"], "44": ["GB", "GG", "IM", "JE"], "45": ["DK"], "46": ["SE"], "47": ["NO", "SJ"], "48": ["PL"], "49": ["DE"], "51": ["PE"], "52": ["MX"], "53": ["CU"], "54": ["AR"], "55": ["BR"], "56": ["CL"], "57": ["CO"], "58": ["VE"], "60": ["MY"], "61": ["AU", "CC", "CX"], "62": ["ID"], "63": ["PH"], "64": ["NZ"], "65": ["SG"], "66": ["TH"], "81": ["JP"], "82": ["KR"], "84": ["VN"], "86": ["CN"], "90": ["TR"], "91": ["IN"], "92": ["PK"], "93": ["AF"], "94": ["LK"], "95": ["MM"], "98": ["IR"], "211": ["SS"], "212": ["MA", "EH"], "213": ["DZ"], "216": ["TN"], "218": ["LY"], "220": ["GM"], "221": ["SN"], "222": ["MR"], "223": ["ML"], "224": ["GN"], "225": ["CI"], "226": ["BF"], "227": ["NE"], "228": ["TG"], "229": ["BJ"], "230": ["MU"], "231": ["LR"], "232": ["SL"], "233": ["GH"], "234": ["NG"], "235": ["TD"], "236": ["CF"], "237": ["CM"], "238": ["CV"], "239": ["ST"], "240": ["GQ"], "241": ["GA"], "242": ["CG"], "243": ["CD"], "244": ["AO"], "245": ["GW"], "246": ["IO"], "247": ["AC"], "248": ["SC"], "249": ["SD"], "250": ["RW"], "251": ["ET"], "252": ["SO"], "253": ["DJ"], "254": ["KE"], "255": ["TZ"], "256": ["UG"], "257": ["BI"], "258": ["MZ"], "260": ["ZM"], "261": ["MG"], "262": ["RE", "YT"], "263": ["ZW"], "264": ["NA"], "265": ["MW"], "266": ["LS"], "267": ["BW"], "268": ["SZ"], "269": ["KM"], "290": ["SH", "TA"], "291": ["ER"], "297": ["AW"], "298": ["FO"], "299": ["GL"], "350": ["GI"], "351": ["PT"], "352": ["LU"], "353": ["IE"], "354": ["IS"], "355": ["AL"], "356": ["MT"], "357": ["CY"], "358": ["FI", "AX"], "359": ["BG"], "370": ["LT"], "371": ["LV"], "372": ["EE"], "373": ["MD"], "374": ["AM"], "375": ["BY"], "376": ["AD"], "377": ["MC"], "378": ["SM"], "380": ["UA"], "381": ["RS"], "382": ["ME"], "383": ["XK"], "385": ["HR"], "386": ["SI"], "387": ["BA"], "389": ["MK"], "420": ["CZ"], "421": ["SK"], "423": ["LI"], "500": ["FK"], "501": ["BZ"], "502": ["GT"], "503": ["SV"], "504": ["HN"], "505": ["NI"], "506": ["CR"], "507": ["PA"], "508": ["PM"], "509": ["HT"], "590": ["GP", "BL", "MF"], "591": ["BO"], "592": ["GY"], "593": ["EC"], "594": ["GF"], "595": ["PY"], "596": ["MQ"], "597": ["SR"], "598": ["UY"], "599": ["CW", "BQ"], "670": ["TL"], "672": ["NF"], "673": ["BN"], "674": ["NR"], "675": ["PG"], "676": ["TO"], "677": ["SB"], "678": ["VU"], "679": ["FJ"], "680": ["PW"], "681": ["WF"], "682": ["CK"], "683": ["NU"], "685": ["WS"], "686": ["KI"], "687": ["NC"], "688": ["TV"], "689": ["PF"], "690": ["TK"], "691": ["FM"], "692": ["MH"], "850": ["KP"], "852": ["HK"], "853": ["MO"], "855": ["KH"], "856": ["LA"], "880": ["BD"], "886": ["TW"], "960": ["MV"], "961": ["LB"], "962": ["JO"], "963": ["SY"], "964": ["IQ"], "965": ["KW"], "966": ["SA"], "967": ["YE"], "968": ["OM"], "970": ["PS"], "971": ["AE"], "972": ["IL"], "973": ["BH"], "974": ["QA"], "975": ["BT"], "976": ["MN"], "977": ["NP"], "992": ["TJ"], "993": ["TM"], "994": ["AZ"], "995": ["GE"], "996": ["KG"], "998": ["UZ"] }, countries: { AC: ["247", "00", "(?:[01589]\\d|[46])\\d{4}", [5, 6], 0, 0, 0, 0, 0, 0, 0, [["6[2-467]\\d{3}", [5]], ["4\\d{4}", [5]], 0, 0, 0, 0, ["(?:0[1-9]|[1589]\\d)\\d{4}", [6]]]], AD: ["376", "00", "(?:1|6\\d)\\d{7}|[135-9]\\d{5}", [6, 8, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["[135-9]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["1"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]], 0, 0, 0, 0, 0, 0, [["[78]\\d{5}", [6]], ["690\\d{6}|[356]\\d{5}", [6, 9]], ["180[02]\\d{4}", [8]], ["[19]\\d{5}", [6]]]], AE: ["971", "00", "(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{2,9})", "$1 $2", ["60|8"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[236]|[479][2-8]"], "0$1"], ["(\\d{3})(\\d)(\\d{5})", "$1 $2 $3", ["[479]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"]], "0", 0, 0, 0, 0, 0, [["[2-4679][2-8]\\d{6}", [8]], ["5[024-68]\\d{7}", [9]], ["400\\d{6}|800\\d{2,9}"], ["900[02]\\d{5}", [9]], 0, 0, ["600[25]\\d{5}", [9]], 0, 0, ["700[05]\\d{5}", [9]]]], AF: ["93", "00", "[2-7]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:[25][0-8]|[34][0-4]|6[0-5])[2-9]\\d{6}"], ["7\\d{8}"]]], AG: ["1", "011", "(?:268|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([457]\\d{6})$|1", "268$1", 0, "268", [["268(?:4(?:6[0-38]|84)|56[0-2])\\d{4}"], ["268(?:464|7(?:1[3-9]|[28]\\d|3[0246]|64|7[0-689]))\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, ["26840[69]\\d{4}"], ["26848[01]\\d{4}"]]], AI: ["1", "011", "(?:264|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2457]\\d{6})$|1", "264$1", 0, "264", [["264(?:292|4(?:6[12]|9[78]))\\d{4}"], ["264(?:235|4(?:69|76)|5(?:3[6-9]|8[1-4])|7(?:29|72))\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, ["264724\\d{4}"]]], AL: ["355", "00", "(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}", [6, 7, 8, 9], [["(\\d{3})(\\d{3,4})", "$1 $2", ["80|9"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["4[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2358][2-5]|4"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["[23578]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["6"], "0$1"]], "0", 0, 0, 0, 0, 0, [["4505[0-2]\\d{3}|(?:[2358][16-9]\\d[2-9]|4410)\\d{4}|(?:[2358][2-5][2-9]|4(?:[2-57-9][2-9]|6\\d))\\d{5}", [8]], ["6(?:[78][2-9]|9\\d)\\d{6}", [9]], ["800\\d{4}", [7]], ["900[1-9]\\d\\d", [6]], ["700[2-9]\\d{4}", [8]], 0, 0, 0, 0, ["808[1-9]\\d\\d", [6]]]], AM: ["374", "00", "(?:[1-489]\\d|55|60|77)\\d{6}", [8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[89]0"], "0 $1"], ["(\\d{3})(\\d{5})", "$1 $2", ["2|3[12]"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["1|47"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[3-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:(?:1[0-25]|47)\\d|2(?:2[2-46]|3[1-8]|4[2-69]|5[2-7]|6[1-9]|8[1-7])|3[12]2)\\d{5}"], ["(?:33|4[1349]|55|77|88|9[13-9])\\d{6}"], ["800\\d{5}"], ["90[016]\\d{5}"], 0, 0, 0, 0, ["60(?:2[78]|3[5-9]|4[02-9]|5[0-46-9]|[6-8]\\d|9[0-2])\\d{4}"], ["80[1-4]\\d{5}"]]], AO: ["244", "00", "[29]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[29]"]]], 0, 0, 0, 0, 0, 0, [["2\\d(?:[0134][25-9]|[25-9]\\d)\\d{5}"], ["9[1-579]\\d{7}"]]], AR: ["54", "00", "(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}", [10, 11], [["(\\d{4})(\\d{2})(\\d{4})", "$1 $2-$3", ["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])", "2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["1"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[68]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2-$3", ["[23]"], "0$1", 1], ["(\\d)(\\d{4})(\\d{2})(\\d{4})", "$2 15-$3-$4", ["9(?:2[2-469]|3[3-578])", "9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))", "9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d)(\\d{2})(\\d{4})(\\d{4})", "$2 15-$3-$4", ["91"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d{3})(\\d{3})(\\d{5})", "$1-$2-$3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{4})", "$2 15-$3-$4", ["9"], "0$1", 0, "$1 $2 $3-$4"]], "0", 0, "0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?", "9$1", 0, 0, [["3(?:7(?:1[15]|81)|8(?:21|4[16]|69|9[12]))[46]\\d{5}|(?:2(?:657|9(?:54|66))|3(?:7(?:55|77)|865))[2-8]\\d{5}|(?:2(?:2(?:2[59]|44|52)|3(?:26|44)|473|9(?:[07]2|2[26]|34|46))|3327)[45]\\d{5}|(?:2(?:284|3(?:02|23)|920)|3(?:4(?:46|8[27]|92)|541|878))[2-7]\\d{5}|(?:2(?:(?:26|62)2|320|477|9(?:42|83))|3(?:329|4(?:62|76|89)|564))[2-6]\\d{5}|(?:(?:11[1-8]|670)\\d|2(?:2(?:0[45]|1[2-6]|3[3-6])|3(?:[06]4|7[45])|494|6(?:04|1[2-8]|[36][45]|4[3-6])|80[45]|9(?:[17][4-6]|[48][45]|9[3-6]))|3(?:364|4(?:1[2-8]|[235][4-6]|84)|5(?:1[2-9]|[38][4-6])|6(?:2[45]|44)|7[069][45]|8(?:0[45]|[17][2-6]|3[4-6]|5[3-6]|8[3-68])))\\d{6}|2(?:2(?:21|4[23]|6[145]|7[1-4]|8[356]|9[267])|3(?:16|3[13-8]|43|5[346-8]|9[3-5])|475|6(?:2[46]|4[78]|5[1568])|9(?:03|2[1457-9]|3[1356]|4[08]|[56][23]|82))4\\d{5}|(?:2(?:2(?:57|81)|3(?:24|46|92)|9(?:01|23|64))|3(?:4(?:42|71)|5(?:25|37|4[347]|71)|7(?:18|5[17])))[3-6]\\d{5}|(?:2(?:2(?:02|2[3467]|4[156]|5[45]|6[6-8]|91)|3(?:1[47]|25|[45][25]|96)|47[48]|625|932)|3(?:38[2578]|4(?:0[0-24-9]|3[78]|4[457]|58|6[03-9]|72|83|9[136-8])|5(?:2[124]|[368][23]|4[2689]|7[2-6])|7(?:16|2[15]|3[145]|4[13]|5[468]|7[2-5]|8[26])|8(?:2[5-7]|3[278]|4[3-5]|5[78]|6[1-378]|[78]7|94)))[4-6]\\d{5}", [10]], ["93(?:7(?:1[15]|81)|8(?:21|4[16]|69|9[12]))[46]\\d{5}|9(?:2(?:657|9(?:54|66))|3(?:7(?:55|77)|865))[2-8]\\d{5}|9(?:2(?:2(?:2[59]|44|52)|3(?:26|44)|473|9(?:[07]2|2[26]|34|46))|3327)[45]\\d{5}|9(?:2(?:284|3(?:02|23)|920)|3(?:4(?:46|8[27]|92)|541|878))[2-7]\\d{5}|9(?:2(?:(?:26|62)2|320|477|9(?:42|83))|3(?:329|4(?:62|76|89)|564))[2-6]\\d{5}|(?:675\\d|9(?:11[1-8]\\d|2(?:2(?:0[45]|1[2-6]|3[3-6])|3(?:[06]4|7[45])|494|6(?:04|1[2-8]|[36][45]|4[3-6])|80[45]|9(?:[17][4-6]|[48][45]|9[3-6]))|3(?:364|4(?:1[2-8]|[235][4-6]|84)|5(?:1[2-9]|[38][4-6])|6(?:2[45]|44)|7[069][45]|8(?:0[45]|[17][2-6]|3[4-6]|5[3-6]|8[3-68]))))\\d{6}|92(?:2(?:21|4[23]|6[145]|7[1-4]|8[356]|9[267])|3(?:16|3[13-8]|43|5[346-8]|9[3-5])|475|6(?:2[46]|4[78]|5[1568])|9(?:03|2[1457-9]|3[1356]|4[08]|[56][23]|82))4\\d{5}|9(?:2(?:2(?:57|81)|3(?:24|46|92)|9(?:01|23|64))|3(?:4(?:42|71)|5(?:25|37|4[347]|71)|7(?:18|5[17])))[3-6]\\d{5}|9(?:2(?:2(?:02|2[3467]|4[156]|5[45]|6[6-8]|91)|3(?:1[47]|25|[45][25]|96)|47[48]|625|932)|3(?:38[2578]|4(?:0[0-24-9]|3[78]|4[457]|58|6[03-9]|72|83|9[136-8])|5(?:2[124]|[368][23]|4[2689]|7[2-6])|7(?:16|2[15]|3[145]|4[13]|5[468]|7[2-5]|8[26])|8(?:2[5-7]|3[278]|4[3-5]|5[78]|6[1-378]|[78]7|94)))[4-6]\\d{5}"], ["800\\d{7,8}"], ["60[04579]\\d{7}", [10]], 0, 0, ["810\\d{7}", [10]]]], AS: ["1", "011", "(?:[58]\\d\\d|684|900)\\d{7}", [10], 0, "1", 0, "([267]\\d{6})$|1", "684$1", 0, "684", [["6846(?:22|33|44|55|77|88|9[19])\\d{4}"], ["684(?:2(?:48|5[2468]|7[26])|7(?:3[13]|70|82))\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], AT: ["43", "00", "1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{3,12})", "$1 $2", ["1(?:11|[2-9])"], "0$1"], ["(\\d{3})(\\d{2})", "$1 $2", ["517"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["5[079]"], "0$1"], ["(\\d{3})(\\d{3,10})", "$1 $2", ["(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]"], "0$1"], ["(\\d{4})(\\d{3,9})", "$1 $2", ["[2-467]|5[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,7})", "$1 $2 $3", ["5"], "0$1"]], "0", 0, 0, 0, 0, 0, [["1(?:11\\d|[2-9]\\d{3,11})|(?:316|463|(?:51|66|73)2)\\d{3,10}|(?:2(?:1[467]|2[13-8]|5[2357]|6[1-46-8]|7[1-8]|8[124-7]|9[1458])|3(?:1[1-578]|3[23568]|4[5-7]|5[1378]|6[1-38]|8[3-68])|4(?:2[1-8]|35|7[1368]|8[2457])|5(?:2[1-8]|3[357]|4[147]|5[12578]|6[37])|6(?:13|2[1-47]|4[135-8]|5[468])|7(?:2[1-8]|35|4[13478]|5[68]|6[16-8]|7[1-6]|9[45]))\\d{4,10}"], ["6(?:5[0-3579]|6[013-9]|[7-9]\\d)\\d{4,10}", [7, 8, 9, 10, 11, 12, 13]], ["800\\d{6,10}", [9, 10, 11, 12, 13]], ["(?:8[69][2-68]|9(?:0[01]|3[019]))\\d{6,10}", [9, 10, 11, 12, 13]], 0, 0, 0, 0, ["5(?:0[1-9]|17|[79]\\d)\\d{2,10}|7[28]0\\d{6,10}", [5, 6, 7, 8, 9, 10, 11, 12, 13]], ["8(?:10|2[018])\\d{6,10}|828\\d{5}", [8, 9, 10, 11, 12, 13]]]], AU: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}", [5, 6, 7, 8, 9, 10, 12], [["(\\d{2})(\\d{3,4})", "$1 $2", ["16"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["16"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["14|4"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[2378]"], "(0$1)"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:30|[89])"]]], "0", 0, "(183[12])|0", 0, 0, 0, [["(?:(?:(?:2(?:[0-26-9]\\d|3[0-8]|4[02-9]|5[0135-9])|7(?:[013-57-9]\\d|2[0-8]))\\d|3(?:(?:[0-3589]\\d|6[1-9]|7[0-35-9])\\d|4(?:[0-578]\\d|90)))\\d\\d|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4])|3\\d\\d)|(?:6[0-8]|[78]\\d)\\d{3}|9(?:[02-9]\\d{3}|1(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79])))))\\d{3}", [9]], ["4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, ["163\\d{2,6}", [5, 6, 7, 8, 9]], ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], AW: ["297", "00", "(?:[25-79]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[25-9]"]]], 0, 0, 0, 0, 0, 0, [["5(?:2\\d|8[1-9])\\d{4}"], ["(?:290|5[69]\\d|6(?:[03]0|22|4[0-2]|[69]\\d)|7(?:[34]\\d|7[07])|9(?:6[45]|9[4-8]))\\d{4}"], ["800\\d{4}"], ["900\\d{4}"], 0, 0, 0, 0, ["(?:28\\d|501)\\d{4}"]]], AX: ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}", [5, 6, 7, 8, 9, 10, 11, 12], 0, "0", 0, 0, 0, 0, "18", [["18[1-8]\\d{3,6}", [6, 7, 8, 9]], ["4946\\d{2,6}|(?:4[0-8]|50)\\d{4,8}", [6, 7, 8, 9, 10]], ["800\\d{4,6}", [7, 8, 9]], ["[67]00\\d{5,6}", [8, 9]], 0, 0, ["20\\d{4,8}|60[12]\\d{5,6}|7(?:099\\d{4,5}|5[03-9]\\d{3,7})|20[2-59]\\d\\d|(?:606|7(?:0[78]|1|3\\d))\\d{7}|(?:10|29|3[09]|70[1-5]\\d)\\d{4,8}"]], "00"], AZ: ["994", "00", "365\\d{6}|(?:[124579]\\d|60|88)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[28]|2|365|46", "1[28]|2|365[45]|46", "1[28]|2|365(?:4|5[02])|46"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[13-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2[12]428|3655[02])\\d{4}|(?:2(?:22[0-79]|63[0-28])|3654)\\d{5}|(?:(?:1[28]|46)\\d|2(?:[014-6]2|[23]3))\\d{6}"], ["36554\\d{4}|(?:[16]0|4[04]|5[015]|7[07]|99)\\d{7}"], ["88\\d{7}"], ["900200\\d{3}"]]], BA: ["387", "00", "6\\d{8}|(?:[35689]\\d|49|70)\\d{6}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[1-3]|[7-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2-$3", ["[3-5]|6[56]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["6"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:3(?:[05-79][2-9]|1[4579]|[23][24-9]|4[2-4689]|8[2457-9])|49[2-579]|5(?:0[2-49]|[13][2-9]|[268][2-4679]|4[4689]|5[2-79]|7[2-69]|9[2-4689]))\\d{5}", [8]], ["6040\\d{5}|6(?:03|[1-356]|44|7\\d)\\d{6}"], ["8[08]\\d{6}", [8]], ["9[0246]\\d{6}", [8]], 0, 0, ["703[235]0\\d{3}|70(?:2[0-5]|3[0146]|[56]0)\\d{4}", [8]], 0, 0, ["8[12]\\d{6}", [8]]]], BB: ["1", "011", "(?:246|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "246$1", 0, "246", [["246521[0369]\\d{3}|246(?:2(?:2[78]|7[0-4])|4(?:1[024-6]|2\\d|3[2-9])|5(?:20|[34]\\d|54|7[1-3])|6(?:2\\d|38)|7[35]7|9(?:1[89]|63))\\d{4}"], ["246(?:(?:2(?:[3568]\\d|4[0-57-9])|3(?:5[2-9]|6[0-6])|4(?:46|5\\d)|69[5-7]|8(?:[2-5]\\d|83))\\d|52(?:1[147]|20))\\d{3}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["(?:246976|900[2-9]\\d\\d)\\d{4}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, ["246(?:292|367|4(?:1[7-9]|3[01]|4[47-9]|67)|7(?:1[2-9]|2\\d|3[016]|53))\\d{4}"], 0, ["24631\\d{5}"]]], BD: ["880", "00", "[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{2})(\\d{4,6})", "$1-$2", ["31[5-8]|[459]1"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1-$2", ["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:[15]|28|4[14])|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"], "0$1"], ["(\\d{4})(\\d{3,6})", "$1-$2", ["[13-9]|22"], "0$1"], ["(\\d)(\\d{7,8})", "$1-$2", ["2"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:4(?:31\\d\\d|423)|5222)\\d{3}(?:\\d{2})?|8332[6-9]\\d\\d|(?:3(?:03[56]|224)|4(?:22[25]|653))\\d{3,4}|(?:3(?:42[47]|529|823)|4(?:027|525|65(?:28|8))|562|6257|7(?:1(?:5[3-5]|6[12]|7[156]|89)|22[589]56|32|42675|52(?:[25689](?:56|8)|[347]8)|71(?:6[1267]|75|89)|92374)|82(?:2[59]|32)56|9(?:03[23]56|23(?:256|373)|31|5(?:1|2[4589]56)))\\d{3}|(?:3(?:02[348]|22[35]|324|422)|4(?:22[67]|32[236-9]|6(?:2[46]|5[57])|953)|5526|6(?:024|6655)|81)\\d{4,5}|(?:2(?:7(?:1[0-267]|2[0-289]|3[0-29]|4[01]|5[1-3]|6[013]|7[0178]|91)|8(?:0[125]|1[1-6]|2[0157-9]|3[1-69]|41|6[1-35]|7[1-5]|8[1-8]|9[0-6])|9(?:0[0-2]|1[0-4]|2[568]|3[3-6]|5[5-7]|6[0136-9]|7[0-7]|8[014-9]))|3(?:0(?:2[025-79]|3[2-4])|181|22[12]|32[2356]|824)|4(?:02[09]|22[348]|32[045]|523|6(?:27|54))|666(?:22|53)|7(?:22[57-9]|42[56]|82[35])8|8(?:0[124-9]|2(?:181|2[02-4679]8)|4[12]|[5-7]2)|9(?:[04]2|2(?:2|328)|81))\\d{4}|(?:2(?:2\\d|[45])\\d\\d|3(?:1(?:2[5-7]|[5-7])|425|822)|4(?:033|1\\d|[257]1|332|4(?:2[246]|5[25])|6(?:2[35]|56|62)|8(?:23|54)|92[2-5])|5(?:02[03489]|22[457]|32[35-79]|42[46]|6(?:[18]|53)|724|826)|6(?:023|2(?:2[2-5]|5[3-5]|8)|32[3478]|42[34]|52[47]|6(?:[18]|6(?:2[34]|5[24]))|[78]2[2-5]|92[2-6])|7(?:02|21\\d|[3-589]1|6[12]|72[24])|8(?:217|3[12]|[5-7]1)|9[24]1)\\d{5}|(?:(?:3[2-8]|5[2-57-9]|6[03-589])1|4[4689][18])\\d{5}|[59]1\\d{5}"], ["(?:1[13-9]\\d|644)\\d{7}|(?:3[78]|44|66)[02-9]\\d{7}", [10]], ["80[03]\\d{7}", [10]], 0, 0, 0, 0, 0, ["96(?:0[469]|1[0-47]|3[389]|43|6[69]|7[78])\\d{6}", [10]]]], BE: ["32", "00", "4\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:80|9)0"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[239]|4[23]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[15-8]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4"], "0$1"]], "0", 0, 0, 0, 0, 0, [["80[2-8]\\d{5}|(?:1[0-69]|[23][2-8]|4[23]|5\\d|6[013-57-9]|71|8[1-79]|9[2-4])\\d{6}", [8]], ["4[5-9]\\d{7}", [9]], ["800[1-9]\\d{4}", [8]], ["(?:70(?:2[0-57]|3[04-7]|44|6[4-69]|7[0579])|90\\d\\d)\\d{4}", [8]], 0, 0, ["78(?:0[57]|1[014-8]|2[25]|3[15-8]|48|[56]0|7[06-8]|9\\d)\\d{4}", [8]], 0, 0, ["7879\\d{4}", [8]]]], BF: ["226", "00", "[025-7]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[025-7]"]]], 0, 0, 0, 0, 0, 0, [["2(?:0(?:49|5[23]|6[5-7]|9[016-9])|4(?:4[569]|5[4-6]|6[5-7]|7[0179])|5(?:[34]\\d|50|6[5-7]))\\d{4}"], ["(?:0[1-35-7]|5[0-8]|[67]\\d)\\d{6}"]]], BG: ["359", "00", "00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}", [6, 7, 8, 9, 12], [["(\\d)(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["43[1-6]|70[1-9]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:70|8)0"], "0$1"], ["(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3", ["43[1-7]|7"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[48]|9[08]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"]], "0", 0, 0, 0, 0, 0, [["2\\d{5,7}|(?:43[1-6]|70[1-9])\\d{4,5}|(?:[36]\\d|4[124-7]|[57][1-9]|8[1-6]|9[1-7])\\d{5,6}", [6, 7, 8]], ["(?:43[07-9]|99[69]\\d)\\d{5}|(?:8[7-9]|98)\\d{7}", [8, 9]], ["(?:00800\\d\\d|800)\\d{5}", [8, 12]], ["90\\d{6}", [8]], 0, 0, 0, 0, 0, ["700\\d{5}", [8]]]], BH: ["973", "00", "[136-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[13679]|8[02-4679]"]]], 0, 0, 0, 0, 0, 0, [["(?:1(?:3[1356]|6[0156]|7\\d)\\d|6(?:1[16]\\d|500|6(?:0\\d|3[12]|44|55|7[7-9]|88)|9[69][69])|7(?:[07]\\d\\d|1(?:11|78)))\\d{4}"], ["(?:3(?:[0-79]\\d|8[0-57-9])\\d|6(?:3(?:00|33|6[16])|441|6(?:3[03-9]|[69]\\d|7[0-689])))\\d{4}"], ["8[02369]\\d{6}"], ["(?:87|9[0-8])\\d{6}"], 0, 0, 0, 0, 0, ["84\\d{6}"]]], BI: ["257", "00", "(?:[267]\\d|31)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2367]"]]], 0, 0, 0, 0, 0, 0, [["(?:22|31)\\d{6}"], ["(?:29|[67][125-9])\\d{6}"]]], BJ: ["229", "00", "[24-689]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-689]"]]], 0, 0, 0, 0, 0, 0, [["2(?:02|1[037]|2[45]|3[68]|4\\d)\\d{5}"], ["(?:4[0-7]|[56]\\d|9[013-9])\\d{6}"], 0, 0, 0, 0, ["81\\d{6}"], 0, ["857[58]\\d{4}"]]], BL: ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:2[7-9]|3[3-7]|5[12]|87)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-5])\\d{4}"]]], BM: ["1", "011", "(?:441|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "441$1", 0, "441", [["441(?:[46]\\d\\d|5(?:4\\d|60|89))\\d{4}"], ["441(?:[2378]\\d|5[0-39]|9[02])\\d{5}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], BN: ["673", "00", "[2-578]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-578]"]]], 0, 0, 0, 0, 0, 0, [["22[0-7]\\d{4}|(?:2[013-9]|[34]\\d|5[0-25-9])\\d{5}"], ["(?:22[89]|[78]\\d\\d)\\d{4}"], 0, 0, 0, 0, 0, 0, ["5[34]\\d{5}"]]], BO: ["591", "00(?:1\\d)?", "8001\\d{5}|(?:[2-467]\\d|50)\\d{6}", [8, 9], [["(\\d)(\\d{7})", "$1 $2", ["[235]|4[46]"]], ["(\\d{8})", "$1", ["[67]"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["8"]]], "0", 0, "0(1\\d)?", 0, 0, 0, [["(?:2(?:2\\d\\d|5(?:11|[258]\\d|9[67])|6(?:12|2\\d|9[34])|8(?:2[34]|39|62))|3(?:3\\d\\d|4(?:6\\d|8[24])|8(?:25|42|5[257]|86|9[25])|9(?:[27]\\d|3[2-4]|4[248]|5[24]|6[2-6]))|4(?:4\\d\\d|6(?:11|[24689]\\d|72)))\\d{4}", [8]], ["[67]\\d{7}", [8]], ["8001[07]\\d{4}", [9]], 0, 0, 0, 0, 0, ["50\\d{6}", [8]]]], BQ: ["599", "00", "(?:[34]1|7\\d)\\d{5}", [7], 0, 0, 0, 0, 0, 0, "[347]", [["(?:318[023]|41(?:6[023]|70)|7(?:1[578]|2[05]|50)\\d)\\d{3}"], ["(?:31(?:8[14-8]|9[14578])|416[14-9]|7(?:0[01]|7[07]|8\\d|9[056])\\d)\\d{3}"]]], BR: ["55", "00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)", "(?:[1-46-9]\\d\\d|5(?:[0-46-9]\\d|5[0-46-9]))\\d{8}|[1-9]\\d{9}|[3589]\\d{8}|[34]\\d{7}", [8, 9, 10, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["300|4(?:0[02]|37)", "4(?:02|37)0|[34]00"]], ["(\\d{3})(\\d{2,3})(\\d{4})", "$1 $2 $3", ["(?:[358]|90)0"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"], "($1)"], ["(\\d{2})(\\d{5})(\\d{4})", "$1 $2-$3", ["[16][1-9]|[2-57-9]"], "($1)"]], "0", 0, "(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?", "$2", 0, 0, [["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-5]\\d{7}", [10]], ["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])(?:7|9\\d)\\d{7}", [10, 11]], ["800\\d{6,7}", [9, 10]], ["300\\d{6}|[59]00\\d{6,7}", [9, 10]], 0, 0, 0, 0, 0, ["(?:30[03]\\d{3}|4(?:0(?:0\\d|20)|370))\\d{4}|300\\d{5}", [8, 10]]]], BS: ["1", "011", "(?:242|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([3-8]\\d{6})$|1", "242$1", 0, "242", [["242(?:3(?:02|[236][1-9]|4[0-24-9]|5[0-68]|7[347]|8[0-4]|9[2-467])|461|502|6(?:0[1-5]|12|2[013]|[45]0|7[67]|8[78]|9[89])|7(?:02|88))\\d{4}"], ["242(?:3(?:5[79]|7[56]|95)|4(?:[23][1-9]|4[1-35-9]|5[1-8]|6[2-8]|7\\d|81)|5(?:2[45]|3[35]|44|5[1-46-9]|65|77)|6[34]6|7(?:27|38)|8(?:0[1-9]|1[02-9]|2\\d|3[0-4]|[89]9))\\d{4}"], ["242300\\d{4}|8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, ["242225\\d{4}"]]], BT: ["975", "00", "[17]\\d{7}|[2-8]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-68]|7[246]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[67]|7"]]], 0, 0, 0, 0, 0, 0, [["(?:2[3-6]|[34][5-7]|5[236]|6[2-46]|7[246]|8[2-4])\\d{5}", [7]], ["(?:1[67]|77)\\d{6}", [8]]]], BW: ["267", "00", "(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["90"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[24-6]|3[15-9]"]], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37]"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["8"]]], 0, 0, 0, 0, 0, 0, [["(?:2(?:4[0-48]|6[0-24]|9[0578])|3(?:1[0-35-9]|55|[69]\\d|7[013]|81)|4(?:6[03]|7[1267]|9[0-5])|5(?:3[03489]|4[0489]|7[1-47]|88|9[0-49])|6(?:2[1-35]|5[149]|8[013467]))\\d{4}", [7]], ["(?:321|7[1-8]\\d)\\d{5}", [8]], ["(?:0800|800\\d)\\d{6}", [10]], ["90\\d{5}", [7]], 0, 0, 0, 0, ["79(?:1(?:[0-2]\\d|3[0-3])|2[0-7]\\d)\\d{3}", [8]]]], BY: ["375", "810", "(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3})", "$1 $2", ["800"], "8 $1"], ["(\\d{3})(\\d{2})(\\d{2,4})", "$1 $2 $3", ["800"], "8 $1"], ["(\\d{4})(\\d{2})(\\d{3})", "$1 $2-$3", ["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])", "1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"], "8 0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["1(?:[56]|7[467])|2[1-3]"], "8 0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-4]"], "8 0$1"], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[89]"], "8 $1"]], "8", 0, "0|80?", 0, 0, 0, [["(?:1(?:5(?:1[1-5]|[24]\\d|6[2-4]|9[1-7])|6(?:[235]\\d|4[1-7])|7\\d\\d)|2(?:1(?:[246]\\d|3[0-35-9]|5[1-9])|2(?:[235]\\d|4[0-8])|3(?:[26]\\d|3[02-79]|4[024-7]|5[03-7])))\\d{5}", [9]], ["(?:2(?:5[5-79]|9[1-9])|(?:33|44)\\d)\\d{6}", [9]], ["800\\d{3,7}|8(?:0[13]|20\\d)\\d{7}"], ["(?:810|902)\\d{7}", [10]], 0, 0, 0, 0, ["249\\d{6}", [9]]], "8~10"], BZ: ["501", "00", "(?:0800\\d|[2-8])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-8]"]], ["(\\d)(\\d{3})(\\d{4})(\\d{3})", "$1-$2-$3-$4", ["0"]]], 0, 0, 0, 0, 0, 0, [["(?:2(?:[02]\\d|36|[68]0)|[3-58](?:[02]\\d|[68]0)|7(?:[02]\\d|32|[68]0))\\d{4}", [7]], ["6[0-35-7]\\d{5}", [7]], ["0800\\d{7}", [11]]]], CA: ["1", "011", "(?:[2-8]\\d|90)\\d{8}|3\\d{6}", [7, 10], 0, "1", 0, 0, 0, 0, 0, [["(?:2(?:04|[23]6|[48]9|50|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|7[39])|90[25])[2-9]\\d{6}", [10]], ["", [10]], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}", [10]], ["900[2-9]\\d{6}", [10]], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:00|2[125-9]|33|44|66|77|88)|622)[2-9]\\d{6}", [10]], 0, ["310\\d{4}", [7]], 0, ["600[2-9]\\d{6}", [10]]]], CC: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}", [9]], ["4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], CD: ["243", "00", "[189]\\d{8}|[1-68]\\d{6}", [7, 9], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[1-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["12\\d{7}|[1-6]\\d{6}"], ["88\\d{5}|(?:8[0-69]|9[017-9])\\d{7}"]]], CF: ["236", "00", "(?:[27]\\d{3}|8776)\\d{4}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[278]"]]], 0, 0, 0, 0, 0, 0, [["2[12]\\d{6}"], ["7[024-7]\\d{6}"], 0, ["8776\\d{4}"]]], CG: ["242", "00", "222\\d{6}|(?:0\\d|80)\\d{7}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[02]"]]], 0, 0, 0, 0, 0, 0, [["222[1-589]\\d{5}"], ["026(?:1[0-5]|6[6-9])\\d{4}|0(?:[14-6]\\d\\d|2(?:40|5[5-8]|6[07-9]))\\d{5}"], 0, ["80[0-2]\\d{6}"]]], CH: ["41", "00", "8\\d{11}|[2-9]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8[047]|90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]|81"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2[12467]|3[1-4]|4[134]|5[256]|6[12]|[7-9]1)\\d{7}"], ["(?:6[89]|7[235-9])\\d{7}"], ["800\\d{6}"], ["90[016]\\d{6}"], ["878\\d{6}"], 0, ["5[18]\\d{7}"], ["74[0248]\\d{6}"], 0, ["84[0248]\\d{6}"]]], CI: ["225", "00", "[02]\\d{9}", [10], [["(\\d{2})(\\d{2})(\\d)(\\d{5})", "$1 $2 $3 $4", ["2"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3 $4", ["0"]]], 0, 0, 0, 0, 0, 0, [["2(?:[15]\\d{3}|7(?:2(?:0[23]|1[2357]|2[245]|3[45]|4[3-5])|3(?:06|1[69]|[2-6]7)))\\d{5}"], ["0[157]\\d{8}"]]], CK: ["682", "00", "[2-578]\\d{4}", [5], [["(\\d{2})(\\d{3})", "$1 $2", ["[2-578]"]]], 0, 0, 0, 0, 0, 0, [["(?:2\\d|3[13-7]|4[1-5])\\d{3}"], ["[578]\\d{4}"]]], CL: ["56", "(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0", "12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}", [9, 10, 11], [["(\\d{5})(\\d{4})", "$1 $2", ["219", "2196"], "($1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["44"]], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2[1-36]"], "($1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["9[2-9]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"], "($1)"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["60|8"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{3})(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["60"]]], 0, 0, 0, 0, 0, 0, [["2(?:1982[0-6]|3314[05-9])\\d{3}|(?:2(?:1(?:160|962)|3(?:2\\d\\d|3(?:[03467]\\d|1[0-35-9]|2[1-9]|5[0-24-9]|8[0-3])|600)|646[59])|80[1-9]\\d\\d|9(?:3(?:[0-57-9]\\d\\d|6(?:0[02-9]|[1-9]\\d))|6(?:[0-8]\\d\\d|9(?:[02-79]\\d|1[05-9]))|7[1-9]\\d\\d|9(?:[03-9]\\d\\d|1(?:[0235-9]\\d|4[0-24-9])|2(?:[0-79]\\d|8[0-46-9]))))\\d{4}|(?:22|3[2-5]|[47][1-35]|5[1-3578]|6[13-57]|8[1-9]|9[2458])\\d{7}", [9]], ["", [9]], ["(?:123|8)00\\d{6}", [9, 11]], 0, 0, 0, 0, 0, ["44\\d{7}", [9]], ["600\\d{7,8}", [10, 11]]]], CM: ["237", "00", "[26]\\d{8}|88\\d{6,7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["88"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[26]|88"]]], 0, 0, 0, 0, 0, 0, [["2(?:22|33)\\d{6}", [9]], ["(?:24[23]|6[25-9]\\d)\\d{6}", [9]], ["88\\d{6,7}"]]], CN: ["86", "00|1(?:[12]\\d|79)\\d\\d00", "1[127]\\d{8,9}|2\\d{9}(?:\\d{2})?|[12]\\d{6,7}|86\\d{6}|(?:1[03-689]\\d|6)\\d{7,9}|(?:[3-579]\\d|8[0-57-9])\\d{6,9}", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5,6})", "$1 $2", ["(?:10|2[0-57-9])[19]", "(?:10|2[0-57-9])(?:10|9[56])", "10(?:10|9[56])|2[0-57-9](?:100|9[56])"], "0$1"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]", "(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]", "85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])", "85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["(?:4|80)0"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|2(?:[02-57-9]|1[1-9])", "10|2(?:[02-57-9]|1[1-9])", "10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"], "0$1", 1], ["(\\d{3})(\\d{7,8})", "$1 $2", ["9"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["80"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[3-578]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["1[3-9]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["[12]"], "0$1", 1]], "0", 0, "(1(?:[12]\\d|79)\\d\\d)|0", 0, 0, 0, [["(?:10(?:[02-79]\\d\\d|[18](?:0[1-9]|[1-9]\\d))|21(?:[18](?:0[1-9]|[1-9]\\d)|[2-79]\\d\\d))\\d{5}|(?:43[35]|754)\\d{7,8}|8(?:078\\d{7}|51\\d{7,8})|(?:10|(?:2|85)1|43[35]|754)(?:100\\d\\d|95\\d{3,4})|(?:2[02-57-9]|3(?:11|7[179])|4(?:[15]1|3[12])|5(?:1\\d|2[37]|3[12]|51|7[13-79]|9[15])|7(?:[39]1|5[57]|6[09])|8(?:71|98))(?:[02-8]\\d{7}|1(?:0(?:0\\d\\d(?:\\d{3})?|[1-9]\\d{5})|[1-9]\\d{6})|9(?:[0-46-9]\\d{6}|5\\d{3}(?:\\d(?:\\d{2})?)?))|(?:3(?:1[02-9]|35|49|5\\d|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|3[46-9]|5[2-9]|6[47-9]|7\\d|8[23])|5(?:3[03-9]|4[36]|5[02-9]|6[1-46]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[17]\\d|2[248]|3[04-9]|4[3-6]|5[0-3689]|6[2368]|9[02-9])|8(?:1[236-8]|2[5-7]|3\\d|5[2-9]|7[02-9]|8[36-8]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:[02-8]\\d{6}|1(?:0(?:0\\d\\d(?:\\d{2})?|[1-9]\\d{4})|[1-9]\\d{5})|9(?:[0-46-9]\\d{5}|5\\d{3,5}))", [7, 8, 9, 10, 11]], ["1740[0-5]\\d{6}|1(?:[38]\\d|4[57]|[59][0-35-9]|6[25-7]|7[0-35-8])\\d{8}", [11]], ["(?:(?:10|21)8|8)00\\d{7}", [10, 12]], ["16[08]\\d{5}", [8]], 0, 0, 0, 0, 0, ["10(?:10\\d{4}|96\\d{3,4})|400\\d{7}|950\\d{7,8}|(?:2[0-57-9]|3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))96\\d{3,4}", [7, 8, 9, 10, 11]]], "00"], CO: ["57", "00(?:4(?:[14]4|56)|[579])", "(?:60\\d\\d|9101)\\d{6}|(?:1\\d|3)\\d{9}", [10, 11], [["(\\d{3})(\\d{7})", "$1 $2", ["6"], "($1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3[0-357]|91"]], ["(\\d)(\\d{3})(\\d{7})", "$1-$2-$3", ["1"], "0$1", 0, "$1 $2 $3"]], "0", 0, "0([3579]|4(?:[14]4|56))?", 0, 0, 0, [["601055(?:[0-4]\\d|50)\\d\\d|6010(?:[0-4]\\d|5[0-4])\\d{4}|60(?:[124-7][2-9]|8[1-9])\\d{6}", [10]], ["333301[0-5]\\d{3}|3333(?:00|2[5-9]|[3-9]\\d)\\d{4}|(?:3(?:24[1-9]|3(?:00|3[0-24-9]))|9101)\\d{6}|3(?:0[0-5]|1\\d|2[0-3]|5[01]|70)\\d{7}", [10]], ["1800\\d{7}", [11]], ["19(?:0[01]|4[78])\\d{7}", [11]]]], CR: ["506", "00", "(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}", [8, 10], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[3-9]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[89]"]]], 0, 0, "(19(?:0[0-2468]|1[09]|20|66|77|99))", 0, 0, 0, [["210[7-9]\\d{4}|2(?:[024-7]\\d|1[1-9])\\d{5}", [8]], ["(?:3005\\d|6500[01])\\d{3}|(?:5[07]|6[0-4]|7[0-3]|8[3-9])\\d{6}", [8]], ["800\\d{7}", [10]], ["90[059]\\d{7}", [10]], 0, 0, 0, 0, ["(?:210[0-6]|4\\d{3}|5100)\\d{4}", [8]]]], CU: ["53", "119", "(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}", [6, 7, 8, 10], [["(\\d{2})(\\d{4,6})", "$1 $2", ["2[1-4]|[34]"], "(0$1)"], ["(\\d)(\\d{6,7})", "$1 $2", ["7"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["[56]"], "0$1"], ["(\\d{3})(\\d{7})", "$1 $2", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:3[23]|4[89])\\d{4,6}|(?:31|4[36]|8(?:0[25]|78)\\d)\\d{6}|(?:2[1-4]|4[1257]|7\\d)\\d{5,6}"], ["(?:5\\d|6[2-4])\\d{6}", [8]], ["800\\d{7}", [10]], 0, 0, 0, 0, 0, 0, ["807\\d{7}", [10]]]], CV: ["238", "0", "(?:[2-59]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2-589]"]]], 0, 0, 0, 0, 0, 0, [["2(?:2[1-7]|3[0-8]|4[12]|5[1256]|6\\d|7[1-3]|8[1-5])\\d{4}"], ["(?:36|5[1-389]|9\\d)\\d{5}"], ["800\\d{4}"], 0, 0, 0, 0, 0, ["(?:3[3-5]|4[356])\\d{5}"]]], CW: ["599", "00", "(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[3467]"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["9[4-8]"]]], 0, 0, 0, 0, 0, "[69]", [["9(?:4(?:3[0-5]|4[14]|6\\d)|50\\d|7(?:2[014]|3[02-9]|4[4-9]|6[357]|77|8[7-9])|8(?:3[39]|[46]\\d|7[01]|8[57-9]))\\d{4}"], ["953[01]\\d{4}|9(?:5[12467]|6[5-9])\\d{5}"], 0, 0, 0, 0, 0, ["955\\d{5}", [8]], 0, ["60[0-2]\\d{4}", [7]]]], CX: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}", [9]], ["4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], CY: ["357", "00", "(?:[279]\\d|[58]0)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[257-9]"]]], 0, 0, 0, 0, 0, 0, [["2[2-6]\\d{6}"], ["9(?:10|[4-79]\\d)\\d{5}"], ["800\\d{5}"], ["90[09]\\d{5}"], ["700\\d{5}"], 0, ["(?:50|77)\\d{6}"], 0, 0, ["80[1-9]\\d{5}"]]], CZ: ["420", "00", "(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]|9[015-7]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["96"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]], 0, 0, 0, 0, 0, 0, [["(?:2\\d|3[1257-9]|4[16-9]|5[13-9])\\d{7}"], ["(?:60[1-8]\\d|7(?:0(?:[2-5]\\d|60)|190|[2379]\\d\\d))\\d{5}"], ["800\\d{6}"], ["9(?:0[05689]|76)\\d{6}"], ["70[01]\\d{6}"], 0, ["9(?:5\\d|7[2-4])\\d{6}"], 0, ["9[17]0\\d{6}"], ["8[134]\\d{7}"]]], DE: ["49", "00", "[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [["(\\d{2})(\\d{3,13})", "$1 $2", ["3[02]|40|[68]9"], "0$1"], ["(\\d{3})(\\d{3,12})", "$1 $2", ["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1", "2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"], "0$1"], ["(\\d{4})(\\d{2,11})", "$1 $2", ["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]", "[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["138"], "0$1"], ["(\\d{5})(\\d{2,10})", "$1 $2", ["3"], "0$1"], ["(\\d{3})(\\d{5,11})", "$1 $2", ["181"], "0$1"], ["(\\d{3})(\\d)(\\d{4,10})", "$1 $2 $3", ["1(?:3|80)|9"], "0$1"], ["(\\d{3})(\\d{7,8})", "$1 $2", ["1[67]"], "0$1"], ["(\\d{3})(\\d{7,12})", "$1 $2", ["8"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["185", "1850", "18500"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["18[68]"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["15[1279]"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["15[03568]", "15(?:[0568]|31)"], "0$1"], ["(\\d{3})(\\d{8})", "$1 $2", ["18"], "0$1"], ["(\\d{3})(\\d{2})(\\d{7,8})", "$1 $2 $3", ["1(?:6[023]|7)"], "0$1"], ["(\\d{4})(\\d{2})(\\d{7})", "$1 $2 $3", ["15[279]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{8})", "$1 $2 $3", ["15"], "0$1"]], "0", 0, 0, 0, 0, 0, [["32\\d{9,11}|49[1-6]\\d{10}|322\\d{6}|49[0-7]\\d{3,9}|(?:[34]0|[68]9)\\d{3,13}|(?:2(?:0[1-689]|[1-3569]\\d|4[0-8]|7[1-7]|8[0-7])|3(?:[3569]\\d|4[0-79]|7[1-7]|8[1-8])|4(?:1[02-9]|[2-48]\\d|5[0-6]|6[0-8]|7[0-79])|5(?:0[2-8]|[124-6]\\d|[38][0-8]|[79][0-7])|6(?:0[02-9]|[1-358]\\d|[47][0-8]|6[1-9])|7(?:0[2-8]|1[1-9]|[27][0-7]|3\\d|[4-6][0-8]|8[0-5]|9[013-7])|8(?:0[2-9]|1[0-79]|2\\d|3[0-46-9]|4[0-6]|5[013-9]|6[1-8]|7[0-8]|8[0-24-6])|9(?:0[6-9]|[1-4]\\d|[589][0-7]|6[0-8]|7[0-467]))\\d{3,12}", [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]], ["15(?:[0-25-9]\\d\\d|310)\\d{6}|1(?:6[023]|7\\d)\\d{7,8}", [10, 11]], ["800\\d{7,12}", [10, 11, 12, 13, 14, 15]], ["(?:137[7-9]|900(?:[135]|9\\d))\\d{6}", [10, 11]], ["700\\d{8}", [11]], 0, ["18(?:1\\d{5,11}|[2-9]\\d{8})", [8, 9, 10, 11, 12, 13, 14]], ["16(?:4\\d{1,10}|[89]\\d{1,11})", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]], 0, ["180\\d{5,11}|13(?:7[1-6]\\d\\d|8)\\d{4}", [7, 8, 9, 10, 11, 12, 13, 14]]]], DJ: ["253", "00", "(?:2\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[27]"]]], 0, 0, 0, 0, 0, 0, [["2(?:1[2-5]|7[45])\\d{5}"], ["77\\d{6}"]]], DK: ["45", "00", "[2-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:(?:2\\d|9[1-46-9])\\d|3(?:[0-37]\\d|4[013]|5[0-58]|6[01347-9]|8[0-8]|9[0-79])|4(?:[0-25]\\d|[34][02-9]|6[013-579]|7[013579]|8[0-47]|9[0-27])|5(?:[0-36]\\d|4[0146-9]|5[03-57-9]|7[0568]|8[0-358]|9[0-69])|6(?:[013578]\\d|2[0-68]|4[02-8]|6[01689]|9[015689])|7(?:[0-69]\\d|7[03-9]|8[0147])|8(?:[16-9]\\d|2[0-58]))\\d{5}"], ["(?:[2-7]\\d|8[126-9]|9[1-46-9])\\d{6}"], ["80\\d{6}"], ["90\\d{6}"]]], DM: ["1", "011", "(?:[58]\\d\\d|767|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "767$1", 0, "767", [["767(?:2(?:55|66)|4(?:2[01]|4[0-25-9])|50[0-4])\\d{4}"], ["767(?:2(?:[2-4689]5|7[5-7])|31[5-7]|61[1-8]|70[1-6])\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], DO: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "8001|8[024]9", [["8(?:[04]9[2-9]\\d\\d|29(?:2(?:[0-59]\\d|6[04-9]|7[0-27]|8[0237-9])|3(?:[0-35-9]\\d|4[7-9])|[45]\\d\\d|6(?:[0-27-9]\\d|[3-5][1-9]|6[0135-8])|7(?:0[013-9]|[1-37]\\d|4[1-35689]|5[1-4689]|6[1-57-9]|8[1-79]|9[1-8])|8(?:0[146-9]|1[0-48]|[248]\\d|3[1-79]|5[01589]|6[013-68]|7[124-8]|9[0-8])|9(?:[0-24]\\d|3[02-46-9]|5[0-79]|60|7[0169]|8[57-9]|9[02-9])))\\d{4}"], ["8[024]9[2-9]\\d{6}"], ["8(?:00(?:14|[2-9]\\d)|(?:33|44|55|66|77|88)[2-9]\\d)\\d{5}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], DZ: ["213", "00", "(?:[1-4]|[5-79]\\d|80)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["9"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-8]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["9619\\d{5}|(?:1\\d|2[013-79]|3[0-8]|4[013-689])\\d{6}"], ["(?:5(?:4[0-29]|5\\d|6[0-2])|6(?:[569]\\d|7[0-6])|7[7-9]\\d)\\d{6}", [9]], ["800\\d{6}", [9]], ["80[3-689]1\\d{5}", [9]], 0, 0, 0, 0, ["98[23]\\d{6}", [9]], ["80[12]1\\d{5}", [9]]]], EC: ["593", "00", "1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}", [8, 9, 10, 11], [["(\\d)(\\d{3})(\\d{4})", "$1 $2-$3", ["[2-7]"], "(0$1)", 0, "$1-$2-$3"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1"]]], "0", 0, 0, 0, 0, 0, [["[2-7][2-7]\\d{6}", [8]], ["964[0-2]\\d{5}|9(?:39|[57][89]|6[0-36-9]|[89]\\d)\\d{6}", [9]], ["1800\\d{7}|1[78]00\\d{6}", [10, 11]], 0, 0, 0, 0, 0, ["[2-7]890\\d{4}", [8]]]], EE: ["372", "00", "8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88", "[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]], ["(\\d{4})(\\d{3,4})", "$1 $2", ["[45]|8(?:00|[1-49])", "[45]|8(?:00[1-9]|[1-49])"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]], 0, 0, 0, 0, 0, 0, [["(?:3[23589]|4[3-8]|6\\d|7[1-9]|88)\\d{5}", [7]], ["(?:5\\d{5}|8(?:1(?:0(?:0(?:00|[178]\\d)|[3-9]\\d\\d)|(?:1(?:0[236]|1\\d)|(?:2[0-59]|[3-79]\\d)\\d)\\d)|2(?:0(?:0(?:00|4\\d)|(?:19|[2-7]\\d)\\d)|(?:(?:[124-6]\\d|3[5-9])\\d|7(?:[0-79]\\d|8[13-9])|8(?:[2-6]\\d|7[01]))\\d)|[349]\\d{4}))\\d\\d|5(?:(?:[02]\\d|5[0-478])\\d|1(?:[0-8]\\d|95)|6(?:4[0-4]|5[1-589]))\\d{3}", [7, 8]], ["800(?:(?:0\\d\\d|1)\\d|[2-9])\\d{3}"], ["(?:40\\d\\d|900)\\d{4}", [7, 8]], ["70[0-2]\\d{5}", [8]]]], EG: ["20", "00", "[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}", [8, 9, 10], [["(\\d)(\\d{7,8})", "$1 $2", ["[23]"], "0$1"], ["(\\d{2})(\\d{6,7})", "$1 $2", ["1[35]|[4-6]|8[2468]|9[235-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{8})", "$1 $2", ["1"], "0$1"]], "0", 0, 0, 0, 0, 0, [["13[23]\\d{6}|(?:15|57)\\d{6,7}|(?:2[2-4]|3|4[05-8]|5[05]|6[24-689]|8[2468]|9[235-7])\\d{7}", [8, 9]], ["1[0-25]\\d{8}", [10]], ["800\\d{7}", [10]], ["900\\d{7}", [10]]]], EH: ["212", "00", "[5-8]\\d{8}", [9], 0, "0", 0, 0, 0, 0, "528[89]", [["528[89]\\d{5}"], ["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-4]|5[01]|8[0-3]))\\d{6}"], ["80[0-7]\\d{6}"], ["89\\d{7}"], 0, 0, 0, 0, ["(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"]]], ER: ["291", "00", "[178]\\d{6}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[178]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1(?:1[12568]|[24]0|55|6[146])|8\\d\\d)\\d{4}"], ["(?:17[1-3]|7\\d\\d)\\d{4}"]]], ES: ["34", "00", "[5-9]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]00"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-9]"]]], 0, 0, 0, 0, 0, 0, [["96906(?:0[0-8]|1[1-9]|[2-9]\\d)\\d\\d|9(?:69(?:0[0-57-9]|[1-9]\\d)|73(?:[0-8]\\d|9[1-9]))\\d{4}|(?:8(?:[1356]\\d|[28][0-8]|[47][1-9])|9(?:[135]\\d|[268][0-8]|4[1-9]|7[124-9]))\\d{6}"], ["(?:590[16]00\\d|9(?:6906(?:09|10)|7390\\d\\d))\\d\\d|(?:6\\d|7[1-48])\\d{7}"], ["[89]00\\d{6}"], ["80[367]\\d{6}"], ["70\\d{7}"], 0, ["51\\d{7}"], 0, 0, ["90[12]\\d{6}"]]], ET: ["251", "00", "(?:11|[2-579]\\d)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-579]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["11667[01]\\d{3}|(?:11(?:1(?:1[124]|2[2-7]|3[1-5]|5[5-8]|8[6-8])|2(?:13|3[6-8]|5[89]|7[05-9]|8[2-6])|3(?:2[01]|3[0-289]|4[1289]|7[1-4]|87)|4(?:1[69]|3[2-49]|4[0-3]|6[5-8])|5(?:1[578]|44|5[0-4])|6(?:1[578]|2[69]|39|4[5-7]|5[0-5]|6[0-59]|8[015-8]))|2(?:2(?:11[1-9]|22[0-7]|33\\d|44[1467]|66[1-68])|5(?:11[124-6]|33[2-8]|44[1467]|55[14]|66[1-3679]|77[124-79]|880))|3(?:3(?:11[0-46-8]|(?:22|55)[0-6]|33[0134689]|44[04]|66[01467])|4(?:44[0-8]|55[0-69]|66[0-3]|77[1-5]))|4(?:6(?:119|22[0-24-7]|33[1-5]|44[13-69]|55[14-689]|660|88[1-4])|7(?:(?:11|22)[1-9]|33[13-7]|44[13-6]|55[1-689]))|5(?:7(?:227|55[05]|(?:66|77)[14-8])|8(?:11[149]|22[013-79]|33[0-68]|44[013-8]|550|66[1-5]|77\\d)))\\d{4}"], ["700[1-9]\\d{5}|(?:7(?:0[1-9]|1[0-8]|22|77|86|99)|9\\d\\d)\\d{6}"]]], FI: ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d{5})", "$1", ["20[2-59]"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1 $2", ["(?:[1-3]0|[68])0|70[07-9]"], "0$1"], ["(\\d{2})(\\d{4,8})", "$1 $2", ["[14]|2[09]|50|7[135]"], "0$1"], ["(\\d{2})(\\d{6,10})", "$1 $2", ["7"], "0$1"], ["(\\d)(\\d{4,9})", "$1 $2", ["(?:1[49]|[2568])[1-8]|3(?:0[1-9]|[1-9])|9"], "0$1"]], "0", 0, 0, 0, 0, "1[03-79]|[2-9]", [["1[35-7][1-8]\\d{3,6}|(?:1[49][1-8]|[23568][1-8]\\d|9(?:00|[1-8]\\d))\\d{2,6}", [5, 6, 7, 8, 9]], ["4946\\d{2,6}|(?:4[0-8]|50)\\d{4,8}", [6, 7, 8, 9, 10]], ["800\\d{4,6}", [7, 8, 9]], ["[67]00\\d{5,6}", [8, 9]], 0, 0, ["20\\d{4,8}|60[12]\\d{5,6}|7(?:099\\d{4,5}|5[03-9]\\d{3,7})|20[2-59]\\d\\d|(?:606|7(?:0[78]|1|3\\d))\\d{7}|(?:10|29|3[09]|70[1-5]\\d)\\d{4,8}"]], "00"], FJ: ["679", "0(?:0|52)", "45\\d{5}|(?:0800\\d|[235-9])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[235-9]|45"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]]], 0, 0, 0, 0, 0, 0, [["603\\d{4}|(?:3[0-5]|6[25-7]|8[58])\\d{5}", [7]], ["(?:[279]\\d|45|5[01568]|8[034679])\\d{5}", [7]], ["0800\\d{7}", [11]]], "00"], FK: ["500", "00", "[2-7]\\d{4}", [5], 0, 0, 0, 0, 0, 0, 0, [["[2-47]\\d{4}"], ["[56]\\d{4}"]]], FM: ["691", "00", "(?:[39]\\d\\d|820)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[389]"]]], 0, 0, 0, 0, 0, 0, [["31(?:00[67]|208|309)\\d\\d|(?:3(?:[2357]0[1-9]|602|804|905)|(?:820|9[2-6]\\d)\\d)\\d{3}"], ["31(?:00[67]|208|309)\\d\\d|(?:3(?:[2357]0[1-9]|602|804|905)|(?:820|9[2-7]\\d)\\d)\\d{3}"]]], FO: ["298", "00", "[2-9]\\d{5}", [6], [["(\\d{6})", "$1", ["[2-9]"]]], 0, 0, "(10(?:01|[12]0|88))", 0, 0, 0, [["(?:20|[34]\\d|8[19])\\d{4}"], ["(?:[27][1-9]|5\\d|9[16])\\d{4}"], ["80[257-9]\\d{3}"], ["90(?:[13-5][15-7]|2[125-7]|9\\d)\\d\\d"], 0, 0, 0, 0, ["(?:6[0-36]|88)\\d{4}"]]], FR: ["33", "00", "[1-9]\\d{8}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0 $1"], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[1-79]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:26[013-9]|59[1-35-9])\\d{6}|(?:[13]\\d|2[0-57-9]|4[1-9]|5[0-8])\\d{7}"], ["(?:6(?:[0-24-8]\\d|3[0-8]|9[589])|7[3-9]\\d)\\d{6}"], ["80[0-5]\\d{6}"], ["836(?:0[0-36-9]|[1-9]\\d)\\d{4}|8(?:1[2-9]|2[2-47-9]|3[0-57-9]|[569]\\d|8[0-35-9])\\d{6}"], 0, 0, ["80[6-9]\\d{6}"], 0, ["9\\d{8}"], ["8(?:1[01]|2[0156]|4[02]|84)\\d{6}"]]], GA: ["241", "00", "(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}", [7, 8], [["(\\d)(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-7]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["11|[67]"], "0$1"]], 0, 0, "0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})", "$1", 0, 0, [["[01]1\\d{6}", [8]], ["(?:(?:0[2-7]|7[467])\\d|6(?:0[0-4]|10|[256]\\d))\\d{5}|[2-7]\\d{6}"]]], GB: ["44", "00", "[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}", [7, 9, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["800", "8001", "80011", "800111", "8001111"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["845", "8454", "84546", "845464"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["800"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["1(?:38|5[23]|69|76|94)", "1(?:(?:38|69)7|5(?:24|39)|768|946)", "1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["1(?:[2-69][02-9]|[78])"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[25]|7(?:0|6[02-9])", "[25]|7(?:0|6(?:[03-9]|2[356]))"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1389]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0-35])|4(?:(?:[0-5]\\d|70)\\d|69[7-9])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|50))\\d)|(?:2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d|1(?:[0-7]\\d|8[0-3]))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d)\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}", [9, 10]], ["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]], 0, " x"], GD: ["1", "011", "(?:473|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "473$1", 0, "473", [["473(?:2(?:3[0-2]|69)|3(?:2[89]|86)|4(?:[06]8|3[5-9]|4[0-4]|5[579]|73|90)|63[68]|7(?:58|84)|800|938)\\d{4}"], ["473(?:4(?:0[2-79]|1[04-9]|2[0-5]|49|5[68])|5(?:2[01]|3[3-8])|901)\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], GE: ["995", "00", "(?:[3-57]\\d\\d|800)\\d{6}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["32"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[57]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[348]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:3(?:[256]\\d|4[124-9]|7[0-4])|4(?:1\\d|2[2-7]|3[1-79]|4[2-8]|7[239]|9[1-7]))\\d{6}"], ["5(?:(?:(?:0555|1(?:[17]77|555))[5-9]|757(?:7[7-9]|8[01]))\\d|22252[0-4])\\d\\d|(?:5(?:0(?:0(?:0\\d|11|22|3[0-6]|44|5[05]|77|88|9[09])|111|22[02]|77\\d)|1(?:1(?:[03][01]|[124]\\d)|4\\d\\d)|[23]555|4(?:4\\d\\d|555)|5(?:[0157-9]\\d\\d|200)|6[89]\\d\\d|7(?:[0147-9]\\d\\d|5(?:00|[57]5))|8(?:0(?:[018]\\d|2[0-4])|5(?:55|8[89])|8(?:55|88))|9(?:090|[1-35-9]\\d\\d))|790\\d\\d)\\d{4}|5(?:0(?:0[17]0|505)|1(?:0[01]0|1(?:07|33|51))|2(?:0[02]0|2[25]2)|3(?:0[03]0|3[35]3)|(?:40[04]|900)0|5222)[0-4]\\d{3}"], ["800\\d{6}"], 0, 0, 0, 0, 0, ["70[67]\\d{6}"]]], GF: ["594", "00", "[56]94\\d{6}|(?:80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[56]|9[47]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[89]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["594(?:[02-49]\\d|1[0-5]|5[6-9]|6[0-3]|80)\\d{4}"], ["694(?:[0-249]\\d|3[0-8])\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:396|76\\d)\\d|476[0-5])\\d{4}"]]], GG: ["44", "00", "(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?", [7, 9, 10], 0, "0", 0, "([25-9]\\d{5})$|0", "1481$1", 0, 0, [["1481[25-9]\\d{5}", [10]], ["7(?:(?:781|839)\\d|911[17])\\d{5}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]]], GH: ["233", "00", "(?:[235]\\d{3}|800)\\d{5}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[235]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["3082[0-5]\\d{4}|3(?:0(?:[237]\\d|8[01])|[167](?:2[0-6]|7\\d|80)|2(?:2[0-5]|7\\d|80)|3(?:2[0-3]|7\\d|80)|4(?:2[013-9]|3[01]|7\\d|80)|5(?:2[0-7]|7\\d|80)|8(?:2[0-2]|7\\d|80)|9(?:[28]0|7\\d))\\d{5}", [9]], ["(?:2(?:[0346-9]\\d|5[67])|5(?:[03-7]\\d|9[1-9]))\\d{6}", [9]], ["800\\d{5}", [8]]]], GI: ["350", "00", "(?:[25]\\d|60)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["2"]]], 0, 0, 0, 0, 0, 0, [["2190[0-2]\\d{3}|2(?:0(?:[02]\\d|3[01])|16[24-9]|2[2-5]\\d)\\d{4}"], ["5251[0-4]\\d{3}|(?:5(?:[146-8]\\d\\d|250)|60(?:1[01]|6\\d))\\d{4}"]]], GL: ["299", "00", "(?:19|[2-689]\\d|70)\\d{4}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["19|[2-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:19|3[1-7]|[68][1-9]|70|9\\d)\\d{4}"], ["[245]\\d{5}"], ["80\\d{4}"], 0, 0, 0, 0, 0, ["3[89]\\d{4}"]]], GM: ["220", "00", "[2-9]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:4(?:[23]\\d\\d|4(?:1[024679]|[6-9]\\d))|5(?:5(?:3\\d|4[0-7])|6[67]\\d|7(?:1[04]|2[035]|3[58]|48))|8\\d{3})\\d{3}"], ["(?:[23679]\\d|5[0-489])\\d{5}"]]], GN: ["224", "00", "722\\d{6}|(?:3|6\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["3"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[67]"]]], 0, 0, 0, 0, 0, 0, [["3(?:0(?:24|3[12]|4[1-35-7]|5[13]|6[189]|[78]1|9[1478])|1\\d\\d)\\d{4}", [8]], ["6[0-356]\\d{7}", [9]], 0, 0, 0, 0, 0, 0, ["722\\d{6}", [9]]]], GP: ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[569]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1-9]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-5])\\d{4}"]]], GQ: ["240", "00", "222\\d{6}|(?:3\\d|55|[89]0)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235]"]], ["(\\d{3})(\\d{6})", "$1 $2", ["[89]"]]], 0, 0, 0, 0, 0, 0, [["33[0-24-9]\\d[46]\\d{4}|3(?:33|5\\d)\\d[7-9]\\d{4}"], ["(?:222|55\\d)\\d{6}"], ["80\\d[1-9]\\d{5}"], ["90\\d[1-9]\\d{5}"]]], GR: ["30", "00", "5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}", [10, 11, 12], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["21|7"]], ["(\\d{4})(\\d{6})", "$1 $2", ["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2689]"]], ["(\\d{3})(\\d{3,4})(\\d{5})", "$1 $2 $3", ["8"]]], 0, 0, 0, 0, 0, 0, [["2(?:1\\d\\d|2(?:2[1-46-9]|[36][1-8]|4[1-7]|5[1-4]|7[1-5]|[89][1-9])|3(?:1\\d|2[1-57]|[35][1-3]|4[13]|7[1-7]|8[124-6]|9[1-79])|4(?:1\\d|2[1-8]|3[1-4]|4[13-5]|6[1-578]|9[1-5])|5(?:1\\d|[29][1-4]|3[1-5]|4[124]|5[1-6])|6(?:1\\d|[269][1-6]|3[1245]|4[1-7]|5[13-9]|7[14]|8[1-5])|7(?:1\\d|2[1-5]|3[1-6]|4[1-7]|5[1-57]|6[135]|9[125-7])|8(?:1\\d|2[1-5]|[34][1-4]|9[1-57]))\\d{6}", [10]], ["68[57-9]\\d{7}|(?:69|94)\\d{8}", [10]], ["800\\d{7,9}"], ["90[19]\\d{7}", [10]], ["70\\d{8}", [10]], 0, ["5005000\\d{3}", [10]], 0, 0, ["8(?:0[16]|12|[27]5|50)\\d{7}", [10]]]], GT: ["502", "00", "80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-8]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]], 0, 0, 0, 0, 0, 0, [["[267][2-9]\\d{6}", [8]], ["(?:[3-5]\\d\\d|80[0-4])\\d{5}", [8]], ["18[01]\\d{8}", [11]], ["19\\d{9}", [11]]]], GU: ["1", "011", "(?:[58]\\d\\d|671|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "671$1", 0, "671", [["671(?:2\\d\\d|3(?:00|3[39]|4[349]|55|6[26])|4(?:00|56|7[1-9]|8[02-46-9])|5(?:55|6[2-5]|88)|6(?:3[2-578]|4[24-9]|5[34]|78|8[235-9])|7(?:[0479]7|2[0167]|3[45]|8[7-9])|8(?:[2-57-9]8|6[48])|9(?:2[29]|6[79]|7[1279]|8[7-9]|9[78]))\\d{4}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], GW: ["245", "00", "[49]\\d{8}|4\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["40"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"]]], 0, 0, 0, 0, 0, 0, [["443\\d{6}", [9]], ["9(?:5\\d|6[569]|77)\\d{6}", [9]], 0, 0, 0, 0, 0, 0, ["40\\d{5}", [7]]]], GY: ["592", "001", "(?:[2-8]\\d{3}|9008)\\d{3}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:2(?:1[6-9]|2[0-35-9]|3[1-4]|5[3-9]|6\\d|7[0-79])|3(?:2[25-9]|3\\d)|4(?:4[0-24]|5[56])|50[0-6]|77[1-57])\\d{4}"], ["510\\d{4}|(?:6\\d|7[0-5])\\d{5}"], ["(?:289|8(?:00|6[28]|88|99))\\d{4}"], ["9008\\d{3}"], 0, 0, 0, 0, ["515\\d{4}"]]], HK: ["852", "00(?:30|5[09]|[126-9]?)", "8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}", [5, 6, 7, 8, 9, 11], [["(\\d{3})(\\d{2,5})", "$1 $2", ["900", "9003"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{3})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]], 0, 0, 0, 0, 0, 0, [["(?:2(?:[13-9]\\d|2[013-9])\\d|3(?:(?:[1569][0-24-9]|4[0-246-9]|7[0-24-69])\\d|8(?:4[0-8]|[59]\\d|6[0-2]))|58(?:0[1-9]|1[2-9]))\\d{4}", [8]], ["(?:4(?:44[0-25-9]|6(?:1[0-7]|4[0-57-9]|6[0-4]))|5(?:73[0-6]|95[0-8])|6(?:26[013-8]|66[0-3])|70(?:7[1-8]|8[0-4])|848[0-35-9]|9(?:29[013-9]|39[01]|59[0-4]|899))\\d{4}|(?:4(?:4[0-35-8]|6[02357-9]|70)|5(?:[1-59][0-46-9]|6[0-4689]|7[0-246-9])|6(?:0[1-9]|[13-59]\\d|[268][0-57-9]|7[0-79])|70[1-39]|84[0-29]|9(?:0[1-9]|1[02-9]|[2358][0-8]|[467]\\d))\\d{5}", [8]], ["800\\d{6}", [9]], ["900(?:[0-24-9]\\d{7}|3\\d{1,4})", [5, 6, 7, 8, 11]], ["8(?:1[0-4679]\\d|2(?:[0-36]\\d|7[0-4])|3(?:[034]\\d|2[09]|70))\\d{4}", [8]], 0, ["30(?:0[1-9]|[15-7]\\d|2[047]|89)\\d{4}", [8]], ["7(?:1(?:0[0-38]|1[0-3679]|3[013]|69|9[0136])|2(?:[02389]\\d|1[18]|7[27-9])|3(?:[0-38]\\d|7[0-369]|9[2357-9])|47\\d|5(?:[178]\\d|5[0-5])|6(?:0[0-7]|2[236-9]|[35]\\d)|7(?:[27]\\d|8[7-9])|8(?:[23689]\\d|7[1-9])|9(?:[025]\\d|6[0-246-8]|7[0-36-9]|8[238]))\\d{4}", [8]]], "00"], HN: ["504", "00", "8\\d{10}|[237-9]\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["[237-9]"]]], 0, 0, 0, 0, 0, 0, [["2(?:2(?:0[0-59]|1[1-9]|[23]\\d|4[02-6]|5[57]|6[245]|7[0135689]|8[01346-9]|9[0-2])|4(?:0[578]|2[3-59]|3[13-9]|4[0-68]|5[1-3589])|5(?:0[2357-9]|1[1-356]|4[03-5]|5\\d|6[014-69]|7[04]|80)|6(?:[056]\\d|17|2[067]|3[047]|4[0-378]|[78][0-8]|9[01])|7(?:0[5-79]|6[46-9]|7[02-9]|8[034]|91)|8(?:79|8[0-357-9]|9[1-57-9]))\\d{4}", [8]], ["[37-9]\\d{7}", [8]], ["8002\\d{7}", [11]]]], HR: ["385", "00", "(?:[24-69]\\d|3[0-79])\\d{7}|80\\d{5,7}|[1-79]\\d{7}|6\\d{5,6}", [6, 7, 8, 9], [["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["6[01]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{4})(\\d{3})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6|7[245]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-57]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["1\\d{7}|(?:2[0-3]|3[1-5]|4[02-47-9]|5[1-3])\\d{6,7}", [8, 9]], ["9(?:(?:0[1-9]|[12589]\\d)\\d\\d|7(?:[0679]\\d\\d|5(?:[01]\\d|44|55|77|9[5-7])))\\d{4}|98\\d{6}", [8, 9]], ["80\\d{5,7}", [7, 8, 9]], ["6[01459]\\d{6}|6[01]\\d{4,5}", [6, 7, 8]], ["7[45]\\d{6}", [8]], 0, ["62\\d{6,7}|72\\d{6}", [8, 9]]]], HT: ["509", "00", "(?:[2-489]\\d|55)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[2-589]"]]], 0, 0, 0, 0, 0, 0, [["2(?:2\\d|5[1-5]|81|9[149])\\d{5}"], ["(?:[34]\\d|55)\\d{6}"], ["8\\d{7}"], 0, 0, 0, 0, 0, ["9(?:[67][0-4]|8[0-3589]|9\\d)\\d{5}"]]], HU: ["36", "00", "[235-7]\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "06 $1"]], "06", 0, 0, 0, 0, 0, [["(?:1\\d|[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6[23689]|8[2-57-9]|9[2-69])\\d{6}", [8]], ["(?:[257]0|3[01])\\d{7}", [9]], ["(?:[48]0\\d|680[29])\\d{5}"], ["9[01]\\d{6}", [8]], 0, 0, ["38\\d{7}", [9]], 0, ["21\\d{7}", [9]]]], ID: ["62", "00[89]", "(?:(?:00[1-9]|8\\d)\\d{4}|[1-36])\\d{6}|00\\d{10}|[1-9]\\d{8,10}|[2-9]\\d{7}", [7, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["15"]], ["(\\d{2})(\\d{5,9})", "$1 $2", ["2[124]|[36]1"], "(0$1)"], ["(\\d{3})(\\d{5,7})", "$1 $2", ["800"], "0$1"], ["(\\d{3})(\\d{5,8})", "$1 $2", ["[2-79]"], "(0$1)"], ["(\\d{3})(\\d{3,4})(\\d{3})", "$1-$2-$3", ["8[1-35-9]"], "0$1"], ["(\\d{3})(\\d{6,8})", "$1 $2", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["804"], "0$1"], ["(\\d{3})(\\d)(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["80"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1-$2-$3", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["2[124]\\d{7,8}|619\\d{8}|2(?:1(?:14|500)|2\\d{3})\\d{3}|61\\d{5,8}|(?:2(?:[35][1-4]|6[0-8]|7[1-6]|8\\d|9[1-8])|3(?:1|[25][1-8]|3[1-68]|4[1-3]|6[1-3568]|7[0-469]|8\\d)|4(?:0[1-589]|1[01347-9]|2[0-36-8]|3[0-24-68]|43|5[1-378]|6[1-5]|7[134]|8[1245])|5(?:1[1-35-9]|2[25-8]|3[124-9]|4[1-3589]|5[1-46]|6[1-8])|6(?:[25]\\d|3[1-69]|4[1-6])|7(?:02|[125][1-9]|[36]\\d|4[1-8]|7[0-36-9])|9(?:0[12]|1[013-8]|2[0-479]|5[125-8]|6[23679]|7[159]|8[01346]))\\d{5,8}", [7, 8, 9, 10, 11]], ["8[1-35-9]\\d{7,10}", [9, 10, 11, 12]], ["00[17]803\\d{7}|(?:177\\d|800)\\d{5,7}|001803\\d{6}", [8, 9, 10, 11, 12, 13]], ["809\\d{7}", [10]], 0, 0, ["(?:1500|8071\\d{3})\\d{3}", [7, 10]], 0, 0, ["804\\d{7}", [10]]]], IE: ["353", "00", "(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["2[24-9]|47|58|6[237-9]|9[35-9]"], "(0$1)"], ["(\\d{3})(\\d{5})", "$1 $2", ["[45]0"], "(0$1)"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2569]|4[1-69]|7[14]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["81"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["4"], "(0$1)"], ["(\\d{2})(\\d)(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1\\d|21)\\d{6,7}|(?:2[24-9]|4(?:0[24]|5\\d|7)|5(?:0[45]|1\\d|8)|6(?:1\\d|[237-9])|9(?:1\\d|[35-9]))\\d{5}|(?:23|4(?:[1-469]|8\\d)|5[23679]|6[4-6]|7[14]|9[04])\\d{7}"], ["8(?:22|[35-9]\\d)\\d{6}", [9]], ["1800\\d{6}", [10]], ["15(?:1[2-8]|[2-8]0|9[089])\\d{6}", [10]], ["700\\d{6}", [9]], 0, ["818\\d{6}", [9]], 0, ["76\\d{7}", [9]], ["18[59]0\\d{6}", [10]]]], IL: ["972", "0(?:0|1[2-9])", "1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}", [7, 8, 9, 10, 11, 12], [["(\\d{4})(\\d{3})", "$1-$2", ["125"]], ["(\\d{4})(\\d{2})(\\d{2})", "$1-$2-$3", ["121"]], ["(\\d)(\\d{3})(\\d{4})", "$1-$2-$3", ["[2-489]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1-$2-$3", ["12"]], ["(\\d{4})(\\d{6})", "$1-$2", ["159"]], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3-$4", ["1[7-9]"]], ["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})", "$1-$2 $3-$4", ["15"]]], "0", 0, 0, 0, 0, 0, [["153\\d{8,9}|29[1-9]\\d{5}|(?:2[0-8]|[3489]\\d)\\d{6}", [8, 11, 12]], ["55(?:410|57[0-289])\\d{4}|5(?:(?:[02][02-9]|[149][2-9]|[36]\\d|8[3-7])\\d|5(?:01|2\\d|3[0-3]|4[34]|5[0-25689]|6[6-8]|7[0-267]|8[7-9]|9[1-9]))\\d{5}", [9]], ["1(?:255|80[019]\\d{3})\\d{3}", [7, 10]], ["1212\\d{4}|1(?:200|9(?:0[0-2]|19))\\d{6}", [8, 10]], 0, 0, ["1599\\d{6}", [10]], 0, ["7(?:38(?:0\\d|5[0-259]|88)|8(?:33|55|77|81)\\d)\\d{4}|7(?:18|2[23]|3[237]|47|6[258]|7\\d|82|9[2-9])\\d{6}", [9]], ["1700\\d{6}", [10]]]], IM: ["44", "00", "1624\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([25-8]\\d{5})$|0", "1624$1", 0, "74576|(?:16|7[56])24", [["1624(?:230|[5-8]\\d\\d)\\d{3}"], ["76245[06]\\d{4}|7(?:4576|[59]24\\d|624[0-4689])\\d{5}"], ["808162\\d{4}"], ["8(?:440[49]06|72299\\d)\\d{3}|(?:8(?:45|70)|90[0167])624\\d{4}"], ["70\\d{8}"], 0, ["3440[49]06\\d{3}|(?:3(?:08162|3\\d{4}|45624|7(?:0624|2299))|55\\d{4})\\d{4}"], 0, ["56\\d{8}"]]], IN: ["91", "00", "(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}", [8, 9, 10, 11, 12, 13], [["(\\d{8})", "$1", ["5(?:0|2[23]|3[03]|[67]1|88)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"], 0, 1], ["(\\d{4})(\\d{4,5})", "$1 $2", ["180", "1800"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["140"], 0, 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["11|2[02]|33|4[04]|79[1-7]|80[2-46]", "11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])", "11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"], "0$1", 1], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807", "1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]", "1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"], "0$1", 1], ["(\\d{5})(\\d{5})", "$1 $2", ["[6-9]"], "0$1", 1], ["(\\d{4})(\\d{2,4})(\\d{4})", "$1 $2 $3", ["1(?:6|8[06])", "1(?:6|8[06]0)"], 0, 1], ["(\\d{4})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["18"], 0, 1]], "0", 0, 0, 0, 0, 0, [["2717(?:[2-7]\\d|95)\\d{4}|(?:271[0-689]|782[0-6])[2-7]\\d{5}|(?:170[24]|2(?:(?:[02][2-79]|90)\\d|80[13468])|(?:3(?:23|80)|683|79[1-7])\\d|4(?:20[24]|72[2-8])|552[1-7])\\d{6}|(?:11|33|4[04]|80)[2-7]\\d{7}|(?:342|674|788)(?:[0189][2-7]|[2-7]\\d)\\d{5}|(?:1(?:2[0-249]|3[0-25]|4[145]|[59][14]|6[014]|7[1257]|8[01346])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[13]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[014-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91))[2-7]\\d{6}|(?:1(?:2[35-8]|3[346-9]|4[236-9]|[59][0235-9]|6[235-9]|7[34689]|8[257-9])|2(?:1[134689]|3[24-8]|4[2-8]|5[25689]|6[2-4679]|7[3-79]|8[2-479]|9[235-9])|3(?:01|1[79]|2[1245]|4[5-8]|5[125689]|6[235-7]|7[157-9]|8[2-46-8])|4(?:1[14578]|2[5689]|3[2-467]|5[4-7]|6[35]|73|8[2689]|9[2389])|5(?:[16][146-9]|2[14-8]|3[1346]|4[14-69]|5[46]|7[2-4]|8[2-8]|9[246])|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])|7(?:1[013-9]|2[0235-9]|3[2679]|4[1-35689]|5[2-46-9]|[67][02-9]|8[013-7]|9[089])|8(?:1[1357-9]|2[235-8]|3[03-57-9]|4[0-24-9]|5\\d|6[2457-9]|7[1-6]|8[1256]|9[2-4]))\\d[2-7]\\d{5}", [10]], ["(?:61279|7(?:887[02-9]|9(?:313|79[07-9]))|8(?:079[04-9]|(?:84|91)7[02-8]))\\d{5}|(?:6(?:12|[2-47]1|5[17]|6[13]|80)[0189]|7(?:1(?:2[0189]|9[0-5])|2(?:[14][017-9]|8[0-59])|3(?:2[5-8]|[34][017-9]|9[016-9])|4(?:1[015-9]|[29][89]|39|8[389])|5(?:[15][017-9]|2[04-9]|9[7-9])|6(?:0[0-47]|1[0-257-9]|2[0-4]|3[19]|5[4589])|70[0289]|88[089]|97[02-8])|8(?:0(?:6[67]|7[02-8])|70[017-9]|84[01489]|91[0-289]))\\d{6}|(?:7(?:31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[0189]\\d|7[02-8])\\d{5}|(?:6(?:[09]\\d|1[04679]|2[03689]|3[05-9]|4[0489]|50|6[069]|7[07]|8[7-9])|7(?:0\\d|2[0235-79]|3[05-8]|40|5[0346-8]|6[6-9]|7[1-9]|8[0-79]|9[089])|8(?:0[01589]|1[0-57-9]|2[235-9]|3[03-57-9]|[45]\\d|6[02457-9]|7[1-69]|8[0-25-9]|9[02-9])|9\\d\\d)\\d{7}|(?:6(?:(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|8[124-6])\\d|7(?:[235689]\\d|4[0189]))|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-5])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]|881))[0189]\\d{5}", [10]], ["000800\\d{7}|1(?:600\\d{6}|80(?:0\\d{4,9}|3\\d{9}))"], ["186[12]\\d{9}", [13]], 0, 0, ["140\\d{7}", [10]], 0, 0, ["1860\\d{7}", [11]]]], IO: ["246", "00", "3\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["3"]]], 0, 0, 0, 0, 0, 0, [["37\\d{5}"], ["38\\d{5}"]]], IQ: ["964", "00", "(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-6]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]], "0", 0, 0, 0, 0, 0, [["1\\d{7}|(?:2[13-5]|3[02367]|4[023]|5[03]|6[026])\\d{6,7}", [8, 9]], ["7[3-9]\\d{8}", [10]]]], IR: ["98", "00", "[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}", [4, 5, 6, 7, 10], [["(\\d{4,5})", "$1", ["96"], "0$1"], ["(\\d{2})(\\d{4,5})", "$1 $2", ["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[1-8]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])(?:[03-57]\\d{7}|[16]\\d{3}(?:\\d{4})?|[289]\\d{3}(?:\\d(?:\\d{3})?)?)|94(?:000[09]|(?:12\\d|30[0-2])\\d|2(?:121|[2689]0\\d)|4(?:111|40\\d))\\d{4}", [6, 7, 10]], ["9(?:(?:0(?:[0-35]\\d|4[4-6])|(?:[13]\\d|2[0-3])\\d)\\d|9(?:[0-46]\\d\\d|5[15]0|8(?:[12]\\d|88)|9(?:0[0-3]|[19]\\d|21|69|77|8[7-9])))\\d{5}", [10]], 0, 0, 0, 0, ["96(?:0[12]|2[16-8]|3(?:08|[14]5|[23]|66)|4(?:0|80)|5[01]|6[89]|86|9[19])", [4, 5]]]], IS: ["354", "00|1(?:0(?:01|[12]0)|100)", "(?:38\\d|[4-9])\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["[4-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["3"]]], 0, 0, 0, 0, 0, 0, [["(?:4(?:1[0-24-69]|2[0-7]|[37][0-8]|4[0-24589]|5[0-68]|6\\d|8[0-36-8])|5(?:05|[156]\\d|2[02578]|3[0-579]|4[03-7]|7[0-2578]|8[0-35-9]|9[013-689])|872)\\d{4}", [7]], ["(?:38[589]\\d\\d|6(?:1[1-8]|2[0-6]|3[026-9]|4[014679]|5[0159]|6[0-69]|70|8[06-8]|9\\d)|7(?:5[057]|[6-9]\\d)|8(?:2[0-59]|[3-69]\\d|8[238]))\\d{4}"], ["80[0-8]\\d{4}", [7]], ["90(?:0\\d|1[5-79]|2[015-79]|3[135-79]|4[125-7]|5[25-79]|7[1-37]|8[0-35-7])\\d{3}", [7]], 0, 0, ["809\\d{4}", [7]], 0, ["49[0-24-79]\\d{4}", [7]]], "00"], IT: ["39", "00", "0\\d{5,10}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?", [6, 7, 8, 9, 10, 11], [["(\\d{2})(\\d{4,6})", "$1 $2", ["0[26]"]], ["(\\d{3})(\\d{3,6})", "$1 $2", ["0[13-57-9][0159]|8(?:03|4[17]|9[2-5])", "0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"]], ["(\\d{4})(\\d{2,6})", "$1 $2", ["0(?:[13-579][2-46-8]|8[236-8])"]], ["(\\d{4})(\\d{4})", "$1 $2", ["894"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[26]|5"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1(?:44|[679])|[378]|43"]], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[13-57-9][0159]|14"]], ["(\\d{2})(\\d{4})(\\d{5})", "$1 $2 $3", ["0[26]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["3"]]], 0, 0, 0, 0, 0, 0, [["0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}"], ["3[2-9]\\d{7,8}|(?:31|43)\\d{8}", [9, 10]], ["80(?:0\\d{3}|3)\\d{3}", [6, 9]], ["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}", [6, 8, 9, 10]], ["1(?:78\\d|99)\\d{6}", [9, 10]], 0, 0, 0, ["55\\d{8}", [10]], ["84(?:[08]\\d{3}|[17])\\d{3}", [6, 9]]]], JE: ["44", "00", "1534\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([0-24-8]\\d{5})$|0", "1534$1", 0, 0, [["1534[0-24-8]\\d{5}"], ["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97\\d))\\d{5}"], ["80(?:07(?:35|81)|8901)\\d{4}"], ["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"], ["701511\\d{4}"], 0, ["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"], ["56\\d{8}"]]], JM: ["1", "011", "(?:[58]\\d\\d|658|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "658|876", [["8766060\\d{3}|(?:658(?:2(?:[0-8]\\d|9[0-46-9])|[3-9]\\d\\d)|876(?:52[35]|6(?:0[1-3579]|1[0235-9]|[23]\\d|40|5[06]|6[2-589]|7[0-25-9]|8[04]|9[4-9])|7(?:0[2-689]|[1-6]\\d|8[056]|9[45])|9(?:0[1-8]|1[02378]|[2-8]\\d|9[2-468])))\\d{4}"], ["(?:658295|876(?:2(?:0[1-9]|[13-9]\\d|2[013-9])|[348]\\d\\d|5(?:0[1-9]|[1-9]\\d)|6(?:4[89]|6[67])|7(?:0[07]|7\\d|8[1-47-9]|9[0-36-9])|9(?:[01]9|9[0579])))\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], JO: ["962", "00", "(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2356]|87"], "(0$1)"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["70"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]], "0", 0, 0, 0, 0, 0, [["87(?:000|90[01])\\d{3}|(?:2(?:6(?:2[0-35-9]|3[0-578]|4[24-7]|5[0-24-8]|[6-8][023]|9[0-3])|7(?:0[1-79]|10|2[014-7]|3[0-689]|4[019]|5[0-3578]))|32(?:0[1-69]|1[1-35-7]|2[024-7]|3\\d|4[0-3]|[5-7][023])|53(?:0[0-3]|[13][023]|2[0-59]|49|5[0-35-9]|6[15]|7[45]|8[1-6]|9[0-36-9])|6(?:2(?:[05]0|22)|3(?:00|33)|4(?:0[0-25]|1[2-7]|2[0569]|[38][07-9]|4[025689]|6[0-589]|7\\d|9[0-2])|5(?:[01][056]|2[034]|3[0-57-9]|4[178]|5[0-69]|6[0-35-9]|7[1-379]|8[0-68]|9[0239]))|87(?:20|7[078]|99))\\d{4}", [8]], ["7(?:[78][0-25-9]|9\\d)\\d{6}", [9]], ["80\\d{6}", [8]], ["9\\d{7}", [8]], ["70\\d{7}", [9]], 0, ["8(?:10|8\\d)\\d{5}", [8]], ["74(?:66|77)\\d{5}", [9]], 0, ["85\\d{6}", [8]]]], JP: ["81", "010", "00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}", [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [["(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3", ["(?:12|57|99)0"], "0$1"], ["(\\d{4})(\\d)(\\d{4})", "$1-$2-$3", ["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51)|9(?:80|9[16])", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["60"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2-$3", ["[36]|4(?:2[09]|7[01])", "[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[0459]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[26-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9]|9[29])|5(?:2|3(?:[045]|9[0-8])|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|3(?:[29]|60)|49|51|6(?:[0-24]|36|5[0-3589]|7[23]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3(?:[045]|9(?:[0-58]|6[4-9]|7[0-35689]))|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|60|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[2-57-9]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|7(?:2[2-468]|3[78])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3", ["[14]|[289][2-9]|5[3-9]|7[2-4679]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["800"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[257-9]"], "0$1"]], "0", 0, "(000[259]\\d{6})$|(?:(?:003768)0?)|0", "$1", 0, 0, [["(?:1(?:1[235-8]|2[3-6]|3[3-9]|4[2-6]|[58][2-8]|6[2-7]|7[2-9]|9[1-9])|(?:2[2-9]|[36][1-9])\\d|4(?:[2-578]\\d|6[02-8]|9[2-59])|5(?:[2-589]\\d|6[1-9]|7[2-8])|7(?:[25-9]\\d|3[4-9]|4[02-9])|8(?:[2679]\\d|3[2-9]|4[5-9]|5[1-9]|8[03-9])|9(?:[2-58]\\d|[679][1-9]))\\d{6}", [9]], ["[7-9]0[1-9]\\d{7}", [10]], ["00777(?:[01]|5\\d)\\d\\d|(?:00(?:7778|882[1245])|(?:120|800\\d)\\d\\d)\\d{4}|00(?:37|66|78)\\d{6,13}"], ["990\\d{6}", [9]], ["60\\d{7}", [9]], 0, ["570\\d{6}", [9]], ["20\\d{8}", [10]], ["50[1-9]\\d{7}", [10]]]], KE: ["254", "000", "(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}", [7, 8, 9, 10], [["(\\d{2})(\\d{5,7})", "$1 $2", ["[24-6]"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[17]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:4[245]|5[1-79]|6[01457-9])\\d{5,7}|(?:4[136]|5[08]|62)\\d{7}|(?:[24]0|66)\\d{6,7}", [7, 8, 9]], ["(?:1(?:0[0-8]|1[0-7]|2[014]|30)|7\\d\\d)\\d{6}", [9]], ["800[02-8]\\d{5,6}", [9, 10]], ["900[02-9]\\d{5}", [9]]]], KG: ["996", "00", "8\\d{9}|[235-9]\\d{8}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["3(?:1[346]|[24-79])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235-79]|88"], "0$1"], ["(\\d{3})(\\d{3})(\\d)(\\d{2,3})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["312(?:5[0-79]\\d|9(?:[0-689]\\d|7[0-24-9]))\\d{3}|(?:3(?:1(?:2[0-46-8]|3[1-9]|47|[56]\\d)|2(?:22|3[0-479]|6[0-7])|4(?:22|5[6-9]|6\\d)|5(?:22|3[4-7]|59|6\\d)|6(?:22|5[35-7]|6\\d)|7(?:22|3[468]|4[1-9]|59|[67]\\d)|9(?:22|4[1-8]|6\\d))|6(?:09|12|2[2-4])\\d)\\d{5}", [9]], ["312(?:58\\d|973)\\d{3}|(?:2(?:0[0-35]|2\\d)|5[0-24-7]\\d|600|7(?:[07]\\d|55)|88[08]|9(?:12|9[05-9]))\\d{6}", [9]], ["800\\d{6,7}"]]], KH: ["855", "00[14-9]", "1\\d{9}|[1-9]\\d{7,8}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0", 0, 0, 0, 0, 0, [["23(?:4(?:[2-4]|[56]\\d)|[568]\\d\\d)\\d{4}|23[236-9]\\d{5}|(?:2[4-6]|3[2-6]|4[2-4]|[5-7][2-5])(?:(?:[237-9]|4[56]|5\\d)\\d{5}|6\\d{5,6})", [8, 9]], ["(?:(?:1[28]|3[18]|9[67])\\d|6[016-9]|7(?:[07-9]|[16]\\d)|8(?:[013-79]|8\\d))\\d{6}|(?:1\\d|9[0-57-9])\\d{6}|(?:2[3-6]|3[2-6]|4[2-4]|[5-7][2-5])48\\d{5}", [8, 9]], ["1800(?:1\\d|2[019])\\d{4}", [10]], ["1900(?:1\\d|2[09])\\d{4}", [10]]]], KI: ["686", "00", "(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}", [5, 8], 0, "0", 0, 0, 0, 0, 0, [["(?:[24]\\d|3[1-9]|50|65(?:02[12]|12[56]|22[89]|[3-5]00)|7(?:27\\d\\d|3100|5(?:02[12]|12[56]|22[89]|[34](?:00|81)|500))|8[0-5])\\d{3}"], ["(?:6200[01]|7(?:310[1-9]|5(?:02[03-9]|12[0-47-9]|22[0-7]|[34](?:0[1-9]|8[02-9])|50[1-9])))\\d{3}|(?:63\\d\\d|7(?:(?:[0146-9]\\d|2[0-689])\\d|3(?:[02-9]\\d|1[1-9])|5(?:[0-2][013-9]|[34][1-79]|5[1-9]|[6-9]\\d)))\\d{4}", [8]], 0, 0, 0, 0, 0, 0, ["30(?:0[01]\\d\\d|12(?:11|20))\\d\\d", [8]]]], KM: ["269", "00", "[3478]\\d{6}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[3478]"]]], 0, 0, 0, 0, 0, 0, [["7[4-7]\\d{5}"], ["[34]\\d{6}"], 0, ["8\\d{6}"]]], KN: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "869$1", 0, "869", [["869(?:2(?:29|36)|302|4(?:6[015-9]|70)|56[5-7])\\d{4}"], ["869(?:48[89]|55[6-8]|66\\d|76[02-7])\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], KP: ["850", "00|99", "85\\d{6}|(?:19\\d|[2-7])\\d{7}", [8, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:(?:195|2)\\d|3[19]|4[159]|5[37]|6[17]|7[39]|85)\\d{6}"], ["19[1-3]\\d{7}", [10]]]], KR: ["82", "00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))", "00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}", [5, 6, 8, 9, 10, 11, 12, 13, 14], [["(\\d{2})(\\d{3,4})", "$1-$2", ["(?:3[1-3]|[46][1-4]|5[1-5])1"], "0$1"], ["(\\d{4})(\\d{4})", "$1-$2", ["1"]], ["(\\d)(\\d{3,4})(\\d{4})", "$1-$2-$3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[36]0|8"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1-$2-$3", ["[1346]|5[1-5]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{2})(\\d{5})(\\d{4})", "$1-$2-$3", ["5"], "0$1"]], "0", 0, "0(8(?:[1-46-8]|5\\d\\d))?", 0, 0, 0, [["(?:2|3[1-3]|[46][1-4]|5[1-5])[1-9]\\d{6,7}|(?:3[1-3]|[46][1-4]|5[1-5])1\\d{2,3}", [5, 6, 8, 9, 10]], ["1(?:05(?:[0-8]\\d|9[0-6])|22[13]\\d)\\d{4,5}|1(?:0[0-46-9]|[16-9]\\d|2[013-9])\\d{6,7}", [9, 10]], ["00(?:308\\d{6,7}|798\\d{7,9})|(?:00368|[38]0)\\d{7}", [9, 11, 12, 13, 14]], ["60[2-9]\\d{6}", [9]], ["50\\d{8,9}", [10, 11]], 0, ["1(?:5(?:22|33|44|66|77|88|99)|6(?:[07]0|44|6[0168]|88)|8(?:00|33|55|77|99))\\d{4}", [8]], ["15\\d{7,8}", [9, 10]], ["70\\d{8}", [10]]]], KW: ["965", "00", "18\\d{5}|(?:[2569]\\d|41)\\d{6}", [7, 8], [["(\\d{4})(\\d{3,4})", "$1 $2", ["[169]|2(?:[235]|4[1-35-9])|52"]], ["(\\d{3})(\\d{5})", "$1 $2", ["[245]"]]], 0, 0, 0, 0, 0, 0, [["2(?:[23]\\d\\d|4(?:[1-35-9]\\d|44)|5(?:0[034]|[2-46]\\d|5[1-3]|7[1-7]))\\d{4}", [8]], ["(?:41\\d\\d|5(?:(?:[05]\\d|1[0-7]|6[56])\\d|2(?:22|5[25])|7(?:55|77)|88[58])|6(?:(?:0[034679]|5[015-9]|6\\d)\\d|1(?:00|11|6[16])|2[26]2|3[36]3|4[46]4|7(?:0[013-9]|[67]\\d)|8[68]8|9(?:[069]\\d|3[039]))|9(?:(?:[04679]\\d|8[057-9])\\d|1(?:1[01]|99)|2(?:00|2\\d)|3(?:00|3[03])|5(?:00|5\\d)))\\d{4}", [8]], ["18\\d{5}", [7]]]], KY: ["1", "011", "(?:345|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "345$1", 0, "345", [["345(?:2(?:22|3[23]|44|66)|333|444|6(?:23|38|40)|7(?:30|4[35-79]|6[6-9]|77)|8(?:00|1[45]|[48]8)|9(?:14|4[035-9]))\\d{4}"], ["345(?:32[1-9]|42[0-4]|5(?:1[67]|2[5-79]|4[6-9]|50|76)|649|82[56]|9(?:1[679]|2[2-9]|3[06-9]|90))\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["(?:345976|900[2-9]\\d\\d)\\d{4}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, ["345849\\d{4}"]]], KZ: ["7", "810", "(?:33622|8\\d{8})\\d{5}|[78]\\d{9}", [10, 14], 0, "8", 0, 0, 0, 0, "33|7", [["(?:33622|7(?:1(?:0(?:[23]\\d|4[0-3]|59|63)|1(?:[23]\\d|4[0-79]|59)|2(?:[23]\\d|59)|3(?:2\\d|3[0-79]|4[0-35-9]|59)|4(?:[24]\\d|3[013-9]|5[1-9]|97)|5(?:2\\d|3[1-9]|4[0-7]|59)|6(?:[2-4]\\d|5[19]|61)|72\\d|8(?:[27]\\d|3[1-46-9]|4[0-5]|59))|2(?:1(?:[23]\\d|4[46-9]|5[3469])|2(?:2\\d|3[0679]|46|5[12679])|3(?:[2-4]\\d|5[139])|4(?:2\\d|3[1-35-9]|59)|5(?:[23]\\d|4[0-8]|59|61)|6(?:2\\d|3[1-9]|4[0-4]|59)|7(?:[2379]\\d|40|5[279])|8(?:[23]\\d|4[0-3]|59)|9(?:2\\d|3[124578]|59))))\\d{5}", [10]], ["7(?:0[0-25-8]|47|6[0-4]|7[15-8]|85)\\d{7}", [10]], ["8(?:00|108\\d{3})\\d{7}"], ["809\\d{7}", [10]], ["808\\d{7}", [10]], 0, 0, 0, ["751\\d{7}", [10]]], "8~10"], LA: ["856", "00", "[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2[13]|3[14]|[4-8]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["30[0135-9]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2[13]|[35-7][14]|41|8[1468])\\d{6}", [8]], ["208[78]\\d{6}|(?:20[23579]|30[24])\\d{7}", [10]], 0, 0, 0, 0, ["30[0135-9]\\d{6}", [9]]]], LB: ["961", "00", "[27-9]\\d{7}|[13-9]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27-9]"]]], "0", 0, 0, 0, 0, 0, [["7(?:62|8[0-7]|9[04-9])\\d{4}|(?:[14-69]\\d|2(?:[14-69]\\d|[78][1-9])|7[2-57]|8[02-9])\\d{5}"], ["793(?:[01]\\d|2[0-4])\\d{3}|(?:(?:3|81)\\d|7(?:[01]\\d|6[013-9]|8[89]|9[12]))\\d{5}"], 0, ["9[01]\\d{6}", [8]], 0, 0, 0, 0, 0, ["80\\d{6}", [8]]]], LC: ["1", "011", "(?:[58]\\d\\d|758|900)\\d{7}", [10], 0, "1", 0, "([2-8]\\d{6})$|1", "758$1", 0, "758", [["758(?:234|4(?:30|5\\d|6[2-9]|8[0-2])|57[0-2]|(?:63|75)8)\\d{4}"], ["758(?:28[4-7]|384|4(?:6[01]|8[4-9])|5(?:1[89]|20|84)|7(?:1[2-9]|2\\d|3[0-3])|812)\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], LI: ["423", "00", "[68]\\d{8}|(?:[2378]\\d|90)\\d{5}", [7, 9], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2379]|8(?:0[09]|7)", "[2379]|8(?:0(?:02|9)|7)"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["69"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]], "0", 0, "(1001)|0", 0, 0, 0, [["(?:2(?:01|1[27]|2[02]|3\\d|6[02-578]|96)|3(?:[24]0|33|7[0135-7]|8[048]|9[0269]))\\d{4}", [7]], ["(?:6(?:(?:4[5-9]|5[0-469])\\d|6(?:[024-6]\\d|[17]0|3[7-9]))\\d|7(?:[37-9]\\d|42|56))\\d{4}"], ["8002[28]\\d\\d|80(?:05\\d|9)\\d{4}"], ["90(?:02[258]|1(?:23|3[14])|66[136])\\d\\d", [7]], 0, 0, ["870(?:28|87)\\d\\d", [7]]]], LK: ["94", "00", "[1-9]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[1-689]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:12[2-9]|602|8[12]\\d|9(?:1\\d|22|9[245]))\\d{6}|(?:11|2[13-7]|3[1-8]|4[157]|5[12457]|6[35-7])[2-57]\\d{6}"], ["7(?:[0-25-8]\\d|4[0-4])\\d{6}"], 0, 0, 0, 0, ["1973\\d{5}"]]], LR: ["231", "00", "(?:[245]\\d|33|77|88)\\d{7}|(?:2\\d|[4-6])\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["4[67]|[56]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-578]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["2\\d{7}", [8]], ["(?:(?:(?:22|33)0|555|(?:77|88)\\d)\\d|4(?:240|[67]))\\d{5}|[56]\\d{6}", [7, 9]], 0, ["332(?:02|[34]\\d)\\d{4}", [9]]]], LS: ["266", "00", "(?:[256]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2568]"]]], 0, 0, 0, 0, 0, 0, [["2\\d{7}"], ["[56]\\d{7}"], ["800[1256]\\d{4}"]]], LT: ["370", "00", "(?:[3469]\\d|52|[78]0)\\d{6}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["52[0-7]"], "(0-$1)", 1], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0 $1", 1], ["(\\d{2})(\\d{6})", "$1 $2", ["37|4(?:[15]|6[1-8])"], "(0-$1)", 1], ["(\\d{3})(\\d{5})", "$1 $2", ["[3-6]"], "(0-$1)", 1]], "0", 0, "[08]", 0, 0, 0, [["(?:3[1478]|4[124-6]|52)\\d{6}"], ["6\\d{7}"], ["80[02]\\d{5}"], ["9(?:0[0239]|10)\\d{5}"], ["70[05]\\d{5}"], 0, ["70[67]\\d{5}"], 0, ["[89]01\\d{5}"], ["808\\d{5}"]]], LU: ["352", "00", "35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}", [4, 5, 6, 7, 8, 9, 10, 11], [["(\\d{2})(\\d{3})", "$1 $2", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["20[2-689]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4", ["2(?:[0367]|4[3-8])"]], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["80[01]|90[015]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["20"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4 $5", ["2(?:[0367]|4[3-8])"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})", "$1 $2 $3 $4", ["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]], 0, 0, "(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)", 0, 0, 0, [["(?:35[013-9]|80[2-9]|90[89])\\d{1,8}|(?:2[2-9]|3[0-46-9]|[457]\\d|8[13-9]|9[2-579])\\d{2,9}"], ["6(?:[269][18]|5[1568]|7[189]|81)\\d{6}", [9]], ["800\\d{5}", [8]], ["90[015]\\d{5}", [8]], 0, 0, 0, 0, ["20(?:1\\d{5}|[2-689]\\d{1,7})", [4, 5, 6, 7, 8, 9, 10]], ["801\\d{5}", [8]]]], LV: ["371", "00", "(?:[268]\\d|90)\\d{6}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[269]|8[01]"]]], 0, 0, 0, 0, 0, 0, [["6\\d{7}"], ["23(?:23[0-57-9]|33[0238])\\d{3}|2(?:[0-24-9]\\d\\d|3(?:0[07]|[14-9]\\d|2[024-9]|3[0-24-9]))\\d{4}"], ["80\\d{6}"], ["90\\d{6}"], 0, 0, 0, 0, 0, ["81\\d{6}"]]], LY: ["218", "00", "[2-9]\\d{8}", [9], [["(\\d{2})(\\d{7})", "$1-$2", ["[2-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2(?:0[56]|[1-6]\\d|7[124579]|8[124])|3(?:1\\d|2[2356])|4(?:[17]\\d|2[1-357]|5[2-4]|8[124])|5(?:[1347]\\d|2[1-469]|5[13-5]|8[1-4])|6(?:[1-479]\\d|5[2-57]|8[1-5])|7(?:[13]\\d|2[13-79])|8(?:[124]\\d|5[124]|84))\\d{6}"], ["9[1-6]\\d{7}"]]], MA: ["212", "00", "[5-8]\\d{8}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5[45]"], "0$1"], ["(\\d{4})(\\d{5})", "$1-$2", ["5(?:2[2-46-9]|3[3-9]|9)|8(?:0[89]|92)"], "0$1"], ["(\\d{2})(\\d{7})", "$1-$2", ["8"], "0$1"], ["(\\d{3})(\\d{6})", "$1-$2", ["[5-7]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["5(?:2(?:[0-25-79]\\d|3[1-578]|4[02-46-8]|8[0235-7])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[014-9]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"], ["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-4]|5[01]|8[0-3]))\\d{6}"], ["80[0-7]\\d{6}"], ["89\\d{7}"], 0, 0, 0, 0, ["(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"]]], MC: ["377", "00", "(?:[3489]|6\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["4"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[389]"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["6"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:870|9[2-47-9]\\d)\\d{5}", [8]], ["4(?:[469]\\d|5[1-9])\\d{5}|(?:3|6\\d)\\d{7}"], ["(?:800|90\\d)\\d{5}", [8]]]], MD: ["373", "00", "(?:[235-7]\\d|[89]0)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["22|3"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[25-7]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:(?:2[1-9]|3[1-79])\\d|5(?:33|5[257]))\\d{5}"], ["562\\d{5}|(?:6\\d|7[16-9])\\d{6}"], ["800\\d{5}"], ["90[056]\\d{5}"], 0, 0, ["803\\d{5}"], 0, ["3[08]\\d{6}"], ["808\\d{5}"]]], ME: ["382", "00", "(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:20[2-8]|3(?:[0-2][2-7]|3[24-7])|4(?:0[2-467]|1[2467])|5(?:0[2467]|1[24-7]|2[2-467]))\\d{5}", [8]], ["6(?:[07-9]\\d|3[024]|6[0-25])\\d{5}", [8]], ["80(?:[0-2578]|9\\d)\\d{5}"], ["9(?:4[1568]|5[178])\\d{5}", [8]], 0, 0, ["77[1-9]\\d{5}", [8]], 0, ["78[1-49]\\d{5}", [8]]]], MF: ["590", "00", "590\\d{6}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:0[079]|[14]3|[27][79]|3[03-7]|5[0-268]|87)\\d{4}"], ["69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-5])\\d{4}"]]], MG: ["261", "00", "[23]\\d{8}", [9], [["(\\d{2})(\\d{2})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0", 0, "([24-9]\\d{6})$|0", "20$1", 0, 0, [["2072[29]\\d{4}|20(?:2\\d|4[47]|5[3467]|6[279]|7[35]|8[268]|9[245])\\d{5}"], ["3[2-47-9]\\d{7}"], 0, 0, 0, 0, 0, 0, ["22\\d{7}"]]], MH: ["692", "011", "329\\d{4}|(?:[256]\\d|45)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-6]"]]], "1", 0, 0, 0, 0, 0, [["(?:247|528|625)\\d{4}"], ["(?:(?:23|54)5|329|45[35-8])\\d{4}"], 0, 0, 0, 0, 0, 0, ["635\\d{4}"]]], MK: ["389", "00", "[2-578]\\d{7}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2|34[47]|4(?:[37]7|5[47]|64)"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[347]"], "0$1"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[58]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:(?:2(?:62|77)0|3444)\\d|4[56]440)\\d{3}|(?:34|4[357])700\\d{3}|(?:2(?:[0-3]\\d|5[0-578]|6[01]|82)|3(?:1[3-68]|[23][2-68]|4[23568])|4(?:[23][2-68]|4[3-68]|5[2568]|6[25-8]|7[24-68]|8[4-68]))\\d{5}"], ["7(?:3555|(?:474|9[019]7)7)\\d{3}|7(?:[0-25-8]\\d\\d|3(?:[1-48]\\d|6[01]|7[01578])|4(?:2\\d|60|7[01578])|9(?:[2-4]\\d|5[01]|7[015]))\\d{4}"], ["800\\d{5}"], ["5\\d{7}"], 0, 0, 0, 0, 0, ["8(?:0[1-9]|[1-9]\\d)\\d{5}"]]], ML: ["223", "00", "[24-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-9]"]]], 0, 0, 0, 0, 0, 0, [["2(?:07[0-8]|12[67])\\d{4}|(?:2(?:02|1[4-689])|4(?:0[0-4]|4[1-39]))\\d{5}"], ["2(?:0(?:01|79)|17\\d)\\d{4}|(?:5[01]|[679]\\d|8[2-49])\\d{6}"], ["80\\d{6}"]]], MM: ["95", "00", "1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}", [6, 7, 8, 9, 10], [["(\\d)(\\d{2})(\\d{3})", "$1 $2 $3", ["16|2"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["[45]|6(?:0[23]|[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-6]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[4-7]|8[1-35]"], "0$1"], ["(\\d)(\\d{3})(\\d{4,6})", "$1 $2 $3", ["9(?:2[0-4]|[35-9]|4[137-9])"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["92"], "0$1"], ["(\\d)(\\d{5})(\\d{4})", "$1 $2 $3", ["9"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1(?:(?:2\\d|3[56]|[89][0-6])\\d|4(?:2[29]|62|7[0-2]|83)|6)|2(?:2(?:00|8[34])|4(?:0\\d|[26]2|7[0-2]|83)|51\\d\\d)|4(?:2(?:2\\d\\d|48[013])|3(?:20\\d|4(?:70|83)|56)|420\\d|5470)|6(?:0(?:[23]|88\\d)|(?:124|[56]2\\d)\\d|2472|3(?:20\\d|470)|4(?:2[04]\\d|472)|7(?:(?:3\\d|8[01459])\\d|4[67]0)))\\d{4}|5(?:2(?:2\\d{5,6}|47[02]\\d{4})|(?:3472|4(?:2(?:1|86)|470)|522\\d|6(?:20\\d|483)|7(?:20\\d|48[01])|8(?:20\\d|47[02])|9(?:20\\d|470))\\d{4})|7(?:(?:0470|4(?:25\\d|470)|5(?:202|470|96\\d))\\d{4}|1(?:20\\d{4,5}|4(?:70|83)\\d{4}))|8(?:1(?:2\\d{5,6}|4(?:10|7[01]\\d)\\d{3})|2(?:2\\d{5,6}|(?:320|490\\d)\\d{3})|(?:3(?:2\\d\\d|470)|4[24-7]|5(?:(?:2\\d|51)\\d|4(?:[1-35-9]\\d|4[0-57-9]))|6[23])\\d{4})|(?:1[2-6]\\d|4(?:2[24-8]|3[2-7]|[46][2-6]|5[3-5])|5(?:[27][2-8]|3[2-68]|4[24-8]|5[23]|6[2-4]|8[24-7]|9[2-7])|6(?:[19]20|42[03-6]|(?:52|7[45])\\d)|7(?:[04][24-8]|[15][2-7]|22|3[2-4])|8(?:1[2-689]|2[2-8]|[35]2\\d))\\d{4}|25\\d{5,6}|(?:2[2-9]|6(?:1[2356]|[24][2-6]|3[24-6]|5[2-4]|6[2-8]|7[235-7]|8[245]|9[24])|8(?:3[24]|5[245]))\\d{4}", [6, 7, 8, 9]], ["(?:17[01]|9(?:2(?:[0-4]|[56]\\d\\d)|(?:3(?:[0-36]|4\\d)|(?:6\\d|8[89]|9[4-8])\\d|7(?:3|40|[5-9]\\d))\\d|4(?:(?:[0245]\\d|[1379])\\d|88)|5[0-6])\\d)\\d{4}|9[69]1\\d{6}|9(?:[68]\\d|9[089])\\d{5}", [7, 8, 9, 10]], ["80080(?:0[1-9]|2\\d)\\d{3}", [10]], 0, 0, 0, 0, 0, ["1333\\d{4}|[12]468\\d{4}", [8]]]], MN: ["976", "001", "[12]\\d{7,9}|[5-9]\\d{7}", [8, 9, 10], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[12]1"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[5-9]"]], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[12]2[1-3]"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["[12](?:27|3[2-8]|4[2-68]|5[1-4689])", "[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["[12]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["[12]2[1-3]\\d{5,6}|(?:(?:[12](?:1|27)|5[368])\\d\\d|7(?:0(?:[0-5]\\d|7[078]|80)|128))\\d{4}|[12](?:3[2-8]|4[2-68]|5[1-4689])\\d{6,7}"], ["(?:83[01]|92[039])\\d{5}|(?:5[05]|6[069]|8[015689]|9[013-9])\\d{6}", [8]], 0, 0, 0, 0, 0, 0, ["712[0-79]\\d{4}|7(?:1[013-9]|[25-9]\\d)\\d{5}", [8]]]], MO: ["853", "00", "0800\\d{3}|(?:28|[68]\\d)\\d{6}", [7, 8], [["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[268]"]]], 0, 0, 0, 0, 0, 0, [["(?:28[2-9]|8(?:11|[2-57-9]\\d))\\d{5}", [8]], ["6800[0-79]\\d{3}|6(?:[235]\\d\\d|6(?:0[0-5]|[1-9]\\d)|8(?:0[1-9]|[14-8]\\d|2[5-9]|[39][0-4]))\\d{4}", [8]], ["0800\\d{3}", [7]]]], MP: ["1", "011", "[58]\\d{9}|(?:67|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "670$1", 0, "670", [["670(?:2(?:3[3-7]|56|8[4-8])|32[1-38]|4(?:33|8[348])|5(?:32|55|88)|6(?:64|70|82)|78[3589]|8[3-9]8|989)\\d{4}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], MQ: ["596", "00", "596\\d{6}|(?:69|80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[569]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["596(?:[03-7]\\d|1[05]|2[7-9]|8[0-39]|9[04-9])\\d{4}"], ["69(?:6(?:[0-46-9]\\d|5[0-6])|727)\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:397[0-3]|477[0-5]|76(?:6\\d|7[0-367]))\\d{4}"]]], MR: ["222", "00", "(?:[2-4]\\d\\d|800)\\d{5}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-48]"]]], 0, 0, 0, 0, 0, 0, [["(?:25[08]|35\\d|45[1-7])\\d{5}"], ["[2-4][0-46-9]\\d{6}"], ["800\\d{5}"]]], MS: ["1", "011", "(?:[58]\\d\\d|664|900)\\d{7}", [10], 0, "1", 0, "([34]\\d{6})$|1", "664$1", 0, "664", [["6644(?:1[0-3]|91)\\d{4}"], ["664(?:3(?:49|9[1-6])|49[2-6])\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], MT: ["356", "00", "3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2357-9]"]]], 0, 0, 0, 0, 0, 0, [["20(?:3[1-4]|6[059])\\d{4}|2(?:0[19]|[1-357]\\d|60)\\d{5}"], ["(?:7(?:210|[79]\\d\\d)|9(?:[29]\\d\\d|69[67]|8(?:1[1-3]|89|97)))\\d{4}"], ["800(?:02|[3467]\\d)\\d{3}"], ["5(?:0(?:0(?:37|43)|(?:6\\d|70|9[0168])\\d)|[12]\\d0[1-5])\\d{3}"], 0, 0, ["501\\d{5}"], ["7117\\d{4}"], ["3550\\d{4}"]]], MU: ["230", "0(?:0|[24-7]0|3[03])", "(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-46]|8[013]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[57]"]], ["(\\d{5})(\\d{5})", "$1 $2", ["8"]]], 0, 0, 0, 0, 0, 0, [["(?:2(?:[0346-8]\\d|1[0-7])|4(?:[013568]\\d|2[4-8]|71)|54(?:[3-5]\\d|71)|6\\d\\d|8(?:14|3[129]))\\d{4}", [7, 8]], ["5(?:4(?:2[1-389]|7[1-9])|87[15-8])\\d{4}|(?:5(?:2[5-9]|4[3-689]|[57]\\d|8[0-689]|9[0-8])|7(?:0[0-4]|3[013]))\\d{5}", [8]], ["802\\d{7}|80[0-2]\\d{4}", [7, 10]], ["30\\d{5}", [7]], 0, 0, 0, 0, ["3(?:20|9\\d)\\d{4}", [7]]], "020"], MV: ["960", "0(?:0|19)", "(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}", [7, 10], [["(\\d{3})(\\d{4})", "$1-$2", ["[34679]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"]]], 0, 0, 0, 0, 0, 0, [["(?:3(?:0[0-3]|3[0-59])|6(?:[58][024689]|6[024-68]|7[02468]))\\d{4}", [7]], ["(?:46[46]|[79]\\d\\d)\\d{4}", [7]], ["800\\d{7}", [10]], ["900\\d{7}", [10]], 0, 0, ["4(?:0[01]|50)\\d{4}", [7]]], "00"], MW: ["265", "00", "(?:[1289]\\d|31|77)\\d{7}|1\\d{6}", [7, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["1[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[137-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1[2-9]|2[12]\\d\\d)\\d{5}"], ["111\\d{6}|(?:31|77|[89][89])\\d{7}", [9]]]], MX: ["52", "0[09]", "[2-9]\\d{9}", [10], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["33|5[56]|81"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-9]"]]], 0, 0, 0, 0, 0, 0, [["657[12]\\d{6}|(?:2(?:0[01]|2\\d|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|3\\d|7[1-8]|9[1-5])|4(?:1[1-57-9]|[25-7][1-9]|3[1-8]|4\\d|8[1-35-9]|9[2-689])|5(?:[56]\\d|88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-3689]|6[0-57-9]|7[1-7]|8[67]|9[4-8])|7(?:[1346][1-9]|[27]\\d|5[13-9]|8[1-69]|9[17])|8(?:1\\d|2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[0-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69]\\d|7[12]|8[1-8]))\\d{7}"], ["657[12]\\d{6}|(?:2(?:2\\d|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|3\\d|7[1-8]|9[1-5])|4(?:1[1-57-9]|[25-7][1-9]|3[1-8]|4\\d|8[1-35-9]|9[2-689])|5(?:[56]\\d|88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-3689]|6[0-57-9]|7[1-7]|8[67]|9[4-8])|7(?:[1346][1-9]|[27]\\d|5[13-9]|8[1-69]|9[17])|8(?:1\\d|2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[0-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69]\\d|7[12]|8[1-8]))\\d{7}"], ["8(?:00|88)\\d{7}"], ["900\\d{7}"], ["500\\d{7}"], 0, 0, 0, 0, ["300\\d{7}"]], "00"], MY: ["60", "00", "1\\d{8,9}|(?:3\\d|[4-9])\\d{7}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1-$2 $3", ["[4-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1-$2 $3", ["1(?:[02469]|[378][1-9]|53)|8", "1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2 $3", ["3"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3-$4", ["1(?:[367]|80)"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2 $3", ["15"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2 $3", ["1"], "0$1"]], "0", 0, 0, 0, 0, 0, [["4270\\d{4}|(?:3(?:2[0-36-9]|3[0-368]|4[0-278]|5[0-24-8]|6[0-467]|7[1246-9]|8\\d|9[0-57])\\d|4(?:2[0-689]|[3-79]\\d|8[1-35689])|5(?:2[0-589]|[3468]\\d|5[0-489]|7[1-9]|9[23])|6(?:2[2-9]|3[1357-9]|[46]\\d|5[0-6]|7[0-35-9]|85|9[015-8])|7(?:[2579]\\d|3[03-68]|4[0-8]|6[5-9]|8[0-35-9])|8(?:[24][2-8]|3[2-5]|5[2-7]|6[2-589]|7[2-578]|[89][2-9])|9(?:0[57]|13|[25-7]\\d|[3489][0-8]))\\d{5}", [8, 9]], ["1(?:1888[689]|4400|8(?:47|8[27])[0-4])\\d{4}|1(?:0(?:[23568]\\d|4[0-6]|7[016-9]|9[0-8])|1(?:[1-5]\\d\\d|6(?:0[5-9]|[1-9]\\d)|7(?:[0-4]\\d|5[0-7]))|(?:[269]\\d|[37][1-9]|4[235-9])\\d|5(?:31|9\\d\\d)|8(?:1[23]|[236]\\d|4[06]|5(?:46|[7-9])|7[016-9]|8[01]|9[0-8]))\\d{5}", [9, 10]], ["1[378]00\\d{6}", [10]], ["1600\\d{6}", [10]], 0, 0, 0, 0, ["15(?:4(?:6[0-4]\\d|8(?:0[125]|[17]\\d|21|3[01]|4[01589]|5[014]|6[02]))|6(?:32[0-6]|78\\d))\\d{4}", [10]]]], MZ: ["258", "00", "(?:2|8\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2|8[2-79]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]], 0, 0, 0, 0, 0, 0, [["2(?:[1346]\\d|5[0-2]|[78][12]|93)\\d{5}", [8]], ["8[2-79]\\d{7}", [9]], ["800\\d{6}", [9]]]], NA: ["264", "00", "[68]\\d{7,8}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["87"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["64426\\d{3}|6(?:1(?:2[2-7]|3[01378]|4[0-4])|254|32[0237]|4(?:27|41|5[25])|52[236-8]|626|7(?:2[2-4]|30))\\d{4,5}|6(?:1(?:(?:0\\d|2[0189]|3[24-69]|4[5-9])\\d|17|69|7[014])|2(?:17|5[0-36-8]|69|70)|3(?:17|2[14-689]|34|6[289]|7[01]|81)|4(?:17|2[0-2]|4[06]|5[0137]|69|7[01])|5(?:17|2[0459]|69|7[01])|6(?:17|25|38|42|69|7[01])|7(?:17|2[569]|3[13]|6[89]|7[01]))\\d{4}"], ["(?:60|8[1245])\\d{7}", [9]], ["80\\d{7}", [9]], ["8701\\d{5}", [9]], 0, 0, 0, 0, ["8(?:3\\d\\d|86)\\d{5}"]]], NC: ["687", "00", "(?:050|[2-57-9]\\d\\d)\\d{3}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1.$2.$3", ["[02-57-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:2[03-9]|3[0-5]|4[1-7]|88)\\d{4}"], ["(?:5[0-4]|[79]\\d|8[0-79])\\d{4}"], ["050\\d{3}"], ["36\\d{4}"]]], NE: ["227", "00", "[027-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["08"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[089]|2[013]|7[0467]"]]], 0, 0, 0, 0, 0, 0, [["2(?:0(?:20|3[1-8]|4[13-5]|5[14]|6[14578]|7[1-578])|1(?:4[145]|5[14]|6[14-68]|7[169]|88))\\d{4}"], ["(?:23|7[0467]|[89]\\d)\\d{6}"], ["08\\d{6}"], ["09\\d{6}"]]], NF: ["672", "00", "[13]\\d{5}", [6], [["(\\d{2})(\\d{4})", "$1 $2", ["1[0-3]"]], ["(\\d)(\\d{5})", "$1 $2", ["[13]"]]], 0, 0, "([0-258]\\d{4})$", "3$1", 0, 0, [["(?:1(?:06|17|28|39)|3[0-2]\\d)\\d{3}"], ["(?:14|3[58])\\d{4}"]]], NG: ["234", "009", "2[0-24-9]\\d{8}|[78]\\d{10,13}|[7-9]\\d{9}|[1-9]\\d{7}|[124-7]\\d{6}", [7, 8, 10, 11, 12, 13, 14], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["78"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]|9(?:0[3-9]|[1-9])"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[3-6]|7(?:0[0-689]|[1-79])|8[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[7-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["20[129]"], "0$1"], ["(\\d{4})(\\d{2})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{3})(\\d{5})(\\d{5,6})", "$1 $2 $3", ["[78]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["20(?:[1259]\\d|3[013-9]|4[1-8]|6[024-689]|7[1-79]|8[2-9])\\d{6}|(?:(?:[1-356]\\d|4[02-8]|8[2-9])\\d|9(?:0[3-9]|[1-9]\\d))\\d{5}|7(?:0(?:[013-689]\\d|2[0-24-9])\\d{3,4}|[1-79]\\d{6})|(?:[12]\\d|4[147]|5[14579]|6[1578]|7[1-3578])\\d{5}", [7, 8, 10]], ["(?:702[0-24-9]|819[01])\\d{6}|(?:7(?:0[13-9]|[12]\\d)|8(?:0[1-9]|1[0-8])|9(?:0[1-9]|1[1-6]))\\d{7}", [10]], ["800\\d{7,11}", [10, 11, 12, 13, 14]], 0, 0, 0, ["700\\d{7,11}", [10, 11, 12, 13, 14]]]], NI: ["505", "00", "(?:1800|[25-8]\\d{3})\\d{4}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[125-8]"]]], 0, 0, 0, 0, 0, 0, [["2\\d{7}"], ["(?:5(?:5[0-7]|[78]\\d)|6(?:20|3[035]|4[045]|5[05]|77|8[1-9]|9[059])|(?:7[5-8]|8\\d)\\d)\\d{5}"], ["1800\\d{4}"]]], NL: ["31", "00", "(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}", [5, 6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{4,7})", "$1 $2", ["[89]0"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["66"], "0$1"], ["(\\d)(\\d{8})", "$1 $2", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-578]|91"], "0$1"], ["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3", ["9"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1(?:[035]\\d|1[13-578]|6[124-8]|7[24]|8[0-467])|2(?:[0346]\\d|2[2-46-9]|5[125]|9[479])|3(?:[03568]\\d|1[3-8]|2[01]|4[1-8])|4(?:[0356]\\d|1[1-368]|7[58]|8[15-8]|9[23579])|5(?:[0358]\\d|[19][1-9]|2[1-57-9]|4[13-8]|6[126]|7[0-3578])|7\\d\\d)\\d{6}", [9]], ["(?:6[1-58]|970\\d)\\d{7}", [9, 11]], ["800\\d{4,7}", [7, 8, 9, 10]], ["90[069]\\d{4,7}", [7, 8, 9, 10]], 0, 0, ["140(?:1[035]|2[0346]|3[03568]|4[0356]|5[0358]|8[458])|(?:140(?:1[16-8]|2[259]|3[124]|4[17-9]|5[124679]|7)|8[478]\\d{6})\\d", [5, 6, 9]], ["66\\d{7}", [9]], ["(?:85|91)\\d{7}", [9]]]], NO: ["47", "00", "(?:0|[2-9]\\d{3})\\d{4}", [5, 8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]"]]], 0, 0, 0, 0, 0, "[02-689]|7[0-8]", [["(?:2[1-4]|3[1-3578]|5[1-35-7]|6[1-4679]|7[0-8])\\d{6}", [8]], ["(?:4[015-8]|9\\d)\\d{6}", [8]], ["80[01]\\d{5}", [8]], ["82[09]\\d{5}", [8]], ["880\\d{5}", [8]], 0, ["(?:0[2-9]|81(?:0(?:0[7-9]|1\\d)|5\\d\\d))\\d{3}"], 0, ["85[0-5]\\d{5}", [8]], ["810(?:0[0-6]|[2-8]\\d)\\d{3}", [8]]]], NP: ["977", "00", "(?:1\\d|9)\\d{9}|[1-9]\\d{7}", [8, 10, 11], [["(\\d)(\\d{7})", "$1-$2", ["1[2-6]"], "0$1"], ["(\\d{2})(\\d{6})", "$1-$2", ["1[01]|[2-8]|9(?:[1-59]|[67][2-6])"], "0$1"], ["(\\d{3})(\\d{7})", "$1-$2", ["9"]]], "0", 0, 0, 0, 0, 0, [["(?:1[0-6]\\d|99[02-6])\\d{5}|(?:2[13-79]|3[135-8]|4[146-9]|5[135-7]|6[13-9]|7[15-9]|8[1-46-9]|9[1-7])[2-6]\\d{5}", [8]], ["9(?:00|6[0-3]|7[024-6]|8[0-24-68])\\d{7}", [10]], ["1(?:66001|800\\d\\d)\\d{5}", [11]]]], NR: ["674", "00", "(?:444|(?:55|8\\d)\\d|666)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[4-68]"]]], 0, 0, 0, 0, 0, 0, [["444\\d{4}"], ["(?:55[3-9]|666|8\\d\\d)\\d{4}"]]], NU: ["683", "00", "(?:[4-7]|888\\d)\\d{3}", [4, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["8"]]], 0, 0, 0, 0, 0, 0, [["[47]\\d{3}", [4]], ["(?:[56]|888[1-9])\\d{3}"]]], NZ: ["64", "0(?:0|161)", "[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,8})", "$1 $2", ["8[1-79]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["50[036-8]|8|90", "50(?:[0367]|88)|8|90"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["24|[346]|7[2-57-9]|9[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:10|74)|[589]"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1|2[028]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,5})", "$1 $2 $3", ["2(?:[169]|7[0-35-9])|7"], "0$1"]], "0", 0, 0, 0, 0, 0, [["24099\\d{3}|(?:3[2-79]|[49][2-9]|6[235-9]|7[2-57-9])\\d{6}", [8]], ["2(?:[0-27-9]\\d|6)\\d{6,7}|2(?:1\\d|75)\\d{5}", [8, 9, 10]], ["508\\d{6,7}|80\\d{6,8}", [8, 9, 10]], ["(?:1[13-57-9]\\d{5}|50(?:0[08]|30|66|77|88))\\d{3}|90\\d{6,8}", [7, 8, 9, 10]], ["70\\d{7}", [9]], 0, ["8(?:1[16-9]|22|3\\d|4[045]|5[459]|6[235-9]|7[0-3579]|90)\\d{2,7}"]], "00"], OM: ["968", "00", "(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}", [7, 8, 9], [["(\\d{3})(\\d{4,6})", "$1 $2", ["[58]"]], ["(\\d{2})(\\d{6})", "$1 $2", ["2"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[179]"]]], 0, 0, 0, 0, 0, 0, [["2[1-6]\\d{6}", [8]], ["(?:1505|90[1-9]\\d)\\d{4}|(?:7[126-9]|9[1-9])\\d{6}", [8]], ["8007\\d{4,5}|(?:500|800[05])\\d{4}"], ["900\\d{5}", [8]]]], PA: ["507", "00", "(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}", [7, 8, 10, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[1-57-9]"]], ["(\\d{4})(\\d{4})", "$1-$2", ["[68]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]], 0, 0, 0, 0, 0, 0, [["(?:1(?:0\\d|1[479]|2[37]|3[0137]|4[17]|5[05]|6[058]|7[0167]|8[2358]|9[1389])|2(?:[0235-79]\\d|1[0-7]|4[013-9]|8[02-9])|3(?:[089]\\d|1[0-7]|2[0-5]|33|4[0-79]|5[0-35]|6[068]|7[0-8])|4(?:00|3[0-579]|4\\d|7[0-57-9])|5(?:[01]\\d|2[0-7]|[56]0|79)|7(?:0[09]|2[0-26-8]|3[03]|4[04]|5[05-9]|6[0156]|7[0-24-9]|8[5-9]|90)|8(?:09|2[89]|3\\d|4[0-24-689]|5[014]|8[02])|9(?:0[5-9]|1[0135-8]|2[036-9]|3[35-79]|40|5[0457-9]|6[05-9]|7[04-9]|8[35-8]|9\\d))\\d{4}", [7]], ["(?:1[16]1|21[89]|6\\d{3}|8(?:1[01]|7[23]))\\d{4}", [7, 8]], ["800\\d{4,5}|(?:00800|800\\d)\\d{6}"], ["(?:8(?:22|55|60|7[78]|86)|9(?:00|81))\\d{4}", [7]]]], PE: ["51", "00|19(?:1[124]|77|90)00", "(?:[14-8]|9\\d)\\d{7}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["80"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["1"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[4-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"]]], "0", 0, 0, 0, 0, 0, [["(?:(?:4[34]|5[14])[0-8]\\d|7(?:173|3[0-8]\\d)|8(?:10[05689]|6(?:0[06-9]|1[6-9]|29)|7(?:0[569]|[56]0)))\\d{4}|(?:1[0-8]|4[12]|5[236]|6[1-7]|7[246]|8[2-4])\\d{6}", [8]], ["9\\d{8}", [9]], ["800\\d{5}", [8]], ["805\\d{5}", [8]], ["80[24]\\d{5}", [8]], 0, 0, 0, 0, ["801\\d{5}", [8]]], "00", " Anexo "], PF: ["689", "00", "4\\d{5}(?:\\d{2})?|8\\d{7,8}", [6, 8, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["44"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4|8[7-9]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]], 0, 0, 0, 0, 0, 0, [["4(?:0[4-689]|9[4-68])\\d{5}", [8]], ["8[7-9]\\d{6}", [8]], ["80[0-5]\\d{6}", [9]], 0, 0, 0, ["44\\d{4}", [6]], 0, ["499\\d{5}", [8]]]], PG: ["675", "00|140[1-3]", "(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["18|[2-69]|85"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[78]"]]], 0, 0, 0, 0, 0, 0, [["(?:(?:3[0-2]|4[257]|5[34]|9[78])\\d|64[1-9]|85[02-46-9])\\d{4}", [7]], ["(?:7\\d|8[1-38])\\d{6}", [8]], ["180\\d{4}", [7]], 0, 0, 0, 0, ["27[01]\\d{4}", [7]], ["2(?:0[0-57]|7[568])\\d{4}", [7]]], "00"], PH: ["63", "00", "(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}", [6, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{5})", "$1 $2", ["2"], "(0$1)"], ["(\\d{4})(\\d{4,6})", "$1 $2", ["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2", "3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"], "(0$1)"], ["(\\d{5})(\\d{4})", "$1 $2", ["346|4(?:27|9[35])|883", "3469|4(?:279|9(?:30|56))|8834"], "(0$1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|8[2-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["1"]]], "0", 0, 0, 0, 0, 0, [["(?:(?:2[3-8]|3[2-68]|4[2-9]|5[2-6]|6[2-58]|7[24578])\\d{3}|88(?:22\\d\\d|42))\\d{4}|(?:2|8[2-8]\\d\\d)\\d{5}", [6, 8, 9, 10]], ["(?:8(?:1[37]|9[5-8])|9(?:0[5-9]|1[0-24-9]|[235-7]\\d|4[2-9]|8[135-9]|9[1-9]))\\d{7}", [10]], ["1800\\d{7,9}", [11, 12, 13]]]], PK: ["92", "00", "122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,7})", "$1 $2 $3", ["[89]0"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["1"]], ["(\\d{3})(\\d{6,7})", "$1 $2", ["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])", "9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"], "(0$1)"], ["(\\d{2})(\\d{7,8})", "$1 $2", ["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"], "(0$1)"], ["(\\d{5})(\\d{5})", "$1 $2", ["58"], "(0$1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[24-9]"], "(0$1)"]], "0", 0, 0, 0, 0, 0, [["(?:(?:21|42)[2-9]|58[126])\\d{7}|(?:2[25]|4[0146-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\\d{6,7}|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8]))[2-9]\\d{5,6}", [9, 10]], ["3(?:[0-247]\\d|3[0-79]|55|64)\\d{7}", [10]], ["800\\d{5}(?:\\d{3})?", [8, 11]], ["900\\d{5}", [8]], ["122\\d{6}", [9]], 0, ["(?:2(?:[125]|3[2358]|4[2-4]|9[2-8])|4(?:[0-246-9]|5[3479])|5(?:[1-35-7]|4[2-467])|6(?:0[468]|[1-8])|7(?:[14]|2[236])|8(?:[16]|2[2-689]|3[23578]|4[3478]|5[2356])|9(?:1|22|3[27-9]|4[2-6]|6[3569]|9[2-7]))111\\d{6}", [11, 12]]]], PL: ["48", "00", "(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{5})", "$1", ["19"]], ["(\\d{3})(\\d{3})", "$1 $2", ["11|20|64"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1", "(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["64"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[2-8]|[2-7]|8[1-79]|9[145]"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["8"]]], 0, 0, 0, 0, 0, 0, [["47\\d{7}|(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])(?:[02-9]\\d{6}|1(?:[0-8]\\d{5}|9\\d{3}(?:\\d{2})?))", [7, 9]], ["21(?:1[013-5]|2\\d)\\d{5}|(?:45|5[0137]|6[069]|7[2389]|88)\\d{7}", [9]], ["800\\d{6,7}", [9, 10]], ["70[01346-8]\\d{6}", [9]], 0, 0, ["804\\d{6}", [9]], ["64\\d{4,7}", [6, 7, 8, 9]], ["39\\d{7}", [9]], ["801\\d{6}", [9]]]], PM: ["508", "00", "[45]\\d{5}|(?:708|80\\d)\\d{6}", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[45]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:4[1-35-7]|5[01])\\d{4}", [6]], ["(?:4[02-4]|5[056]|708[45][0-5])\\d{4}"], ["80[0-5]\\d{6}", [9]]]], PR: ["1", "011", "(?:[589]\\d\\d|787)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "787|939", [["(?:787|939)[2-9]\\d{6}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], PS: ["970", "00", "[2489]2\\d{6}|(?:1\\d|5)\\d{8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2489]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0", 0, 0, 0, 0, 0, [["(?:22[2-47-9]|42[45]|82[014-68]|92[3569])\\d{5}", [8]], ["5[69]\\d{7}", [9]], ["1800\\d{6}", [10]], 0, 0, 0, 0, 0, 0, ["1700\\d{6}", [10]]]], PT: ["351", "00", "1693\\d{5}|(?:[26-9]\\d|30)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["2[12]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["16|[236-9]"]]], 0, 0, 0, 0, 0, 0, [["2(?:[12]\\d|3[1-689]|4[1-59]|[57][1-9]|6[1-35689]|8[1-69]|9[1256])\\d{6}"], ["6(?:[06]92(?:30|9\\d)|[35]92(?:[049]\\d|3[034]))\\d{3}|(?:(?:16|6[0356])93|9(?:[1-36]\\d\\d|480))\\d{5}"], ["80[02]\\d{6}"], ["(?:6(?:0[178]|4[68])\\d|76(?:0[1-57]|1[2-47]|2[237]))\\d{5}"], ["884[0-4689]\\d{5}"], 0, ["70(?:38[01]|596|(?:7\\d|8[17])\\d)\\d{4}"], ["6(?:222\\d|8988)\\d{4}"], ["30\\d{7}"], ["80(?:8\\d|9[1579])\\d{5}"]]], PW: ["680", "01[12]", "(?:[24-8]\\d\\d|345|900)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:2(?:55|77)|345|488|5(?:35|44|87)|6(?:22|54|79)|7(?:33|47)|8(?:24|55|76)|900)\\d{4}"], ["(?:(?:46|83)[0-5]|6[2-4689]0)\\d{4}|(?:45|77|88)\\d{5}"]]], PY: ["595", "00", "59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3,6})", "$1 $2", ["[2-9]0"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"], "(0$1)"], ["(\\d{3})(\\d{4,5})", "$1 $2", ["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["87"]], ["(\\d{3})(\\d{6})", "$1 $2", ["9(?:[5-79]|8[1-7])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"]]], "0", 0, 0, 0, 0, 0, [["(?:[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36])\\d{5,7}|(?:2(?:2[4-68]|[4-68]\\d|7[15]|9[1-5])|3(?:18|3[167]|4[2357]|51|[67]\\d)|4(?:3[12]|5[13]|9[1-47])|5(?:[1-4]\\d|5[02-4])|6(?:3[1-3]|44|7[1-8])|7(?:4[0-4]|5\\d|6[1-578]|75|8[0-8])|858)\\d{5,6}", [7, 8, 9]], ["9(?:51|6[129]|7[1-6]|8[1-7]|9[1-5])\\d{6}", [9]], ["9800\\d{5,7}", [9, 10, 11]], 0, 0, 0, ["[2-9]0\\d{4,7}", [6, 7, 8, 9]], 0, ["8700[0-4]\\d{4}", [9]]]], QA: ["974", "00", "800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}", [7, 8, 9, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["2[16]|8"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[3-7]"]]], 0, 0, 0, 0, 0, 0, [["4(?:1111|2022)\\d{3}|4(?:[04]\\d\\d|14[0-6]|999)\\d{4}", [8]], ["[35-7]\\d{7}", [8]], ["800\\d{4}|(?:0080[01]|800)\\d{6}", [7, 9, 11]], 0, 0, 0, 0, ["2[16]\\d{5}", [7]]]], RE: ["262", "00", "(?:26|[689]\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2689]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["26(?:2\\d\\d|3(?:0\\d|1[0-6]))\\d{4}"], ["69(?:2\\d\\d|3(?:[06][0-6]|1[013]|2[0-2]|3[0-39]|4\\d|5[0-5]|7[0-37]|8[0-8]|9[0-479]))\\d{4}"], ["80\\d{7}"], ["89[1-37-9]\\d{6}"], 0, 0, 0, 0, ["9(?:399[0-3]|479[0-5]|76(?:2[278]|3[0-37]))\\d{4}"], ["8(?:1[019]|2[0156]|84|90)\\d{6}"]]], RO: ["40", "00", "(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}", [6, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["2[3-6]", "2[3-6]\\d9"], "0$1"], ["(\\d{2})(\\d{4})", "$1 $2", ["219|31"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[23]1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[236-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["[23][13-6]\\d{7}|(?:2(?:19\\d|[3-6]\\d9)|31\\d\\d)\\d\\d"], ["(?:630|702)0\\d{5}|(?:6(?:[04]0|2\\d)|7(?:0[013-9]|1[0-3]|[2-7]\\d|8[03-8]|9[0-39]))\\d{6}", [9]], ["800\\d{6}", [9]], ["90[0136]\\d{6}", [9]], 0, 0, ["(?:37\\d|80[578])\\d{6}", [9]], 0, 0, ["801\\d{6}", [9]]], 0, " int "], RS: ["381", "00", "38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}", [6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{3,9})", "$1 $2", ["(?:2[389]|39)0|[7-9]"], "0$1"], ["(\\d{2})(\\d{5,10})", "$1 $2", ["[1-36]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:11[1-9]\\d|(?:2[389]|39)(?:0[2-9]|[2-9]\\d))\\d{3,8}|(?:1[02-9]|2[0-24-7]|3[0-8])[2-9]\\d{4,9}", [7, 8, 9, 10, 11, 12]], ["6(?:[0-689]|7\\d)\\d{6,7}", [8, 9, 10]], ["800\\d{3,9}"], ["(?:78\\d|90[0169])\\d{3,7}", [6, 7, 8, 9, 10]], 0, 0, ["7[06]\\d{4,10}"]]], RU: ["7", "810", "8\\d{13}|[347-9]\\d{9}", [10, 14], [["(\\d{4})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-8]|2[1-9])", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"], "8 ($1)", 1], ["(\\d{5})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-68]|2[1-9])", "7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))", "7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[349]|8(?:[02-7]|1[1-8])"], "8 ($1)", 1], ["(\\d{4})(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["8"], "8 ($1)"]], "8", 0, 0, 0, 0, "3[04-689]|[489]", [["(?:3(?:0[12]|4[1-35-79]|5[1-3]|65|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15]|6[1-35-79]|7[1-37-9]))\\d{7}", [10]], ["9\\d{9}", [10]], ["8(?:0[04]|108\\d{3})\\d{7}"], ["80[39]\\d{7}", [10]], ["808\\d{7}", [10]]], "8~10"], RW: ["250", "00", "(?:06|[27]\\d\\d|[89]00)\\d{6}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:06|2[23568]\\d)\\d{6}"], ["7[237-9]\\d{7}", [9]], ["800\\d{6}", [9]], ["900\\d{6}", [9]]]], SA: ["966", "00", "92\\d{7}|(?:[15]|8\\d)\\d{8}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["9"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["81"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]], "0", 0, 0, 0, 0, 0, [["1(?:1\\d|2[24-8]|3[35-8]|4[3-68]|6[2-5]|7[235-7])\\d{6}", [9]], ["579[01]\\d{5}|5(?:[013-689]\\d|7[0-8])\\d{6}", [9]], ["800\\d{7}", [10]], ["925\\d{6}", [9]], 0, 0, ["811\\d{7}", [10]], 0, 0, ["920\\d{6}", [9]]]], SB: ["677", "0[01]", "[6-9]\\d{6}|[1-6]\\d{4}", [5, 7], [["(\\d{2})(\\d{5})", "$1 $2", ["6[89]|7|8[4-9]|9(?:[1-8]|9[0-8])"]]], 0, 0, 0, 0, 0, 0, [["(?:1[4-79]|[23]\\d|4[0-2]|5[03]|6[0-37])\\d{3}", [5]], ["48\\d{3}|(?:(?:6[89]|7[1-9]|8[4-9])\\d|9(?:1[2-9]|2[013-9]|3[0-2]|[46]\\d|5[0-46-9]|7[0-689]|8[0-79]|9[0-8]))\\d{4}"], ["1[38]\\d{3}", [5]], 0, 0, 0, 0, 0, ["5[12]\\d{3}", [5]]]], SC: ["248", "010|0[0-2]", "(?:[2489]\\d|64)\\d{5}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[246]|9[57]"]]], 0, 0, 0, 0, 0, 0, [["4[2-46]\\d{5}"], ["2[125-8]\\d{5}"], ["800[08]\\d{3}"], ["85\\d{5}"], 0, 0, 0, 0, ["971\\d{4}|(?:64|95)\\d{5}"]], "00"], SD: ["249", "00", "[19]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[19]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["1(?:5\\d|8[35-7])\\d{6}"], ["(?:1[0-2]|9[0-3569])\\d{7}"]]], SE: ["46", "00", "(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}", [6, 7, 8, 9, 10], [["(\\d{2})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["20"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{4})", "$1-$2", ["9(?:00|39|44|9)"], "0$1", 0, "$1 $2"], ["(\\d{2})(\\d{3})(\\d{2})", "$1-$2 $3", ["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3"], ["(\\d)(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{2,3})(\\d{3})", "$1-$2 $3", ["9(?:00|39|44)"], "0$1", 0, "$1 $2 $3"], ["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["10|7"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{3})", "$1-$2 $3 $4", ["9"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4 $5", ["[26]"], "0$1", 0, "$1 $2 $3 $4 $5"]], "0", 0, 0, 0, 0, 0, [["(?:(?:[12][136]|3[356]|4[0246]|6[03]|8\\d)\\d|90[1-9])\\d{4,6}|(?:1(?:2[0-35]|4[0-4]|5[0-25-9]|7[13-6]|[89]\\d)|2(?:2[0-7]|4[0136-8]|5[0138]|7[018]|8[01]|9[0-57])|3(?:0[0-4]|1\\d|2[0-25]|4[056]|7[0-2]|8[0-3]|9[023])|4(?:1[013-8]|3[0135]|5[14-79]|7[0-246-9]|8[0156]|9[0-689])|5(?:0[0-6]|[15][0-5]|2[0-68]|3[0-4]|4\\d|6[03-5]|7[013]|8[0-79]|9[01])|6(?:1[1-3]|2[0-4]|4[02-57]|5[0-37]|6[0-3]|7[0-2]|8[0247]|9[0-356])|9(?:1[0-68]|2\\d|3[02-5]|4[0-3]|5[0-4]|[68][01]|7[0135-8]))\\d{5,6}", [7, 8, 9]], ["7[02369]\\d{7}", [9]], ["20\\d{4,7}", [6, 7, 8, 9]], ["649\\d{6}|99[1-59]\\d{4}(?:\\d{3})?|9(?:00|39|44)[1-8]\\d{3,6}", [7, 8, 9, 10]], ["75[1-8]\\d{6}", [9]], 0, ["10[1-8]\\d{6}", [9]], ["74[02-9]\\d{6}", [9]], 0, ["77[0-7]\\d{6}", [9]]]], SG: ["65", "0[0-3]\\d", "(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}", [8, 10, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[369]|8(?:0[1-9]|[1-9])"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{4})(\\d{4})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]], 0, 0, 0, 0, 0, 0, [["662[0-24-9]\\d{4}|6(?:[0-578]\\d|6[013-57-9]|9[0-35-9])\\d{5}", [8]], ["8(?:09[0-68]|95[0-2])\\d{4}|(?:8(?:0[1-8]|[1-8]\\d|9[0-4])|9[0-8]\\d)\\d{5}", [8]], ["(?:18|8)00\\d{7}", [10, 11]], ["1900\\d{7}", [11]], 0, 0, ["7000\\d{7}", [11]], 0, ["(?:3[12]\\d|666)\\d{5}", [8]]]], SH: ["290", "00", "(?:[256]\\d|8)\\d{3}", [4, 5], 0, 0, 0, 0, 0, 0, "[256]", [["2(?:[0-57-9]\\d|6[4-9])\\d\\d"], ["[56]\\d{4}", [5]], 0, 0, 0, 0, 0, 0, ["262\\d\\d", [5]]]], SI: ["386", "00|10(?:22|66|88|99)", "[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}", [5, 6, 7, 8], [["(\\d{2})(\\d{3,6})", "$1 $2", ["8[09]|9"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["59|8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37][01]|4[0139]|51|6"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-57]"], "(0$1)"]], "0", 0, 0, 0, 0, 0, [["(?:[1-357][2-8]|4[24-8])\\d{6}", [8]], ["65(?:[178]\\d|5[56]|6[01])\\d{4}|(?:[37][01]|4[0139]|51|6[489])\\d{6}", [8]], ["80\\d{4,6}", [6, 7, 8]], ["89[1-3]\\d{2,5}|90\\d{4,6}"], 0, 0, 0, 0, ["(?:59\\d\\d|8(?:1(?:[67]\\d|8[0-589])|2(?:0\\d|2[0-37-9]|8[0-2489])|3[389]\\d))\\d{4}", [8]]], "00"], SJ: ["47", "00", "0\\d{4}|(?:[489]\\d|79)\\d{6}", [5, 8], 0, 0, 0, 0, 0, 0, "79", [["79\\d{6}", [8]], ["(?:4[015-8]|9\\d)\\d{6}", [8]], ["80[01]\\d{5}", [8]], ["82[09]\\d{5}", [8]], ["880\\d{5}", [8]], 0, ["(?:0[2-9]|81(?:0(?:0[7-9]|1\\d)|5\\d\\d))\\d{3}"], 0, ["85[0-5]\\d{5}", [8]], ["810(?:0[0-6]|[2-8]\\d)\\d{3}", [8]]]], SK: ["421", "00", "[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}", [6, 7, 9], [["(\\d)(\\d{2})(\\d{3,4})", "$1 $2 $3", ["21"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["[3-5][1-8]1", "[3-5][1-8]1[67]"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1/$2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[689]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1/$2 $3 $4", ["[3-5]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2(?:16|[2-9]\\d{3})|(?:(?:[3-5][1-8]\\d|819)\\d|601[1-5])\\d)\\d{4}|(?:2|[3-5][1-8])1[67]\\d{3}|[3-5][1-8]16\\d\\d"], ["909[1-9]\\d{5}|9(?:0[1-8]|1[0-24-9]|4[03-57-9]|5\\d)\\d{6}", [9]], ["800\\d{6}", [9]], ["9(?:00|[78]\\d)\\d{6}", [9]], 0, 0, ["96\\d{7}", [9]], ["9090\\d{3}", [7]], ["6(?:02|5[0-4]|9[0-6])\\d{6}", [9]], ["8[5-9]\\d{7}", [9]]]], SL: ["232", "00", "(?:[237-9]\\d|66)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[236-9]"], "(0$1)"]], "0", 0, 0, 0, 0, 0, [["22[2-4][2-9]\\d{4}"], ["(?:25|3[0-5]|66|7[2-9]|8[08]|9[09])\\d{6}"]]], SM: ["378", "00", "(?:0549|[5-7]\\d)\\d{6}", [8, 10], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-7]"]], ["(\\d{4})(\\d{6})", "$1 $2", ["0"]]], 0, 0, "([89]\\d{5})$", "0549$1", 0, 0, [["0549(?:8[0157-9]|9\\d)\\d{4}", [10]], ["6[16]\\d{6}", [8]], 0, ["7[178]\\d{6}", [8]], 0, 0, 0, 0, ["5[158]\\d{6}", [8]]]], SN: ["221", "00", "(?:[378]\\d|93)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[379]"]]], 0, 0, 0, 0, 0, 0, [["3(?:0(?:1[0-2]|80)|282|3(?:8[1-9]|9[3-9])|611)\\d{5}"], ["7(?:(?:[06-8]\\d|21|90)\\d|5(?:01|[19]0|25|[38]3|[4-7]\\d))\\d{5}"], ["800\\d{6}"], ["88[4689]\\d{6}"], 0, 0, 0, 0, ["(?:3(?:392|9[01]\\d)\\d|93(?:3[13]0|929))\\d{4}"], ["81[02468]\\d{6}"]]], SO: ["252", "00", "[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}", [6, 7, 8, 9], [["(\\d{2})(\\d{4})", "$1 $2", ["8[125]"]], ["(\\d{6})", "$1", ["[134]"]], ["(\\d)(\\d{6})", "$1 $2", ["[15]|2[0-79]|3[0-46-8]|4[0-7]"]], ["(\\d)(\\d{7})", "$1 $2", ["(?:2|90)4|[67]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[348]|64|79|90"]], ["(\\d{2})(\\d{5,7})", "$1 $2", ["1|28|6[0-35-9]|77|9[2-9]"]]], "0", 0, 0, 0, 0, 0, [["(?:1\\d|2[0-79]|3[0-46-8]|4[0-7]|5[57-9])\\d{5}|(?:[134]\\d|8[125])\\d{4}", [6, 7]], ["(?:(?:15|(?:3[59]|4[89]|6\\d|7[79]|8[08])\\d|9(?:0\\d|[2-9]))\\d|2(?:4\\d|8))\\d{5}|(?:[67]\\d\\d|904)\\d{5}", [7, 8, 9]]]], SR: ["597", "00", "(?:[2-5]|68|[78]\\d)\\d{5}", [6, 7], [["(\\d{2})(\\d{2})(\\d{2})", "$1-$2-$3", ["56"]], ["(\\d{3})(\\d{3})", "$1-$2", ["[2-5]"]], ["(\\d{3})(\\d{4})", "$1-$2", ["[6-8]"]]], 0, 0, 0, 0, 0, 0, [["(?:2[1-3]|3[0-7]|(?:4|68)\\d|5[2-58])\\d{4}"], ["(?:7[124-7]|8[124-9])\\d{5}", [7]], 0, 0, 0, 0, 0, 0, ["56\\d{4}", [6]]]], SS: ["211", "00", "[19]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[19]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["1[89]\\d{7}"], ["(?:12|9[1257-9])\\d{7}"]]], ST: ["239", "00", "(?:22|9\\d)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[29]"]]], 0, 0, 0, 0, 0, 0, [["22\\d{5}"], ["900[5-9]\\d{3}|9(?:0[1-9]|[89]\\d)\\d{4}"]]], SV: ["503", "00", "[267]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?", [7, 8, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[89]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[267]"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[89]"]]], 0, 0, 0, 0, 0, 0, [["2(?:79(?:0[0347-9]|[1-9]\\d)|89(?:0[024589]|[1-9]\\d))\\d{3}|2(?:[1-69]\\d|[78][0-8])\\d{5}", [8]], ["[67]\\d{7}", [8]], ["800\\d{8}|80[01]\\d{4}", [7, 11]], ["900\\d{4}(?:\\d{4})?", [7, 11]]]], SX: ["1", "011", "7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "(5\\d{6})$|1", "721$1", 0, "721", [["7215(?:4[2-8]|8[239]|9[056])\\d{4}"], ["7215(?:1[02]|2\\d|5[034679]|8[014-8])\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], SY: ["963", "00", "[1-39]\\d{8}|[1-5]\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-5]"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1", 1]], "0", 0, 0, 0, 0, 0, [["21\\d{6,7}|(?:1(?:[14]\\d|[2356])|2[235]|3(?:[13]\\d|4)|4[134]|5[1-3])\\d{6}"], ["9[1-689]\\d{7}", [9]]]], SZ: ["268", "00", "0800\\d{4}|(?:[237]\\d|900)\\d{6}", [8, 9], [["(\\d{4})(\\d{4})", "$1 $2", ["[0237]"]], ["(\\d{5})(\\d{4})", "$1 $2", ["9"]]], 0, 0, 0, 0, 0, 0, [["[23][2-5]\\d{6}", [8]], ["7[6-9]\\d{6}", [8]], ["0800\\d{4}", [8]], ["900\\d{6}", [9]], 0, 0, 0, 0, ["70\\d{6}", [8]]]], TA: ["290", "00", "8\\d{3}", [4], 0, 0, 0, 0, 0, 0, "8", [["8\\d{3}"]]], TC: ["1", "011", "(?:[58]\\d\\d|649|900)\\d{7}", [10], 0, "1", 0, "([2-479]\\d{6})$|1", "649$1", 0, "649", [["649(?:266|712|9(?:4\\d|50))\\d{4}"], ["649(?:2(?:3[129]|4[1-79])|3\\d\\d|4[34][1-3])\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, 0, ["649(?:71[01]|966)\\d{4}"]]], TD: ["235", "00|16", "(?:22|[689]\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[26-9]"]]], 0, 0, 0, 0, 0, 0, [["22(?:[37-9]0|5[0-5]|6[89])\\d{4}"], ["(?:[69]\\d|77|8[56])\\d{6}"]], "00"], TG: ["228", "00", "[279]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[279]"]]], 0, 0, 0, 0, 0, 0, [["2(?:2[2-7]|3[23]|4[45]|55|6[67]|77)\\d{5}"], ["(?:7[019]|9[0-36-9])\\d{6}"]]], TH: ["66", "00[1-9]", "(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}", [8, 9, 10, 13], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[13-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0", 0, 0, 0, 0, 0, [["(?:1[0689]|2\\d|3[2-9]|4[2-5]|5[2-6]|7[3-7])\\d{6}", [8]], ["67(?:1[0-8]|2[4-7])\\d{5}|(?:14|6[1-6]|[89]\\d)\\d{7}", [9]], ["(?:001800\\d|1800)\\d{6}", [10, 13]], ["1900\\d{6}", [10]], 0, 0, 0, 0, ["6[08]\\d{7}", [9]]]], TJ: ["992", "810", "[0-57-9]\\d{8}", [9], [["(\\d{6})(\\d)(\\d{2})", "$1 $2 $3", ["331", "3317"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["44[02-479]|[34]7"]], ["(\\d{4})(\\d)(\\d{4})", "$1 $2 $3", ["3(?:[1245]|3[12])"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[0-57-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:3(?:1[3-5]|2[245]|3[12]|4[24-7]|5[25]|72)|4(?:46|74|87))\\d{6}"], ["(?:33[03-9]|4(?:1[18]|4[02-479])|81[1-9])\\d{6}|(?:0[0-57-9]|1[017]|2[02]|[34]0|5[05]|7[01578]|8[078]|9\\d)\\d{7}"]], "8~10"], TK: ["690", "00", "[2-47]\\d{3,6}", [4, 5, 6, 7], 0, 0, 0, 0, 0, 0, 0, [["(?:2[2-4]|[34]\\d)\\d{2,5}"], ["7[2-4]\\d{2,5}"]]], TL: ["670", "00", "7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-489]|70"]], ["(\\d{4})(\\d{4})", "$1 $2", ["7"]]], 0, 0, 0, 0, 0, 0, [["(?:2[1-5]|3[1-9]|4[1-4])\\d{5}", [7]], ["7[2-8]\\d{6}", [8]], ["80\\d{5}", [7]], ["90\\d{5}", [7]], ["70\\d{5}", [7]]]], TM: ["993", "810", "(?:[1-6]\\d|71)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["12"], "(8 $1)"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-5]"], "(8 $1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[67]"], "8 $1"]], "8", 0, 0, 0, 0, 0, [["(?:1(?:2\\d|3[1-9])|2(?:22|4[0-35-8])|3(?:22|4[03-9])|4(?:22|3[128]|4\\d|6[15])|5(?:22|5[7-9]|6[014-689]))\\d{5}"], ["(?:6\\d|71)\\d{6}"]], "8~10"], TN: ["216", "00", "[2-57-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-57-9]"]]], 0, 0, 0, 0, 0, 0, [["81200\\d{3}|(?:3[0-2]|7\\d)\\d{6}"], ["3(?:001|[12]40)\\d{4}|(?:(?:[259]\\d|4[0-8])\\d|3(?:1[1-35]|6[0-4]|91))\\d{5}"], ["8010\\d{4}"], ["88\\d{6}"], 0, 0, 0, 0, 0, ["8[12]10\\d{4}"]]], TO: ["676", "00", "(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}", [5, 7], [["(\\d{2})(\\d{3})", "$1-$2", ["[2-4]|50|6[09]|7[0-24-69]|8[05]"]], ["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[5-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:2\\d|3[0-8]|4[0-4]|50|6[09]|7[0-24-69]|8[05])\\d{3}", [5]], ["(?:5(?:4[0-5]|5[4-6])|6(?:[09]\\d|3[02]|8[15-9])|(?:7\\d|8[46-9])\\d|999)\\d{4}", [7]], ["0800\\d{3}", [7]], 0, 0, 0, 0, 0, ["55[0-37-9]\\d{4}", [7]]]], TR: ["90", "00", "4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}", [7, 10, 12, 13], [["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["512|8[01589]|90"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5(?:[0-59]|61)", "5(?:[0-59]|61[06])", "5(?:[0-59]|61[06]1)"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24][1-8]|3[1-9]"], "(0$1)", 1], ["(\\d{3})(\\d{3})(\\d{6,7})", "$1 $2 $3", ["80"], "0$1", 1]], "0", 0, 0, 0, 0, 0, [["(?:2(?:[13][26]|[28][2468]|[45][268]|[67][246])|3(?:[13][28]|[24-6][2468]|[78][02468]|92)|4(?:[16][246]|[23578][2468]|4[26]))\\d{7}", [10]], ["561(?:011|61\\d)\\d{4}|5(?:0[15-7]|1[06]|24|[34]\\d|5[1-59]|9[46])\\d{7}", [10]], ["8(?:00\\d{7}(?:\\d{2,3})?|11\\d{7})", [10, 12, 13]], ["(?:8[89]8|900)\\d{7}", [10]], ["592(?:21[12]|461)\\d{4}", [10]], 0, ["444\\d{4}", [7]], ["512\\d{7}", [10]], ["850\\d{7}", [10]]]], TT: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-46-8]\\d{6})$|1", "868$1", 0, "868", [["868(?:2(?:01|1[5-9]|[23]\\d|4[0-2])|6(?:0[7-9]|1[02-8]|2[1-9]|[3-69]\\d|7[0-79])|82[124])\\d{4}"], ["868(?:(?:2[5-9]|3\\d)\\d|4(?:3[0-6]|[6-9]\\d)|6(?:20|78|8\\d)|7(?:0[1-9]|1[02-9]|[2-9]\\d))\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], TV: ["688", "00", "(?:2|7\\d\\d|90)\\d{4}", [5, 6, 7], [["(\\d{2})(\\d{3})", "$1 $2", ["2"]], ["(\\d{2})(\\d{4})", "$1 $2", ["90"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]], 0, 0, 0, 0, 0, 0, [["2[02-9]\\d{3}", [5]], ["(?:7[01]\\d|90)\\d{4}", [6, 7]]]], TW: ["886", "0(?:0[25-79]|19)", "[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}", [7, 8, 9, 10, 11], [["(\\d{2})(\\d)(\\d{4})", "$1 $2 $3", ["202"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[258]0"], "0$1"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]", "[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["7"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2[2-8]\\d|370|55[01]|7[1-9])\\d{6}|4(?:(?:0(?:0[1-9]|[2-48]\\d)|1[023]\\d)\\d{4,5}|(?:[239]\\d\\d|4(?:0[56]|12|49))\\d{5})|6(?:[01]\\d{7}|4(?:0[56]|12|24|4[09])\\d{4,5})|8(?:(?:2(?:3\\d|4[0-269]|[578]0|66)|36[24-9]|90\\d\\d)\\d{4}|4(?:0[56]|12|24|4[09])\\d{4,5})|(?:2(?:2(?:0\\d\\d|4(?:0[68]|[249]0|3[0-467]|5[0-25-9]|6[0235689]))|(?:3(?:[09]\\d|1[0-4])|(?:4\\d|5[0-49]|6[0-29]|7[0-5])\\d)\\d)|(?:(?:3[2-9]|5[2-8]|6[0-35-79]|8[7-9])\\d\\d|4(?:2(?:[089]\\d|7[1-9])|(?:3[0-4]|[78]\\d|9[01])\\d))\\d)\\d{3}", [8, 9]], ["(?:40001[0-2]|9[0-8]\\d{4})\\d{3}", [9]], ["80[0-79]\\d{6}|800\\d{5}", [8, 9]], ["20(?:[013-9]\\d\\d|2)\\d{4}", [7, 9]], ["99\\d{7}", [9]], 0, ["50[0-46-9]\\d{6}", [9]], 0, ["7010(?:[0-2679]\\d|3[0-7]|8[0-5])\\d{5}|70\\d{8}", [10, 11]]], 0, "#"], TZ: ["255", "00[056]", "(?:[25-8]\\d|41|90)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[24]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["5"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[67]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["2[2-8]\\d{7}"], ["(?:6[125-9]|7[13-9])\\d{7}"], ["80[08]\\d{6}"], ["90\\d{7}"], 0, 0, 0, 0, ["41\\d{7}"], ["8(?:40|6[01])\\d{6}"]]], UA: ["380", "00", "[89]\\d{9}|[3-9]\\d{8}", [9, 10], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]", "6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])", "3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|89|9[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:3[1-8]|4[13-8]|5[1-7]|6[12459])\\d{7}", [9]], ["(?:39|50|6[36-8]|7[1-357]|9[1-9])\\d{7}", [9]], ["800[1-8]\\d{5,6}"], ["900[239]\\d{5,6}"], 0, 0, 0, 0, ["89[1-579]\\d{6}", [9]]], "0~0"], UG: ["256", "00[057]", "800\\d{6}|(?:[29]0|[347]\\d)\\d{7}", [9], [["(\\d{4})(\\d{5})", "$1 $2", ["202", "2024"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[27-9]|4(?:6[45]|[7-9])"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[34]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["20(?:(?:240|30[67])\\d|6(?:00[0-2]|30[0-4]))\\d{3}|(?:20(?:[017]\\d|2[5-9]|3[1-4]|5[0-4]|6[15-9])|[34]\\d{3})\\d{5}"], ["72(?:[48]0|6[01])\\d{5}|7(?:[015-8]\\d|20|36|4[0-5]|9[89])\\d{6}"], ["800[1-3]\\d{5}"], ["90[1-3]\\d{6}"]]], US: ["1", "011", "[2-9]\\d{9}|3\\d{6}", [10], [["(\\d{3})(\\d{4})", "$1-$2", ["310"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "($1) $2-$3", ["[2-9]"], 0, 1, "$1-$2-$3"]], "1", 0, 0, 0, 0, 0, [["(?:3052(?:0[0-8]|[1-9]\\d)|5056(?:[0-35-9]\\d|4[468])|7302[0-4]\\d)\\d{4}|(?:305[3-9]|472[24]|505[2-57-9]|7306|983[2-47-9])\\d{6}|(?:2(?:0[1-35-9]|1[02-9]|2[03-57-9]|3[1459]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-47-9]|1[02-9]|2[013569]|3[0-24679]|4[167]|5[0-2]|6[01349]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-47-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|3[016]|4[0156]|5[01679]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-8]|3[1247]|4[037]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[068]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, 0, ["305209\\d{4}"]]], UY: ["598", "0(?:0|1[3-9]\\d)", "0004\\d{2,9}|[1249]\\d{7}|(?:[49]\\d|80)\\d{5}", [6, 7, 8, 9, 10, 11, 12, 13], [["(\\d{3})(\\d{3,4})", "$1 $2", ["0"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[49]0|8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[124]"]], ["(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3 $4", ["0"]]], "0", 0, 0, 0, 0, 0, [["(?:1(?:770|9(?:20|87))|(?:2\\d|4[2-7])\\d\\d)\\d{4}", [8]], ["9[1-9]\\d{6}", [8]], ["0004\\d{2,9}|(?:405|80[05])\\d{4}"], ["90[0-8]\\d{4}", [7]]], "00", " int. "], UZ: ["998", "00", "(?:20|33|[5-79]\\d|88)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[235-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:55\\d\\d|6(?:1(?:22|3[124]|4[1-4]|5[1-3578]|64)|2(?:22|3[0-57-9]|41)|5(?:22|3[3-7]|5[024-8])|6\\d\\d|7(?:[23]\\d|7[69])|9(?:22|4[1-8]|6[135]))|7(?:0(?:5[4-9]|6[0146]|7[124-6]|9[135-8])|(?:1[12]|[68]\\d)\\d|2(?:22|3[13-57-9]|4[1-3579]|5[14])|3(?:2\\d|3[1578]|4[1-35-7]|5[1-57]|61)|4(?:2\\d|3[1-579]|7[1-79])|5(?:22|5[1-9]|6[1457])|9(?:22|5[1-9])))\\d{5}"], ["(?:(?:[25]0|33|88|9[0-57-9])\\d{3}|6(?:1(?:2(?:2[01]|98)|35[0-4]|50\\d|61[23]|7(?:[01][017]|4\\d|55|9[5-9]))|2(?:(?:11|7\\d)\\d|2(?:[12]1|9[01379])|5(?:[126]\\d|3[0-4]))|5(?:19[01]|2(?:27|9[26])|(?:30|59|7\\d)\\d)|6(?:2(?:1[5-9]|2[0367]|38|41|52|60)|(?:3[79]|9[0-3])\\d|4(?:56|83)|7(?:[07]\\d|1[017]|3[07]|4[047]|5[057]|67|8[0178]|9[79]))|7(?:2(?:24|3[237]|4[5-9]|7[15-8])|5(?:7[12]|8[0589])|7(?:0\\d|[39][07])|9(?:0\\d|7[079]))|9(?:2(?:1[1267]|3[01]|5\\d|7[0-4])|(?:5[67]|7\\d)\\d|6(?:2[0-26]|8\\d)))|7(?:[07]\\d{3}|1(?:13[01]|6(?:0[47]|1[67]|66)|71[3-69]|98\\d)|2(?:2(?:2[79]|95)|3(?:2[5-9]|6[0-6])|57\\d|7(?:0\\d|1[17]|2[27]|3[37]|44|5[057]|66|88))|3(?:2(?:1[0-6]|21|3[469]|7[159])|(?:33|9[4-6])\\d|5(?:0[0-4]|5[579]|9\\d)|7(?:[0-3579]\\d|4[0467]|6[67]|8[078]))|4(?:2(?:29|5[0257]|6[0-7]|7[1-57])|5(?:1[0-4]|8\\d|9[5-9])|7(?:0\\d|1[024589]|2[0-27]|3[0137]|[46][07]|5[01]|7[5-9]|9[079])|9(?:7[015-9]|[89]\\d))|5(?:112|2(?:0\\d|2[29]|[49]4)|3[1568]\\d|52[6-9]|7(?:0[01578]|1[017]|[23]7|4[047]|[5-7]\\d|8[78]|9[079]))|9(?:22[128]|3(?:2[0-4]|7\\d)|57[02569]|7(?:2[05-9]|3[37]|4\\d|60|7[2579]|87|9[07]))))\\d{4}"]]], VA: ["39", "00", "0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}", [6, 7, 8, 9, 10, 11], 0, 0, 0, 0, 0, 0, "06698", [["06698\\d{1,6}"], ["3[1-9]\\d{8}|3[2-9]\\d{7}", [9, 10]], ["80(?:0\\d{3}|3)\\d{3}", [6, 9]], ["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}", [6, 8, 9, 10]], ["1(?:78\\d|99)\\d{6}", [9, 10]], 0, 0, 0, ["55\\d{8}", [10]], ["84(?:[08]\\d{3}|[17])\\d{3}", [6, 9]]]], VC: ["1", "011", "(?:[58]\\d\\d|784|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "784$1", 0, "784", [["784(?:266|3(?:6[6-9]|7\\d|8[0-6])|4(?:38|5[0-36-8]|8[0-8])|5(?:55|7[0-2]|93)|638|784)\\d{4}"], ["784(?:4(?:3[0-5]|5[45]|89|9[0-8])|5(?:2[6-9]|3[0-4])|720)\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, 0, ["78451[0-2]\\d{4}"]]], VE: ["58", "00", "[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}", [10], [["(\\d{3})(\\d{7})", "$1-$2", ["[24-689]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2(?:12|3[457-9]|[467]\\d|[58][1-9]|9[1-6])|[4-6]00)\\d{7}"], ["4(?:1[24-8]|2[46])\\d{7}"], ["800\\d{7}"], ["90[01]\\d{7}"], 0, 0, ["501\\d{7}"]]], VG: ["1", "011", "(?:284|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-578]\\d{6})$|1", "284$1", 0, "284", [["284(?:229|4(?:22|9[45])|774|8(?:52|6[459]))\\d{4}"], ["284(?:245|3(?:0[0-3]|4[0-7]|68|9[34])|4(?:4[0-6]|68|9[69])|5(?:4[0-7]|68|9[69]))\\d{4}"], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], VI: ["1", "011", "[58]\\d{9}|(?:34|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "340$1", 0, "340", [["340(?:2(?:0\\d|10|2[06-8]|4[49]|77)|3(?:32|44)|4(?:2[23]|44|7[34]|89)|5(?:1[34]|55)|6(?:2[56]|4[23]|77|9[023])|7(?:1[2-57-9]|2[57]|7\\d)|884|998)\\d{4}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"]]], VN: ["84", "00", "[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["80"], "0$1", 1], ["(\\d{4})(\\d{4,6})", "$1 $2", ["1"], 0, 1], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["6"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[357-9]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["2[48]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["2"], "0$1", 1]], "0", 0, 0, 0, 0, 0, [["2(?:0[3-9]|1[0-689]|2[0-25-9]|[38][2-9]|4[2-8]|5[124-9]|6[0-39]|7[0-7]|9[0-4679])\\d{7}", [10]], ["(?:5(?:2[238]|59)|89[6-9]|99[013-9])\\d{6}|(?:3\\d|5[1689]|7[06-9]|8[1-8]|9[0-8])\\d{7}", [9]], ["1800\\d{4,6}|12(?:0[13]|28)\\d{4}", [8, 9, 10]], ["1900\\d{4,6}", [8, 9, 10]], 0, 0, ["(?:[17]99|80\\d)\\d{4}|69\\d{5,6}", [7, 8]], 0, ["672\\d{6}", [9]]]], VU: ["678", "00", "[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}", [5, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["[57-9]"]]], 0, 0, 0, 0, 0, 0, [["(?:38[0-8]|48[4-9])\\d\\d|(?:2[02-9]|3[4-7]|88)\\d{3}", [5]], ["(?:[58]\\d|7[013-7])\\d{5}", [7]], ["81[18]\\d\\d", [5]], 0, 0, 0, ["(?:3[03]|900\\d)\\d{3}"], 0, ["9(?:0[1-9]|1[01])\\d{4}", [7]]]], WF: ["681", "00", "(?:40|72)\\d{4}|8\\d{5}(?:\\d{3})?", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[478]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]], 0, 0, 0, 0, 0, 0, [["72\\d{4}", [6]], ["(?:72|8[23])\\d{4}", [6]], ["80[0-5]\\d{6}", [9]]]], WS: ["685", "0", "(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}", [5, 6, 7, 10], [["(\\d{5})", "$1", ["[2-5]|6[1-9]"]], ["(\\d{3})(\\d{3,7})", "$1 $2", ["[68]"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]], 0, 0, 0, 0, 0, 0, [["6[1-9]\\d{3}|(?:[2-5]|60)\\d{4}", [5, 6]], ["(?:7[1-35-7]|8(?:[3-7]|9\\d{3}))\\d{5}", [7, 10]], ["800\\d{3}", [6]]]], XK: ["383", "00", "2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2|39"], "0$1"], ["(\\d{2})(\\d{7,10})", "$1 $2", ["3"], "0$1"]], "0", 0, 0, 0, 0, 0, [["38\\d{6,10}|(?:2[89]|39)(?:0\\d{5,6}|[1-9]\\d{5})"], ["4[3-9]\\d{6}", [8]], ["800\\d{5}", [8]], ["900\\d{5}", [8]]]], YE: ["967", "00", "(?:1|7\\d)\\d{7}|[1-7]\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-6]|7(?:[24-6]|8[0-7])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"], "0$1"]], "0", 0, 0, 0, 0, 0, [["78[0-7]\\d{4}|17\\d{6}|(?:[12][2-68]|3[2358]|4[2-58]|5[2-6]|6[3-58]|7[24-6])\\d{5}", [7, 8]], ["7[01378]\\d{7}", [9]]]], YT: ["262", "00", "(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}", [9], 0, "0", 0, 0, 0, 0, 0, [["269(?:0[0-467]|15|5[0-4]|6\\d|[78]0)\\d{4}"], ["639(?:0[0-79]|1[019]|[267]\\d|3[09]|40|5[05-9]|9[04-79])\\d{4}"], ["80\\d{7}"], 0, 0, 0, 0, 0, ["9(?:(?:39|47)8[01]|769\\d)\\d{4}"]]], ZA: ["27", "00", "[1-79]\\d{8}|8\\d{4,9}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,4})", "$1 $2", ["8[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["8[1-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["860"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:2(?:0330|4302)|52087)0\\d{3}|(?:1[0-8]|2[1-378]|3[1-69]|4\\d|5[1346-8])\\d{7}", [9]], ["(?:1(?:3492[0-25]|4495[0235]|549(?:20|5[01]))|4[34]492[01])\\d{3}|8[1-4]\\d{3,7}|(?:2[27]|47|54)4950\\d{3}|(?:1(?:049[2-4]|9[12]\\d\\d)|(?:6\\d|7[0-46-9])\\d{3}|8(?:5\\d{3}|7(?:08[67]|158|28[5-9]|310)))\\d{4}|(?:1[6-8]|28|3[2-69]|4[025689]|5[36-8])4920\\d{3}|(?:12|[2-5]1)492\\d{4}", [5, 6, 7, 8, 9]], ["80\\d{7}", [9]], ["(?:86[2-9]|9[0-2]\\d)\\d{6}", [9]], 0, 0, ["861\\d{6,7}", [9, 10]], 0, ["87(?:08[0-589]|15[0-79]|28[0-4]|31[1-9])\\d{4}|87(?:[02][0-79]|1[0-46-9]|3[02-9]|[4-9]\\d)\\d{5}", [9]], ["860\\d{6}", [9]]]], ZM: ["260", "00", "800\\d{6}|(?:21|63|[79]\\d)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[28]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[79]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["21[1-8]\\d{6}"], ["(?:7[5-79]|9[5-8])\\d{7}"], ["800\\d{6}"], 0, 0, 0, 0, 0, ["63\\d{7}"]]], ZW: ["263", "00", "2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}", [5, 6, 7, 8, 9, 10], [["(\\d{3})(\\d{3,5})", "$1 $2", ["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"], "0$1"], ["(\\d)(\\d{3})(\\d{2,4})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["80"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2", "2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)", "2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["29[013-9]|39|54"], "0$1"], ["(\\d{4})(\\d{3,5})", "$1 $2", ["(?:25|54)8", "258|5483"], "0$1"]], "0", 0, 0, 0, 0, 0, [["(?:1(?:(?:3\\d|9)\\d|[4-8])|2(?:(?:(?:0(?:2[014]|5)|(?:2[0157]|31|84|9)\\d\\d|[56](?:[14]\\d\\d|20)|7(?:[089]|2[03]|[35]\\d\\d))\\d|4(?:2\\d\\d|8))\\d|1(?:2|[39]\\d{4}))|3(?:(?:123|(?:29\\d|92)\\d)\\d\\d|7(?:[19]|[56]\\d))|5(?:0|1[2-478]|26|[37]2|4(?:2\\d{3}|83)|5(?:25\\d\\d|[78])|[689]\\d)|6(?:(?:[16-8]21|28|52[013])\\d\\d|[39])|8(?:[1349]28|523)\\d\\d)\\d{3}|(?:4\\d\\d|9[2-9])\\d{4,5}|(?:(?:2(?:(?:(?:0|8[146])\\d|7[1-7])\\d|2(?:[278]\\d|92)|58(?:2\\d|3))|3(?:[26]|9\\d{3})|5(?:4\\d|5)\\d\\d)\\d|6(?:(?:(?:[0-246]|[78]\\d)\\d|37)\\d|5[2-8]))\\d\\d|(?:2(?:[569]\\d|8[2-57-9])|3(?:[013-59]\\d|8[37])|6[89]8)\\d{3}"], ["7(?:[1278]\\d|3[1-9])\\d{6}", [9]], ["80(?:[01]\\d|20|8[0-8])\\d{3}", [7]], 0, 0, 0, 0, 0, ["86(?:1[12]|22|30|44|55|77|8[368])\\d{6}", [10]]]] }, nonGeographic: { "800": ["800", 0, "(?:00|[1-9]\\d)\\d{6}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["\\d"]]], 0, 0, 0, 0, 0, 0, [0, 0, ["(?:00|[1-9]\\d)\\d{6}"]]], "808": ["808", 0, "[1-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[1-9]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, ["[1-9]\\d{7}"]]], "870": ["870", 0, "7\\d{11}|[35-7]\\d{8}", [9, 12], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[35-7]"]]], 0, 0, 0, 0, 0, 0, [0, ["(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"]]], "878": ["878", 0, "10\\d{10}", [12], [["(\\d{2})(\\d{5})(\\d{5})", "$1 $2 $3", ["1"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["10\\d{10}"]]], "881": ["881", 0, "6\\d{9}|[0-36-9]\\d{8}", [9, 10], [["(\\d)(\\d{3})(\\d{5})", "$1 $2 $3", ["[0-37-9]"]], ["(\\d)(\\d{3})(\\d{5,6})", "$1 $2 $3", ["6"]]], 0, 0, 0, 0, 0, 0, [0, ["6\\d{9}|[0-36-9]\\d{8}"]]], "882": ["882", 0, "[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5})", "$1 $2", ["16|342"]], ["(\\d{2})(\\d{6})", "$1 $2", ["49"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["1[36]|9"]], ["(\\d{2})(\\d{4})(\\d{3})", "$1 $2 $3", ["3[23]"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["16"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|23|3(?:[15]|4[57])|4|51"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["34"]], ["(\\d{2})(\\d{4,5})(\\d{5})", "$1 $2 $3", ["[1-35]"]]], 0, 0, 0, 0, 0, 0, [0, ["342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}", [7, 8, 9, 10, 12]], 0, 0, 0, 0, 0, 0, ["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"]]], "883": ["883", 0, "(?:[1-4]\\d|51)\\d{6,10}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,8})", "$1 $2 $3", ["[14]|2[24-689]|3[02-689]|51[24-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["510"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["21"]], ["(\\d{4})(\\d{4})(\\d{4})", "$1 $2 $3", ["51[13]"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[235]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[0-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"]]], "888": ["888", 0, "\\d{11}", [11], [["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3"]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, ["\\d{11}"]]], "979": ["979", 0, "[1359]\\d{8}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[1359]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, ["[1359]\\d{8}"]]] } };
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/isObject.js
var require_isObject2 = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/isObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = isObject;
    var objectConstructor = {}.constructor;
    function isObject(object) {
      return object !== void 0 && object !== null && object.constructor === objectConstructor;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/normalizeArguments.js
var require_normalizeArguments = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/normalizeArguments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = normalizeArguments;
    var _isObject = _interopRequireDefault(require_isObject2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function normalizeArguments(args) {
      var _Array$prototype$slic = Array.prototype.slice.call(args), _Array$prototype$slic2 = _slicedToArray(_Array$prototype$slic, 4), arg_1 = _Array$prototype$slic2[0], arg_2 = _Array$prototype$slic2[1], arg_3 = _Array$prototype$slic2[2], arg_4 = _Array$prototype$slic2[3];
      var text;
      var options;
      var metadata;
      if (typeof arg_1 === "string") {
        text = arg_1;
      } else throw new TypeError("A text for parsing must be a string.");
      if (!arg_2 || typeof arg_2 === "string") {
        if (arg_4) {
          options = arg_3;
          metadata = arg_4;
        } else {
          options = void 0;
          metadata = arg_3;
        }
        if (arg_2) {
          options = _objectSpread({
            defaultCountry: arg_2
          }, options);
        }
      } else if ((0, _isObject["default"])(arg_2)) {
        if (arg_3) {
          options = arg_2;
          metadata = arg_3;
        } else {
          metadata = arg_2;
        }
      } else throw new Error("Invalid second argument: ".concat(arg_2));
      return {
        text,
        options,
        metadata
      };
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/constants.js
var require_constants7 = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WHITESPACE = exports2.VALID_PUNCTUATION = exports2.VALID_DIGITS = exports2.PLUS_CHARS = exports2.MIN_LENGTH_FOR_NSN = exports2.MAX_LENGTH_FOR_NSN = exports2.MAX_LENGTH_COUNTRY_CODE = void 0;
    var MIN_LENGTH_FOR_NSN = 2;
    exports2.MIN_LENGTH_FOR_NSN = MIN_LENGTH_FOR_NSN;
    var MAX_LENGTH_FOR_NSN = 17;
    exports2.MAX_LENGTH_FOR_NSN = MAX_LENGTH_FOR_NSN;
    var MAX_LENGTH_COUNTRY_CODE = 3;
    exports2.MAX_LENGTH_COUNTRY_CODE = MAX_LENGTH_COUNTRY_CODE;
    var VALID_DIGITS = "0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9";
    exports2.VALID_DIGITS = VALID_DIGITS;
    var DASHES = "-\u2010-\u2015\u2212\u30FC\uFF0D";
    var SLASHES = "\uFF0F/";
    var DOTS = "\uFF0E.";
    var WHITESPACE = " \xA0\xAD\u200B\u2060\u3000";
    exports2.WHITESPACE = WHITESPACE;
    var BRACKETS = "()\uFF08\uFF09\uFF3B\uFF3D\\[\\]";
    var TILDES = "~\u2053\u223C\uFF5E";
    var VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
    exports2.VALID_PUNCTUATION = VALID_PUNCTUATION;
    var PLUS_CHARS = "+\uFF0B";
    exports2.PLUS_CHARS = PLUS_CHARS;
  }
});

// asset-input/node_modules/libphonenumber-js/build/ParseError.js
var require_ParseError = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/ParseError.js"(exports2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var ParseError = /* @__PURE__ */ function(_Error) {
      _inherits(ParseError2, _Error);
      var _super = _createSuper(ParseError2);
      function ParseError2(code) {
        var _this;
        _classCallCheck(this, ParseError2);
        _this = _super.call(this, code);
        Object.setPrototypeOf(_assertThisInitialized(_this), ParseError2.prototype);
        _this.name = _this.constructor.name;
        return _this;
      }
      return _createClass(ParseError2);
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    exports2["default"] = ParseError;
  }
});

// asset-input/node_modules/libphonenumber-js/build/tools/semver-compare.js
var require_semver_compare = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/tools/semver-compare.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = _default;
    function _default(a, b) {
      a = a.split("-");
      b = b.split("-");
      var pa = a[0].split(".");
      var pb = b[0].split(".");
      for (var i = 0; i < 3; i++) {
        var na = Number(pa[i]);
        var nb = Number(pb[i]);
        if (na > nb) return 1;
        if (nb > na) return -1;
        if (!isNaN(na) && isNaN(nb)) return 1;
        if (isNaN(na) && !isNaN(nb)) return -1;
      }
      if (a[1] && b[1]) {
        return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
      }
      return !a[1] && b[1] ? 1 : a[1] && !b[1] ? -1 : 0;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/metadata.js
var require_metadata = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    exports2.getCountryCallingCode = getCountryCallingCode;
    exports2.getExtPrefix = getExtPrefix;
    exports2.isSupportedCountry = isSupportedCountry;
    exports2.validateMetadata = validateMetadata;
    var _semverCompare = _interopRequireDefault(require_semver_compare());
    var _isObject = _interopRequireDefault(require_isObject2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var V3 = "1.2.0";
    var V4 = "1.7.35";
    var DEFAULT_EXT_PREFIX = " ext. ";
    var CALLING_CODE_REG_EXP = /^\d+$/;
    var Metadata = /* @__PURE__ */ function() {
      function Metadata2(metadata) {
        _classCallCheck(this, Metadata2);
        validateMetadata(metadata);
        this.metadata = metadata;
        setVersion.call(this, metadata);
      }
      _createClass(Metadata2, [{
        key: "getCountries",
        value: function getCountries() {
          return Object.keys(this.metadata.countries).filter(function(_) {
            return _ !== "001";
          });
        }
      }, {
        key: "getCountryMetadata",
        value: function getCountryMetadata(countryCode) {
          return this.metadata.countries[countryCode];
        }
      }, {
        key: "nonGeographic",
        value: function nonGeographic() {
          if (this.v1 || this.v2 || this.v3) return;
          return this.metadata.nonGeographic || this.metadata.nonGeographical;
        }
      }, {
        key: "hasCountry",
        value: function hasCountry(country2) {
          return this.getCountryMetadata(country2) !== void 0;
        }
      }, {
        key: "hasCallingCode",
        value: function hasCallingCode(callingCode) {
          if (this.getCountryCodesForCallingCode(callingCode)) {
            return true;
          }
          if (this.nonGeographic()) {
            if (this.nonGeographic()[callingCode]) {
              return true;
            }
          } else {
            var countryCodes = this.countryCallingCodes()[callingCode];
            if (countryCodes && countryCodes.length === 1 && countryCodes[0] === "001") {
              return true;
            }
          }
        }
      }, {
        key: "isNonGeographicCallingCode",
        value: function isNonGeographicCallingCode(callingCode) {
          if (this.nonGeographic()) {
            return this.nonGeographic()[callingCode] ? true : false;
          } else {
            return this.getCountryCodesForCallingCode(callingCode) ? false : true;
          }
        }
        // Deprecated.
      }, {
        key: "country",
        value: function country2(countryCode) {
          return this.selectNumberingPlan(countryCode);
        }
      }, {
        key: "selectNumberingPlan",
        value: function selectNumberingPlan(countryCode, callingCode) {
          if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {
            callingCode = countryCode;
            countryCode = null;
          }
          if (countryCode && countryCode !== "001") {
            if (!this.hasCountry(countryCode)) {
              throw new Error("Unknown country: ".concat(countryCode));
            }
            this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
          } else if (callingCode) {
            if (!this.hasCallingCode(callingCode)) {
              throw new Error("Unknown calling code: ".concat(callingCode));
            }
            this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
          } else {
            this.numberingPlan = void 0;
          }
          return this;
        }
      }, {
        key: "getCountryCodesForCallingCode",
        value: function getCountryCodesForCallingCode(callingCode) {
          var countryCodes = this.countryCallingCodes()[callingCode];
          if (countryCodes) {
            if (countryCodes.length === 1 && countryCodes[0].length === 3) {
              return;
            }
            return countryCodes;
          }
        }
      }, {
        key: "getCountryCodeForCallingCode",
        value: function getCountryCodeForCallingCode(callingCode) {
          var countryCodes = this.getCountryCodesForCallingCode(callingCode);
          if (countryCodes) {
            return countryCodes[0];
          }
        }
      }, {
        key: "getNumberingPlanMetadata",
        value: function getNumberingPlanMetadata(callingCode) {
          var countryCode = this.getCountryCodeForCallingCode(callingCode);
          if (countryCode) {
            return this.getCountryMetadata(countryCode);
          }
          if (this.nonGeographic()) {
            var metadata = this.nonGeographic()[callingCode];
            if (metadata) {
              return metadata;
            }
          } else {
            var countryCodes = this.countryCallingCodes()[callingCode];
            if (countryCodes && countryCodes.length === 1 && countryCodes[0] === "001") {
              return this.metadata.countries["001"];
            }
          }
        }
        // Deprecated.
      }, {
        key: "countryCallingCode",
        value: function countryCallingCode() {
          return this.numberingPlan.callingCode();
        }
        // Deprecated.
      }, {
        key: "IDDPrefix",
        value: function IDDPrefix() {
          return this.numberingPlan.IDDPrefix();
        }
        // Deprecated.
      }, {
        key: "defaultIDDPrefix",
        value: function defaultIDDPrefix() {
          return this.numberingPlan.defaultIDDPrefix();
        }
        // Deprecated.
      }, {
        key: "nationalNumberPattern",
        value: function nationalNumberPattern() {
          return this.numberingPlan.nationalNumberPattern();
        }
        // Deprecated.
      }, {
        key: "possibleLengths",
        value: function possibleLengths() {
          return this.numberingPlan.possibleLengths();
        }
        // Deprecated.
      }, {
        key: "formats",
        value: function formats() {
          return this.numberingPlan.formats();
        }
        // Deprecated.
      }, {
        key: "nationalPrefixForParsing",
        value: function nationalPrefixForParsing() {
          return this.numberingPlan.nationalPrefixForParsing();
        }
        // Deprecated.
      }, {
        key: "nationalPrefixTransformRule",
        value: function nationalPrefixTransformRule() {
          return this.numberingPlan.nationalPrefixTransformRule();
        }
        // Deprecated.
      }, {
        key: "leadingDigits",
        value: function leadingDigits() {
          return this.numberingPlan.leadingDigits();
        }
        // Deprecated.
      }, {
        key: "hasTypes",
        value: function hasTypes() {
          return this.numberingPlan.hasTypes();
        }
        // Deprecated.
      }, {
        key: "type",
        value: function type(_type) {
          return this.numberingPlan.type(_type);
        }
        // Deprecated.
      }, {
        key: "ext",
        value: function ext() {
          return this.numberingPlan.ext();
        }
      }, {
        key: "countryCallingCodes",
        value: function countryCallingCodes() {
          if (this.v1) return this.metadata.country_phone_code_to_countries;
          return this.metadata.country_calling_codes;
        }
        // Deprecated.
      }, {
        key: "chooseCountryByCountryCallingCode",
        value: function chooseCountryByCountryCallingCode(callingCode) {
          return this.selectNumberingPlan(callingCode);
        }
      }, {
        key: "hasSelectedNumberingPlan",
        value: function hasSelectedNumberingPlan() {
          return this.numberingPlan !== void 0;
        }
      }]);
      return Metadata2;
    }();
    exports2["default"] = Metadata;
    var NumberingPlan = /* @__PURE__ */ function() {
      function NumberingPlan2(metadata, globalMetadataObject) {
        _classCallCheck(this, NumberingPlan2);
        this.globalMetadataObject = globalMetadataObject;
        this.metadata = metadata;
        setVersion.call(this, globalMetadataObject.metadata);
      }
      _createClass(NumberingPlan2, [{
        key: "callingCode",
        value: function callingCode() {
          return this.metadata[0];
        }
        // Formatting information for regions which share
        // a country calling code is contained by only one region
        // for performance reasons. For example, for NANPA region
        // ("North American Numbering Plan Administration",
        //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
        // it will be contained in the metadata for `US`.
      }, {
        key: "getDefaultCountryMetadataForRegion",
        value: function getDefaultCountryMetadataForRegion() {
          return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
        }
        // Is always present.
      }, {
        key: "IDDPrefix",
        value: function IDDPrefix() {
          if (this.v1 || this.v2) return;
          return this.metadata[1];
        }
        // Is only present when a country supports multiple IDD prefixes.
      }, {
        key: "defaultIDDPrefix",
        value: function defaultIDDPrefix() {
          if (this.v1 || this.v2) return;
          return this.metadata[12];
        }
      }, {
        key: "nationalNumberPattern",
        value: function nationalNumberPattern() {
          if (this.v1 || this.v2) return this.metadata[1];
          return this.metadata[2];
        }
        // "possible length" data is always present in Google's metadata.
      }, {
        key: "possibleLengths",
        value: function possibleLengths() {
          if (this.v1) return;
          return this.metadata[this.v2 ? 2 : 3];
        }
      }, {
        key: "_getFormats",
        value: function _getFormats(metadata) {
          return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
        }
        // For countries of the same region (e.g. NANPA)
        // formats are all stored in the "main" country for that region.
        // E.g. "RU" and "KZ", "US" and "CA".
      }, {
        key: "formats",
        value: function formats() {
          var _this = this;
          var formats2 = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
          return formats2.map(function(_) {
            return new Format(_, _this);
          });
        }
      }, {
        key: "nationalPrefix",
        value: function nationalPrefix() {
          return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
        }
      }, {
        key: "_getNationalPrefixFormattingRule",
        value: function _getNationalPrefixFormattingRule(metadata) {
          return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
        }
        // For countries of the same region (e.g. NANPA)
        // national prefix formatting rule is stored in the "main" country for that region.
        // E.g. "RU" and "KZ", "US" and "CA".
      }, {
        key: "nationalPrefixFormattingRule",
        value: function nationalPrefixFormattingRule() {
          return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
        }
      }, {
        key: "_nationalPrefixForParsing",
        value: function _nationalPrefixForParsing() {
          return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
        }
      }, {
        key: "nationalPrefixForParsing",
        value: function nationalPrefixForParsing() {
          return this._nationalPrefixForParsing() || this.nationalPrefix();
        }
      }, {
        key: "nationalPrefixTransformRule",
        value: function nationalPrefixTransformRule() {
          return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
        }
      }, {
        key: "_getNationalPrefixIsOptionalWhenFormatting",
        value: function _getNationalPrefixIsOptionalWhenFormatting() {
          return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
        }
        // For countries of the same region (e.g. NANPA)
        // "national prefix is optional when formatting" flag is
        // stored in the "main" country for that region.
        // E.g. "RU" and "KZ", "US" and "CA".
      }, {
        key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
        value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
          return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
        }
      }, {
        key: "leadingDigits",
        value: function leadingDigits() {
          return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
        }
      }, {
        key: "types",
        value: function types() {
          return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
        }
      }, {
        key: "hasTypes",
        value: function hasTypes() {
          if (this.types() && this.types().length === 0) {
            return false;
          }
          return !!this.types();
        }
      }, {
        key: "type",
        value: function type(_type2) {
          if (this.hasTypes() && getType(this.types(), _type2)) {
            return new Type(getType(this.types(), _type2), this);
          }
        }
      }, {
        key: "ext",
        value: function ext() {
          if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;
          return this.metadata[13] || DEFAULT_EXT_PREFIX;
        }
      }]);
      return NumberingPlan2;
    }();
    var Format = /* @__PURE__ */ function() {
      function Format2(format, metadata) {
        _classCallCheck(this, Format2);
        this._format = format;
        this.metadata = metadata;
      }
      _createClass(Format2, [{
        key: "pattern",
        value: function pattern() {
          return this._format[0];
        }
      }, {
        key: "format",
        value: function format() {
          return this._format[1];
        }
      }, {
        key: "leadingDigitsPatterns",
        value: function leadingDigitsPatterns() {
          return this._format[2] || [];
        }
      }, {
        key: "nationalPrefixFormattingRule",
        value: function nationalPrefixFormattingRule() {
          return this._format[3] || this.metadata.nationalPrefixFormattingRule();
        }
      }, {
        key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
        value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
          return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
        }
      }, {
        key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
        value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
          return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
        }
        // Checks whether national prefix formatting rule contains national prefix.
      }, {
        key: "usesNationalPrefix",
        value: function usesNationalPrefix() {
          return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
          !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) ? true : false;
        }
      }, {
        key: "internationalFormat",
        value: function internationalFormat() {
          return this._format[5] || this.format();
        }
      }]);
      return Format2;
    }();
    var FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;
    var Type = /* @__PURE__ */ function() {
      function Type2(type, metadata) {
        _classCallCheck(this, Type2);
        this.type = type;
        this.metadata = metadata;
      }
      _createClass(Type2, [{
        key: "pattern",
        value: function pattern() {
          if (this.metadata.v1) return this.type;
          return this.type[0];
        }
      }, {
        key: "possibleLengths",
        value: function possibleLengths() {
          if (this.metadata.v1) return;
          return this.type[1] || this.metadata.possibleLengths();
        }
      }]);
      return Type2;
    }();
    function getType(types, type) {
      switch (type) {
        case "FIXED_LINE":
          return types[0];
        case "MOBILE":
          return types[1];
        case "TOLL_FREE":
          return types[2];
        case "PREMIUM_RATE":
          return types[3];
        case "PERSONAL_NUMBER":
          return types[4];
        case "VOICEMAIL":
          return types[5];
        case "UAN":
          return types[6];
        case "PAGER":
          return types[7];
        case "VOIP":
          return types[8];
        case "SHARED_COST":
          return types[9];
      }
    }
    function validateMetadata(metadata) {
      if (!metadata) {
        throw new Error("[libphonenumber-js] `metadata` argument not passed. Check your arguments.");
      }
      if (!(0, _isObject["default"])(metadata) || !(0, _isObject["default"])(metadata.countries)) {
        throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat((0, _isObject["default"])(metadata) ? "an object of shape: { " + Object.keys(metadata).join(", ") + " }" : "a " + typeOf(metadata) + ": " + metadata, "."));
      }
    }
    var typeOf = function typeOf2(_) {
      return _typeof(_);
    };
    function getExtPrefix(country2, metadata) {
      metadata = new Metadata(metadata);
      if (metadata.hasCountry(country2)) {
        return metadata.country(country2).ext();
      }
      return DEFAULT_EXT_PREFIX;
    }
    function getCountryCallingCode(country2, metadata) {
      metadata = new Metadata(metadata);
      if (metadata.hasCountry(country2)) {
        return metadata.country(country2).countryCallingCode();
      }
      throw new Error("Unknown country: ".concat(country2));
    }
    function isSupportedCountry(country2, metadata) {
      return metadata.countries.hasOwnProperty(country2);
    }
    function setVersion(metadata) {
      var version = metadata.version;
      if (typeof version === "number") {
        this.v1 = version === 1;
        this.v2 = version === 2;
        this.v3 = version === 3;
        this.v4 = version === 4;
      } else {
        if (!version) {
          this.v1 = true;
        } else if ((0, _semverCompare["default"])(version, V3) === -1) {
          this.v2 = true;
        } else if ((0, _semverCompare["default"])(version, V4) === -1) {
          this.v3 = true;
        } else {
          this.v4 = true;
        }
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extension/createExtensionPattern.js
var require_createExtensionPattern = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extension/createExtensionPattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = createExtensionPattern;
    var _constants = require_constants7();
    var RFC3966_EXTN_PREFIX = ";ext=";
    var getExtensionDigitsPattern = function getExtensionDigitsPattern2(maxLength) {
      return "([".concat(_constants.VALID_DIGITS, "]{1,").concat(maxLength, "})");
    };
    function createExtensionPattern(purpose) {
      var extLimitAfterExplicitLabel = "20";
      var extLimitAfterLikelyLabel = "15";
      var extLimitAfterAmbiguousChar = "9";
      var extLimitWhenNotSure = "6";
      var possibleSeparatorsBetweenNumberAndExtLabel = "[ \xA0\\t,]*";
      var possibleCharsAfterExtLabel = "[:\\.\uFF0E]?[ \xA0\\t,-]*";
      var optionalExtnSuffix = "#?";
      var explicitExtLabels = "(?:e?xt(?:ensi(?:o\u0301?|\xF3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|\u0434\u043E\u0431|anexo)";
      var ambiguousExtLabels = "(?:[x\uFF58#\uFF03~\uFF5E]|int|\uFF49\uFF4E\uFF54)";
      var ambiguousSeparator = "[- ]+";
      var possibleSeparatorsNumberExtLabelNoComma = "[ \xA0\\t]*";
      var autoDiallingAndExtLabelsFound = "(?:,{2}|;)";
      var rfcExtn = RFC3966_EXTN_PREFIX + getExtensionDigitsPattern(extLimitAfterExplicitLabel);
      var explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterExplicitLabel) + optionalExtnSuffix;
      var ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
      var americanStyleExtnWithSuffix = ambiguousSeparator + getExtensionDigitsPattern(extLimitWhenNotSure) + "#";
      var autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterLikelyLabel) + optionalExtnSuffix;
      var onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma + "(?:,)+" + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
      return rfcExtn + "|" + explicitExtn + "|" + ambiguousExtn + "|" + americanStyleExtnWithSuffix + "|" + autoDiallingExtn + "|" + onlyCommasExtn;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/isViablePhoneNumber.js
var require_isViablePhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/isViablePhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VALID_PHONE_NUMBER_WITH_EXTENSION = exports2.VALID_PHONE_NUMBER = void 0;
    exports2["default"] = isViablePhoneNumber;
    exports2.isViablePhoneNumberStart = isViablePhoneNumberStart;
    var _constants = require_constants7();
    var _createExtensionPattern = _interopRequireDefault(require_createExtensionPattern());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var MIN_LENGTH_PHONE_NUMBER_PATTERN = "[" + _constants.VALID_DIGITS + "]{" + _constants.MIN_LENGTH_FOR_NSN + "}";
    var VALID_PHONE_NUMBER = "[" + _constants.PLUS_CHARS + "]{0,1}(?:[" + _constants.VALID_PUNCTUATION + "]*[" + _constants.VALID_DIGITS + "]){3,}[" + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + "]*";
    exports2.VALID_PHONE_NUMBER = VALID_PHONE_NUMBER;
    var VALID_PHONE_NUMBER_START_REG_EXP = new RegExp("^[" + _constants.PLUS_CHARS + "]{0,1}(?:[" + _constants.VALID_PUNCTUATION + "]*[" + _constants.VALID_DIGITS + "]){1,2}$", "i");
    var VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER + // Phone number extensions
    "(?:" + (0, _createExtensionPattern["default"])() + ")?";
    exports2.VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER_WITH_EXTENSION;
    var VALID_PHONE_NUMBER_PATTERN = new RegExp(
      // Either a short two-digit-only phone number
      "^" + MIN_LENGTH_PHONE_NUMBER_PATTERN + "$|^" + VALID_PHONE_NUMBER_WITH_EXTENSION + "$",
      "i"
    );
    function isViablePhoneNumber(number) {
      return number.length >= _constants.MIN_LENGTH_FOR_NSN && VALID_PHONE_NUMBER_PATTERN.test(number);
    }
    function isViablePhoneNumberStart(number) {
      return VALID_PHONE_NUMBER_START_REG_EXP.test(number);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extension/extractExtension.js
var require_extractExtension = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extension/extractExtension.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = extractExtension;
    var _createExtensionPattern = _interopRequireDefault(require_createExtensionPattern());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var EXTN_PATTERN = new RegExp("(?:" + (0, _createExtensionPattern["default"])() + ")$", "i");
    function extractExtension(number) {
      var start = number.search(EXTN_PATTERN);
      if (start < 0) {
        return {};
      }
      var numberWithoutExtension = number.slice(0, start);
      var matches = number.match(EXTN_PATTERN);
      var i = 1;
      while (i < matches.length) {
        if (matches[i]) {
          return {
            number: numberWithoutExtension,
            ext: matches[i]
          };
        }
        i++;
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/parseDigits.js
var require_parseDigits = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/parseDigits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DIGITS = void 0;
    exports2["default"] = parseDigits;
    exports2.parseDigit = parseDigit;
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var DIGITS = {
      "0": "0",
      "1": "1",
      "2": "2",
      "3": "3",
      "4": "4",
      "5": "5",
      "6": "6",
      "7": "7",
      "8": "8",
      "9": "9",
      "\uFF10": "0",
      // Fullwidth digit 0
      "\uFF11": "1",
      // Fullwidth digit 1
      "\uFF12": "2",
      // Fullwidth digit 2
      "\uFF13": "3",
      // Fullwidth digit 3
      "\uFF14": "4",
      // Fullwidth digit 4
      "\uFF15": "5",
      // Fullwidth digit 5
      "\uFF16": "6",
      // Fullwidth digit 6
      "\uFF17": "7",
      // Fullwidth digit 7
      "\uFF18": "8",
      // Fullwidth digit 8
      "\uFF19": "9",
      // Fullwidth digit 9
      "\u0660": "0",
      // Arabic-indic digit 0
      "\u0661": "1",
      // Arabic-indic digit 1
      "\u0662": "2",
      // Arabic-indic digit 2
      "\u0663": "3",
      // Arabic-indic digit 3
      "\u0664": "4",
      // Arabic-indic digit 4
      "\u0665": "5",
      // Arabic-indic digit 5
      "\u0666": "6",
      // Arabic-indic digit 6
      "\u0667": "7",
      // Arabic-indic digit 7
      "\u0668": "8",
      // Arabic-indic digit 8
      "\u0669": "9",
      // Arabic-indic digit 9
      "\u06F0": "0",
      // Eastern-Arabic digit 0
      "\u06F1": "1",
      // Eastern-Arabic digit 1
      "\u06F2": "2",
      // Eastern-Arabic digit 2
      "\u06F3": "3",
      // Eastern-Arabic digit 3
      "\u06F4": "4",
      // Eastern-Arabic digit 4
      "\u06F5": "5",
      // Eastern-Arabic digit 5
      "\u06F6": "6",
      // Eastern-Arabic digit 6
      "\u06F7": "7",
      // Eastern-Arabic digit 7
      "\u06F8": "8",
      // Eastern-Arabic digit 8
      "\u06F9": "9"
      // Eastern-Arabic digit 9
    };
    exports2.DIGITS = DIGITS;
    function parseDigit(character) {
      return DIGITS[character];
    }
    function parseDigits(string) {
      var result = "";
      for (var _iterator = _createForOfIteratorHelperLoose(string.split("")), _step; !(_step = _iterator()).done; ) {
        var character = _step.value;
        var digit = parseDigit(character);
        if (digit) {
          result += digit;
        }
      }
      return result;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/parseIncompletePhoneNumber.js
var require_parseIncompletePhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/parseIncompletePhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = parseIncompletePhoneNumber;
    exports2.parsePhoneNumberCharacter = parsePhoneNumberCharacter;
    var _parseDigits = require_parseDigits();
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function parseIncompletePhoneNumber(string) {
      var result = "";
      for (var _iterator = _createForOfIteratorHelperLoose(string.split("")), _step; !(_step = _iterator()).done; ) {
        var character = _step.value;
        result += parsePhoneNumberCharacter(character, result) || "";
      }
      return result;
    }
    function parsePhoneNumberCharacter(character, prevParsedCharacters, emitEvent) {
      if (character === "+") {
        if (prevParsedCharacters) {
          if (typeof emitEvent === "function") {
            emitEvent("end");
          }
          return;
        }
        return "+";
      }
      return (0, _parseDigits.parseDigit)(character);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/getCountryCallingCode.js
var require_getCountryCallingCode = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/getCountryCallingCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "default", {
      enumerable: true,
      get: function get() {
        return _metadata.getCountryCallingCode;
      }
    });
    var _metadata = require_metadata();
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/mergeArrays.js
var require_mergeArrays = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/mergeArrays.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = mergeArrays;
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function mergeArrays(a, b) {
      var merged = a.slice();
      for (var _iterator = _createForOfIteratorHelperLoose(b), _step; !(_step = _iterator()).done; ) {
        var element = _step.value;
        if (a.indexOf(element) < 0) {
          merged.push(element);
        }
      }
      return merged.sort(function(a2, b2) {
        return a2 - b2;
      });
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/checkNumberLength.js
var require_checkNumberLength = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/checkNumberLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.checkNumberLengthForType = checkNumberLengthForType;
    exports2["default"] = checkNumberLength;
    var _mergeArrays = _interopRequireDefault(require_mergeArrays());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function checkNumberLength(nationalNumber, metadata) {
      return checkNumberLengthForType(nationalNumber, void 0, metadata);
    }
    function checkNumberLengthForType(nationalNumber, type, metadata) {
      var type_info = metadata.type(type);
      var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();
      if (!possible_lengths) {
        return "IS_POSSIBLE";
      }
      if (type === "FIXED_LINE_OR_MOBILE") {
        if (!metadata.type("FIXED_LINE")) {
          return checkNumberLengthForType(nationalNumber, "MOBILE", metadata);
        }
        var mobile_type = metadata.type("MOBILE");
        if (mobile_type) {
          possible_lengths = (0, _mergeArrays["default"])(possible_lengths, mobile_type.possibleLengths());
        }
      } else if (type && !type_info) {
        return "INVALID_LENGTH";
      }
      var actual_length = nationalNumber.length;
      var minimum_length = possible_lengths[0];
      if (minimum_length === actual_length) {
        return "IS_POSSIBLE";
      }
      if (minimum_length > actual_length) {
        return "TOO_SHORT";
      }
      if (possible_lengths[possible_lengths.length - 1] < actual_length) {
        return "TOO_LONG";
      }
      return possible_lengths.indexOf(actual_length, 1) >= 0 ? "IS_POSSIBLE" : "INVALID_LENGTH";
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/isPossible.js
var require_isPossible = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/isPossible.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = isPossiblePhoneNumber;
    exports2.isPossibleNumber = isPossibleNumber;
    var _metadata = _interopRequireDefault(require_metadata());
    var _checkNumberLength = _interopRequireDefault(require_checkNumberLength());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function isPossiblePhoneNumber(input, options, metadata) {
      if (options === void 0) {
        options = {};
      }
      metadata = new _metadata["default"](metadata);
      if (options.v2) {
        if (!input.countryCallingCode) {
          throw new Error("Invalid phone number object passed");
        }
        metadata.selectNumberingPlan(input.countryCallingCode);
      } else {
        if (!input.phone) {
          return false;
        }
        if (input.country) {
          if (!metadata.hasCountry(input.country)) {
            throw new Error("Unknown country: ".concat(input.country));
          }
          metadata.country(input.country);
        } else {
          if (!input.countryCallingCode) {
            throw new Error("Invalid phone number object passed");
          }
          metadata.selectNumberingPlan(input.countryCallingCode);
        }
      }
      if (metadata.possibleLengths()) {
        return isPossibleNumber(input.phone || input.nationalNumber, metadata);
      } else {
        if (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {
          return true;
        } else {
          throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
        }
      }
    }
    function isPossibleNumber(nationalNumber, metadata) {
      switch ((0, _checkNumberLength["default"])(nationalNumber, metadata)) {
        case "IS_POSSIBLE":
          return true;
        default:
          return false;
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/matchesEntirely.js
var require_matchesEntirely = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/matchesEntirely.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = matchesEntirely;
    function matchesEntirely(text, regular_expression) {
      text = text || "";
      return new RegExp("^(?:" + regular_expression + ")$").test(text);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/getNumberType.js
var require_getNumberType = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/getNumberType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getNumberType;
    exports2.isNumberTypeEqualTo = isNumberTypeEqualTo;
    var _metadata = _interopRequireDefault(require_metadata());
    var _matchesEntirely = _interopRequireDefault(require_matchesEntirely());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var NON_FIXED_LINE_PHONE_TYPES = ["MOBILE", "PREMIUM_RATE", "TOLL_FREE", "SHARED_COST", "VOIP", "PERSONAL_NUMBER", "PAGER", "UAN", "VOICEMAIL"];
    function getNumberType(input, options, metadata) {
      options = options || {};
      if (!input.country && !input.countryCallingCode) {
        return;
      }
      metadata = new _metadata["default"](metadata);
      metadata.selectNumberingPlan(input.country, input.countryCallingCode);
      var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
      if (!(0, _matchesEntirely["default"])(nationalNumber, metadata.nationalNumberPattern())) {
        return;
      }
      if (isNumberTypeEqualTo(nationalNumber, "FIXED_LINE", metadata)) {
        if (metadata.type("MOBILE") && metadata.type("MOBILE").pattern() === "") {
          return "FIXED_LINE_OR_MOBILE";
        }
        if (!metadata.type("MOBILE")) {
          return "FIXED_LINE_OR_MOBILE";
        }
        if (isNumberTypeEqualTo(nationalNumber, "MOBILE", metadata)) {
          return "FIXED_LINE_OR_MOBILE";
        }
        return "FIXED_LINE";
      }
      for (var _iterator = _createForOfIteratorHelperLoose(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done; ) {
        var type = _step.value;
        if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {
          return type;
        }
      }
    }
    function isNumberTypeEqualTo(nationalNumber, type, metadata) {
      type = metadata.type(type);
      if (!type || !type.pattern()) {
        return false;
      }
      if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
        return false;
      }
      return (0, _matchesEntirely["default"])(nationalNumber, type.pattern());
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/isValid.js
var require_isValid = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/isValid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = isValidNumber;
    var _metadata = _interopRequireDefault(require_metadata());
    var _matchesEntirely = _interopRequireDefault(require_matchesEntirely());
    var _getNumberType = _interopRequireDefault(require_getNumberType());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function isValidNumber(input, options, metadata) {
      options = options || {};
      metadata = new _metadata["default"](metadata);
      metadata.selectNumberingPlan(input.country, input.countryCallingCode);
      if (metadata.hasTypes()) {
        return (0, _getNumberType["default"])(input, options, metadata.metadata) !== void 0;
      }
      var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
      return (0, _matchesEntirely["default"])(nationalNumber, metadata.nationalNumberPattern());
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/getPossibleCountriesForNumber.js
var require_getPossibleCountriesForNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/getPossibleCountriesForNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getPossibleCountriesForNumber;
    var _metadata2 = _interopRequireDefault(require_metadata());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {
      var _metadata = new _metadata2["default"](metadata);
      var possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode);
      if (!possibleCountries) {
        return [];
      }
      return possibleCountries.filter(function(country2) {
        return couldNationalNumberBelongToCountry(nationalNumber, country2, metadata);
      });
    }
    function couldNationalNumberBelongToCountry(nationalNumber, country2, metadata) {
      var _metadata = new _metadata2["default"](metadata);
      _metadata.selectNumberingPlan(country2);
      if (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {
        return true;
      }
      return false;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/applyInternationalSeparatorStyle.js
var require_applyInternationalSeparatorStyle = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/applyInternationalSeparatorStyle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = applyInternationalSeparatorStyle;
    var _constants = require_constants7();
    function applyInternationalSeparatorStyle(formattedNumber) {
      return formattedNumber.replace(new RegExp("[".concat(_constants.VALID_PUNCTUATION, "]+"), "g"), " ").trim();
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/formatNationalNumberUsingFormat.js
var require_formatNationalNumberUsingFormat = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/formatNationalNumberUsingFormat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FIRST_GROUP_PATTERN = void 0;
    exports2["default"] = formatNationalNumberUsingFormat;
    var _applyInternationalSeparatorStyle = _interopRequireDefault(require_applyInternationalSeparatorStyle());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var FIRST_GROUP_PATTERN = /(\$\d)/;
    exports2.FIRST_GROUP_PATTERN = FIRST_GROUP_PATTERN;
    function formatNationalNumberUsingFormat(number, format, _ref) {
      var useInternationalFormat = _ref.useInternationalFormat, withNationalPrefix = _ref.withNationalPrefix, carrierCode = _ref.carrierCode, metadata = _ref.metadata;
      var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalFormat ? format.internationalFormat() : (
        // This library doesn't use `domestic_carrier_code_formatting_rule`,
        // because that one is only used when formatting phone numbers
        // for dialing from a mobile phone, and this is not a dialing library.
        // carrierCode && format.domesticCarrierCodeFormattingRule()
        // 	// First, replace the $CC in the formatting rule with the desired carrier code.
        // 	// Then, replace the $FG in the formatting rule with the first group
        // 	// and the carrier code combined in the appropriate way.
        // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
        // 	: (
        // 		withNationalPrefix && format.nationalPrefixFormattingRule()
        // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
        // 			: format.format()
        // 	)
        withNationalPrefix && format.nationalPrefixFormattingRule() ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format()
      ));
      if (useInternationalFormat) {
        return (0, _applyInternationalSeparatorStyle["default"])(formattedNumber);
      }
      return formattedNumber;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/getIddPrefix.js
var require_getIddPrefix = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/getIddPrefix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getIddPrefix;
    var _metadata = _interopRequireDefault(require_metadata());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var SINGLE_IDD_PREFIX_REG_EXP = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;
    function getIddPrefix(country2, callingCode, metadata) {
      var countryMetadata = new _metadata["default"](metadata);
      countryMetadata.selectNumberingPlan(country2, callingCode);
      if (countryMetadata.defaultIDDPrefix()) {
        return countryMetadata.defaultIDDPrefix();
      }
      if (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {
        return countryMetadata.IDDPrefix();
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/RFC3966.js
var require_RFC3966 = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/RFC3966.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.formatRFC3966 = formatRFC3966;
    exports2.parseRFC3966 = parseRFC3966;
    var _isViablePhoneNumber = _interopRequireDefault(require_isViablePhoneNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function parseRFC3966(text) {
      var number;
      var ext;
      text = text.replace(/^tel:/, "tel=");
      for (var _iterator = _createForOfIteratorHelperLoose(text.split(";")), _step; !(_step = _iterator()).done; ) {
        var part = _step.value;
        var _part$split = part.split("="), _part$split2 = _slicedToArray(_part$split, 2), name = _part$split2[0], value = _part$split2[1];
        switch (name) {
          case "tel":
            number = value;
            break;
          case "ext":
            ext = value;
            break;
          case "phone-context":
            if (value[0] === "+") {
              number = value + number;
            }
            break;
        }
      }
      if (!(0, _isViablePhoneNumber["default"])(number)) {
        return {};
      }
      var result = {
        number
      };
      if (ext) {
        result.ext = ext;
      }
      return result;
    }
    function formatRFC3966(_ref) {
      var number = _ref.number, ext = _ref.ext;
      if (!number) {
        return "";
      }
      if (number[0] !== "+") {
        throw new Error('"formatRFC3966()" expects "number" to be in E.164 format.');
      }
      return "tel:".concat(number).concat(ext ? ";ext=" + ext : "");
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/format.js
var require_format = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/format.js"(exports2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.chooseFormatForNumber = chooseFormatForNumber;
    exports2["default"] = formatNumber2;
    var _matchesEntirely = _interopRequireDefault(require_matchesEntirely());
    var _formatNationalNumberUsingFormat = _interopRequireDefault(require_formatNationalNumberUsingFormat());
    var _metadata = _interopRequireWildcard(require_metadata());
    var _getIddPrefix = _interopRequireDefault(require_getIddPrefix());
    var _RFC = require_RFC3966();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var DEFAULT_OPTIONS = {
      formatExtension: function formatExtension(formattedNumber, extension, metadata) {
        return "".concat(formattedNumber).concat(metadata.ext()).concat(extension);
      }
    };
    function formatNumber2(input, format, options, metadata) {
      if (options) {
        options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);
      } else {
        options = DEFAULT_OPTIONS;
      }
      metadata = new _metadata["default"](metadata);
      if (input.country && input.country !== "001") {
        if (!metadata.hasCountry(input.country)) {
          throw new Error("Unknown country: ".concat(input.country));
        }
        metadata.country(input.country);
      } else if (input.countryCallingCode) {
        metadata.selectNumberingPlan(input.countryCallingCode);
      } else return input.phone || "";
      var countryCallingCode = metadata.countryCallingCode();
      var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
      var number;
      switch (format) {
        case "NATIONAL":
          if (!nationalNumber) {
            return "";
          }
          number = formatNationalNumber(nationalNumber, input.carrierCode, "NATIONAL", metadata, options);
          return addExtension(number, input.ext, metadata, options.formatExtension);
        case "INTERNATIONAL":
          if (!nationalNumber) {
            return "+".concat(countryCallingCode);
          }
          number = formatNationalNumber(nationalNumber, null, "INTERNATIONAL", metadata, options);
          number = "+".concat(countryCallingCode, " ").concat(number);
          return addExtension(number, input.ext, metadata, options.formatExtension);
        case "E.164":
          return "+".concat(countryCallingCode).concat(nationalNumber);
        case "RFC3966":
          return (0, _RFC.formatRFC3966)({
            number: "+".concat(countryCallingCode).concat(nationalNumber),
            ext: input.ext
          });
        case "IDD":
          if (!options.fromCountry) {
            return;
          }
          var formattedNumber = formatIDD(nationalNumber, input.carrierCode, countryCallingCode, options.fromCountry, metadata);
          return addExtension(formattedNumber, input.ext, metadata, options.formatExtension);
        default:
          throw new Error('Unknown "format" argument passed to "formatNumber()": "'.concat(format, '"'));
      }
    }
    function formatNationalNumber(number, carrierCode, formatAs, metadata, options) {
      var format = chooseFormatForNumber(metadata.formats(), number);
      if (!format) {
        return number;
      }
      return (0, _formatNationalNumberUsingFormat["default"])(number, format, {
        useInternationalFormat: formatAs === "INTERNATIONAL",
        withNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options && options.nationalPrefix === false ? false : true,
        carrierCode,
        metadata
      });
    }
    function chooseFormatForNumber(availableFormats, nationalNnumber) {
      for (var _iterator = _createForOfIteratorHelperLoose(availableFormats), _step; !(_step = _iterator()).done; ) {
        var format = _step.value;
        if (format.leadingDigitsPatterns().length > 0) {
          var lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1];
          if (nationalNnumber.search(lastLeadingDigitsPattern) !== 0) {
            continue;
          }
        }
        if ((0, _matchesEntirely["default"])(nationalNnumber, format.pattern())) {
          return format;
        }
      }
    }
    function addExtension(formattedNumber, ext, metadata, formatExtension) {
      return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;
    }
    function formatIDD(nationalNumber, carrierCode, countryCallingCode, fromCountry, metadata) {
      var fromCountryCallingCode = (0, _metadata.getCountryCallingCode)(fromCountry, metadata.metadata);
      if (fromCountryCallingCode === countryCallingCode) {
        var formattedNumber = formatNationalNumber(nationalNumber, carrierCode, "NATIONAL", metadata);
        if (countryCallingCode === "1") {
          return countryCallingCode + " " + formattedNumber;
        }
        return formattedNumber;
      }
      var iddPrefix = (0, _getIddPrefix["default"])(fromCountry, void 0, metadata.metadata);
      if (iddPrefix) {
        return "".concat(iddPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber(nationalNumber, null, "INTERNATIONAL", metadata));
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/PhoneNumber.js
var require_PhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/PhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _metadata = _interopRequireDefault(require_metadata());
    var _isPossible = _interopRequireDefault(require_isPossible());
    var _isValid = _interopRequireDefault(require_isValid());
    var _getNumberType = _interopRequireDefault(require_getNumberType());
    var _getPossibleCountriesForNumber = _interopRequireDefault(require_getPossibleCountriesForNumber());
    var _format2 = _interopRequireDefault(require_format());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
    var PhoneNumber = /* @__PURE__ */ function() {
      function PhoneNumber2(countryOrCountryCallingCode, nationalNumber, metadata) {
        _classCallCheck(this, PhoneNumber2);
        if (!countryOrCountryCallingCode) {
          throw new TypeError("`country` or `countryCallingCode` not passed");
        }
        if (!nationalNumber) {
          throw new TypeError("`nationalNumber` not passed");
        }
        if (!metadata) {
          throw new TypeError("`metadata` not passed");
        }
        var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata), country2 = _getCountryAndCountry.country, countryCallingCode = _getCountryAndCountry.countryCallingCode;
        this.country = country2;
        this.countryCallingCode = countryCallingCode;
        this.nationalNumber = nationalNumber;
        this.number = "+" + this.countryCallingCode + this.nationalNumber;
        this.getMetadata = function() {
          return metadata;
        };
      }
      _createClass(PhoneNumber2, [{
        key: "setExt",
        value: function setExt(ext) {
          this.ext = ext;
        }
      }, {
        key: "getPossibleCountries",
        value: function getPossibleCountries() {
          if (this.country) {
            return [this.country];
          }
          return (0, _getPossibleCountriesForNumber["default"])(this.countryCallingCode, this.nationalNumber, this.getMetadata());
        }
      }, {
        key: "isPossible",
        value: function isPossible() {
          return (0, _isPossible["default"])(this, {
            v2: true
          }, this.getMetadata());
        }
      }, {
        key: "isValid",
        value: function isValid() {
          return (0, _isValid["default"])(this, {
            v2: true
          }, this.getMetadata());
        }
      }, {
        key: "isNonGeographic",
        value: function isNonGeographic() {
          var metadata = new _metadata["default"](this.getMetadata());
          return metadata.isNonGeographicCallingCode(this.countryCallingCode);
        }
      }, {
        key: "isEqual",
        value: function isEqual(phoneNumber) {
          return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
        }
        // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
        // but later it was found out that it doesn't include the possible `TOO_SHORT` result
        // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,
        // so eventually I simply commented out this method from the `PhoneNumber` class
        // and just left the `validatePhoneNumberLength()` function, even though that one would require
        // and additional step to also validate the actual country / calling code of the phone number.
        // validateLength() {
        // 	const metadata = new Metadata(this.getMetadata())
        // 	metadata.selectNumberingPlan(this.countryCallingCode)
        // 	const result = checkNumberLength(this.nationalNumber, metadata)
        // 	if (result !== 'IS_POSSIBLE') {
        // 		return result
        // 	}
        // }
      }, {
        key: "getType",
        value: function getType() {
          return (0, _getNumberType["default"])(this, {
            v2: true
          }, this.getMetadata());
        }
      }, {
        key: "format",
        value: function format(_format, options) {
          return (0, _format2["default"])(this, _format, options ? _objectSpread(_objectSpread({}, options), {}, {
            v2: true
          }) : {
            v2: true
          }, this.getMetadata());
        }
      }, {
        key: "formatNational",
        value: function formatNational(options) {
          return this.format("NATIONAL", options);
        }
      }, {
        key: "formatInternational",
        value: function formatInternational(options) {
          return this.format("INTERNATIONAL", options);
        }
      }, {
        key: "getURI",
        value: function getURI(options) {
          return this.format("RFC3966", options);
        }
      }]);
      return PhoneNumber2;
    }();
    exports2["default"] = PhoneNumber;
    var isCountryCode = function isCountryCode2(value) {
      return /^[A-Z]{2}$/.test(value);
    };
    function getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {
      var country2;
      var countryCallingCode;
      var metadata = new _metadata["default"](metadataJson);
      if (isCountryCode(countryOrCountryCallingCode)) {
        country2 = countryOrCountryCallingCode;
        metadata.selectNumberingPlan(country2);
        countryCallingCode = metadata.countryCallingCode();
      } else {
        countryCallingCode = countryOrCountryCallingCode;
        if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
          if (metadata.isNonGeographicCallingCode(countryCallingCode)) {
            country2 = "001";
          }
        }
      }
      return {
        country: country2,
        countryCallingCode
      };
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/stripIddPrefix.js
var require_stripIddPrefix = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/stripIddPrefix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = stripIddPrefix;
    var _metadata = _interopRequireDefault(require_metadata());
    var _constants = require_constants7();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var CAPTURING_DIGIT_PATTERN = new RegExp("([" + _constants.VALID_DIGITS + "])");
    function stripIddPrefix(number, country2, callingCode, metadata) {
      if (!country2) {
        return;
      }
      var countryMetadata = new _metadata["default"](metadata);
      countryMetadata.selectNumberingPlan(country2, callingCode);
      var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());
      if (number.search(IDDPrefixPattern) !== 0) {
        return;
      }
      number = number.slice(number.match(IDDPrefixPattern)[0].length);
      var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
      if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
        if (matchedGroups[1] === "0") {
          return;
        }
      }
      return number;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js
var require_extractNationalNumberFromPossiblyIncompleteNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = extractNationalNumberFromPossiblyIncompleteNumber;
    function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {
      if (number && metadata.numberingPlan.nationalPrefixForParsing()) {
        var prefixPattern = new RegExp("^(?:" + metadata.numberingPlan.nationalPrefixForParsing() + ")");
        var prefixMatch = prefixPattern.exec(number);
        if (prefixMatch) {
          var nationalNumber;
          var carrierCode;
          var capturedGroupsCount = prefixMatch.length - 1;
          var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];
          if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {
            nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule());
            if (capturedGroupsCount > 1) {
              carrierCode = prefixMatch[1];
            }
          } else {
            var prefixBeforeNationalNumber = prefixMatch[0];
            nationalNumber = number.slice(prefixBeforeNationalNumber.length);
            if (hasCapturedGroups) {
              carrierCode = prefixMatch[1];
            }
          }
          var nationalPrefix;
          if (hasCapturedGroups) {
            var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);
            var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup);
            if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {
              nationalPrefix = metadata.numberingPlan.nationalPrefix();
            }
          } else {
            nationalPrefix = prefixMatch[0];
          }
          return {
            nationalNumber,
            nationalPrefix,
            carrierCode
          };
        }
      }
      return {
        nationalNumber: number
      };
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extractNationalNumber.js
var require_extractNationalNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extractNationalNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = extractNationalNumber;
    var _extractNationalNumberFromPossiblyIncompleteNumber = _interopRequireDefault(require_extractNationalNumberFromPossiblyIncompleteNumber());
    var _matchesEntirely = _interopRequireDefault(require_matchesEntirely());
    var _checkNumberLength = _interopRequireDefault(require_checkNumberLength());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function extractNationalNumber(number, metadata) {
      var _extractNationalNumbe = (0, _extractNationalNumberFromPossiblyIncompleteNumber["default"])(number, metadata), carrierCode = _extractNationalNumbe.carrierCode, nationalNumber = _extractNationalNumbe.nationalNumber;
      if (nationalNumber !== number) {
        if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {
          return {
            nationalNumber: number
          };
        }
        if (metadata.possibleLengths()) {
          if (!isPossibleIncompleteNationalNumber(nationalNumber, metadata)) {
            return {
              nationalNumber: number
            };
          }
        }
      }
      return {
        nationalNumber,
        carrierCode
      };
    }
    function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {
      if ((0, _matchesEntirely["default"])(nationalNumberBefore, metadata.nationalNumberPattern()) && !(0, _matchesEntirely["default"])(nationalNumberAfter, metadata.nationalNumberPattern())) {
        return false;
      }
      return true;
    }
    function isPossibleIncompleteNationalNumber(nationalNumber, metadata) {
      switch ((0, _checkNumberLength["default"])(nationalNumber, metadata)) {
        case "TOO_SHORT":
        case "INVALID_LENGTH":
          return false;
        default:
          return true;
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js
var require_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign;
    var _metadata = _interopRequireDefault(require_metadata());
    var _matchesEntirely = _interopRequireDefault(require_matchesEntirely());
    var _extractNationalNumber = _interopRequireDefault(require_extractNationalNumber());
    var _checkNumberLength = _interopRequireDefault(require_checkNumberLength());
    var _getCountryCallingCode = _interopRequireDefault(require_getCountryCallingCode());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country2, callingCode, metadata) {
      var countryCallingCode = country2 ? (0, _getCountryCallingCode["default"])(country2, metadata) : callingCode;
      if (number.indexOf(countryCallingCode) === 0) {
        metadata = new _metadata["default"](metadata);
        metadata.selectNumberingPlan(country2, callingCode);
        var possibleShorterNumber = number.slice(countryCallingCode.length);
        var _extractNationalNumbe = (0, _extractNationalNumber["default"])(possibleShorterNumber, metadata), possibleShorterNationalNumber = _extractNationalNumbe.nationalNumber;
        var _extractNationalNumbe2 = (0, _extractNationalNumber["default"])(number, metadata), nationalNumber = _extractNationalNumbe2.nationalNumber;
        if (!(0, _matchesEntirely["default"])(nationalNumber, metadata.nationalNumberPattern()) && (0, _matchesEntirely["default"])(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || (0, _checkNumberLength["default"])(nationalNumber, metadata) === "TOO_LONG") {
          return {
            countryCallingCode,
            number: possibleShorterNumber
          };
        }
      }
      return {
        number
      };
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extractCountryCallingCode.js
var require_extractCountryCallingCode = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extractCountryCallingCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = extractCountryCallingCode;
    var _stripIddPrefix = _interopRequireDefault(require_stripIddPrefix());
    var _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign = _interopRequireDefault(require_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign());
    var _metadata = _interopRequireDefault(require_metadata());
    var _constants = require_constants7();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function extractCountryCallingCode(number, country2, callingCode, metadata) {
      if (!number) {
        return {};
      }
      var isNumberWithIddPrefix;
      if (number[0] !== "+") {
        var numberWithoutIDD = (0, _stripIddPrefix["default"])(number, country2, callingCode, metadata);
        if (numberWithoutIDD && numberWithoutIDD !== number) {
          isNumberWithIddPrefix = true;
          number = "+" + numberWithoutIDD;
        } else {
          if (country2 || callingCode) {
            var _extractCountryCallin = (0, _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign["default"])(number, country2, callingCode, metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, shorterNumber = _extractCountryCallin.number;
            if (countryCallingCode) {
              return {
                countryCallingCodeSource: "FROM_NUMBER_WITHOUT_PLUS_SIGN",
                countryCallingCode,
                number: shorterNumber
              };
            }
          }
          return {
            // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
            // countryCallingCodeSource: 'UNSPECIFIED',
            number
          };
        }
      }
      if (number[1] === "0") {
        return {};
      }
      metadata = new _metadata["default"](metadata);
      var i = 2;
      while (i - 1 <= _constants.MAX_LENGTH_COUNTRY_CODE && i <= number.length) {
        var _countryCallingCode = number.slice(1, i);
        if (metadata.hasCallingCode(_countryCallingCode)) {
          metadata.selectNumberingPlan(_countryCallingCode);
          return {
            countryCallingCodeSource: isNumberWithIddPrefix ? "FROM_NUMBER_WITH_IDD" : "FROM_NUMBER_WITH_PLUS_SIGN",
            countryCallingCode: _countryCallingCode,
            number: number.slice(i)
          };
        }
        i++;
      }
      return {};
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/getCountryByNationalNumber.js
var require_getCountryByNationalNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/getCountryByNationalNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getCountryByNationalNumber;
    var _metadata = _interopRequireDefault(require_metadata());
    var _getNumberType = _interopRequireDefault(require_getNumberType());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function getCountryByNationalNumber(nationalPhoneNumber, _ref) {
      var countries = _ref.countries, defaultCountry = _ref.defaultCountry, metadata = _ref.metadata;
      metadata = new _metadata["default"](metadata);
      var matchingCountries = [];
      for (var _iterator = _createForOfIteratorHelperLoose(countries), _step; !(_step = _iterator()).done; ) {
        var country2 = _step.value;
        metadata.country(country2);
        if (metadata.leadingDigits()) {
          if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) {
            return country2;
          }
        } else if ((0, _getNumberType["default"])({
          phone: nationalPhoneNumber,
          country: country2
        }, void 0, metadata.metadata)) {
          if (defaultCountry) {
            if (country2 === defaultCountry) {
              return country2;
            }
            matchingCountries.push(country2);
          } else {
            return country2;
          }
        }
      }
      if (matchingCountries.length > 0) {
        return matchingCountries[0];
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/getCountryByCallingCode.js
var require_getCountryByCallingCode = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/getCountryByCallingCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getCountryByCallingCode;
    var _getCountryByNationalNumber = _interopRequireDefault(require_getCountryByNationalNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
    function getCountryByCallingCode(callingCode, _ref) {
      var nationalPhoneNumber = _ref.nationalNumber, defaultCountry = _ref.defaultCountry, metadata = _ref.metadata;
      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
        if (metadata.isNonGeographicCallingCode(callingCode)) {
          return "001";
        }
      }
      var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);
      if (!possibleCountries) {
        return;
      }
      if (possibleCountries.length === 1) {
        return possibleCountries[0];
      }
      return (0, _getCountryByNationalNumber["default"])(nationalPhoneNumber, {
        countries: possibleCountries,
        defaultCountry,
        metadata: metadata.metadata
      });
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extractPhoneContext.js
var require_extractPhoneContext = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extractPhoneContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RFC3966_PREFIX_ = exports2.RFC3966_PHONE_CONTEXT_ = exports2.RFC3966_ISDN_SUBADDRESS_ = exports2.PLUS_SIGN = void 0;
    exports2["default"] = extractPhoneContext;
    exports2.isPhoneContextValid = isPhoneContextValid;
    var _constants = require_constants7();
    var PLUS_SIGN = "+";
    exports2.PLUS_SIGN = PLUS_SIGN;
    var RFC3966_VISUAL_SEPARATOR_ = "[\\-\\.\\(\\)]?";
    var RFC3966_PHONE_DIGIT_ = "([" + _constants.VALID_DIGITS + "]|" + RFC3966_VISUAL_SEPARATOR_ + ")";
    var RFC3966_GLOBAL_NUMBER_DIGITS_ = "^\\" + PLUS_SIGN + RFC3966_PHONE_DIGIT_ + "*[" + _constants.VALID_DIGITS + "]" + RFC3966_PHONE_DIGIT_ + "*$";
    var RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_ = new RegExp(RFC3966_GLOBAL_NUMBER_DIGITS_, "g");
    var ALPHANUM_ = _constants.VALID_DIGITS;
    var RFC3966_DOMAINLABEL_ = "[" + ALPHANUM_ + "]+((\\-)*[" + ALPHANUM_ + "])*";
    var VALID_ALPHA_ = "a-zA-Z";
    var RFC3966_TOPLABEL_ = "[" + VALID_ALPHA_ + "]+((\\-)*[" + ALPHANUM_ + "])*";
    var RFC3966_DOMAINNAME_ = "^(" + RFC3966_DOMAINLABEL_ + "\\.)*" + RFC3966_TOPLABEL_ + "\\.?$";
    var RFC3966_DOMAINNAME_PATTERN_ = new RegExp(RFC3966_DOMAINNAME_, "g");
    var RFC3966_PREFIX_ = "tel:";
    exports2.RFC3966_PREFIX_ = RFC3966_PREFIX_;
    var RFC3966_PHONE_CONTEXT_ = ";phone-context=";
    exports2.RFC3966_PHONE_CONTEXT_ = RFC3966_PHONE_CONTEXT_;
    var RFC3966_ISDN_SUBADDRESS_ = ";isub=";
    exports2.RFC3966_ISDN_SUBADDRESS_ = RFC3966_ISDN_SUBADDRESS_;
    function extractPhoneContext(numberToExtractFrom) {
      var indexOfPhoneContext = numberToExtractFrom.indexOf(RFC3966_PHONE_CONTEXT_);
      if (indexOfPhoneContext < 0) {
        return null;
      }
      var phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT_.length;
      if (phoneContextStart >= numberToExtractFrom.length) {
        return "";
      }
      var phoneContextEnd = numberToExtractFrom.indexOf(";", phoneContextStart);
      if (phoneContextEnd >= 0) {
        return numberToExtractFrom.substring(phoneContextStart, phoneContextEnd);
      } else {
        return numberToExtractFrom.substring(phoneContextStart);
      }
    }
    function isPhoneContextValid(phoneContext) {
      if (phoneContext === null) {
        return true;
      }
      if (phoneContext.length === 0) {
        return false;
      }
      return RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_.test(phoneContext) || RFC3966_DOMAINNAME_PATTERN_.test(phoneContext);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js
var require_extractFormattedPhoneNumberFromPossibleRfc3966NumberUri = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js"(exports2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = extractFormattedPhoneNumberFromPossibleRfc3966NumberUri;
    var _extractPhoneContext = _interopRequireWildcard(require_extractPhoneContext());
    var _ParseError = _interopRequireDefault(require_ParseError());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(numberToParse, _ref) {
      var extractFormattedPhoneNumber = _ref.extractFormattedPhoneNumber;
      var phoneContext = (0, _extractPhoneContext["default"])(numberToParse);
      if (!(0, _extractPhoneContext.isPhoneContextValid)(phoneContext)) {
        throw new _ParseError["default"]("NOT_A_NUMBER");
      }
      var phoneNumberString;
      if (phoneContext === null) {
        phoneNumberString = extractFormattedPhoneNumber(numberToParse) || "";
      } else {
        phoneNumberString = "";
        if (phoneContext.charAt(0) === _extractPhoneContext.PLUS_SIGN) {
          phoneNumberString += phoneContext;
        }
        var indexOfRfc3966Prefix = numberToParse.indexOf(_extractPhoneContext.RFC3966_PREFIX_);
        var indexOfNationalNumber;
        if (indexOfRfc3966Prefix >= 0) {
          indexOfNationalNumber = indexOfRfc3966Prefix + _extractPhoneContext.RFC3966_PREFIX_.length;
        } else {
          indexOfNationalNumber = 0;
        }
        var indexOfPhoneContext = numberToParse.indexOf(_extractPhoneContext.RFC3966_PHONE_CONTEXT_);
        phoneNumberString += numberToParse.substring(indexOfNationalNumber, indexOfPhoneContext);
      }
      var indexOfIsdn = phoneNumberString.indexOf(_extractPhoneContext.RFC3966_ISDN_SUBADDRESS_);
      if (indexOfIsdn > 0) {
        phoneNumberString = phoneNumberString.substring(0, indexOfIsdn);
      }
      if (phoneNumberString !== "") {
        return phoneNumberString;
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/parse.js
var require_parse = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/parse.js"(exports2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = parse;
    var _constants = require_constants7();
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _metadata = _interopRequireDefault(require_metadata());
    var _isViablePhoneNumber = _interopRequireWildcard(require_isViablePhoneNumber());
    var _extractExtension = _interopRequireDefault(require_extractExtension());
    var _parseIncompletePhoneNumber = _interopRequireDefault(require_parseIncompletePhoneNumber());
    var _getCountryCallingCode = _interopRequireDefault(require_getCountryCallingCode());
    var _isPossible = require_isPossible();
    var _PhoneNumber = _interopRequireDefault(require_PhoneNumber());
    var _matchesEntirely = _interopRequireDefault(require_matchesEntirely());
    var _extractCountryCallingCode = _interopRequireDefault(require_extractCountryCallingCode());
    var _extractNationalNumber = _interopRequireDefault(require_extractNationalNumber());
    var _stripIddPrefix = _interopRequireDefault(require_stripIddPrefix());
    var _getCountryByCallingCode = _interopRequireDefault(require_getCountryByCallingCode());
    var _extractFormattedPhoneNumberFromPossibleRfc3966NumberUri = _interopRequireDefault(require_extractFormattedPhoneNumberFromPossibleRfc3966NumberUri());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var MAX_INPUT_STRING_LENGTH = 250;
    var PHONE_NUMBER_START_PATTERN = new RegExp("[" + _constants.PLUS_CHARS + _constants.VALID_DIGITS + "]");
    var AFTER_PHONE_NUMBER_END_PATTERN = new RegExp("[^" + _constants.VALID_DIGITS + "#]+$");
    var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
    function parse(text, options, metadata) {
      options = options || {};
      metadata = new _metadata["default"](metadata);
      if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {
        if (options.v2) {
          throw new _ParseError["default"]("INVALID_COUNTRY");
        }
        throw new Error("Unknown country: ".concat(options.defaultCountry));
      }
      var _parseInput = parseInput(text, options.v2, options.extract), formattedPhoneNumber = _parseInput.number, ext = _parseInput.ext, error = _parseInput.error;
      if (!formattedPhoneNumber) {
        if (options.v2) {
          if (error === "TOO_SHORT") {
            throw new _ParseError["default"]("TOO_SHORT");
          }
          throw new _ParseError["default"]("NOT_A_NUMBER");
        }
        return {};
      }
      var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata), country2 = _parsePhoneNumber.country, nationalNumber = _parsePhoneNumber.nationalNumber, countryCallingCode = _parsePhoneNumber.countryCallingCode, countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource, carrierCode = _parsePhoneNumber.carrierCode;
      if (!metadata.hasSelectedNumberingPlan()) {
        if (options.v2) {
          throw new _ParseError["default"]("INVALID_COUNTRY");
        }
        return {};
      }
      if (!nationalNumber || nationalNumber.length < _constants.MIN_LENGTH_FOR_NSN) {
        if (options.v2) {
          throw new _ParseError["default"]("TOO_SHORT");
        }
        return {};
      }
      if (nationalNumber.length > _constants.MAX_LENGTH_FOR_NSN) {
        if (options.v2) {
          throw new _ParseError["default"]("TOO_LONG");
        }
        return {};
      }
      if (options.v2) {
        var phoneNumber = new _PhoneNumber["default"](countryCallingCode, nationalNumber, metadata.metadata);
        if (country2) {
          phoneNumber.country = country2;
        }
        if (carrierCode) {
          phoneNumber.carrierCode = carrierCode;
        }
        if (ext) {
          phoneNumber.ext = ext;
        }
        phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;
        return phoneNumber;
      }
      var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country2) ? (0, _matchesEntirely["default"])(nationalNumber, metadata.nationalNumberPattern()) : false;
      if (!options.extended) {
        return valid ? result(country2, nationalNumber, ext) : {};
      }
      return {
        country: country2,
        countryCallingCode,
        carrierCode,
        valid,
        possible: valid ? true : options.extended === true && metadata.possibleLengths() && (0, _isPossible.isPossibleNumber)(nationalNumber, metadata) ? true : false,
        phone: nationalNumber,
        ext
      };
    }
    function _extractFormattedPhoneNumber(text, extract, throwOnError) {
      if (!text) {
        return;
      }
      if (text.length > MAX_INPUT_STRING_LENGTH) {
        if (throwOnError) {
          throw new _ParseError["default"]("TOO_LONG");
        }
        return;
      }
      if (extract === false) {
        return text;
      }
      var startsAt = text.search(PHONE_NUMBER_START_PATTERN);
      if (startsAt < 0) {
        return;
      }
      return text.slice(startsAt).replace(AFTER_PHONE_NUMBER_END_PATTERN, "");
    }
    function parseInput(text, v2, extract) {
      var number = (0, _extractFormattedPhoneNumberFromPossibleRfc3966NumberUri["default"])(text, {
        extractFormattedPhoneNumber: function extractFormattedPhoneNumber(text2) {
          return _extractFormattedPhoneNumber(text2, extract, v2);
        }
      });
      if (!number) {
        return {};
      }
      if (!(0, _isViablePhoneNumber["default"])(number)) {
        if ((0, _isViablePhoneNumber.isViablePhoneNumberStart)(number)) {
          return {
            error: "TOO_SHORT"
          };
        }
        return {};
      }
      var withExtensionStripped = (0, _extractExtension["default"])(number);
      if (withExtensionStripped.ext) {
        return withExtensionStripped;
      }
      return {
        number
      };
    }
    function result(country2, nationalNumber, ext) {
      var result2 = {
        country: country2,
        phone: nationalNumber
      };
      if (ext) {
        result2.ext = ext;
      }
      return result2;
    }
    function parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {
      var _extractCountryCallin = (0, _extractCountryCallingCode["default"])((0, _parseIncompletePhoneNumber["default"])(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata), countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource, countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
      var country2;
      if (countryCallingCode) {
        metadata.selectNumberingPlan(countryCallingCode);
      } else if (number && (defaultCountry || defaultCallingCode)) {
        metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);
        if (defaultCountry) {
          country2 = defaultCountry;
        } else {
          if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
            if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {
              country2 = "001";
            }
          }
        }
        countryCallingCode = defaultCallingCode || (0, _getCountryCallingCode["default"])(defaultCountry, metadata.metadata);
      } else return {};
      if (!number) {
        return {
          countryCallingCodeSource,
          countryCallingCode
        };
      }
      var _extractNationalNumbe = (0, _extractNationalNumber["default"])((0, _parseIncompletePhoneNumber["default"])(number), metadata), nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
      var exactCountry = (0, _getCountryByCallingCode["default"])(countryCallingCode, {
        nationalNumber,
        defaultCountry,
        metadata
      });
      if (exactCountry) {
        country2 = exactCountry;
        if (exactCountry === "001") {
        } else {
          metadata.country(country2);
        }
      }
      return {
        country: country2,
        countryCallingCode,
        countryCallingCodeSource,
        nationalNumber,
        carrierCode
      };
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/parsePhoneNumberWithError_.js
var require_parsePhoneNumberWithError = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/parsePhoneNumberWithError_.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = parsePhoneNumberWithError;
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function parsePhoneNumberWithError(text, options, metadata) {
      return (0, _parse["default"])(text, _objectSpread(_objectSpread({}, options), {}, {
        v2: true
      }), metadata);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/parsePhoneNumber_.js
var require_parsePhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/parsePhoneNumber_.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = parsePhoneNumber;
    var _parsePhoneNumberWithError_ = _interopRequireDefault(require_parsePhoneNumberWithError());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _metadata = require_metadata();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function parsePhoneNumber(text, options, metadata) {
      if (options && options.defaultCountry && !(0, _metadata.isSupportedCountry)(options.defaultCountry, metadata)) {
        options = _objectSpread(_objectSpread({}, options), {}, {
          defaultCountry: void 0
        });
      }
      try {
        return (0, _parsePhoneNumberWithError_["default"])(text, options, metadata);
      } catch (error) {
        if (error instanceof _ParseError["default"]) {
        } else {
          throw error;
        }
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/parsePhoneNumber.js
var require_parsePhoneNumber2 = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/parsePhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = parsePhoneNumber;
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    var _parsePhoneNumber_ = _interopRequireDefault(require_parsePhoneNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function parsePhoneNumber() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      return (0, _parsePhoneNumber_["default"])(text, options, metadata);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/parsePhoneNumberWithError.js
var require_parsePhoneNumberWithError2 = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/parsePhoneNumberWithError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = parsePhoneNumberWithError;
    var _parsePhoneNumberWithError_ = _interopRequireDefault(require_parsePhoneNumberWithError());
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function parsePhoneNumberWithError() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      return (0, _parsePhoneNumberWithError_["default"])(text, options, metadata);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/isValidPhoneNumber.js
var require_isValidPhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/isValidPhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = isValidPhoneNumber;
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    var _parsePhoneNumber_ = _interopRequireDefault(require_parsePhoneNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function isValidPhoneNumber() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      options = _objectSpread(_objectSpread({}, options), {}, {
        extract: false
      });
      var phoneNumber = (0, _parsePhoneNumber_["default"])(text, options, metadata);
      return phoneNumber && phoneNumber.isValid() || false;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/isPossiblePhoneNumber.js
var require_isPossiblePhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/isPossiblePhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = isPossiblePhoneNumber;
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    var _parsePhoneNumber_ = _interopRequireDefault(require_parsePhoneNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function isPossiblePhoneNumber() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      options = _objectSpread(_objectSpread({}, options), {}, {
        extract: false
      });
      var phoneNumber = (0, _parsePhoneNumber_["default"])(text, options, metadata);
      return phoneNumber && phoneNumber.isPossible() || false;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/validatePhoneNumberLength.js
var require_validatePhoneNumberLength = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/validatePhoneNumberLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = validatePhoneNumberLength;
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    var _parsePhoneNumberWithError_ = _interopRequireDefault(require_parsePhoneNumberWithError());
    var _ParseError = _interopRequireDefault(require_ParseError());
    var _metadata = _interopRequireDefault(require_metadata());
    var _checkNumberLength = _interopRequireDefault(require_checkNumberLength());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function validatePhoneNumberLength() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      options = _objectSpread(_objectSpread({}, options), {}, {
        extract: false
      });
      try {
        var phoneNumber = (0, _parsePhoneNumberWithError_["default"])(text, options, metadata);
        metadata = new _metadata["default"](metadata);
        metadata.selectNumberingPlan(phoneNumber.countryCallingCode);
        var result = (0, _checkNumberLength["default"])(phoneNumber.nationalNumber, metadata);
        if (result !== "IS_POSSIBLE") {
          return result;
        }
      } catch (error) {
        if (error instanceof _ParseError["default"]) {
          return error.message;
        } else {
          throw error;
        }
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/LRUCache.js
var require_LRUCache = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/LRUCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Node = /* @__PURE__ */ _createClass(function Node2(key, value) {
      var next = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var prev = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      _classCallCheck(this, Node2);
      this.key = key;
      this.value = value;
      this.next = next;
      this.prev = prev;
    });
    var LRUCache = /* @__PURE__ */ function() {
      function LRUCache2() {
        var limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
        _classCallCheck(this, LRUCache2);
        this.size = 0;
        this.limit = limit;
        this.head = null;
        this.tail = null;
        this.cache = {};
      }
      _createClass(LRUCache2, [{
        key: "put",
        value: function put(key, value) {
          this.ensureLimit();
          if (!this.head) {
            this.head = this.tail = new Node(key, value);
          } else {
            var node = new Node(key, value, this.head);
            this.head.prev = node;
            this.head = node;
          }
          this.cache[key] = this.head;
          this.size++;
        }
        // Read from cache map and make that node as new Head of LinkedList
      }, {
        key: "get",
        value: function get(key) {
          if (this.cache[key]) {
            var value = this.cache[key].value;
            this.remove(key);
            this.put(key, value);
            return value;
          }
          console.log("Item not available in cache for key ".concat(key));
        }
      }, {
        key: "ensureLimit",
        value: function ensureLimit() {
          if (this.size === this.limit) {
            this.remove(this.tail.key);
          }
        }
      }, {
        key: "remove",
        value: function remove(key) {
          var node = this.cache[key];
          if (node.prev !== null) {
            node.prev.next = node.next;
          } else {
            this.head = node.next;
          }
          if (node.next !== null) {
            node.next.prev = node.prev;
          } else {
            this.tail = node.prev;
          }
          delete this.cache[key];
          this.size--;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = null;
          this.tail = null;
          this.size = 0;
          this.cache = {};
        }
        // // Invokes the callback function with every node of the chain and the index of the node.
        // forEach(fn) {
        //   let node = this.head;
        //   let counter = 0;
        //   while (node) {
        //     fn(node, counter);
        //     node = node.next;
        //     counter++;
        //   }
        // }
        // // To iterate over LRU with a 'for...of' loop
        // *[Symbol.iterator]() {
        //   let node = this.head;
        //   while (node) {
        //     yield node;
        //     node = node.next;
        //   }
        // }
      }]);
      return LRUCache2;
    }();
    exports2["default"] = LRUCache;
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/RegExpCache.js
var require_RegExpCache = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/RegExpCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _LRUCache = _interopRequireDefault(require_LRUCache());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var RegExpCache = /* @__PURE__ */ function() {
      function RegExpCache2(size) {
        _classCallCheck(this, RegExpCache2);
        this.cache = new _LRUCache["default"](size);
      }
      _createClass(RegExpCache2, [{
        key: "getPatternForRegExp",
        value: function getPatternForRegExp(pattern) {
          var regExp = this.cache.get(pattern);
          if (!regExp) {
            regExp = new RegExp("^" + pattern);
            this.cache.put(pattern, regExp);
          }
          return regExp;
        }
      }]);
      return RegExpCache2;
    }();
    exports2["default"] = RegExpCache;
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/util.js
var require_util2 = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.endsWith = endsWith;
    exports2.limit = limit;
    exports2.startsWith = startsWith;
    exports2.trimAfterFirstMatch = trimAfterFirstMatch;
    function limit(lower, upper) {
      if (lower < 0 || upper <= 0 || upper < lower) {
        throw new TypeError();
      }
      return "{".concat(lower, ",").concat(upper, "}");
    }
    function trimAfterFirstMatch(regexp, string) {
      var index = string.search(regexp);
      if (index >= 0) {
        return string.slice(0, index);
      }
      return string;
    }
    function startsWith(string, substring) {
      return string.indexOf(substring) === 0;
    }
    function endsWith(string, substring) {
      return string.indexOf(substring, string.length - substring.length) === string.length - substring.length;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/utf-8.js
var require_utf_8 = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/utf-8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._pN = exports2._pL = exports2.PZ = void 0;
    exports2.isInvalidPunctuationSymbol = isInvalidPunctuationSymbol;
    exports2.isLatinLetter = isLatinLetter;
    exports2.pZ = exports2.pNd = void 0;
    var _pZ = " \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000";
    var pZ = "[".concat(_pZ, "]");
    exports2.pZ = pZ;
    var PZ = "[^".concat(_pZ, "]");
    exports2.PZ = PZ;
    var _pN = "0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19";
    exports2._pN = _pN;
    var _pNd = "0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19";
    var pNd = "[".concat(_pNd, "]");
    exports2.pNd = pNd;
    var _pL = "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    exports2._pL = _pL;
    var pL = "[".concat(_pL, "]");
    var pL_regexp = new RegExp(pL);
    var _pSc = "$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20B9\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6";
    var pSc = "[".concat(_pSc, "]");
    var pSc_regexp = new RegExp(pSc);
    var _pMn = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26";
    var pMn = "[".concat(_pMn, "]");
    var pMn_regexp = new RegExp(pMn);
    var _InBasic_Latin = "\0-\x7F";
    var _InLatin_1_Supplement = "\x80-\xFF";
    var _InLatin_Extended_A = "\u0100-\u017F";
    var _InLatin_Extended_Additional = "\u1E00-\u1EFF";
    var _InLatin_Extended_B = "\u0180-\u024F";
    var _InCombining_Diacritical_Marks = "\u0300-\u036F";
    var latinLetterRegexp = new RegExp("[" + _InBasic_Latin + _InLatin_1_Supplement + _InLatin_Extended_A + _InLatin_Extended_Additional + _InLatin_Extended_B + _InCombining_Diacritical_Marks + "]");
    function isLatinLetter(letter) {
      if (!pL_regexp.test(letter) && !pMn_regexp.test(letter)) {
        return false;
      }
      return latinLetterRegexp.test(letter);
    }
    function isInvalidPunctuationSymbol(character) {
      return character === "%" || pSc_regexp.test(character);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/matchPhoneNumberStringAgainstPhoneNumber.js
var require_matchPhoneNumberStringAgainstPhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/matchPhoneNumberStringAgainstPhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = matchPhoneNumberStringAgainstPhoneNumber;
    var _parsePhoneNumber = _interopRequireDefault(require_parsePhoneNumber2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function matchPhoneNumberStringAgainstPhoneNumber(phoneNumberString, phoneNumber, metadata) {
      var phoneNumberStringContainsCallingCode = true;
      var parsedPhoneNumber = (0, _parsePhoneNumber["default"])(phoneNumberString, metadata);
      if (!parsedPhoneNumber) {
        phoneNumberStringContainsCallingCode = false;
        parsedPhoneNumber = (0, _parsePhoneNumber["default"])(phoneNumberString, {
          defaultCallingCode: phoneNumber.countryCallingCode
        }, metadata);
      }
      if (!parsedPhoneNumber) {
        return "INVALID_NUMBER";
      }
      if (phoneNumber.ext) {
        if (parsedPhoneNumber.ext !== phoneNumber.ext) {
          return "NO_MATCH";
        }
      } else {
        if (parsedPhoneNumber.ext) {
          return "NO_MATCH";
        }
      }
      if (phoneNumberStringContainsCallingCode) {
        if (phoneNumber.countryCallingCode !== parsedPhoneNumber.countryCallingCode) {
          return "NO_MATCH";
        }
      }
      if (phoneNumber.number === parsedPhoneNumber.number) {
        if (phoneNumberStringContainsCallingCode) {
          return "EXACT_MATCH";
        } else {
          return "NSN_MATCH";
        }
      }
      if (phoneNumber.nationalNumber.indexOf(parsedPhoneNumber.nationalNumber) === 0 || parsedPhoneNumber.nationalNumber.indexOf(phoneNumber.nationalNumber) === 0) {
        return "SHORT_NSN_MATCH";
      }
      return "NO_MATCH";
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/Leniency.js
var require_Leniency = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/Leniency.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.containsMoreThanOneSlashInNationalNumber = containsMoreThanOneSlashInNationalNumber;
    exports2["default"] = void 0;
    var _isValid = _interopRequireDefault(require_isValid());
    var _parseDigits = _interopRequireDefault(require_parseDigits());
    var _matchPhoneNumberStringAgainstPhoneNumber = _interopRequireDefault(require_matchPhoneNumberStringAgainstPhoneNumber());
    var _metadata2 = _interopRequireDefault(require_metadata());
    var _getCountryByCallingCode = _interopRequireDefault(require_getCountryByCallingCode());
    var _format = require_format();
    var _util = require_util2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var _default = {
      /**
       * Phone numbers accepted are "possible", but not necessarily "valid".
       */
      POSSIBLE: function POSSIBLE(phoneNumber, _ref) {
        var candidate = _ref.candidate, metadata = _ref.metadata;
        return true;
      },
      /**
       * Phone numbers accepted are "possible" and "valid".
       * Numbers written in national format must have their national-prefix
       * present if it is usually written for a number of this type.
       */
      VALID: function VALID(phoneNumber, _ref2) {
        var candidate = _ref2.candidate, defaultCountry = _ref2.defaultCountry, metadata = _ref2.metadata;
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata)) {
          return false;
        }
        return true;
      },
      /**
       * Phone numbers accepted are "valid" and
       * are grouped in a possible way for this locale. For example, a US number written as
       * "65 02 53 00 00" and "650253 0000" are not accepted at this leniency level, whereas
       * "650 253 0000", "650 2530000" or "6502530000" are.
       * Numbers with more than one '/' symbol in the national significant number
       * are also dropped at this level.
       *
       * Warning: This level might result in lower coverage especially for regions outside of
       * country code "+1". If you are not sure about which level to use,
       * email the discussion group libphonenumber-discuss@googlegroups.com.
       */
      STRICT_GROUPING: function STRICT_GROUPING(phoneNumber, _ref3) {
        var candidate = _ref3.candidate, defaultCountry = _ref3.defaultCountry, metadata = _ref3.metadata, regExpCache = _ref3.regExpCache;
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {
          defaultCountry,
          metadata
        })) {
          return false;
        }
        return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);
      },
      /**
       * Phone numbers accepted are "valid" and are grouped in the same way
       * that we would have formatted it, or as a single block.
       * For example, a US number written as "650 2530000" is not accepted
       * at this leniency level, whereas "650 253 0000" or "6502530000" are.
       * Numbers with more than one '/' symbol are also dropped at this level.
       *
       * Warning: This level might result in lower coverage especially for regions outside of
       * country code "+1". If you are not sure about which level to use, email the discussion group
       * libphonenumber-discuss@googlegroups.com.
       */
      EXACT_GROUPING: function EXACT_GROUPING(phoneNumber, _ref4) {
        var candidate = _ref4.candidate, defaultCountry = _ref4.defaultCountry, metadata = _ref4.metadata, regExpCache = _ref4.regExpCache;
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {
          defaultCountry,
          metadata
        })) {
          return false;
        }
        return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);
      }
    };
    exports2["default"] = _default;
    function containsOnlyValidXChars(phoneNumber, candidate, metadata) {
      for (var index = 0; index < candidate.length - 1; index++) {
        var charAtIndex = candidate.charAt(index);
        if (charAtIndex === "x" || charAtIndex === "X") {
          var charAtNextIndex = candidate.charAt(index + 1);
          if (charAtNextIndex === "x" || charAtNextIndex === "X") {
            index++;
            if ((0, _matchPhoneNumberStringAgainstPhoneNumber["default"])(candidate.substring(index), phoneNumber, metadata) !== "NSN_MATCH") {
              return false;
            }
          } else {
            var ext = (0, _parseDigits["default"])(candidate.substring(index));
            if (ext) {
              if (phoneNumber.ext !== ext) {
                return false;
              }
            } else {
              if (phoneNumber.ext) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }
    function isNationalPrefixPresentIfRequired(phoneNumber, _ref5) {
      var defaultCountry = _ref5.defaultCountry, _metadata = _ref5.metadata;
      if (phoneNumber.__countryCallingCodeSource !== "FROM_DEFAULT_COUNTRY") {
        return true;
      }
      var metadata = new _metadata2["default"](_metadata);
      metadata.selectNumberingPlan(phoneNumber.countryCallingCode);
      var phoneNumberRegion = phoneNumber.country || (0, _getCountryByCallingCode["default"])(phoneNumber.countryCallingCode, {
        nationalNumber: phoneNumber.nationalNumber,
        defaultCountry,
        metadata
      });
      var nationalNumber = phoneNumber.nationalNumber;
      var format = (0, _format.chooseFormatForNumber)(metadata.numberingPlan.formats(), nationalNumber);
      if (format.nationalPrefixFormattingRule()) {
        if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {
          return true;
        }
        if (!format.usesNationalPrefix()) {
          return true;
        }
        return Boolean(phoneNumber.nationalPrefix);
      }
      return true;
    }
    function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {
      var firstSlashInBodyIndex = candidate.indexOf("/");
      if (firstSlashInBodyIndex < 0) {
        return false;
      }
      var secondSlashInBodyIndex = candidate.indexOf("/", firstSlashInBodyIndex + 1);
      if (secondSlashInBodyIndex < 0) {
        return false;
      }
      var candidateHasCountryCode = phoneNumber.__countryCallingCodeSource === "FROM_NUMBER_WITH_PLUS_SIGN" || phoneNumber.__countryCallingCodeSource === "FROM_NUMBER_WITHOUT_PLUS_SIGN";
      if (candidateHasCountryCode && (0, _parseDigits["default"])(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode) {
        return candidate.slice(secondSlashInBodyIndex + 1).indexOf("/") >= 0;
      }
      return true;
    }
    function checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {
      throw new Error("This part of code hasn't been ported");
      var normalizedCandidate = normalizeDigits(
        candidate,
        true
        /* keep non-digits */
      );
      var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);
      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
        return true;
      }
      var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());
      var nationalSignificantNumber = util.getNationalSignificantNumber(number);
      if (alternateFormats) {
        for (var _iterator = _createForOfIteratorHelperLoose(alternateFormats.numberFormats()), _step; !(_step = _iterator()).done; ) {
          var alternateFormat = _step.value;
          if (alternateFormat.leadingDigitsPatterns().length > 0) {
            var leadingDigitsRegExp = regExpCache.getPatternForRegExp("^" + alternateFormat.leadingDigitsPatterns()[0]);
            if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {
              continue;
            }
          }
          formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);
          if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
            return true;
          }
        }
      }
      return false;
    }
    function getNationalNumberGroups(metadata, number, formattingPattern) {
      throw new Error("This part of code hasn't been ported");
      if (formattingPattern) {
        var nationalSignificantNumber = util.getNationalSignificantNumber(number);
        return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, "RFC3966", metadata).split("-");
      }
      var rfc3966Format = formatNumber(number, "RFC3966", metadata);
      var endIndex = rfc3966Format.indexOf(";");
      if (endIndex < 0) {
        endIndex = rfc3966Format.length;
      }
      var startIndex = rfc3966Format.indexOf("-") + 1;
      return rfc3966Format.slice(startIndex, endIndex).split("-");
    }
    function allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {
      throw new Error("This part of code hasn't been ported");
      var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN);
      var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1;
      if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {
        return true;
      }
      var formattedNumberGroupIndex = formattedNumberGroups.length - 1;
      while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {
        if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {
          return false;
        }
        formattedNumberGroupIndex--;
        candidateNumberGroupIndex--;
      }
      return candidateNumberGroupIndex >= 0 && (0, _util.endsWith)(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);
    }
    function allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {
      throw new Error("This part of code hasn't been ported");
      var fromIndex = 0;
      if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {
        var countryCode = String(number.getCountryCode());
        fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();
      }
      for (var i = 0; i < formattedNumberGroups.length; i++) {
        fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);
        if (fromIndex < 0) {
          return false;
        }
        fromIndex += formattedNumberGroups[i].length();
        if (i == 0 && fromIndex < normalizedCandidate.length()) {
          var region = util.getRegionCodeForCountryCode(number.getCountryCode());
          if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {
            var nationalSignificantNumber = util.getNationalSignificantNumber(number);
            return (0, _util.startsWith)(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);
          }
        }
      }
      return normalizedCandidate.slice(fromIndex).contains(number.getExtension());
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/parsePreCandidate.js
var require_parsePreCandidate = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/parsePreCandidate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = parsePreCandidate;
    var _util = require_util2();
    var SECOND_NUMBER_START_PATTERN = /[\\/] *x/;
    function parsePreCandidate(candidate) {
      return (0, _util.trimAfterFirstMatch)(SECOND_NUMBER_START_PATTERN, candidate);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/isValidPreCandidate.js
var require_isValidPreCandidate = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/isValidPreCandidate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = isValidPreCandidate;
    var SLASH_SEPARATED_DATES = /(?:(?:[0-3]?\d\/[01]?\d)|(?:[01]?\d\/[0-3]?\d))\/(?:[12]\d)?\d{2}/;
    var TIME_STAMPS = /[12]\d{3}[-/]?[01]\d[-/]?[0-3]\d +[0-2]\d$/;
    var TIME_STAMPS_SUFFIX_LEADING = /^:[0-5]\d/;
    function isValidPreCandidate(candidate, offset, text) {
      if (SLASH_SEPARATED_DATES.test(candidate)) {
        return false;
      }
      if (TIME_STAMPS.test(candidate)) {
        var followingText = text.slice(offset + candidate.length);
        if (TIME_STAMPS_SUFFIX_LEADING.test(followingText)) {
          return false;
        }
      }
      return true;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findNumbers/isValidCandidate.js
var require_isValidCandidate = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findNumbers/isValidCandidate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LEAD_CLASS = void 0;
    exports2["default"] = isValidCandidate;
    var _constants = require_constants7();
    var _util = require_util2();
    var _utf = require_utf_8();
    var OPENING_PARENS = "(\\[\uFF08\uFF3B";
    var CLOSING_PARENS = ")\\]\uFF09\uFF3D";
    var NON_PARENS = "[^".concat(OPENING_PARENS).concat(CLOSING_PARENS, "]");
    var LEAD_CLASS = "[".concat(OPENING_PARENS).concat(_constants.PLUS_CHARS, "]");
    exports2.LEAD_CLASS = LEAD_CLASS;
    var LEAD_CLASS_LEADING = new RegExp("^" + LEAD_CLASS);
    var BRACKET_PAIR_LIMIT = (0, _util.limit)(0, 3);
    var MATCHING_BRACKETS_ENTIRE = new RegExp("^(?:[" + OPENING_PARENS + "])?(?:" + NON_PARENS + "+[" + CLOSING_PARENS + "])?" + NON_PARENS + "+(?:[" + OPENING_PARENS + "]" + NON_PARENS + "+[" + CLOSING_PARENS + "])" + BRACKET_PAIR_LIMIT + NON_PARENS + "*$");
    var PUB_PAGES = /\d{1,5}-+\d{1,5}\s{0,4}\(\d{1,4}/;
    function isValidCandidate(candidate, offset, text, leniency) {
      if (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {
        return;
      }
      if (leniency !== "POSSIBLE") {
        if (offset > 0 && !LEAD_CLASS_LEADING.test(candidate)) {
          var previousChar = text[offset - 1];
          if ((0, _utf.isInvalidPunctuationSymbol)(previousChar) || (0, _utf.isLatinLetter)(previousChar)) {
            return false;
          }
        }
        var lastCharIndex = offset + candidate.length;
        if (lastCharIndex < text.length) {
          var nextChar = text[lastCharIndex];
          if ((0, _utf.isInvalidPunctuationSymbol)(nextChar) || (0, _utf.isLatinLetter)(nextChar)) {
            return false;
          }
        }
      }
      return true;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/PhoneNumberMatcher.js
var require_PhoneNumberMatcher = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/PhoneNumberMatcher.js"(exports2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _PhoneNumber = _interopRequireDefault(require_PhoneNumber());
    var _constants = require_constants7();
    var _createExtensionPattern = _interopRequireDefault(require_createExtensionPattern());
    var _RegExpCache = _interopRequireDefault(require_RegExpCache());
    var _util = require_util2();
    var _utf = require_utf_8();
    var _Leniency = _interopRequireDefault(require_Leniency());
    var _parsePreCandidate = _interopRequireDefault(require_parsePreCandidate());
    var _isValidPreCandidate = _interopRequireDefault(require_isValidPreCandidate());
    var _isValidCandidate = _interopRequireWildcard(require_isValidCandidate());
    var _metadata = require_metadata();
    var _parsePhoneNumber = _interopRequireDefault(require_parsePhoneNumber2());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
    var EXTN_PATTERNS_FOR_MATCHING = (0, _createExtensionPattern["default"])("matching");
    var INNER_MATCHES = [
      // Breaks on the slash - e.g. "651-234-2345/332-445-1234"
      "\\/+(.*)/",
      // Note that the bracket here is inside the capturing group, since we consider it part of the
      // phone number. Will match a pattern like "(650) 223 3345 (754) 223 3321".
      "(\\([^(]*)",
      // Breaks on a hyphen - e.g. "12345 - 332-445-1234 is my number."
      // We require a space on either side of the hyphen for it to be considered a separator.
      "(?:".concat(_utf.pZ, "-|-").concat(_utf.pZ, ")").concat(_utf.pZ, "*(.+)"),
      // Various types of wide hyphens. Note we have decided not to enforce a space here, since it's
      // possible that it's supposed to be used to break two numbers without spaces, and we haven't
      // seen many instances of it used within a number.
      "[\u2012-\u2015\uFF0D]".concat(_utf.pZ, "*(.+)"),
      // Breaks on a full stop - e.g. "12345. 332-445-1234 is my number."
      "\\.+".concat(_utf.pZ, "*([^.]+)"),
      // Breaks on space - e.g. "3324451234 8002341234"
      "".concat(_utf.pZ, "+(").concat(_utf.PZ, "+)")
    ];
    var leadLimit = (0, _util.limit)(0, 2);
    var punctuationLimit = (0, _util.limit)(0, 4);
    var digitBlockLimit = _constants.MAX_LENGTH_FOR_NSN + _constants.MAX_LENGTH_COUNTRY_CODE;
    var blockLimit = (0, _util.limit)(0, digitBlockLimit);
    var punctuation = "[".concat(_constants.VALID_PUNCTUATION, "]") + punctuationLimit;
    var digitSequence = _utf.pNd + (0, _util.limit)(1, digitBlockLimit);
    var PATTERN = "(?:" + _isValidCandidate.LEAD_CLASS + punctuation + ")" + leadLimit + digitSequence + "(?:" + punctuation + digitSequence + ")" + blockLimit + "(?:" + EXTN_PATTERNS_FOR_MATCHING + ")?";
    var UNWANTED_END_CHAR_PATTERN = new RegExp("[^".concat(_utf._pN).concat(_utf._pL, "#]+$"));
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    var PhoneNumberMatcher = /* @__PURE__ */ function() {
      function PhoneNumberMatcher2() {
        var text = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var metadata = arguments.length > 2 ? arguments[2] : void 0;
        _classCallCheck(this, PhoneNumberMatcher2);
        options = {
          v2: options.v2,
          defaultCallingCode: options.defaultCallingCode,
          defaultCountry: options.defaultCountry && (0, _metadata.isSupportedCountry)(options.defaultCountry, metadata) ? options.defaultCountry : void 0,
          leniency: options.leniency || (options.extended ? "POSSIBLE" : "VALID"),
          maxTries: options.maxTries || MAX_SAFE_INTEGER
        };
        if (!options.leniency) {
          throw new TypeError("`leniency` is required");
        }
        if (options.leniency !== "POSSIBLE" && options.leniency !== "VALID") {
          throw new TypeError('Invalid `leniency`: "'.concat(options.leniency, '". Supported values: "POSSIBLE", "VALID".'));
        }
        if (options.maxTries < 0) {
          throw new TypeError("`maxTries` must be `>= 0`");
        }
        this.text = text;
        this.options = options;
        this.metadata = metadata;
        this.leniency = _Leniency["default"][options.leniency];
        if (!this.leniency) {
          throw new TypeError('Unknown leniency: "'.concat(options.leniency, '"'));
        }
        this.maxTries = options.maxTries;
        this.PATTERN = new RegExp(PATTERN, "ig");
        this.state = "NOT_READY";
        this.searchIndex = 0;
        this.regExpCache = new _RegExpCache["default"](32);
      }
      _createClass(PhoneNumberMatcher2, [{
        key: "find",
        value: function find() {
          var matches;
          while (this.maxTries > 0 && (matches = this.PATTERN.exec(this.text)) !== null) {
            var candidate = matches[0];
            var offset = matches.index;
            candidate = (0, _parsePreCandidate["default"])(candidate);
            if ((0, _isValidPreCandidate["default"])(candidate, offset, this.text)) {
              var match = (
                // Try to come up with a valid match given the entire candidate.
                this.parseAndVerify(candidate, offset, this.text) || this.extractInnerMatch(candidate, offset, this.text)
              );
              if (match) {
                if (this.options.v2) {
                  return {
                    startsAt: match.startsAt,
                    endsAt: match.endsAt,
                    number: match.phoneNumber
                  };
                } else {
                  var phoneNumber = match.phoneNumber;
                  var result = {
                    startsAt: match.startsAt,
                    endsAt: match.endsAt,
                    phone: phoneNumber.nationalNumber
                  };
                  if (phoneNumber.country) {
                    if (USE_NON_GEOGRAPHIC_COUNTRY_CODE && country === "001") {
                      result.countryCallingCode = phoneNumber.countryCallingCode;
                    } else {
                      result.country = phoneNumber.country;
                    }
                  } else {
                    result.countryCallingCode = phoneNumber.countryCallingCode;
                  }
                  if (phoneNumber.ext) {
                    result.ext = phoneNumber.ext;
                  }
                  return result;
                }
              }
            }
            this.maxTries--;
          }
        }
        /**
         * Attempts to extract a match from `substring`
         * if the substring itself does not qualify as a match.
         */
      }, {
        key: "extractInnerMatch",
        value: function extractInnerMatch(substring, offset, text) {
          for (var _iterator = _createForOfIteratorHelperLoose(INNER_MATCHES), _step; !(_step = _iterator()).done; ) {
            var innerMatchPattern = _step.value;
            var isFirstMatch = true;
            var candidateMatch = void 0;
            var innerMatchRegExp = new RegExp(innerMatchPattern, "g");
            while (this.maxTries > 0 && (candidateMatch = innerMatchRegExp.exec(substring)) !== null) {
              if (isFirstMatch) {
                var _candidate = (0, _util.trimAfterFirstMatch)(UNWANTED_END_CHAR_PATTERN, substring.slice(0, candidateMatch.index));
                var _match = this.parseAndVerify(_candidate, offset, text);
                if (_match) {
                  return _match;
                }
                this.maxTries--;
                isFirstMatch = false;
              }
              var candidate = (0, _util.trimAfterFirstMatch)(UNWANTED_END_CHAR_PATTERN, candidateMatch[1]);
              var candidateIndexGuess = substring.indexOf(candidate, candidateMatch.index);
              var match = this.parseAndVerify(candidate, offset + candidateIndexGuess, text);
              if (match) {
                return match;
              }
              this.maxTries--;
            }
          }
        }
        /**
         * Parses a phone number from the `candidate` using `parse` and
         * verifies it matches the requested `leniency`. If parsing and verification succeed,
         * a corresponding `PhoneNumberMatch` is returned, otherwise this method returns `null`.
         *
         * @param candidate  the candidate match
         * @param offset  the offset of {@code candidate} within {@link #text}
         * @return  the parsed and validated phone number match, or null
         */
      }, {
        key: "parseAndVerify",
        value: function parseAndVerify(candidate, offset, text) {
          if (!(0, _isValidCandidate["default"])(candidate, offset, text, this.options.leniency)) {
            return;
          }
          var phoneNumber = (0, _parsePhoneNumber["default"])(candidate, {
            extended: true,
            defaultCountry: this.options.defaultCountry,
            defaultCallingCode: this.options.defaultCallingCode
          }, this.metadata);
          if (!phoneNumber) {
            return;
          }
          if (!phoneNumber.isPossible()) {
            return;
          }
          if (this.leniency(phoneNumber, {
            candidate,
            defaultCountry: this.options.defaultCountry,
            metadata: this.metadata,
            regExpCache: this.regExpCache
          })) {
            return {
              startsAt: offset,
              endsAt: offset + candidate.length,
              phoneNumber
            };
          }
        }
      }, {
        key: "hasNext",
        value: function hasNext() {
          if (this.state === "NOT_READY") {
            this.lastMatch = this.find();
            if (this.lastMatch) {
              this.state = "READY";
            } else {
              this.state = "DONE";
            }
          }
          return this.state === "READY";
        }
      }, {
        key: "next",
        value: function next() {
          if (!this.hasNext()) {
            throw new Error("No next element");
          }
          var result = this.lastMatch;
          this.lastMatch = null;
          this.state = "NOT_READY";
          return result;
        }
      }]);
      return PhoneNumberMatcher2;
    }();
    exports2["default"] = PhoneNumberMatcher;
  }
});

// asset-input/node_modules/libphonenumber-js/build/legacy/findNumbers.js
var require_findNumbers = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/legacy/findNumbers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = findNumbers;
    var _PhoneNumberMatcher = _interopRequireDefault(require_PhoneNumberMatcher());
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function findNumbers() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      var matcher = new _PhoneNumberMatcher["default"](text, options, metadata);
      var results = [];
      while (matcher.hasNext()) {
        results.push(matcher.next());
      }
      return results;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/legacy/searchNumbers.js
var require_searchNumbers = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/legacy/searchNumbers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = searchNumbers;
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    var _PhoneNumberMatcher = _interopRequireDefault(require_PhoneNumberMatcher());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function searchNumbers() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      var matcher = new _PhoneNumberMatcher["default"](text, options, metadata);
      return _defineProperty({}, Symbol.iterator, function() {
        return {
          next: function next() {
            if (matcher.hasNext()) {
              return {
                done: false,
                value: matcher.next()
              };
            }
            return {
              done: true
            };
          }
        };
      });
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/findPhoneNumbersInText.js
var require_findPhoneNumbersInText = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/findPhoneNumbersInText.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = findPhoneNumbersInText;
    var _PhoneNumberMatcher = _interopRequireDefault(require_PhoneNumberMatcher());
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function findPhoneNumbersInText() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      var matcher = new _PhoneNumberMatcher["default"](text, _objectSpread(_objectSpread({}, options), {}, {
        v2: true
      }), metadata);
      var results = [];
      while (matcher.hasNext()) {
        results.push(matcher.next());
      }
      return results;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/searchPhoneNumbersInText.js
var require_searchPhoneNumbersInText = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/searchPhoneNumbersInText.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = searchPhoneNumbersInText;
    var _PhoneNumberMatcher = _interopRequireDefault(require_PhoneNumberMatcher());
    var _normalizeArguments2 = _interopRequireDefault(require_normalizeArguments());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function searchPhoneNumbersInText() {
      var _normalizeArguments = (0, _normalizeArguments2["default"])(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
      var matcher = new _PhoneNumberMatcher["default"](text, _objectSpread(_objectSpread({}, options), {}, {
        v2: true
      }), metadata);
      return _defineProperty({}, Symbol.iterator, function() {
        return {
          next: function next() {
            if (matcher.hasNext()) {
              return {
                done: false,
                value: matcher.next()
              };
            }
            return {
              done: true
            };
          }
        };
      });
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouTypeState.js
var require_AsYouTypeState = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouTypeState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var AsYouTypeState = /* @__PURE__ */ function() {
      function AsYouTypeState2(_ref) {
        var onCountryChange = _ref.onCountryChange, onCallingCodeChange = _ref.onCallingCodeChange;
        _classCallCheck(this, AsYouTypeState2);
        this.onCountryChange = onCountryChange;
        this.onCallingCodeChange = onCallingCodeChange;
      }
      _createClass(AsYouTypeState2, [{
        key: "reset",
        value: function reset(_ref2) {
          var country2 = _ref2.country, callingCode = _ref2.callingCode;
          this.international = false;
          this.missingPlus = false;
          this.IDDPrefix = void 0;
          this.callingCode = void 0;
          this.digits = "";
          this.resetNationalSignificantNumber();
          this.initCountryAndCallingCode(country2, callingCode);
        }
      }, {
        key: "resetNationalSignificantNumber",
        value: function resetNationalSignificantNumber() {
          this.nationalSignificantNumber = this.getNationalDigits();
          this.nationalSignificantNumberMatchesInput = true;
          this.nationalPrefix = void 0;
          this.carrierCode = void 0;
          this.complexPrefixBeforeNationalSignificantNumber = void 0;
        }
      }, {
        key: "update",
        value: function update(properties) {
          for (var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            this[key] = properties[key];
          }
        }
      }, {
        key: "initCountryAndCallingCode",
        value: function initCountryAndCallingCode(country2, callingCode) {
          this.setCountry(country2);
          this.setCallingCode(callingCode);
        }
      }, {
        key: "setCountry",
        value: function setCountry(country2) {
          this.country = country2;
          this.onCountryChange(country2);
        }
      }, {
        key: "setCallingCode",
        value: function setCallingCode(callingCode) {
          this.callingCode = callingCode;
          this.onCallingCodeChange(callingCode, this.country);
        }
      }, {
        key: "startInternationalNumber",
        value: function startInternationalNumber(country2, callingCode) {
          this.international = true;
          this.initCountryAndCallingCode(country2, callingCode);
        }
      }, {
        key: "appendDigits",
        value: function appendDigits(nextDigits) {
          this.digits += nextDigits;
        }
      }, {
        key: "appendNationalSignificantNumberDigits",
        value: function appendNationalSignificantNumberDigits(nextDigits) {
          this.nationalSignificantNumber += nextDigits;
        }
        /**
         * Returns the part of `this.digits` that corresponds to the national number.
         * Basically, all digits that have been input by the user, except for the
         * international prefix and the country calling code part
         * (if the number is an international one).
         * @return {string}
         */
      }, {
        key: "getNationalDigits",
        value: function getNationalDigits() {
          if (this.international) {
            return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));
          }
          return this.digits;
        }
      }, {
        key: "getDigitsWithoutInternationalPrefix",
        value: function getDigitsWithoutInternationalPrefix() {
          if (this.international) {
            if (this.IDDPrefix) {
              return this.digits.slice(this.IDDPrefix.length);
            }
          }
          return this.digits;
        }
      }]);
      return AsYouTypeState2;
    }();
    exports2["default"] = AsYouTypeState;
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.util.js
var require_AsYouTypeFormatter_util = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DIGIT_PLACEHOLDER = void 0;
    exports2.closeNonPairedParens = closeNonPairedParens;
    exports2.countOccurences = countOccurences;
    exports2.cutAndStripNonPairedParens = cutAndStripNonPairedParens;
    exports2.populateTemplateWithDigits = populateTemplateWithDigits;
    exports2.repeat = repeat;
    exports2.stripNonPairedParens = stripNonPairedParens;
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var DIGIT_PLACEHOLDER = "x";
    exports2.DIGIT_PLACEHOLDER = DIGIT_PLACEHOLDER;
    var DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);
    function countOccurences(symbol, string) {
      var count = 0;
      for (var _iterator = _createForOfIteratorHelperLoose(string.split("")), _step; !(_step = _iterator()).done; ) {
        var character = _step.value;
        if (character === symbol) {
          count++;
        }
      }
      return count;
    }
    function repeat(string, times) {
      if (times < 1) {
        return "";
      }
      var result = "";
      while (times > 1) {
        if (times & 1) {
          result += string;
        }
        times >>= 1;
        string += string;
      }
      return result + string;
    }
    function cutAndStripNonPairedParens(string, cutBeforeIndex) {
      if (string[cutBeforeIndex] === ")") {
        cutBeforeIndex++;
      }
      return stripNonPairedParens(string.slice(0, cutBeforeIndex));
    }
    function closeNonPairedParens(template, cut_before) {
      var retained_template = template.slice(0, cut_before);
      var opening_braces = countOccurences("(", retained_template);
      var closing_braces = countOccurences(")", retained_template);
      var dangling_braces = opening_braces - closing_braces;
      while (dangling_braces > 0 && cut_before < template.length) {
        if (template[cut_before] === ")") {
          dangling_braces--;
        }
        cut_before++;
      }
      return template.slice(0, cut_before);
    }
    function stripNonPairedParens(string) {
      var dangling_braces = [];
      var i = 0;
      while (i < string.length) {
        if (string[i] === "(") {
          dangling_braces.push(i);
        } else if (string[i] === ")") {
          dangling_braces.pop();
        }
        i++;
      }
      var start = 0;
      var cleared_string = "";
      dangling_braces.push(string.length);
      for (var _i = 0, _dangling_braces = dangling_braces; _i < _dangling_braces.length; _i++) {
        var index = _dangling_braces[_i];
        cleared_string += string.slice(start, index);
        start = index + 1;
      }
      return cleared_string;
    }
    function populateTemplateWithDigits(template, position, digits) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(digits.split("")), _step2; !(_step2 = _iterator2()).done; ) {
        var digit = _step2.value;
        if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {
          return;
        }
        position = template.search(DIGIT_PLACEHOLDER_MATCHER);
        template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);
      }
      return [template, position];
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.complete.js
var require_AsYouTypeFormatter_complete = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.complete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.canFormatCompleteNumber = canFormatCompleteNumber;
    exports2["default"] = formatCompleteNumber;
    var _checkNumberLength = _interopRequireDefault(require_checkNumberLength());
    var _parseDigits = _interopRequireDefault(require_parseDigits());
    var _formatNationalNumberUsingFormat = _interopRequireDefault(require_formatNationalNumberUsingFormat());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function formatCompleteNumber(state, format, _ref) {
      var metadata = _ref.metadata, shouldTryNationalPrefixFormattingRule = _ref.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref.getSeparatorAfterNationalPrefix;
      var matcher = new RegExp("^(?:".concat(format.pattern(), ")$"));
      if (matcher.test(state.nationalSignificantNumber)) {
        return formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {
          metadata,
          shouldTryNationalPrefixFormattingRule,
          getSeparatorAfterNationalPrefix
        });
      }
    }
    function canFormatCompleteNumber(nationalSignificantNumber, metadata) {
      return (0, _checkNumberLength["default"])(nationalSignificantNumber, metadata) === "IS_POSSIBLE";
    }
    function formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, _ref2) {
      var metadata = _ref2.metadata, shouldTryNationalPrefixFormattingRule = _ref2.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref2.getSeparatorAfterNationalPrefix;
      var nationalSignificantNumber = state.nationalSignificantNumber, international = state.international, nationalPrefix = state.nationalPrefix, carrierCode = state.carrierCode;
      if (shouldTryNationalPrefixFormattingRule(format)) {
        var formattedNumber = formatNationalNumber(state, format, {
          useNationalPrefixFormattingRule: true,
          getSeparatorAfterNationalPrefix,
          metadata
        });
        if (formattedNumber) {
          return formattedNumber;
        }
      }
      return formatNationalNumber(state, format, {
        useNationalPrefixFormattingRule: false,
        getSeparatorAfterNationalPrefix,
        metadata
      });
    }
    function formatNationalNumber(state, format, _ref3) {
      var metadata = _ref3.metadata, useNationalPrefixFormattingRule = _ref3.useNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref3.getSeparatorAfterNationalPrefix;
      var formattedNationalNumber = (0, _formatNationalNumberUsingFormat["default"])(state.nationalSignificantNumber, format, {
        carrierCode: state.carrierCode,
        useInternationalFormat: state.international,
        withNationalPrefix: useNationalPrefixFormattingRule,
        metadata
      });
      if (!useNationalPrefixFormattingRule) {
        if (state.nationalPrefix) {
          formattedNationalNumber = state.nationalPrefix + getSeparatorAfterNationalPrefix(format) + formattedNationalNumber;
        } else if (state.complexPrefixBeforeNationalSignificantNumber) {
          formattedNationalNumber = state.complexPrefixBeforeNationalSignificantNumber + " " + formattedNationalNumber;
        }
      }
      if (isValidFormattedNationalNumber(formattedNationalNumber, state)) {
        return formattedNationalNumber;
      }
    }
    function isValidFormattedNationalNumber(formattedNationalNumber, state) {
      return (0, _parseDigits["default"])(formattedNationalNumber) === state.getNationalDigits();
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.PatternParser.js
var require_AsYouTypeFormatter_PatternParser = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.PatternParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var PatternParser = /* @__PURE__ */ function() {
      function PatternParser2() {
        _classCallCheck(this, PatternParser2);
      }
      _createClass(PatternParser2, [{
        key: "parse",
        value: function parse(pattern) {
          this.context = [{
            or: true,
            instructions: []
          }];
          this.parsePattern(pattern);
          if (this.context.length !== 1) {
            throw new Error("Non-finalized contexts left when pattern parse ended");
          }
          var _this$context$ = this.context[0], branches = _this$context$.branches, instructions = _this$context$.instructions;
          if (branches) {
            return {
              op: "|",
              args: branches.concat([expandSingleElementArray(instructions)])
            };
          }
          if (instructions.length === 0) {
            throw new Error("Pattern is required");
          }
          if (instructions.length === 1) {
            return instructions[0];
          }
          return instructions;
        }
      }, {
        key: "startContext",
        value: function startContext(context) {
          this.context.push(context);
        }
      }, {
        key: "endContext",
        value: function endContext() {
          this.context.pop();
        }
      }, {
        key: "getContext",
        value: function getContext() {
          return this.context[this.context.length - 1];
        }
      }, {
        key: "parsePattern",
        value: function parsePattern(pattern) {
          if (!pattern) {
            throw new Error("Pattern is required");
          }
          var match = pattern.match(OPERATOR);
          if (!match) {
            if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {
              throw new Error("Illegal characters found in a pattern: ".concat(pattern));
            }
            this.getContext().instructions = this.getContext().instructions.concat(pattern.split(""));
            return;
          }
          var operator = match[1];
          var before = pattern.slice(0, match.index);
          var rightPart = pattern.slice(match.index + operator.length);
          switch (operator) {
            case "(?:":
              if (before) {
                this.parsePattern(before);
              }
              this.startContext({
                or: true,
                instructions: [],
                branches: []
              });
              break;
            case ")":
              if (!this.getContext().or) {
                throw new Error('")" operator must be preceded by "(?:" operator');
              }
              if (before) {
                this.parsePattern(before);
              }
              if (this.getContext().instructions.length === 0) {
                throw new Error('No instructions found after "|" operator in an "or" group');
              }
              var _this$getContext = this.getContext(), branches = _this$getContext.branches;
              branches.push(expandSingleElementArray(this.getContext().instructions));
              this.endContext();
              this.getContext().instructions.push({
                op: "|",
                args: branches
              });
              break;
            case "|":
              if (!this.getContext().or) {
                throw new Error('"|" operator can only be used inside "or" groups');
              }
              if (before) {
                this.parsePattern(before);
              }
              if (!this.getContext().branches) {
                if (this.context.length === 1) {
                  this.getContext().branches = [];
                } else {
                  throw new Error('"branches" not found in an "or" group context');
                }
              }
              this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));
              this.getContext().instructions = [];
              break;
            case "[":
              if (before) {
                this.parsePattern(before);
              }
              this.startContext({
                oneOfSet: true
              });
              break;
            case "]":
              if (!this.getContext().oneOfSet) {
                throw new Error('"]" operator must be preceded by "[" operator');
              }
              this.endContext();
              this.getContext().instructions.push({
                op: "[]",
                args: parseOneOfSet(before)
              });
              break;
            default:
              throw new Error("Unknown operator: ".concat(operator));
          }
          if (rightPart) {
            this.parsePattern(rightPart);
          }
        }
      }]);
      return PatternParser2;
    }();
    exports2["default"] = PatternParser;
    function parseOneOfSet(pattern) {
      var values = [];
      var i = 0;
      while (i < pattern.length) {
        if (pattern[i] === "-") {
          if (i === 0 || i === pattern.length - 1) {
            throw new Error("Couldn't parse a one-of set pattern: ".concat(pattern));
          }
          var prevValue = pattern[i - 1].charCodeAt(0) + 1;
          var nextValue = pattern[i + 1].charCodeAt(0) - 1;
          var value = prevValue;
          while (value <= nextValue) {
            values.push(String.fromCharCode(value));
            value++;
          }
        } else {
          values.push(pattern[i]);
        }
        i++;
      }
      return values;
    }
    var ILLEGAL_CHARACTER_REGEXP = /[\(\)\[\]\?\:\|]/;
    var OPERATOR = new RegExp(
      // any of:
      "(\\||\\(\\?\\:|\\)|\\[|\\])"
    );
    function expandSingleElementArray(array) {
      if (array.length === 1) {
        return array[0];
      }
      return array;
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.PatternMatcher.js
var require_AsYouTypeFormatter_PatternMatcher = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.PatternMatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _AsYouTypeFormatterPatternParser = _interopRequireDefault(require_AsYouTypeFormatter_PatternParser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var PatternMatcher = /* @__PURE__ */ function() {
      function PatternMatcher2(pattern) {
        _classCallCheck(this, PatternMatcher2);
        this.matchTree = new _AsYouTypeFormatterPatternParser["default"]().parse(pattern);
      }
      _createClass(PatternMatcher2, [{
        key: "match",
        value: function match(string) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, allowOverflow = _ref.allowOverflow;
          if (!string) {
            throw new Error("String is required");
          }
          var result = _match(string.split(""), this.matchTree, true);
          if (result && result.match) {
            delete result.matchedChars;
          }
          if (result && result.overflow) {
            if (!allowOverflow) {
              return;
            }
          }
          return result;
        }
      }]);
      return PatternMatcher2;
    }();
    exports2["default"] = PatternMatcher;
    function _match(characters, tree, last) {
      if (typeof tree === "string") {
        var characterString = characters.join("");
        if (tree.indexOf(characterString) === 0) {
          if (characters.length === tree.length) {
            return {
              match: true,
              matchedChars: characters
            };
          }
          return {
            partialMatch: true
            // matchedChars: characters
          };
        }
        if (characterString.indexOf(tree) === 0) {
          if (last) {
            if (characters.length > tree.length) {
              return {
                overflow: true
              };
            }
          }
          return {
            match: true,
            matchedChars: characters.slice(0, tree.length)
          };
        }
        return;
      }
      if (Array.isArray(tree)) {
        var restCharacters = characters.slice();
        var i = 0;
        while (i < tree.length) {
          var subtree = tree[i];
          var result = _match(restCharacters, subtree, last && i === tree.length - 1);
          if (!result) {
            return;
          } else if (result.overflow) {
            return result;
          } else if (result.match) {
            restCharacters = restCharacters.slice(result.matchedChars.length);
            if (restCharacters.length === 0) {
              if (i === tree.length - 1) {
                return {
                  match: true,
                  matchedChars: characters
                };
              } else {
                return {
                  partialMatch: true
                  // matchedChars: characters
                };
              }
            }
          } else {
            if (result.partialMatch) {
              return {
                partialMatch: true
                // matchedChars: characters
              };
            } else {
              throw new Error("Unsupported match result:\n".concat(JSON.stringify(result, null, 2)));
            }
          }
          i++;
        }
        if (last) {
          return {
            overflow: true
          };
        }
        return {
          match: true,
          matchedChars: characters.slice(0, characters.length - restCharacters.length)
        };
      }
      switch (tree.op) {
        case "|":
          var partialMatch;
          for (var _iterator = _createForOfIteratorHelperLoose(tree.args), _step; !(_step = _iterator()).done; ) {
            var branch = _step.value;
            var _result = _match(characters, branch, last);
            if (_result) {
              if (_result.overflow) {
                return _result;
              } else if (_result.match) {
                return {
                  match: true,
                  matchedChars: _result.matchedChars
                };
              } else {
                if (_result.partialMatch) {
                  partialMatch = true;
                } else {
                  throw new Error("Unsupported match result:\n".concat(JSON.stringify(_result, null, 2)));
                }
              }
            }
          }
          if (partialMatch) {
            return {
              partialMatch: true
              // matchedChars: ...
            };
          }
          return;
        case "[]":
          for (var _iterator2 = _createForOfIteratorHelperLoose(tree.args), _step2; !(_step2 = _iterator2()).done; ) {
            var _char = _step2.value;
            if (characters[0] === _char) {
              if (characters.length === 1) {
                return {
                  match: true,
                  matchedChars: characters
                };
              }
              if (last) {
                return {
                  overflow: true
                };
              }
              return {
                match: true,
                matchedChars: [_char]
              };
            }
          }
          return;
        default:
          throw new Error("Unsupported instruction tree: ".concat(tree));
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.js
var require_AsYouTypeFormatter = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouTypeFormatter.js"(exports2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DIGIT_PLACEHOLDER", {
      enumerable: true,
      get: function get() {
        return _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER;
      }
    });
    exports2["default"] = void 0;
    var _AsYouTypeFormatterUtil = require_AsYouTypeFormatter_util();
    var _AsYouTypeFormatterComplete = _interopRequireWildcard(require_AsYouTypeFormatter_complete());
    var _AsYouTypeFormatterPatternMatcher = _interopRequireDefault(require_AsYouTypeFormatter_PatternMatcher());
    var _parseDigits = _interopRequireDefault(require_parseDigits());
    var _formatNationalNumberUsingFormat = require_formatNationalNumberUsingFormat();
    var _constants = require_constants7();
    var _applyInternationalSeparatorStyle = _interopRequireDefault(require_applyInternationalSeparatorStyle());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var DUMMY_DIGIT = "9";
    var LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;
    var LONGEST_DUMMY_PHONE_NUMBER = (0, _AsYouTypeFormatterUtil.repeat)(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);
    var NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/;
    var SUPPORT_LEGACY_FORMATTING_PATTERNS = true;
    var CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
      return /\[([^\[\]])*\]/g;
    };
    var CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
      return /\d(?=[^,}][^,}])/g;
    };
    var NON_ALTERING_FORMAT_REG_EXP = new RegExp("[" + _constants.VALID_PUNCTUATION + "]*\\$1[" + _constants.VALID_PUNCTUATION + "]*(\\$\\d[" + _constants.VALID_PUNCTUATION + "]*)*$");
    var MIN_LEADING_DIGITS_LENGTH = 3;
    var AsYouTypeFormatter = /* @__PURE__ */ function() {
      function AsYouTypeFormatter2(_ref) {
        var state = _ref.state, metadata = _ref.metadata;
        _classCallCheck(this, AsYouTypeFormatter2);
        this.metadata = metadata;
        this.resetFormat();
      }
      _createClass(AsYouTypeFormatter2, [{
        key: "resetFormat",
        value: function resetFormat() {
          this.chosenFormat = void 0;
          this.template = void 0;
          this.nationalNumberTemplate = void 0;
          this.populatedNationalNumberTemplate = void 0;
          this.populatedNationalNumberTemplatePosition = -1;
        }
      }, {
        key: "reset",
        value: function reset(numberingPlan, state) {
          this.resetFormat();
          if (numberingPlan) {
            this.isNANP = numberingPlan.callingCode() === "1";
            this.matchingFormats = numberingPlan.formats();
            if (state.nationalSignificantNumber) {
              this.narrowDownMatchingFormats(state);
            }
          } else {
            this.isNANP = void 0;
            this.matchingFormats = [];
          }
        }
        /**
         * Formats an updated phone number.
         * @param  {string} nextDigits — Additional phone number digits.
         * @param  {object} state — `AsYouType` state.
         * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.
         */
      }, {
        key: "format",
        value: function format(nextDigits, state) {
          var _this = this;
          if ((0, _AsYouTypeFormatterComplete.canFormatCompleteNumber)(state.nationalSignificantNumber, this.metadata)) {
            for (var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done; ) {
              var format2 = _step.value;
              var formattedCompleteNumber = (0, _AsYouTypeFormatterComplete["default"])(state, format2, {
                metadata: this.metadata,
                shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format3) {
                  return _this.shouldTryNationalPrefixFormattingRule(format3, {
                    international: state.international,
                    nationalPrefix: state.nationalPrefix
                  });
                },
                getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format3) {
                  return _this.getSeparatorAfterNationalPrefix(format3);
                }
              });
              if (formattedCompleteNumber) {
                this.resetFormat();
                this.chosenFormat = format2;
                this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\d/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER), state);
                this.populatedNationalNumberTemplate = formattedCompleteNumber;
                this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);
                return formattedCompleteNumber;
              }
            }
          }
          return this.formatNationalNumberWithNextDigits(nextDigits, state);
        }
        // Formats the next phone number digits.
      }, {
        key: "formatNationalNumberWithNextDigits",
        value: function formatNationalNumberWithNextDigits(nextDigits, state) {
          var previouslyChosenFormat = this.chosenFormat;
          var newlyChosenFormat = this.chooseFormat(state);
          if (newlyChosenFormat) {
            if (newlyChosenFormat === previouslyChosenFormat) {
              return this.formatNextNationalNumberDigits(nextDigits);
            } else {
              return this.formatNextNationalNumberDigits(state.getNationalDigits());
            }
          }
        }
      }, {
        key: "narrowDownMatchingFormats",
        value: function narrowDownMatchingFormats(_ref2) {
          var _this2 = this;
          var nationalSignificantNumber = _ref2.nationalSignificantNumber, nationalPrefix = _ref2.nationalPrefix, international = _ref2.international;
          var leadingDigits = nationalSignificantNumber;
          var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;
          if (leadingDigitsPatternIndex < 0) {
            leadingDigitsPatternIndex = 0;
          }
          this.matchingFormats = this.matchingFormats.filter(function(format) {
            return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);
          });
          if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {
            this.resetFormat();
          }
        }
      }, {
        key: "formatSuits",
        value: function formatSuits(format, international, nationalPrefix) {
          if (nationalPrefix && !format.usesNationalPrefix() && // !format.domesticCarrierCodeFormattingRule() &&
          !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {
            return false;
          }
          if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {
            return false;
          }
          return true;
        }
      }, {
        key: "formatMatches",
        value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {
          var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length;
          if (leadingDigitsPatternsCount === 0) {
            return true;
          }
          leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);
          var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex];
          if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {
            try {
              return new _AsYouTypeFormatterPatternMatcher["default"](leadingDigitsPattern).match(leadingDigits, {
                allowOverflow: true
              }) !== void 0;
            } catch (error) {
              console.error(error);
              return true;
            }
          }
          return new RegExp("^(".concat(leadingDigitsPattern, ")")).test(leadingDigits);
        }
      }, {
        key: "getFormatFormat",
        value: function getFormatFormat(format, international) {
          return international ? format.internationalFormat() : format.format();
        }
      }, {
        key: "chooseFormat",
        value: function chooseFormat(state) {
          var _this3 = this;
          var _loop = function _loop2() {
            var format = _step2.value;
            if (_this3.chosenFormat === format) {
              return "break";
            }
            if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) {
              return "continue";
            }
            if (!_this3.createTemplateForFormat(format, state)) {
              _this3.matchingFormats = _this3.matchingFormats.filter(function(_) {
                return _ !== format;
              });
              return "continue";
            }
            _this3.chosenFormat = format;
            return "break";
          };
          for (var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done; ) {
            var _ret = _loop();
            if (_ret === "break") break;
            if (_ret === "continue") continue;
          }
          if (!this.chosenFormat) {
            this.resetFormat();
          }
          return this.chosenFormat;
        }
      }, {
        key: "createTemplateForFormat",
        value: function createTemplateForFormat(format, state) {
          if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf("|") >= 0) {
            return;
          }
          var template = this.getTemplateForFormat(format, state);
          if (template) {
            this.setNationalNumberTemplate(template, state);
            return true;
          }
        }
      }, {
        key: "getSeparatorAfterNationalPrefix",
        value: function getSeparatorAfterNationalPrefix(format) {
          if (this.isNANP) {
            return " ";
          }
          if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {
            return " ";
          }
          return "";
        }
      }, {
        key: "getInternationalPrefixBeforeCountryCallingCode",
        value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {
          var IDDPrefix = _ref3.IDDPrefix, missingPlus = _ref3.missingPlus;
          if (IDDPrefix) {
            return options && options.spacing === false ? IDDPrefix : IDDPrefix + " ";
          }
          if (missingPlus) {
            return "";
          }
          return "+";
        }
      }, {
        key: "getTemplate",
        value: function getTemplate(state) {
          if (!this.template) {
            return;
          }
          var index = -1;
          var i = 0;
          var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {
            spacing: false
          }) : "";
          while (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {
            index = this.template.indexOf(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, index + 1);
            i++;
          }
          return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.template, index + 1);
        }
      }, {
        key: "setNationalNumberTemplate",
        value: function setNationalNumberTemplate(template, state) {
          this.nationalNumberTemplate = template;
          this.populatedNationalNumberTemplate = template;
          this.populatedNationalNumberTemplatePosition = -1;
          if (state.international) {
            this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\d\+]/g, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER) + (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, state.callingCode.length) + " " + template;
          } else {
            this.template = template;
          }
        }
        /**
         * Generates formatting template for a national phone number,
         * optionally containing a national prefix, for a format.
         * @param  {Format} format
         * @param  {string} nationalPrefix
         * @return {string}
         */
      }, {
        key: "getTemplateForFormat",
        value: function getTemplateForFormat(format, _ref4) {
          var nationalSignificantNumber = _ref4.nationalSignificantNumber, international = _ref4.international, nationalPrefix = _ref4.nationalPrefix, complexPrefixBeforeNationalSignificantNumber = _ref4.complexPrefixBeforeNationalSignificantNumber;
          var pattern = format.pattern();
          if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {
            pattern = pattern.replace(CREATE_CHARACTER_CLASS_PATTERN(), "\\d").replace(CREATE_STANDALONE_DIGIT_PATTERN(), "\\d");
          }
          var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0];
          if (nationalSignificantNumber.length > digits.length) {
            return;
          }
          var strictPattern = new RegExp("^" + pattern + "$");
          var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\d/g, DUMMY_DIGIT);
          if (strictPattern.test(nationalNumberDummyDigits)) {
            digits = nationalNumberDummyDigits;
          }
          var numberFormat = this.getFormatFormat(format, international);
          var nationalPrefixIncludedInTemplate;
          if (this.shouldTryNationalPrefixFormattingRule(format, {
            international,
            nationalPrefix
          })) {
            var numberFormatWithNationalPrefix = numberFormat.replace(_formatNationalNumberUsingFormat.FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule());
            if ((0, _parseDigits["default"])(format.nationalPrefixFormattingRule()) === (nationalPrefix || "") + (0, _parseDigits["default"])("$1")) {
              numberFormat = numberFormatWithNationalPrefix;
              nationalPrefixIncludedInTemplate = true;
              if (nationalPrefix) {
                var i = nationalPrefix.length;
                while (i > 0) {
                  numberFormat = numberFormat.replace(/\d/, _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);
                  i--;
                }
              }
            }
          }
          var template = digits.replace(new RegExp(pattern), numberFormat).replace(new RegExp(DUMMY_DIGIT, "g"), _AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER);
          if (!nationalPrefixIncludedInTemplate) {
            if (complexPrefixBeforeNationalSignificantNumber) {
              template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, complexPrefixBeforeNationalSignificantNumber.length) + " " + template;
            } else if (nationalPrefix) {
              template = (0, _AsYouTypeFormatterUtil.repeat)(_AsYouTypeFormatterUtil.DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;
            }
          }
          if (international) {
            template = (0, _applyInternationalSeparatorStyle["default"])(template);
          }
          return template;
        }
      }, {
        key: "formatNextNationalNumberDigits",
        value: function formatNextNationalNumberDigits(digits) {
          var result = (0, _AsYouTypeFormatterUtil.populateTemplateWithDigits)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);
          if (!result) {
            this.resetFormat();
            return;
          }
          this.populatedNationalNumberTemplate = result[0];
          this.populatedNationalNumberTemplatePosition = result[1];
          return (0, _AsYouTypeFormatterUtil.cutAndStripNonPairedParens)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1);
        }
      }, {
        key: "shouldTryNationalPrefixFormattingRule",
        value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {
          var international = _ref5.international, nationalPrefix = _ref5.nationalPrefix;
          if (format.nationalPrefixFormattingRule()) {
            var usesNationalPrefix = format.usesNationalPrefix();
            if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) {
              return true;
            }
          }
        }
      }]);
      return AsYouTypeFormatter2;
    }();
    exports2["default"] = AsYouTypeFormatter;
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouTypeParser.js
var require_AsYouTypeParser = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouTypeParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    exports2.extractFormattedDigitsAndPlus = extractFormattedDigitsAndPlus;
    var _extractCountryCallingCode2 = _interopRequireDefault(require_extractCountryCallingCode());
    var _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign = _interopRequireDefault(require_extractCountryCallingCodeFromInternationalNumberWithoutPlusSign());
    var _extractNationalNumberFromPossiblyIncompleteNumber = _interopRequireDefault(require_extractNationalNumberFromPossiblyIncompleteNumber());
    var _stripIddPrefix = _interopRequireDefault(require_stripIddPrefix());
    var _parseDigits = _interopRequireDefault(require_parseDigits());
    var _constants = require_constants7();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = "[" + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + "]+";
    var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp("^" + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + "$", "i");
    var VALID_FORMATTED_PHONE_NUMBER_PART = "(?:[" + _constants.PLUS_CHARS + "][" + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + "]*|[" + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + "]+)";
    var AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp("[^" + _constants.VALID_PUNCTUATION + _constants.VALID_DIGITS + "]+.*$");
    var COMPLEX_NATIONAL_PREFIX = /[^\d\[\]]/;
    var AsYouTypeParser = /* @__PURE__ */ function() {
      function AsYouTypeParser2(_ref) {
        var defaultCountry = _ref.defaultCountry, defaultCallingCode = _ref.defaultCallingCode, metadata = _ref.metadata, onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;
        _classCallCheck(this, AsYouTypeParser2);
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.metadata = metadata;
        this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;
      }
      _createClass(AsYouTypeParser2, [{
        key: "input",
        value: function input(text, state) {
          var _extractFormattedDigi = extractFormattedDigitsAndPlus(text), _extractFormattedDigi2 = _slicedToArray(_extractFormattedDigi, 2), formattedDigits = _extractFormattedDigi2[0], hasPlus = _extractFormattedDigi2[1];
          var digits = (0, _parseDigits["default"])(formattedDigits);
          var justLeadingPlus;
          if (hasPlus) {
            if (!state.digits) {
              state.startInternationalNumber();
              if (!digits) {
                justLeadingPlus = true;
              }
            }
          }
          if (digits) {
            this.inputDigits(digits, state);
          }
          return {
            digits,
            justLeadingPlus
          };
        }
        /**
         * Inputs "next" phone number digits.
         * @param  {string} digits
         * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means "don't format the national phone number at this stage".
         */
      }, {
        key: "inputDigits",
        value: function inputDigits(nextDigits, state) {
          var digits = state.digits;
          var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3;
          state.appendDigits(nextDigits);
          if (hasReceivedThreeLeadingDigits) {
            this.extractIddPrefix(state);
          }
          if (this.isWaitingForCountryCallingCode(state)) {
            if (!this.extractCountryCallingCode(state)) {
              return;
            }
          } else {
            state.appendNationalSignificantNumberDigits(nextDigits);
          }
          if (!state.international) {
            if (!this.hasExtractedNationalSignificantNumber) {
              this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
                return state.update(stateUpdate);
              });
            }
          }
        }
      }, {
        key: "isWaitingForCountryCallingCode",
        value: function isWaitingForCountryCallingCode(_ref2) {
          var international = _ref2.international, callingCode = _ref2.callingCode;
          return international && !callingCode;
        }
        // Extracts a country calling code from a number
        // being entered in internatonal format.
      }, {
        key: "extractCountryCallingCode",
        value: function extractCountryCallingCode(state) {
          var _extractCountryCallin = (0, _extractCountryCallingCode2["default"])("+" + state.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
          if (countryCallingCode) {
            state.setCallingCode(countryCallingCode);
            state.update({
              nationalSignificantNumber: number
            });
            return true;
          }
        }
      }, {
        key: "reset",
        value: function reset(numberingPlan) {
          if (numberingPlan) {
            this.hasSelectedNumberingPlan = true;
            var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();
            this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);
          } else {
            this.hasSelectedNumberingPlan = void 0;
            this.couldPossiblyExtractAnotherNationalSignificantNumber = void 0;
          }
        }
        /**
         * Extracts a national (significant) number from user input.
         * Google's library is different in that it only applies `national_prefix_for_parsing`
         * and doesn't apply `national_prefix_transform_rule` after that.
         * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539
         * @return {boolean} [extracted]
         */
      }, {
        key: "extractNationalSignificantNumber",
        value: function extractNationalSignificantNumber(nationalDigits, setState) {
          if (!this.hasSelectedNumberingPlan) {
            return;
          }
          var _extractNationalNumbe = (0, _extractNationalNumberFromPossiblyIncompleteNumber["default"])(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe.nationalPrefix, nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
          if (nationalNumber === nationalDigits) {
            return;
          }
          this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
          return true;
        }
        /**
         * In Google's code this function is called "attempt to extract longer NDD".
         * "Some national prefixes are a substring of others", they say.
         * @return {boolean} [result] — Returns `true` if extracting a national prefix produced different results from what they were.
         */
      }, {
        key: "extractAnotherNationalSignificantNumber",
        value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {
          if (!this.hasExtractedNationalSignificantNumber) {
            return this.extractNationalSignificantNumber(nationalDigits, setState);
          }
          if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {
            return;
          }
          var _extractNationalNumbe2 = (0, _extractNationalNumberFromPossiblyIncompleteNumber["default"])(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe2.nationalPrefix, nationalNumber = _extractNationalNumbe2.nationalNumber, carrierCode = _extractNationalNumbe2.carrierCode;
          if (nationalNumber === prevNationalSignificantNumber) {
            return;
          }
          this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
          return true;
        }
      }, {
        key: "onExtractedNationalNumber",
        value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {
          var complexPrefixBeforeNationalSignificantNumber;
          var nationalSignificantNumberMatchesInput;
          var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber);
          if (nationalSignificantNumberIndex >= 0 && nationalSignificantNumberIndex === nationalDigits.length - nationalSignificantNumber.length) {
            nationalSignificantNumberMatchesInput = true;
            var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex);
            if (prefixBeforeNationalNumber !== nationalPrefix) {
              complexPrefixBeforeNationalSignificantNumber = prefixBeforeNationalNumber;
            }
          }
          setState({
            nationalPrefix,
            carrierCode,
            nationalSignificantNumber,
            nationalSignificantNumberMatchesInput,
            complexPrefixBeforeNationalSignificantNumber
          });
          this.hasExtractedNationalSignificantNumber = true;
          this.onNationalSignificantNumberChange();
        }
      }, {
        key: "reExtractNationalSignificantNumber",
        value: function reExtractNationalSignificantNumber(state) {
          if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function(stateUpdate) {
            return state.update(stateUpdate);
          })) {
            return true;
          }
          if (this.extractIddPrefix(state)) {
            this.extractCallingCodeAndNationalSignificantNumber(state);
            return true;
          }
          if (this.fixMissingPlus(state)) {
            this.extractCallingCodeAndNationalSignificantNumber(state);
            return true;
          }
        }
      }, {
        key: "extractIddPrefix",
        value: function extractIddPrefix(state) {
          var international = state.international, IDDPrefix = state.IDDPrefix, digits = state.digits, nationalSignificantNumber = state.nationalSignificantNumber;
          if (international || IDDPrefix) {
            return;
          }
          var numberWithoutIDD = (0, _stripIddPrefix["default"])(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);
          if (numberWithoutIDD !== void 0 && numberWithoutIDD !== digits) {
            state.update({
              IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)
            });
            this.startInternationalNumber(state, {
              country: void 0,
              callingCode: void 0
            });
            return true;
          }
        }
      }, {
        key: "fixMissingPlus",
        value: function fixMissingPlus(state) {
          if (!state.international) {
            var _extractCountryCallin2 = (0, _extractCountryCallingCodeFromInternationalNumberWithoutPlusSign["default"])(state.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), newCallingCode = _extractCountryCallin2.countryCallingCode, number = _extractCountryCallin2.number;
            if (newCallingCode) {
              state.update({
                missingPlus: true
              });
              this.startInternationalNumber(state, {
                country: state.country,
                callingCode: newCallingCode
              });
              return true;
            }
          }
        }
      }, {
        key: "startInternationalNumber",
        value: function startInternationalNumber(state, _ref3) {
          var country2 = _ref3.country, callingCode = _ref3.callingCode;
          state.startInternationalNumber(country2, callingCode);
          if (state.nationalSignificantNumber) {
            state.resetNationalSignificantNumber();
            this.onNationalSignificantNumberChange();
            this.hasExtractedNationalSignificantNumber = void 0;
          }
        }
      }, {
        key: "extractCallingCodeAndNationalSignificantNumber",
        value: function extractCallingCodeAndNationalSignificantNumber(state) {
          if (this.extractCountryCallingCode(state)) {
            this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
              return state.update(stateUpdate);
            });
          }
        }
      }]);
      return AsYouTypeParser2;
    }();
    exports2["default"] = AsYouTypeParser;
    function extractFormattedPhoneNumber(text) {
      var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);
      if (startsAt < 0) {
        return;
      }
      text = text.slice(startsAt);
      var hasPlus;
      if (text[0] === "+") {
        hasPlus = true;
        text = text.slice("+".length);
      }
      text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, "");
      if (hasPlus) {
        text = "+" + text;
      }
      return text;
    }
    function _extractFormattedDigitsAndPlus(text) {
      var extractedNumber = extractFormattedPhoneNumber(text) || "";
      if (extractedNumber[0] === "+") {
        return [extractedNumber.slice("+".length), true];
      }
      return [extractedNumber];
    }
    function extractFormattedDigitsAndPlus(text) {
      var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text), _extractFormattedDigi4 = _slicedToArray(_extractFormattedDigi3, 2), formattedDigits = _extractFormattedDigi4[0], hasPlus = _extractFormattedDigi4[1];
      if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {
        formattedDigits = "";
      }
      return [formattedDigits, hasPlus];
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/AsYouType.js
var require_AsYouType = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/AsYouType.js"(exports2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _metadata = _interopRequireDefault(require_metadata());
    var _PhoneNumber = _interopRequireDefault(require_PhoneNumber());
    var _AsYouTypeState = _interopRequireDefault(require_AsYouTypeState());
    var _AsYouTypeFormatter = _interopRequireWildcard(require_AsYouTypeFormatter());
    var _AsYouTypeParser = _interopRequireWildcard(require_AsYouTypeParser());
    var _getCountryByCallingCode = _interopRequireDefault(require_getCountryByCallingCode());
    var _getCountryByNationalNumber = _interopRequireDefault(require_getCountryByNationalNumber());
    var _isObject = _interopRequireDefault(require_isObject2());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
    var AsYouType = /* @__PURE__ */ function() {
      function AsYouType2(optionsOrDefaultCountry, metadata) {
        _classCallCheck(this, AsYouType2);
        this.metadata = new _metadata["default"](metadata);
        var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry), _this$getCountryAndCa2 = _slicedToArray(_this$getCountryAndCa, 2), defaultCountry = _this$getCountryAndCa2[0], defaultCallingCode = _this$getCountryAndCa2[1];
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.reset();
      }
      _createClass(AsYouType2, [{
        key: "getCountryAndCallingCode",
        value: function getCountryAndCallingCode(optionsOrDefaultCountry) {
          var defaultCountry;
          var defaultCallingCode;
          if (optionsOrDefaultCountry) {
            if ((0, _isObject["default"])(optionsOrDefaultCountry)) {
              defaultCountry = optionsOrDefaultCountry.defaultCountry;
              defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;
            } else {
              defaultCountry = optionsOrDefaultCountry;
            }
          }
          if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {
            defaultCountry = void 0;
          }
          if (defaultCallingCode) {
            if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
              if (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {
                defaultCountry = "001";
              }
            }
          }
          return [defaultCountry, defaultCallingCode];
        }
        /**
         * Inputs "next" phone number characters.
         * @param  {string} text
         * @return {string} Formatted phone number characters that have been input so far.
         */
      }, {
        key: "input",
        value: function input(text) {
          var _this$parser$input = this.parser.input(text, this.state), digits = _this$parser$input.digits, justLeadingPlus = _this$parser$input.justLeadingPlus;
          if (justLeadingPlus) {
            this.formattedOutput = "+";
          } else if (digits) {
            this.determineTheCountryIfNeeded();
            if (this.state.nationalSignificantNumber) {
              this.formatter.narrowDownMatchingFormats(this.state);
            }
            var formattedNationalNumber;
            if (this.metadata.hasSelectedNumberingPlan()) {
              formattedNationalNumber = this.formatter.format(digits, this.state);
            }
            if (formattedNationalNumber === void 0) {
              if (this.parser.reExtractNationalSignificantNumber(this.state)) {
                this.determineTheCountryIfNeeded();
                var nationalDigits = this.state.getNationalDigits();
                if (nationalDigits) {
                  formattedNationalNumber = this.formatter.format(nationalDigits, this.state);
                }
              }
            }
            this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();
          }
          return this.formattedOutput;
        }
      }, {
        key: "reset",
        value: function reset() {
          var _this = this;
          this.state = new _AsYouTypeState["default"]({
            onCountryChange: function onCountryChange(country2) {
              _this.country = country2;
            },
            onCallingCodeChange: function onCallingCodeChange(callingCode, country2) {
              _this.metadata.selectNumberingPlan(country2, callingCode);
              _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
              _this.parser.reset(_this.metadata.numberingPlan);
            }
          });
          this.formatter = new _AsYouTypeFormatter["default"]({
            state: this.state,
            metadata: this.metadata
          });
          this.parser = new _AsYouTypeParser["default"]({
            defaultCountry: this.defaultCountry,
            defaultCallingCode: this.defaultCallingCode,
            metadata: this.metadata,
            state: this.state,
            onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {
              _this.determineTheCountryIfNeeded();
              _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
            }
          });
          this.state.reset({
            country: this.defaultCountry,
            callingCode: this.defaultCallingCode
          });
          this.formattedOutput = "";
          return this;
        }
        /**
         * Returns `true` if the phone number is being input in international format.
         * In other words, returns `true` if and only if the parsed phone number starts with a `"+"`.
         * @return {boolean}
         */
      }, {
        key: "isInternational",
        value: function isInternational() {
          return this.state.international;
        }
        /**
         * Returns the "calling code" part of the phone number when it's being input
         * in an international format.
         * If no valid calling code has been entered so far, returns `undefined`.
         * @return {string} [callingCode]
         */
      }, {
        key: "getCallingCode",
        value: function getCallingCode() {
          if (this.isInternational()) {
            return this.state.callingCode;
          }
        }
        // A legacy alias.
      }, {
        key: "getCountryCallingCode",
        value: function getCountryCallingCode() {
          return this.getCallingCode();
        }
        /**
         * Returns a two-letter country code of the phone number.
         * Returns `undefined` for "non-geographic" phone numbering plans.
         * Returns `undefined` if no phone number has been input yet.
         * @return {string} [country]
         */
      }, {
        key: "getCountry",
        value: function getCountry() {
          var digits = this.state.digits;
          if (digits) {
            return this._getCountry();
          }
        }
        /**
         * Returns a two-letter country code of the phone number.
         * Returns `undefined` for "non-geographic" phone numbering plans.
         * @return {string} [country]
         */
      }, {
        key: "_getCountry",
        value: function _getCountry() {
          var country2 = this.state.country;
          if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
            if (country2 === "001") {
              return;
            }
          }
          return country2;
        }
      }, {
        key: "determineTheCountryIfNeeded",
        value: function determineTheCountryIfNeeded() {
          if (!this.state.country || this.isCountryCallingCodeAmbiguous()) {
            this.determineTheCountry();
          }
        }
        // Prepends `+CountryCode ` in case of an international phone number
      }, {
        key: "getFullNumber",
        value: function getFullNumber(formattedNationalNumber) {
          var _this2 = this;
          if (this.isInternational()) {
            var prefix = function prefix2(text) {
              return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {
                spacing: text ? true : false
              }) + text;
            };
            var callingCode = this.state.callingCode;
            if (!callingCode) {
              return prefix("".concat(this.state.getDigitsWithoutInternationalPrefix()));
            }
            if (!formattedNationalNumber) {
              return prefix(callingCode);
            }
            return prefix("".concat(callingCode, " ").concat(formattedNationalNumber));
          }
          return formattedNationalNumber;
        }
      }, {
        key: "getNonFormattedNationalNumberWithPrefix",
        value: function getNonFormattedNationalNumberWithPrefix() {
          var _this$state = this.state, nationalSignificantNumber = _this$state.nationalSignificantNumber, complexPrefixBeforeNationalSignificantNumber = _this$state.complexPrefixBeforeNationalSignificantNumber, nationalPrefix = _this$state.nationalPrefix;
          var number = nationalSignificantNumber;
          var prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix;
          if (prefix) {
            number = prefix + number;
          }
          return number;
        }
      }, {
        key: "getNonFormattedNumber",
        value: function getNonFormattedNumber() {
          var nationalSignificantNumberMatchesInput = this.state.nationalSignificantNumberMatchesInput;
          return this.getFullNumber(nationalSignificantNumberMatchesInput ? this.getNonFormattedNationalNumberWithPrefix() : this.state.getNationalDigits());
        }
      }, {
        key: "getNonFormattedTemplate",
        value: function getNonFormattedTemplate() {
          var number = this.getNonFormattedNumber();
          if (number) {
            return number.replace(/[\+\d]/g, _AsYouTypeFormatter.DIGIT_PLACEHOLDER);
          }
        }
      }, {
        key: "isCountryCallingCodeAmbiguous",
        value: function isCountryCallingCodeAmbiguous() {
          var callingCode = this.state.callingCode;
          var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);
          return countryCodes && countryCodes.length > 1;
        }
        // Determines the country of the phone number
        // entered so far based on the country phone code
        // and the national phone number.
      }, {
        key: "determineTheCountry",
        value: function determineTheCountry() {
          this.state.setCountry((0, _getCountryByCallingCode["default"])(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, {
            nationalNumber: this.state.nationalSignificantNumber,
            defaultCountry: this.defaultCountry,
            metadata: this.metadata
          }));
        }
        /**
         * Returns a E.164 phone number value for the user's input.
         *
         * For example, for country `"US"` and input `"(222) 333-4444"`
         * it will return `"+12223334444"`.
         *
         * For international phone number input, it will also auto-correct
         * some minor errors such as using a national prefix when writing
         * an international phone number. For example, if the user inputs
         * `"+44 0 7400 000000"` then it will return an auto-corrected
         * `"+447400000000"` phone number value.
         *
         * Will return `undefined` if no digits have been input,
         * or when inputting a phone number in national format and no
         * default country or default "country calling code" have been set.
         *
         * @return {string} [value]
         */
      }, {
        key: "getNumberValue",
        value: function getNumberValue() {
          var _this$state2 = this.state, digits = _this$state2.digits, callingCode = _this$state2.callingCode, country2 = _this$state2.country, nationalSignificantNumber = _this$state2.nationalSignificantNumber;
          if (!digits) {
            return;
          }
          if (this.isInternational()) {
            if (callingCode) {
              return "+" + callingCode + nationalSignificantNumber;
            } else {
              return "+" + digits;
            }
          } else {
            if (country2 || callingCode) {
              var callingCode_ = country2 ? this.metadata.countryCallingCode() : callingCode;
              return "+" + callingCode_ + nationalSignificantNumber;
            }
          }
        }
        /**
         * Returns an instance of `PhoneNumber` class.
         * Will return `undefined` if no national (significant) number
         * digits have been entered so far, or if no `defaultCountry` has been
         * set and the user enters a phone number not in international format.
         */
      }, {
        key: "getNumber",
        value: function getNumber() {
          var _this$state3 = this.state, nationalSignificantNumber = _this$state3.nationalSignificantNumber, carrierCode = _this$state3.carrierCode, callingCode = _this$state3.callingCode;
          var country2 = this._getCountry();
          if (!nationalSignificantNumber) {
            return;
          }
          if (!country2 && !callingCode) {
            return;
          }
          if (country2) {
            if (country2 === this.defaultCountry) {
              var metadata = new _metadata["default"](this.metadata.metadata);
              metadata.selectNumberingPlan(country2);
              var _callingCode = metadata.numberingPlan.callingCode();
              var ambiguousCountries = this.metadata.getCountryCodesForCallingCode(_callingCode);
              if (ambiguousCountries.length > 1) {
                var exactCountry = (0, _getCountryByNationalNumber["default"])(nationalSignificantNumber, {
                  countries: ambiguousCountries,
                  defaultCountry: this.defaultCountry,
                  metadata: this.metadata.metadata
                });
                if (exactCountry) {
                  country2 = exactCountry;
                }
              }
            }
          }
          var phoneNumber = new _PhoneNumber["default"](country2 || callingCode, nationalSignificantNumber, this.metadata.metadata);
          if (carrierCode) {
            phoneNumber.carrierCode = carrierCode;
          }
          return phoneNumber;
        }
        /**
         * Returns `true` if the phone number is "possible".
         * Is just a shortcut for `PhoneNumber.isPossible()`.
         * @return {boolean}
         */
      }, {
        key: "isPossible",
        value: function isPossible() {
          var phoneNumber = this.getNumber();
          if (!phoneNumber) {
            return false;
          }
          return phoneNumber.isPossible();
        }
        /**
         * Returns `true` if the phone number is "valid".
         * Is just a shortcut for `PhoneNumber.isValid()`.
         * @return {boolean}
         */
      }, {
        key: "isValid",
        value: function isValid() {
          var phoneNumber = this.getNumber();
          if (!phoneNumber) {
            return false;
          }
          return phoneNumber.isValid();
        }
        /**
         * @deprecated
         * This method is used in `react-phone-number-input/source/input-control.js`
         * in versions before `3.0.16`.
         */
      }, {
        key: "getNationalNumber",
        value: function getNationalNumber() {
          return this.state.nationalSignificantNumber;
        }
        /**
         * Returns the phone number characters entered by the user.
         * @return {string}
         */
      }, {
        key: "getChars",
        value: function getChars() {
          return (this.state.international ? "+" : "") + this.state.digits;
        }
        /**
         * Returns the template for the formatted phone number.
         * @return {string}
         */
      }, {
        key: "getTemplate",
        value: function getTemplate() {
          return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || "";
        }
      }]);
      return AsYouType2;
    }();
    exports2["default"] = AsYouType;
  }
});

// asset-input/node_modules/libphonenumber-js/build/getCountries.js
var require_getCountries = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/getCountries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getCountries;
    var _metadata = _interopRequireDefault(require_metadata());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function getCountries(metadata) {
      return new _metadata["default"](metadata).getCountries();
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/getExampleNumber.js
var require_getExampleNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/getExampleNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = getExampleNumber;
    var _PhoneNumber = _interopRequireDefault(require_PhoneNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function getExampleNumber(country2, examples, metadata) {
      if (examples[country2]) {
        return new _PhoneNumber["default"](country2, examples[country2], metadata);
      }
    }
  }
});

// asset-input/node_modules/libphonenumber-js/build/formatIncompletePhoneNumber.js
var require_formatIncompletePhoneNumber = __commonJS({
  "asset-input/node_modules/libphonenumber-js/build/formatIncompletePhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = formatIncompletePhoneNumber;
    var _AsYouType = _interopRequireDefault(require_AsYouType());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function formatIncompletePhoneNumber(value, optionsOrDefaultCountry, metadata) {
      if (!metadata) {
        metadata = optionsOrDefaultCountry;
        optionsOrDefaultCountry = void 0;
      }
      return new _AsYouType["default"](optionsOrDefaultCountry, metadata).input(value);
    }
  }
});

// asset-input/node_modules/libphonenumber-js/core/index.cjs
var require_core = __commonJS({
  "asset-input/node_modules/libphonenumber-js/core/index.cjs"(exports2, module2) {
    "use strict";
    var parsePhoneNumberFromString = require_parsePhoneNumber2().default;
    exports2 = module2.exports = parsePhoneNumberFromString;
    exports2["default"] = parsePhoneNumberFromString;
    exports2.ParseError = require_ParseError().default;
    var parsePhoneNumberWithError = require_parsePhoneNumberWithError2().default;
    exports2.parsePhoneNumberWithError = parsePhoneNumberWithError;
    exports2.parsePhoneNumber = parsePhoneNumberWithError;
    exports2.parsePhoneNumberFromString = parsePhoneNumberFromString;
    exports2.isValidPhoneNumber = require_isValidPhoneNumber().default;
    exports2.isPossiblePhoneNumber = require_isPossiblePhoneNumber().default;
    exports2.validatePhoneNumberLength = require_validatePhoneNumberLength().default;
    exports2.findNumbers = require_findNumbers().default;
    exports2.searchNumbers = require_searchNumbers().default;
    exports2.findPhoneNumbersInText = require_findPhoneNumbersInText().default;
    exports2.searchPhoneNumbersInText = require_searchPhoneNumbersInText().default;
    exports2.PhoneNumberMatcher = require_PhoneNumberMatcher().default;
    exports2.AsYouType = require_AsYouType().default;
    exports2.Metadata = require_metadata().default;
    exports2.isSupportedCountry = require_metadata().isSupportedCountry;
    exports2.getCountries = require_getCountries().default;
    exports2.getCountryCallingCode = require_metadata().getCountryCallingCode;
    exports2.getExtPrefix = require_metadata().getExtPrefix;
    exports2.getExampleNumber = require_getExampleNumber().default;
    exports2.formatIncompletePhoneNumber = require_formatIncompletePhoneNumber().default;
    exports2.parseIncompletePhoneNumber = require_parseIncompletePhoneNumber().default;
    exports2.parsePhoneNumberCharacter = require_parseIncompletePhoneNumber().parsePhoneNumberCharacter;
    exports2.parseDigits = require_parseDigits().default;
    exports2.DIGIT_PLACEHOLDER = require_AsYouTypeFormatter().DIGIT_PLACEHOLDER;
    exports2.parseRFC3966 = require_RFC3966().parseRFC3966;
    exports2.formatRFC3966 = require_RFC3966().formatRFC3966;
  }
});

// asset-input/node_modules/libphonenumber-js/max/index.cjs
var require_max = __commonJS({
  "asset-input/node_modules/libphonenumber-js/max/index.cjs"(exports2, module2) {
    "use strict";
    var metadata = require_metadata_max();
    var core = require_core();
    function call(func, _arguments) {
      var args = Array.prototype.slice.call(_arguments);
      args.push(metadata);
      return func.apply(this, args);
    }
    function parsePhoneNumberFromString() {
      return call(core.parsePhoneNumberFromString, arguments);
    }
    exports2 = module2.exports = parsePhoneNumberFromString;
    exports2["default"] = parsePhoneNumberFromString;
    exports2.ParseError = core.ParseError;
    function parsePhoneNumberWithError() {
      return call(core.parsePhoneNumberWithError, arguments);
    }
    exports2.parsePhoneNumber = parsePhoneNumberWithError;
    exports2.parsePhoneNumberWithError = parsePhoneNumberWithError;
    exports2.parsePhoneNumberFromString = parsePhoneNumberFromString;
    exports2.isValidPhoneNumber = function isValidPhoneNumber() {
      return call(core.isValidPhoneNumber, arguments);
    };
    exports2.isPossiblePhoneNumber = function isPossiblePhoneNumber() {
      return call(core.isPossiblePhoneNumber, arguments);
    };
    exports2.validatePhoneNumberLength = function validatePhoneNumberLength() {
      return call(core.validatePhoneNumberLength, arguments);
    };
    exports2.findNumbers = function findNumbers() {
      return call(core.findNumbers, arguments);
    };
    exports2.searchNumbers = function searchNumbers() {
      return call(core.searchNumbers, arguments);
    };
    exports2.findPhoneNumbersInText = function findPhoneNumbersInText() {
      return call(core.findPhoneNumbersInText, arguments);
    };
    exports2.searchPhoneNumbersInText = function searchPhoneNumbersInText() {
      return call(core.searchPhoneNumbersInText, arguments);
    };
    exports2.PhoneNumberMatcher = function PhoneNumberMatcher(text, options) {
      return core.PhoneNumberMatcher.call(this, text, options, metadata);
    };
    exports2.PhoneNumberMatcher.prototype = Object.create(core.PhoneNumberMatcher.prototype, {});
    exports2.PhoneNumberMatcher.prototype.constructor = exports2.PhoneNumberMatcher;
    exports2.AsYouType = function AsYouType(country2) {
      return core.AsYouType.call(this, country2, metadata);
    };
    exports2.AsYouType.prototype = Object.create(core.AsYouType.prototype, {});
    exports2.AsYouType.prototype.constructor = exports2.AsYouType;
    exports2.isSupportedCountry = function isSupportedCountry(country2) {
      return call(core.isSupportedCountry, arguments);
    };
    exports2.getCountries = function getCountries() {
      return call(core.getCountries, arguments);
    };
    exports2.getCountryCallingCode = function getCountryCallingCode() {
      return call(core.getCountryCallingCode, arguments);
    };
    exports2.getExtPrefix = function getExtPrefix(country2) {
      return call(core.getExtPrefix, arguments);
    };
    exports2.getExampleNumber = function getExampleNumber() {
      return call(core.getExampleNumber, arguments);
    };
    exports2.formatIncompletePhoneNumber = function formatIncompletePhoneNumber() {
      return call(core.formatIncompletePhoneNumber, arguments);
    };
    exports2.parseIncompletePhoneNumber = core.parseIncompletePhoneNumber;
    exports2.parsePhoneNumberCharacter = core.parsePhoneNumberCharacter;
    exports2.parseDigits = core.parseDigits;
    exports2.DIGIT_PLACEHOLDER = core.DIGIT_PLACEHOLDER;
    exports2.parseRFC3966 = core.parseRFC3966;
    exports2.formatRFC3966 = core.formatRFC3966;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsPhoneNumber.js
var require_IsPhoneNumber = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsPhoneNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsPhoneNumber = exports2.isPhoneNumber = exports2.IS_PHONE_NUMBER = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var max_1 = require_max();
    exports2.IS_PHONE_NUMBER = "isPhoneNumber";
    function isPhoneNumber(value, region) {
      if (typeof value !== "string" || value.trim() !== value) {
        return false;
      }
      try {
        const phoneNumber = (0, max_1.parsePhoneNumber)(value, region);
        if (region && phoneNumber.country !== region) {
          return false;
        }
        return phoneNumber.isValid();
      } catch (error) {
        return false;
      }
    }
    exports2.isPhoneNumber = isPhoneNumber;
    function IsPhoneNumber(region, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_PHONE_NUMBER,
        constraints: [region],
        validator: {
          validate: (value, args) => isPhoneNumber(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid phone number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsPhoneNumber = IsPhoneNumber;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsMilitaryTime.js
var require_IsMilitaryTime = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsMilitaryTime.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsMilitaryTime = exports2.isMilitaryTime = exports2.IS_MILITARY_TIME = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var matches_1 = __importDefault(require_matches());
    exports2.IS_MILITARY_TIME = "isMilitaryTime";
    function isMilitaryTime(value) {
      const militaryTimeRegex = /^([01]\d|2[0-3]):?([0-5]\d)$/;
      return typeof value === "string" && (0, matches_1.default)(value, militaryTimeRegex);
    }
    exports2.isMilitaryTime = isMilitaryTime;
    function IsMilitaryTime(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_MILITARY_TIME,
        validator: {
          validate: (value, args) => isMilitaryTime(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid representation of military time in the format HH:MM", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsMilitaryTime = IsMilitaryTime;
  }
});

// asset-input/node_modules/validator/lib/isHash.js
var require_isHash = __commonJS({
  "asset-input/node_modules/validator/lib/isHash.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isHash;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lengths = {
      md5: 32,
      md4: 32,
      sha1: 40,
      sha256: 64,
      sha384: 96,
      sha512: 128,
      ripemd128: 32,
      ripemd160: 40,
      tiger128: 32,
      tiger160: 40,
      tiger192: 48,
      crc32: 8,
      crc32b: 8
    };
    function isHash(str, algorithm) {
      (0, _assertString.default)(str);
      var hash = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
      return hash.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsHash.js
var require_IsHash = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsHash.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsHash = exports2.isHash = exports2.IS_HASH = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isHash_1 = __importDefault(require_isHash());
    exports2.IS_HASH = "isHash";
    function isHash(value, algorithm) {
      return typeof value === "string" && (0, isHash_1.default)(value, algorithm);
    }
    exports2.isHash = isHash;
    function IsHash(algorithm, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_HASH,
        constraints: [algorithm],
        validator: {
          validate: (value, args) => isHash(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a hash of type $constraint1", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsHash = IsHash;
  }
});

// asset-input/node_modules/validator/lib/isISSN.js
var require_isISSN = __commonJS({
  "asset-input/node_modules/validator/lib/isISSN.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISSN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var issn = "^\\d{4}-?\\d{3}[\\dX]$";
    function isISSN(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var testIssn = issn;
      testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn;
      testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
      if (!testIssn.test(str)) {
        return false;
      }
      var digits = str.replace("-", "").toUpperCase();
      var checksum = 0;
      for (var i = 0; i < digits.length; i++) {
        var digit = digits[i];
        checksum += (digit === "X" ? 10 : +digit) * (8 - i);
      }
      return checksum % 11 === 0;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsISSN.js
var require_IsISSN = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsISSN.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISSN = exports2.isISSN = exports2.IS_ISSN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISSN_1 = __importDefault(require_isISSN());
    exports2.IS_ISSN = "isISSN";
    function isISSN(value, options) {
      return typeof value === "string" && (0, isISSN_1.default)(value, options);
    }
    exports2.isISSN = isISSN;
    function IsISSN(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISSN,
        constraints: [options],
        validator: {
          validate: (value, args) => isISSN(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a ISSN", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISSN = IsISSN;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsDateString.js
var require_IsDateString = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsDateString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsDateString = exports2.isDateString = exports2.IS_DATE_STRING = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var IsISO8601_1 = require_IsISO8601();
    exports2.IS_DATE_STRING = "isDateString";
    function isDateString(value, options) {
      return (0, IsISO8601_1.isISO8601)(value, options);
    }
    exports2.isDateString = isDateString;
    function IsDateString(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_DATE_STRING,
        constraints: [options],
        validator: {
          validate: (value) => isDateString(value, options),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid ISO 8601 date string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsDateString = IsDateString;
  }
});

// asset-input/node_modules/validator/lib/isBoolean.js
var require_isBoolean = __commonJS({
  "asset-input/node_modules/validator/lib/isBoolean.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBoolean;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var defaultOptions = {
      loose: false
    };
    var strictBooleans = ["true", "false", "1", "0"];
    var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
    function isBoolean(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions;
      (0, _assertString.default)(str);
      if (options.loose) {
        return looseBooleans.includes(str.toLowerCase());
      }
      return strictBooleans.includes(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsBooleanString.js
var require_IsBooleanString = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsBooleanString.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsBooleanString = exports2.isBooleanString = exports2.IS_BOOLEAN_STRING = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isBoolean_1 = __importDefault(require_isBoolean());
    exports2.IS_BOOLEAN_STRING = "isBooleanString";
    function isBooleanString(value) {
      return typeof value === "string" && (0, isBoolean_1.default)(value);
    }
    exports2.isBooleanString = isBooleanString;
    function IsBooleanString(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BOOLEAN_STRING,
        validator: {
          validate: (value, args) => isBooleanString(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a boolean string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsBooleanString = IsBooleanString;
  }
});

// asset-input/node_modules/validator/lib/isNumeric.js
var require_isNumeric = __commonJS({
  "asset-input/node_modules/validator/lib/isNumeric.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isNumeric;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var numericNoSymbols = /^[0-9]+$/;
    function isNumeric(str, options) {
      (0, _assertString.default)(str);
      if (options && options.no_symbols) {
        return numericNoSymbols.test(str);
      }
      return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsNumberString.js
var require_IsNumberString = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsNumberString.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsNumberString = exports2.isNumberString = exports2.IS_NUMBER_STRING = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isNumeric_1 = __importDefault(require_isNumeric());
    exports2.IS_NUMBER_STRING = "isNumberString";
    function isNumberString(value, options) {
      return typeof value === "string" && (0, isNumeric_1.default)(value, options);
    }
    exports2.isNumberString = isNumberString;
    function IsNumberString(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_NUMBER_STRING,
        constraints: [options],
        validator: {
          validate: (value, args) => isNumberString(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a number string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsNumberString = IsNumberString;
  }
});

// asset-input/node_modules/validator/lib/isBase32.js
var require_isBase32 = __commonJS({
  "asset-input/node_modules/validator/lib/isBase32.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBase32;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var base32 = /^[A-Z2-7]+=*$/;
    var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
    var defaultBase32Options = {
      crockford: false
    };
    function isBase32(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase32Options);
      if (options.crockford) {
        return crockfordBase32.test(str);
      }
      var len = str.length;
      if (len % 8 === 0 && base32.test(str)) {
        return true;
      }
      return false;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsBase32.js
var require_IsBase32 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsBase32.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsBase32 = exports2.isBase32 = exports2.IS_BASE32 = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isBase32_1 = __importDefault(require_isBase32());
    exports2.IS_BASE32 = "isBase32";
    function isBase32(value) {
      return typeof value === "string" && (0, isBase32_1.default)(value);
    }
    exports2.isBase32 = isBase32;
    function IsBase32(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BASE32,
        validator: {
          validate: (value, args) => isBase32(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be base32 encoded", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsBase32 = IsBase32;
  }
});

// asset-input/node_modules/validator/lib/isBIC.js
var require_isBIC = __commonJS({
  "asset-input/node_modules/validator/lib/isBIC.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBIC;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isISO31661Alpha = require_isISO31661Alpha2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
    function isBIC(str) {
      (0, _assertString.default)(str);
      var countryCode = str.slice(4, 6).toUpperCase();
      if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== "XK") {
        return false;
      }
      return isBICReg.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsBIC.js
var require_IsBIC = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsBIC.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsBIC = exports2.isBIC = exports2.IS_BIC = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isBIC_1 = __importDefault(require_isBIC());
    exports2.IS_BIC = "isBIC";
    function isBIC(value) {
      return typeof value === "string" && (0, isBIC_1.default)(value);
    }
    exports2.isBIC = isBIC;
    function IsBIC(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BIC,
        validator: {
          validate: (value, args) => isBIC(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a BIC or SWIFT code", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsBIC = IsBIC;
  }
});

// asset-input/node_modules/validator/lib/isBtcAddress.js
var require_isBtcAddress = __commonJS({
  "asset-input/node_modules/validator/lib/isBtcAddress.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBtcAddress;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
    var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
    function isBtcAddress(str) {
      (0, _assertString.default)(str);
      return bech32.test(str) || base58.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsBtcAddress.js
var require_IsBtcAddress = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsBtcAddress.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsBtcAddress = exports2.isBtcAddress = exports2.IS_BTC_ADDRESS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isBtcAddress_1 = __importDefault(require_isBtcAddress());
    exports2.IS_BTC_ADDRESS = "isBtcAddress";
    function isBtcAddress(value) {
      return typeof value === "string" && (0, isBtcAddress_1.default)(value);
    }
    exports2.isBtcAddress = isBtcAddress;
    function IsBtcAddress(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BTC_ADDRESS,
        validator: {
          validate: (value, args) => isBtcAddress(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a BTC address", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsBtcAddress = IsBtcAddress;
  }
});

// asset-input/node_modules/validator/lib/isDataURI.js
var require_isDataURI = __commonJS({
  "asset-input/node_modules/validator/lib/isDataURI.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isDataURI;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
    var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
    var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
    function isDataURI(str) {
      (0, _assertString.default)(str);
      var data = str.split(",");
      if (data.length < 2) {
        return false;
      }
      var attributes = data.shift().trim().split(";");
      var schemeAndMediaType = attributes.shift();
      if (schemeAndMediaType.slice(0, 5) !== "data:") {
        return false;
      }
      var mediaType = schemeAndMediaType.slice(5);
      if (mediaType !== "" && !validMediaType.test(mediaType)) {
        return false;
      }
      for (var i = 0; i < attributes.length; i++) {
        if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === "base64") && !validAttribute.test(attributes[i])) {
          return false;
        }
      }
      for (var _i = 0; _i < data.length; _i++) {
        if (!validData.test(data[_i])) {
          return false;
        }
      }
      return true;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsDataURI.js
var require_IsDataURI = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsDataURI.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsDataURI = exports2.isDataURI = exports2.IS_DATA_URI = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isDataURI_1 = __importDefault(require_isDataURI());
    exports2.IS_DATA_URI = "isDataURI";
    function isDataURI(value) {
      return typeof value === "string" && (0, isDataURI_1.default)(value);
    }
    exports2.isDataURI = isDataURI;
    function IsDataURI(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_DATA_URI,
        validator: {
          validate: (value, args) => isDataURI(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a data uri format", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsDataURI = IsDataURI;
  }
});

// asset-input/node_modules/validator/lib/isEAN.js
var require_isEAN = __commonJS({
  "asset-input/node_modules/validator/lib/isEAN.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isEAN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var LENGTH_EAN_8 = 8;
    var LENGTH_EAN_14 = 14;
    var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;
    function getPositionWeightThroughLengthAndIndex(length, index) {
      if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
        return index % 2 === 0 ? 3 : 1;
      }
      return index % 2 === 0 ? 1 : 3;
    }
    function calculateCheckDigit(ean) {
      var checksum = ean.slice(0, -1).split("").map(function(char, index) {
        return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index);
      }).reduce(function(acc, partialSum) {
        return acc + partialSum;
      }, 0);
      var remainder = 10 - checksum % 10;
      return remainder < 10 ? remainder : 0;
    }
    function isEAN(str) {
      (0, _assertString.default)(str);
      var actualCheckDigit = Number(str.slice(-1));
      return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsEAN.js
var require_IsEAN = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsEAN.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsEAN = exports2.isEAN = exports2.IS_EAN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isEAN_1 = __importDefault(require_isEAN());
    exports2.IS_EAN = "isEAN";
    function isEAN(value) {
      return typeof value === "string" && (0, isEAN_1.default)(value);
    }
    exports2.isEAN = isEAN;
    function IsEAN(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_EAN,
        validator: {
          validate: (value, args) => isEAN(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an EAN (European Article Number)", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsEAN = IsEAN;
  }
});

// asset-input/node_modules/validator/lib/isEthereumAddress.js
var require_isEthereumAddress = __commonJS({
  "asset-input/node_modules/validator/lib/isEthereumAddress.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isEthereumAddress;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var eth = /^(0x)[0-9a-f]{40}$/i;
    function isEthereumAddress(str) {
      (0, _assertString.default)(str);
      return eth.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsEthereumAddress.js
var require_IsEthereumAddress = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsEthereumAddress.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsEthereumAddress = exports2.isEthereumAddress = exports2.IS_ETHEREUM_ADDRESS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isEthereumAddress_1 = __importDefault(require_isEthereumAddress());
    exports2.IS_ETHEREUM_ADDRESS = "isEthereumAddress";
    function isEthereumAddress(value) {
      return typeof value === "string" && (0, isEthereumAddress_1.default)(value);
    }
    exports2.isEthereumAddress = isEthereumAddress;
    function IsEthereumAddress(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ETHEREUM_ADDRESS,
        validator: {
          validate: (value, args) => isEthereumAddress(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an Ethereum address", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsEthereumAddress = IsEthereumAddress;
  }
});

// asset-input/node_modules/validator/lib/isHSL.js
var require_isHSL = __commonJS({
  "asset-input/node_modules/validator/lib/isHSL.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isHSL;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
    var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
    function isHSL(str) {
      (0, _assertString.default)(str);
      var strippedStr = str.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
      if (strippedStr.indexOf(",") !== -1) {
        return hslComma.test(strippedStr);
      }
      return hslSpace.test(strippedStr);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsHSL.js
var require_IsHSL = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsHSL.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsHSL = exports2.isHSL = exports2.IS_HSL = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isHSL_1 = __importDefault(require_isHSL());
    exports2.IS_HSL = "isHSL";
    function isHSL(value) {
      return typeof value === "string" && (0, isHSL_1.default)(value);
    }
    exports2.isHSL = isHSL;
    function IsHSL(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_HSL,
        validator: {
          validate: (value, args) => isHSL(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a HSL color", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsHSL = IsHSL;
  }
});

// asset-input/node_modules/validator/lib/isIBAN.js
var require_isIBAN = __commonJS({
  "asset-input/node_modules/validator/lib/isIBAN.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isIBAN;
    exports2.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ibanRegexThroughCountryCode = {
      AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
      AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
      AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
      AT: /^(AT[0-9]{2})\d{16}$/,
      AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      BA: /^(BA[0-9]{2})\d{16}$/,
      BE: /^(BE[0-9]{2})\d{12}$/,
      BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
      BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
      BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
      BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
      CR: /^(CR[0-9]{2})\d{18}$/,
      CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
      CZ: /^(CZ[0-9]{2})\d{20}$/,
      DE: /^(DE[0-9]{2})\d{18}$/,
      DK: /^(DK[0-9]{2})\d{14}$/,
      DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
      DZ: /^(DZ\d{24})$/,
      EE: /^(EE[0-9]{2})\d{16}$/,
      EG: /^(EG[0-9]{2})\d{25}$/,
      ES: /^(ES[0-9]{2})\d{20}$/,
      FI: /^(FI[0-9]{2})\d{14}$/,
      FO: /^(FO[0-9]{2})\d{14}$/,
      FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
      GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
      GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
      GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
      GL: /^(GL[0-9]{2})\d{14}$/,
      GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
      GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
      HR: /^(HR[0-9]{2})\d{17}$/,
      HU: /^(HU[0-9]{2})\d{24}$/,
      IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
      IL: /^(IL[0-9]{2})\d{19}$/,
      IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
      IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
      IS: /^(IS[0-9]{2})\d{22}$/,
      IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
      JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
      KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
      KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
      LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
      LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
      LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
      LT: /^(LT[0-9]{2})\d{16}$/,
      LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
      LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
      MA: /^(MA[0-9]{26})$/,
      MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
      MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
      ME: /^(ME[0-9]{2})\d{18}$/,
      MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
      MR: /^(MR[0-9]{2})\d{23}$/,
      MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
      MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
      MZ: /^(MZ[0-9]{2})\d{21}$/,
      NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
      NO: /^(NO[0-9]{2})\d{11}$/,
      PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
      PL: /^(PL[0-9]{2})\d{24}$/,
      PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
      PT: /^(PT[0-9]{2})\d{21}$/,
      QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
      RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
      RS: /^(RS[0-9]{2})\d{18}$/,
      SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
      SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
      SE: /^(SE[0-9]{2})\d{20}$/,
      SI: /^(SI[0-9]{2})\d{15}$/,
      SK: /^(SK[0-9]{2})\d{20}$/,
      SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
      SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      TL: /^(TL[0-9]{2})\d{19}$/,
      TN: /^(TN[0-9]{2})\d{20}$/,
      TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
      UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
      VA: /^(VA[0-9]{2})\d{18}$/,
      VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
      XK: /^(XK[0-9]{2})\d{16}$/
    };
    function hasOnlyValidCountryCodes(countryCodeArray) {
      var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function(countryCode) {
        return !(countryCode in ibanRegexThroughCountryCode);
      });
      if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
        return false;
      }
      return true;
    }
    function hasValidIbanFormat(str, options) {
      var strippedStr = str.replace(/[\s\-]+/gi, "").toUpperCase();
      var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
      var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
      if (options.whitelist) {
        if (!hasOnlyValidCountryCodes(options.whitelist)) {
          return false;
        }
        var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);
        if (!isoCountryCodeInWhiteList) {
          return false;
        }
      }
      if (options.blacklist) {
        var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);
        if (isoCountryCodeInBlackList) {
          return false;
        }
      }
      return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
    }
    function hasValidIbanChecksum(str) {
      var strippedStr = str.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
      var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
      var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char) {
        return char.charCodeAt(0) - 55;
      });
      var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value) {
        return Number(acc + value) % 97;
      }, "");
      return remainder === 1;
    }
    function isIBAN(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
    }
    var locales = exports2.locales = Object.keys(ibanRegexThroughCountryCode);
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsIBAN.js
var require_IsIBAN = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsIBAN.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsIBAN = exports2.isIBAN = exports2.IS_IBAN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isIBAN_1 = __importDefault(require_isIBAN());
    exports2.IS_IBAN = "isIBAN";
    function isIBAN(value) {
      return typeof value === "string" && (0, isIBAN_1.default)(value);
    }
    exports2.isIBAN = isIBAN;
    function IsIBAN(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_IBAN,
        validator: {
          validate: (value, args) => isIBAN(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an IBAN", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsIBAN = IsIBAN;
  }
});

// asset-input/node_modules/validator/lib/isIdentityCard.js
var require_isIdentityCard = __commonJS({
  "asset-input/node_modules/validator/lib/isIdentityCard.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isIdentityCard;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isInt = _interopRequireDefault(require_isInt());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validators = {
      PL: function PL(str) {
        (0, _assertString.default)(str);
        var weightOfDigits = {
          1: 1,
          2: 3,
          3: 7,
          4: 9,
          5: 1,
          6: 3,
          7: 7,
          8: 9,
          9: 1,
          10: 3,
          11: 0
        };
        if (str != null && str.length === 11 && (0, _isInt.default)(str, {
          allow_leading_zeroes: true
        })) {
          var digits = str.split("").slice(0, -1);
          var sum = digits.reduce(function(acc, digit, index) {
            return acc + Number(digit) * weightOfDigits[index + 1];
          }, 0);
          var modulo = sum % 10;
          var lastDigit = Number(str.charAt(str.length - 1));
          if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
            return true;
          }
        }
        return false;
      },
      ES: function ES(str) {
        (0, _assertString.default)(str);
        var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
        var charsValue = {
          X: 0,
          Y: 1,
          Z: 2
        };
        var controlDigits = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
        var sanitized = str.trim().toUpperCase();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function(char) {
          return charsValue[char];
        });
        return sanitized.endsWith(controlDigits[number % 23]);
      },
      FI: function FI(str) {
        (0, _assertString.default)(str);
        if (str.length !== 11) {
          return false;
        }
        if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
          return false;
        }
        var checkDigits = "0123456789ABCDEFHJKLMNPRSTUVWXY";
        var idAsNumber = parseInt(str.slice(0, 6), 10) * 1e3 + parseInt(str.slice(7, 10), 10);
        var remainder = idAsNumber % 31;
        var checkDigit = checkDigits[remainder];
        return checkDigit === str.slice(10, 11);
      },
      IN: function IN(str) {
        var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;
        var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
        var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var c = 0;
        var invertedArray = sanitized.replace(/\s/g, "").split("").map(Number).reverse();
        invertedArray.forEach(function(val, i) {
          c = d[c][p[i % 8][val]];
        });
        return c === 0;
      },
      IR: function IR(str) {
        if (!str.match(/^\d{10}$/)) return false;
        str = "0000".concat(str).slice(str.length - 6);
        if (parseInt(str.slice(3, 9), 10) === 0) return false;
        var lastNumber = parseInt(str.slice(9, 10), 10);
        var sum = 0;
        for (var i = 0; i < 9; i++) {
          sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
        }
        sum %= 11;
        return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
      },
      IT: function IT(str) {
        if (str.length !== 9) return false;
        if (str === "CA00000AA") return false;
        return str.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1;
      },
      NO: function NO(str) {
        var sanitized = str.trim();
        if (isNaN(Number(sanitized))) return false;
        if (sanitized.length !== 11) return false;
        if (sanitized === "00000000000") return false;
        var f = sanitized.split("").map(Number);
        var k1 = (11 - (3 * f[0] + 7 * f[1] + 6 * f[2] + 1 * f[3] + 8 * f[4] + 9 * f[5] + 4 * f[6] + 5 * f[7] + 2 * f[8]) % 11) % 11;
        var k2 = (11 - (5 * f[0] + 4 * f[1] + 3 * f[2] + 2 * f[3] + 7 * f[4] + 6 * f[5] + 5 * f[6] + 4 * f[7] + 3 * f[8] + 2 * k1) % 11) % 11;
        if (k1 !== f[9] || k2 !== f[10]) return false;
        return true;
      },
      TH: function TH(str) {
        if (!str.match(/^[1-8]\d{12}$/)) return false;
        var sum = 0;
        for (var i = 0; i < 12; i++) {
          sum += parseInt(str[i], 10) * (13 - i);
        }
        return str[12] === ((11 - sum % 11) % 10).toString();
      },
      LK: function LK(str) {
        var old_nic = /^[1-9]\d{8}[vx]$/i;
        var new_nic = /^[1-9]\d{11}$/i;
        if (str.length === 10 && old_nic.test(str)) return true;
        else if (str.length === 12 && new_nic.test(str)) return true;
        return false;
      },
      "he-IL": function heIL(str) {
        var DNI = /^\d{9}$/;
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var id = sanitized;
        var sum = 0, incNum;
        for (var i = 0; i < id.length; i++) {
          incNum = Number(id[i]) * (i % 2 + 1);
          sum += incNum > 9 ? incNum - 9 : incNum;
        }
        return sum % 10 === 0;
      },
      "ar-LY": function arLY(str) {
        var NIN = /^(1|2)\d{11}$/;
        var sanitized = str.trim();
        if (!NIN.test(sanitized)) {
          return false;
        }
        return true;
      },
      "ar-TN": function arTN(str) {
        var DNI = /^\d{8}$/;
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        return true;
      },
      "zh-CN": function zhCN(str) {
        var provincesAndCities = [
          "11",
          // 北京
          "12",
          // 天津
          "13",
          // 河北
          "14",
          // 山西
          "15",
          // 内蒙古
          "21",
          // 辽宁
          "22",
          // 吉林
          "23",
          // 黑龙江
          "31",
          // 上海
          "32",
          // 江苏
          "33",
          // 浙江
          "34",
          // 安徽
          "35",
          // 福建
          "36",
          // 江西
          "37",
          // 山东
          "41",
          // 河南
          "42",
          // 湖北
          "43",
          // 湖南
          "44",
          // 广东
          "45",
          // 广西
          "46",
          // 海南
          "50",
          // 重庆
          "51",
          // 四川
          "52",
          // 贵州
          "53",
          // 云南
          "54",
          // 西藏
          "61",
          // 陕西
          "62",
          // 甘肃
          "63",
          // 青海
          "64",
          // 宁夏
          "65",
          // 新疆
          "71",
          // 台湾
          "81",
          // 香港
          "82",
          // 澳门
          "91"
          // 国外
        ];
        var powers = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"];
        var parityBit = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
        var checkAddressCode = function checkAddressCode2(addressCode) {
          return provincesAndCities.includes(addressCode);
        };
        var checkBirthDayCode = function checkBirthDayCode2(birDayCode) {
          var yyyy = parseInt(birDayCode.substring(0, 4), 10);
          var mm = parseInt(birDayCode.substring(4, 6), 10);
          var dd = parseInt(birDayCode.substring(6), 10);
          var xdata = new Date(yyyy, mm - 1, dd);
          if (xdata > /* @__PURE__ */ new Date()) {
            return false;
          } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
            return true;
          }
          return false;
        };
        var getParityBit = function getParityBit2(idCardNo) {
          var id17 = idCardNo.substring(0, 17);
          var power = 0;
          for (var i = 0; i < 17; i++) {
            power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
          }
          var mod = power % 11;
          return parityBit[mod];
        };
        var checkParityBit = function checkParityBit2(idCardNo) {
          return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
        };
        var check15IdCardNo = function check15IdCardNo2(idCardNo) {
          var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
          if (!check) return false;
          var addressCode = idCardNo.substring(0, 2);
          check = checkAddressCode(addressCode);
          if (!check) return false;
          var birDayCode = "19".concat(idCardNo.substring(6, 12));
          check = checkBirthDayCode(birDayCode);
          if (!check) return false;
          return true;
        };
        var check18IdCardNo = function check18IdCardNo2(idCardNo) {
          var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
          if (!check) return false;
          var addressCode = idCardNo.substring(0, 2);
          check = checkAddressCode(addressCode);
          if (!check) return false;
          var birDayCode = idCardNo.substring(6, 14);
          check = checkBirthDayCode(birDayCode);
          if (!check) return false;
          return checkParityBit(idCardNo);
        };
        var checkIdCardNo = function checkIdCardNo2(idCardNo) {
          var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
          if (!check) return false;
          if (idCardNo.length === 15) {
            return check15IdCardNo(idCardNo);
          }
          return check18IdCardNo(idCardNo);
        };
        return checkIdCardNo(str);
      },
      "zh-HK": function zhHK(str) {
        str = str.trim();
        var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
        var regexIsDigit = /^[0-9]$/;
        str = str.toUpperCase();
        if (!regexHKID.test(str)) return false;
        str = str.replace(/\[|\]|\(|\)/g, "");
        if (str.length === 8) str = "3".concat(str);
        var checkSumVal = 0;
        for (var i = 0; i <= 7; i++) {
          var convertedChar = void 0;
          if (!regexIsDigit.test(str[i])) convertedChar = (str[i].charCodeAt(0) - 55) % 11;
          else convertedChar = str[i];
          checkSumVal += convertedChar * (9 - i);
        }
        checkSumVal %= 11;
        var checkSumConverted;
        if (checkSumVal === 0) checkSumConverted = "0";
        else if (checkSumVal === 1) checkSumConverted = "A";
        else checkSumConverted = String(11 - checkSumVal);
        if (checkSumConverted === str[str.length - 1]) return true;
        return false;
      },
      "zh-TW": function zhTW(str) {
        var ALPHABET_CODES = {
          A: 10,
          B: 11,
          C: 12,
          D: 13,
          E: 14,
          F: 15,
          G: 16,
          H: 17,
          I: 34,
          J: 18,
          K: 19,
          L: 20,
          M: 21,
          N: 22,
          O: 35,
          P: 23,
          Q: 24,
          R: 25,
          S: 26,
          T: 27,
          U: 28,
          V: 29,
          W: 32,
          X: 30,
          Y: 31,
          Z: 33
        };
        var sanitized = str.trim().toUpperCase();
        if (!/^[A-Z][0-9]{9}$/.test(sanitized)) return false;
        return Array.from(sanitized).reduce(function(sum, number, index) {
          if (index === 0) {
            var code = ALPHABET_CODES[number];
            return code % 10 * 9 + Math.floor(code / 10);
          }
          if (index === 9) {
            return (10 - sum % 10 - Number(number)) % 10 === 0;
          }
          return sum + Number(number) * (9 - index);
        }, 0);
      }
    };
    function isIdentityCard(str, locale) {
      (0, _assertString.default)(str);
      if (locale in validators) {
        return validators[locale](str);
      } else if (locale === "any") {
        for (var key in validators) {
          if (validators.hasOwnProperty(key)) {
            var validator = validators[key];
            if (validator(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsIdentityCard.js
var require_IsIdentityCard = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsIdentityCard.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsIdentityCard = exports2.isIdentityCard = exports2.IS_IDENTITY_CARD = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isIdentityCard_1 = __importDefault(require_isIdentityCard());
    exports2.IS_IDENTITY_CARD = "isIdentityCard";
    function isIdentityCard(value, locale) {
      return typeof value === "string" && (0, isIdentityCard_1.default)(value, locale);
    }
    exports2.isIdentityCard = isIdentityCard;
    function IsIdentityCard(locale, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_IDENTITY_CARD,
        constraints: [locale],
        validator: {
          validate: (value, args) => isIdentityCard(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a identity card number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsIdentityCard = IsIdentityCard;
  }
});

// asset-input/node_modules/validator/lib/isISRC.js
var require_isISRC = __commonJS({
  "asset-input/node_modules/validator/lib/isISRC.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISRC;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
    function isISRC(str) {
      (0, _assertString.default)(str);
      return isrc.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsISRC.js
var require_IsISRC = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsISRC.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISRC = exports2.isISRC = exports2.IS_ISRC = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISRC_1 = __importDefault(require_isISRC());
    exports2.IS_ISRC = "isISRC";
    function isISRC(value) {
      return typeof value === "string" && (0, isISRC_1.default)(value);
    }
    exports2.isISRC = isISRC;
    function IsISRC(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISRC,
        validator: {
          validate: (value, args) => isISRC(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an ISRC", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISRC = IsISRC;
  }
});

// asset-input/node_modules/validator/lib/isLocale.js
var require_isLocale = __commonJS({
  "asset-input/node_modules/validator/lib/isLocale.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLocale;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var extlang = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
    var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");
    var script = "([A-Za-z]{4})";
    var region = "([A-Za-z]{2}|\\d{3})";
    var variant = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))";
    var singleton = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])";
    var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");
    var privateuse = "(x(-[A-Za-z0-9]{1,8})+)";
    var irregular = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))";
    var regular = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))";
    var grandfathered = "(".concat(irregular, "|").concat(regular, ")");
    var delimiter = "(-|_)";
    var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");
    var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
    function isLocale(str) {
      (0, _assertString.default)(str);
      return languageTagRegex.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsLocale.js
var require_IsLocale = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsLocale.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsLocale = exports2.isLocale = exports2.IS_LOCALE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isLocale_1 = __importDefault(require_isLocale());
    exports2.IS_LOCALE = "isLocale";
    function isLocale(value) {
      return typeof value === "string" && (0, isLocale_1.default)(value);
    }
    exports2.isLocale = isLocale;
    function IsLocale(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_LOCALE,
        validator: {
          validate: (value, args) => isLocale(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be locale", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsLocale = IsLocale;
  }
});

// asset-input/node_modules/validator/lib/isMagnetURI.js
var require_isMagnetURI = __commonJS({
  "asset-input/node_modules/validator/lib/isMagnetURI.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMagnetURI;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
    function isMagnetURI(url) {
      (0, _assertString.default)(url);
      if (url.indexOf("magnet:?") !== 0) {
        return false;
      }
      return magnetURIComponent.test(url);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsMagnetURI.js
var require_IsMagnetURI = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsMagnetURI.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsMagnetURI = exports2.isMagnetURI = exports2.IS_MAGNET_URI = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isMagnetURI_1 = __importDefault(require_isMagnetURI());
    exports2.IS_MAGNET_URI = "isMagnetURI";
    function isMagnetURI(value) {
      return typeof value === "string" && (0, isMagnetURI_1.default)(value);
    }
    exports2.isMagnetURI = isMagnetURI;
    function IsMagnetURI(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_MAGNET_URI,
        validator: {
          validate: (value, args) => isMagnetURI(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be magnet uri format", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsMagnetURI = IsMagnetURI;
  }
});

// asset-input/node_modules/validator/lib/isMimeType.js
var require_isMimeType = __commonJS({
  "asset-input/node_modules/validator/lib/isMimeType.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMimeType;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i;
    var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
    var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
    function isMimeType(str) {
      (0, _assertString.default)(str);
      return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsMimeType.js
var require_IsMimeType = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsMimeType.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsMimeType = exports2.isMimeType = exports2.IS_MIME_TYPE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isMimeType_1 = __importDefault(require_isMimeType());
    exports2.IS_MIME_TYPE = "isMimeType";
    function isMimeType(value) {
      return typeof value === "string" && (0, isMimeType_1.default)(value);
    }
    exports2.isMimeType = isMimeType;
    function IsMimeType(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_MIME_TYPE,
        validator: {
          validate: (value, args) => isMimeType(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be MIME type format", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsMimeType = IsMimeType;
  }
});

// asset-input/node_modules/validator/lib/isOctal.js
var require_isOctal = __commonJS({
  "asset-input/node_modules/validator/lib/isOctal.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isOctal;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var octal = /^(0o)?[0-7]+$/i;
    function isOctal(str) {
      (0, _assertString.default)(str);
      return octal.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsOctal.js
var require_IsOctal = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsOctal.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsOctal = exports2.isOctal = exports2.IS_OCTAL = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isOctal_1 = __importDefault(require_isOctal());
    exports2.IS_OCTAL = "isOctal";
    function isOctal(value) {
      return typeof value === "string" && (0, isOctal_1.default)(value);
    }
    exports2.isOctal = isOctal;
    function IsOctal(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_OCTAL,
        validator: {
          validate: (value, args) => isOctal(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be valid octal number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsOctal = IsOctal;
  }
});

// asset-input/node_modules/validator/lib/isPassportNumber.js
var require_isPassportNumber = __commonJS({
  "asset-input/node_modules/validator/lib/isPassportNumber.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isPassportNumber;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var passportRegexByCountryCode = {
      AM: /^[A-Z]{2}\d{7}$/,
      // ARMENIA
      AR: /^[A-Z]{3}\d{6}$/,
      // ARGENTINA
      AT: /^[A-Z]\d{7}$/,
      // AUSTRIA
      AU: /^[A-Z]\d{7}$/,
      // AUSTRALIA
      AZ: /^[A-Z]{1}\d{8}$/,
      // AZERBAIJAN
      BE: /^[A-Z]{2}\d{6}$/,
      // BELGIUM
      BG: /^\d{9}$/,
      // BULGARIA
      BR: /^[A-Z]{2}\d{6}$/,
      // BRAZIL
      BY: /^[A-Z]{2}\d{7}$/,
      // BELARUS
      CA: /^[A-Z]{2}\d{6}$/,
      // CANADA
      CH: /^[A-Z]\d{7}$/,
      // SWITZERLAND
      CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
      // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
      CY: /^[A-Z](\d{6}|\d{8})$/,
      // CYPRUS
      CZ: /^\d{8}$/,
      // CZECH REPUBLIC
      DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
      // GERMANY
      DK: /^\d{9}$/,
      // DENMARK
      DZ: /^\d{9}$/,
      // ALGERIA
      EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
      // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
      ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
      // SPAIN
      FI: /^[A-Z]{2}\d{7}$/,
      // FINLAND
      FR: /^\d{2}[A-Z]{2}\d{5}$/,
      // FRANCE
      GB: /^\d{9}$/,
      // UNITED KINGDOM
      GR: /^[A-Z]{2}\d{7}$/,
      // GREECE
      HR: /^\d{9}$/,
      // CROATIA
      HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
      // HUNGARY
      IE: /^[A-Z0-9]{2}\d{7}$/,
      // IRELAND
      IN: /^[A-Z]{1}-?\d{7}$/,
      // INDIA
      ID: /^[A-C]\d{7}$/,
      // INDONESIA
      IR: /^[A-Z]\d{8}$/,
      // IRAN
      IS: /^(A)\d{7}$/,
      // ICELAND
      IT: /^[A-Z0-9]{2}\d{7}$/,
      // ITALY
      JM: /^[Aa]\d{7}$/,
      // JAMAICA
      JP: /^[A-Z]{2}\d{7}$/,
      // JAPAN
      KR: /^[MS]\d{8}$/,
      // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
      KZ: /^[a-zA-Z]\d{7}$/,
      // KAZAKHSTAN
      LI: /^[a-zA-Z]\d{5}$/,
      // LIECHTENSTEIN
      LT: /^[A-Z0-9]{8}$/,
      // LITHUANIA
      LU: /^[A-Z0-9]{8}$/,
      // LUXEMBURG
      LV: /^[A-Z0-9]{2}\d{7}$/,
      // LATVIA
      LY: /^[A-Z0-9]{8}$/,
      // LIBYA
      MT: /^\d{7}$/,
      // MALTA
      MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
      // MOZAMBIQUE
      MY: /^[AHK]\d{8}$/,
      // MALAYSIA
      MX: /^\d{10,11}$/,
      // MEXICO
      NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
      // NETHERLANDS
      NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
      // NEW ZEALAND
      PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
      // PHILIPPINES
      PK: /^[A-Z]{2}\d{7}$/,
      // PAKISTAN
      PL: /^[A-Z]{2}\d{7}$/,
      // POLAND
      PT: /^[A-Z]\d{6}$/,
      // PORTUGAL
      RO: /^\d{8,9}$/,
      // ROMANIA
      RU: /^\d{9}$/,
      // RUSSIAN FEDERATION
      SE: /^\d{8}$/,
      // SWEDEN
      SL: /^(P)[A-Z]\d{7}$/,
      // SLOVENIA
      SK: /^[0-9A-Z]\d{7}$/,
      // SLOVAKIA
      TH: /^[A-Z]{1,2}\d{6,7}$/,
      // THAILAND
      TR: /^[A-Z]\d{8}$/,
      // TURKEY
      UA: /^[A-Z]{2}\d{6}$/,
      // UKRAINE
      US: /^\d{9}$/,
      // UNITED STATES
      ZA: /^[TAMD]\d{8}$/
      // SOUTH AFRICA
    };
    function isPassportNumber(str, countryCode) {
      (0, _assertString.default)(str);
      var normalizedStr = str.replace(/\s/g, "").toUpperCase();
      return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsPassportNumber.js
var require_IsPassportNumber = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsPassportNumber.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsPassportNumber = exports2.isPassportNumber = exports2.IS_PASSPORT_NUMBER = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isPassportNumber_1 = __importDefault(require_isPassportNumber());
    exports2.IS_PASSPORT_NUMBER = "isPassportNumber";
    function isPassportNumber(value, countryCode) {
      return typeof value === "string" && (0, isPassportNumber_1.default)(value, countryCode);
    }
    exports2.isPassportNumber = isPassportNumber;
    function IsPassportNumber(countryCode, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_PASSPORT_NUMBER,
        constraints: [countryCode],
        validator: {
          validate: (value, args) => isPassportNumber(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be valid passport number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsPassportNumber = IsPassportNumber;
  }
});

// asset-input/node_modules/validator/lib/isPostalCode.js
var require_isPostalCode = __commonJS({
  "asset-input/node_modules/validator/lib/isPostalCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isPostalCode;
    exports2.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var threeDigit = /^\d{3}$/;
    var fourDigit = /^\d{4}$/;
    var fiveDigit = /^\d{5}$/;
    var sixDigit = /^\d{6}$/;
    var patterns = {
      AD: /^AD\d{3}$/,
      AT: fourDigit,
      AU: fourDigit,
      AZ: /^AZ\d{4}$/,
      BA: /^([7-8]\d{4}$)/,
      BE: fourDigit,
      BG: fourDigit,
      BR: /^\d{5}-\d{3}$/,
      BY: /^2[1-4]\d{4}$/,
      CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
      CH: fourDigit,
      CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
      CZ: /^\d{3}\s?\d{2}$/,
      DE: fiveDigit,
      DK: fourDigit,
      DO: fiveDigit,
      DZ: fiveDigit,
      EE: fiveDigit,
      ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
      FI: fiveDigit,
      FR: /^\d{2}\s?\d{3}$/,
      GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
      GR: /^\d{3}\s?\d{2}$/,
      HR: /^([1-5]\d{4}$)/,
      HT: /^HT\d{4}$/,
      HU: fourDigit,
      ID: fiveDigit,
      IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
      IL: /^(\d{5}|\d{7})$/,
      IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
      IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
      IS: threeDigit,
      IT: fiveDigit,
      JP: /^\d{3}\-\d{4}$/,
      KE: fiveDigit,
      KR: /^(\d{5}|\d{6})$/,
      LI: /^(948[5-9]|949[0-7])$/,
      LT: /^LT\-\d{5}$/,
      LU: fourDigit,
      LV: /^LV\-\d{4}$/,
      LK: fiveDigit,
      MG: threeDigit,
      MX: fiveDigit,
      MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
      MY: fiveDigit,
      NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
      NO: fourDigit,
      NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
      NZ: fourDigit,
      PL: /^\d{2}\-\d{3}$/,
      PR: /^00[679]\d{2}([ -]\d{4})?$/,
      PT: /^\d{4}\-\d{3}?$/,
      RO: sixDigit,
      RU: sixDigit,
      SA: fiveDigit,
      SE: /^[1-9]\d{2}\s?\d{2}$/,
      SG: sixDigit,
      SI: fourDigit,
      SK: /^\d{3}\s?\d{2}$/,
      TH: fiveDigit,
      TN: fourDigit,
      TW: /^\d{3}(\d{2})?$/,
      UA: fiveDigit,
      US: /^\d{5}(-\d{4})?$/,
      ZA: fourDigit,
      ZM: fiveDigit
    };
    var locales = exports2.locales = Object.keys(patterns);
    function isPostalCode(str, locale) {
      (0, _assertString.default)(str);
      if (locale in patterns) {
        return patterns[locale].test(str);
      } else if (locale === "any") {
        for (var key in patterns) {
          if (patterns.hasOwnProperty(key)) {
            var pattern = patterns[key];
            if (pattern.test(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsPostalCode.js
var require_IsPostalCode = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsPostalCode.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsPostalCode = exports2.isPostalCode = exports2.IS_POSTAL_CODE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isPostalCode_1 = __importDefault(require_isPostalCode());
    exports2.IS_POSTAL_CODE = "isPostalCode";
    function isPostalCode(value, locale) {
      return typeof value === "string" && (0, isPostalCode_1.default)(value, locale);
    }
    exports2.isPostalCode = isPostalCode;
    function IsPostalCode(locale, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_POSTAL_CODE,
        constraints: [locale],
        validator: {
          validate: (value, args) => isPostalCode(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a postal code", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsPostalCode = IsPostalCode;
  }
});

// asset-input/node_modules/validator/lib/isRFC3339.js
var require_isRFC3339 = __commonJS({
  "asset-input/node_modules/validator/lib/isRFC3339.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isRFC3339;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dateFullYear = /[0-9]{4}/;
    var dateMonth = /(0[1-9]|1[0-2])/;
    var dateMDay = /([12]\d|0[1-9]|3[01])/;
    var timeHour = /([01][0-9]|2[0-3])/;
    var timeMinute = /[0-5][0-9]/;
    var timeSecond = /([0-5][0-9]|60)/;
    var timeSecFrac = /(\.[0-9]+)?/;
    var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
    var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
    var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
    var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
    var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
    var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
    function isRFC3339(str) {
      (0, _assertString.default)(str);
      return rfc3339.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsRFC3339.js
var require_IsRFC3339 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsRFC3339.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsRFC3339 = exports2.isRFC3339 = exports2.IS_RFC_3339 = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isRFC3339_1 = __importDefault(require_isRFC3339());
    exports2.IS_RFC_3339 = "isRFC3339";
    function isRFC3339(value) {
      return typeof value === "string" && (0, isRFC3339_1.default)(value);
    }
    exports2.isRFC3339 = isRFC3339;
    function IsRFC3339(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_RFC_3339,
        validator: {
          validate: (value, args) => isRFC3339(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be RFC 3339 date", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsRFC3339 = IsRFC3339;
  }
});

// asset-input/node_modules/validator/lib/isRgbColor.js
var require_isRgbColor = __commonJS({
  "asset-input/node_modules/validator/lib/isRgbColor.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isRgbColor;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
    var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
    var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
    var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
    function isRgbColor(str) {
      var includePercentValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      (0, _assertString.default)(str);
      if (!includePercentValues) {
        return rgbColor.test(str) || rgbaColor.test(str);
      }
      return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsRgbColor.js
var require_IsRgbColor = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsRgbColor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsRgbColor = exports2.isRgbColor = exports2.IS_RGB_COLOR = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isRgbColor_1 = __importDefault(require_isRgbColor());
    exports2.IS_RGB_COLOR = "isRgbColor";
    function isRgbColor(value, includePercentValues) {
      return typeof value === "string" && (0, isRgbColor_1.default)(value, includePercentValues);
    }
    exports2.isRgbColor = isRgbColor;
    function IsRgbColor(includePercentValues, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_RGB_COLOR,
        constraints: [includePercentValues],
        validator: {
          validate: (value, args) => isRgbColor(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be RGB color", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsRgbColor = IsRgbColor;
  }
});

// asset-input/node_modules/validator/lib/util/multilineRegex.js
var require_multilineRegex = __commonJS({
  "asset-input/node_modules/validator/lib/util/multilineRegex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = multilineRegexp;
    function multilineRegexp(parts, flags) {
      var regexpAsStringLiteral = parts.join("");
      return new RegExp(regexpAsStringLiteral, flags);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isSemVer.js
var require_isSemVer = __commonJS({
  "asset-input/node_modules/validator/lib/isSemVer.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isSemVer;
    var _assertString = _interopRequireDefault(require_assertString());
    var _multilineRegex = _interopRequireDefault(require_multilineRegex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var semanticVersioningRegex = (0, _multilineRegex.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
    function isSemVer(str) {
      (0, _assertString.default)(str);
      return semanticVersioningRegex.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsSemVer.js
var require_IsSemVer = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsSemVer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsSemVer = exports2.isSemVer = exports2.IS_SEM_VER = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isSemVer_1 = __importDefault(require_isSemVer());
    exports2.IS_SEM_VER = "isSemVer";
    function isSemVer(value) {
      return typeof value === "string" && (0, isSemVer_1.default)(value);
    }
    exports2.isSemVer = isSemVer;
    function IsSemVer(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_SEM_VER,
        validator: {
          validate: (value, args) => isSemVer(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a Semantic Versioning Specification", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsSemVer = IsSemVer;
  }
});

// asset-input/node_modules/validator/lib/toDate.js
var require_toDate = __commonJS({
  "asset-input/node_modules/validator/lib/toDate.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toDate;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toDate(date) {
      (0, _assertString.default)(date);
      date = Date.parse(date);
      return !isNaN(date) ? new Date(date) : null;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/toInt.js
var require_toInt = __commonJS({
  "asset-input/node_modules/validator/lib/toInt.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toInt;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toInt(str, radix) {
      (0, _assertString.default)(str);
      return parseInt(str, radix || 10);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/toBoolean.js
var require_toBoolean = __commonJS({
  "asset-input/node_modules/validator/lib/toBoolean.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toBoolean;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toBoolean(str, strict) {
      (0, _assertString.default)(str);
      if (strict) {
        return str === "1" || /^true$/i.test(str);
      }
      return str !== "0" && !/^false$/i.test(str) && str !== "";
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/equals.js
var require_equals = __commonJS({
  "asset-input/node_modules/validator/lib/equals.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = equals;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function equals(str, comparison) {
      (0, _assertString.default)(str);
      return str === comparison;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isIPRange.js
var require_isIPRange = __commonJS({
  "asset-input/node_modules/validator/lib/isIPRange.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isIPRange;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isIP = _interopRequireDefault(require_isIP());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var subnetMaybe = /^\d{1,3}$/;
    var v4Subnet = 32;
    var v6Subnet = 128;
    function isIPRange(str) {
      var version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (0, _assertString.default)(str);
      var parts = str.split("/");
      if (parts.length !== 2) {
        return false;
      }
      if (!subnetMaybe.test(parts[1])) {
        return false;
      }
      if (parts[1].length > 1 && parts[1].startsWith("0")) {
        return false;
      }
      var isValidIP = (0, _isIP.default)(parts[0], version);
      if (!isValidIP) {
        return false;
      }
      var expectedSubnet = null;
      switch (String(version)) {
        case "4":
          expectedSubnet = v4Subnet;
          break;
        case "6":
          expectedSubnet = v6Subnet;
          break;
        default:
          expectedSubnet = (0, _isIP.default)(parts[0], "6") ? v6Subnet : v4Subnet;
      }
      return parts[1] <= expectedSubnet && parts[1] >= 0;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isDate.js
var require_isDate = __commonJS({
  "asset-input/node_modules/validator/lib/isDate.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isDate;
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var default_date_options = {
      format: "YYYY/MM/DD",
      delimiters: ["/", "-"],
      strictMode: false
    };
    function isValidFormat(format) {
      return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
    }
    function zip(date, format) {
      var zippedArr = [], len = Math.min(date.length, format.length);
      for (var i = 0; i < len; i++) {
        zippedArr.push([date[i], format[i]]);
      }
      return zippedArr;
    }
    function isDate(input, options) {
      if (typeof options === "string") {
        options = (0, _merge.default)({
          format: options
        }, default_date_options);
      } else {
        options = (0, _merge.default)(options, default_date_options);
      }
      if (typeof input === "string" && isValidFormat(options.format)) {
        var formatDelimiter = options.delimiters.find(function(delimiter) {
          return options.format.indexOf(delimiter) !== -1;
        });
        var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function(delimiter) {
          return input.indexOf(delimiter) !== -1;
        });
        var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
        var dateObj = {};
        var _iterator = _createForOfIteratorHelper(dateAndFormat), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), dateWord = _step$value[0], formatWord = _step$value[1];
            if (dateWord.length !== formatWord.length) {
              return false;
            }
            dateObj[formatWord.charAt(0)] = dateWord;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var fullYear = dateObj.y;
        if (fullYear.startsWith("-")) {
          return false;
        }
        if (dateObj.y.length === 2) {
          var parsedYear = parseInt(dateObj.y, 10);
          if (isNaN(parsedYear)) {
            return false;
          }
          var currentYearLastTwoDigits = (/* @__PURE__ */ new Date()).getFullYear() % 100;
          if (parsedYear < currentYearLastTwoDigits) {
            fullYear = "20".concat(dateObj.y);
          } else {
            fullYear = "19".concat(dateObj.y);
          }
        }
        var month = dateObj.m;
        if (dateObj.m.length === 1) {
          month = "0".concat(dateObj.m);
        }
        var day = dateObj.d;
        if (dateObj.d.length === 1) {
          day = "0".concat(dateObj.d);
        }
        return new Date("".concat(fullYear, "-").concat(month, "-").concat(day, "T00:00:00.000Z")).getUTCDate() === +dateObj.d;
      }
      if (!options.strictMode) {
        return Object.prototype.toString.call(input) === "[object Date]" && isFinite(input);
      }
      return false;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isTime.js
var require_isTime = __commonJS({
  "asset-input/node_modules/validator/lib/isTime.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isTime;
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_time_options = {
      hourFormat: "hour24",
      mode: "default"
    };
    var formats = {
      hour24: {
        default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
        withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
      },
      hour12: {
        default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
        withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
      }
    };
    function isTime(input, options) {
      options = (0, _merge.default)(options, default_time_options);
      if (typeof input !== "string") return false;
      return formats[options.hourFormat][options.mode].test(input);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isAbaRouting.js
var require_isAbaRouting = __commonJS({
  "asset-input/node_modules/validator/lib/isAbaRouting.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isAbaRouting;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
    function isAbaRouting(str) {
      (0, _assertString.default)(str);
      if (!isRoutingReg.test(str)) return false;
      var checkSumVal = 0;
      for (var i = 0; i < str.length; i++) {
        if (i % 3 === 0) checkSumVal += str[i] * 3;
        else if (i % 3 === 1) checkSumVal += str[i] * 7;
        else checkSumVal += str[i] * 1;
      }
      return checkSumVal % 10 === 0;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isIMEI.js
var require_isIMEI = __commonJS({
  "asset-input/node_modules/validator/lib/isIMEI.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isIMEI;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var imeiRegexWithoutHypens = /^[0-9]{15}$/;
    var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
    function isIMEI(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var imeiRegex = imeiRegexWithoutHypens;
      if (options.allow_hyphens) {
        imeiRegex = imeiRegexWithHypens;
      }
      if (!imeiRegex.test(str)) {
        return false;
      }
      str = str.replace(/-/g, "");
      var sum = 0, mul = 2, l = 14;
      for (var i = 0; i < l; i++) {
        var digit = str.substring(l - i - 1, l - i);
        var tp = parseInt(digit, 10) * mul;
        if (tp >= 10) {
          sum += tp % 10 + 1;
        } else {
          sum += tp;
        }
        if (mul === 1) {
          mul += 1;
        } else {
          mul -= 1;
        }
      }
      var chk = (10 - sum % 10) % 10;
      if (chk !== parseInt(str.substring(14, 15), 10)) {
        return false;
      }
      return true;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isMD5.js
var require_isMD5 = __commonJS({
  "asset-input/node_modules/validator/lib/isMD5.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMD5;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var md5 = /^[a-f0-9]{32}$/;
    function isMD5(str) {
      (0, _assertString.default)(str);
      return md5.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isEmpty.js
var require_isEmpty = __commonJS({
  "asset-input/node_modules/validator/lib/isEmpty.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isEmpty;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_is_empty_options = {
      ignore_whitespace: false
    };
    function isEmpty(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_is_empty_options);
      return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isAfter.js
var require_isAfter = __commonJS({
  "asset-input/node_modules/validator/lib/isAfter.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isAfter;
    var _toDate = _interopRequireDefault(require_toDate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAfter(date, options) {
      var comparisonDate = (options === null || options === void 0 ? void 0 : options.comparisonDate) || options || Date().toString();
      var comparison = (0, _toDate.default)(comparisonDate);
      var original = (0, _toDate.default)(date);
      return !!(original && comparison && original > comparison);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isBefore.js
var require_isBefore = __commonJS({
  "asset-input/node_modules/validator/lib/isBefore.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBefore;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toDate = _interopRequireDefault(require_toDate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isBefore(str) {
      var date = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : String(/* @__PURE__ */ new Date());
      (0, _assertString.default)(str);
      var comparison = (0, _toDate.default)(date);
      var original = (0, _toDate.default)(str);
      return !!(original && comparison && original < comparison);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isIn.js
var require_isIn = __commonJS({
  "asset-input/node_modules/validator/lib/isIn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isIn;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toString = _interopRequireDefault(require_toString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function isIn(str, options) {
      (0, _assertString.default)(str);
      var i;
      if (Object.prototype.toString.call(options) === "[object Array]") {
        var array = [];
        for (i in options) {
          if ({}.hasOwnProperty.call(options, i)) {
            array[i] = (0, _toString.default)(options[i]);
          }
        }
        return array.indexOf(str) >= 0;
      } else if (_typeof(options) === "object") {
        return options.hasOwnProperty(str);
      } else if (options && typeof options.indexOf === "function") {
        return options.indexOf(str) >= 0;
      }
      return false;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/util/algorithms.js
var require_algorithms = __commonJS({
  "asset-input/node_modules/validator/lib/util/algorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.iso7064Check = iso7064Check;
    exports2.luhnCheck = luhnCheck;
    exports2.reverseMultiplyAndSum = reverseMultiplyAndSum;
    exports2.verhoeffCheck = verhoeffCheck;
    function iso7064Check(str) {
      var checkvalue = 10;
      for (var i = 0; i < str.length - 1; i++) {
        checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;
      }
      checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
      return checkvalue === parseInt(str[10], 10);
    }
    function luhnCheck(str) {
      var checksum = 0;
      var second = false;
      for (var i = str.length - 1; i >= 0; i--) {
        if (second) {
          var product = parseInt(str[i], 10) * 2;
          if (product > 9) {
            checksum += product.toString().split("").map(function(a) {
              return parseInt(a, 10);
            }).reduce(function(a, b) {
              return a + b;
            }, 0);
          } else {
            checksum += product;
          }
        } else {
          checksum += parseInt(str[i], 10);
        }
        second = !second;
      }
      return checksum % 10 === 0;
    }
    function reverseMultiplyAndSum(digits, base) {
      var total = 0;
      for (var i = 0; i < digits.length; i++) {
        total += digits[i] * (base - i);
      }
      return total;
    }
    function verhoeffCheck(str) {
      var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
      var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
      var str_copy = str.split("").reverse().join("");
      var checksum = 0;
      for (var i = 0; i < str_copy.length; i++) {
        checksum = d_table[checksum][p_table[i % 8][parseInt(str_copy[i], 10)]];
      }
      return checksum === 0;
    }
  }
});

// asset-input/node_modules/validator/lib/isTaxID.js
var require_isTaxID = __commonJS({
  "asset-input/node_modules/validator/lib/isTaxID.js"(exports2, module2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isTaxID;
    var _assertString = _interopRequireDefault(require_assertString());
    var algorithms = _interopRequireWildcard(require_algorithms());
    var _isDate = _interopRequireDefault(require_isDate());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function bgBgCheck(tin) {
      var century_year = tin.slice(0, 2);
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 40) {
        month -= 40;
        century_year = "20".concat(century_year);
      } else if (month > 20) {
        month -= 20;
        century_year = "18".concat(century_year);
      } else {
        century_year = "19".concat(century_year);
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
      var checksum = 0;
      for (var i = 0; i < multip_lookup.length; i++) {
        checksum += digits[i] * multip_lookup[i];
      }
      checksum = checksum % 11 === 10 ? 0 : checksum % 11;
      return checksum === digits[9];
    }
    function isCanadianSIN(input) {
      var digitsArray = input.split("");
      var even = digitsArray.filter(function(_, idx) {
        return idx % 2;
      }).map(function(i) {
        return Number(i) * 2;
      }).join("").split("");
      var total = digitsArray.filter(function(_, idx) {
        return !(idx % 2);
      }).concat(even).map(function(i) {
        return Number(i);
      }).reduce(function(acc, cur) {
        return acc + cur;
      });
      return total % 10 === 0;
    }
    function csCzCheck(tin) {
      tin = tin.replace(/\W/, "");
      var full_year = parseInt(tin.slice(0, 2), 10);
      if (tin.length === 10) {
        if (full_year < 54) {
          full_year = "20".concat(full_year);
        } else {
          full_year = "19".concat(full_year);
        }
      } else {
        if (tin.slice(6) === "000") {
          return false;
        }
        if (full_year < 54) {
          full_year = "19".concat(full_year);
        } else {
          return false;
        }
      }
      if (full_year.length === 3) {
        full_year = [full_year.slice(0, 2), "0", full_year.slice(2)].join("");
      }
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 50) {
        month -= 50;
      }
      if (month > 20) {
        if (parseInt(full_year, 10) < 2004) {
          return false;
        }
        month -= 20;
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      if (tin.length === 10) {
        if (parseInt(tin, 10) % 11 !== 0) {
          var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
          if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
            if (parseInt(tin.slice(9), 10) !== 0) {
              return false;
            }
          } else {
            return false;
          }
        }
      }
      return true;
    }
    function deAtCheck(tin) {
      return algorithms.luhnCheck(tin);
    }
    function deDeCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var occurences = [];
      for (var i = 0; i < digits.length - 1; i++) {
        occurences.push("");
        for (var j = 0; j < digits.length - 1; j++) {
          if (digits[i] === digits[j]) {
            occurences[i] += j;
          }
        }
      }
      occurences = occurences.filter(function(a) {
        return a.length > 1;
      });
      if (occurences.length !== 2 && occurences.length !== 3) {
        return false;
      }
      if (occurences[0].length === 3) {
        var trip_locations = occurences[0].split("").map(function(a) {
          return parseInt(a, 10);
        });
        var recurrent = 0;
        for (var _i = 0; _i < trip_locations.length - 1; _i++) {
          if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
            recurrent += 1;
          }
        }
        if (recurrent === 2) {
          return false;
        }
      }
      return algorithms.iso7064Check(tin);
    }
    function dkDkCheck(tin) {
      tin = tin.replace(/\W/, "");
      var year = parseInt(tin.slice(4, 6), 10);
      var century_digit = tin.slice(6, 7);
      switch (century_digit) {
        case "0":
        case "1":
        case "2":
        case "3":
          year = "19".concat(year);
          break;
        case "4":
        case "9":
          if (year < 37) {
            year = "20".concat(year);
          } else {
            year = "19".concat(year);
          }
          break;
        default:
          if (year < 37) {
            year = "20".concat(year);
          } else if (year > 58) {
            year = "18".concat(year);
          } else {
            return false;
          }
          break;
      }
      if (year.length === 3) {
        year = [year.slice(0, 2), "0", year.slice(2)].join("");
      }
      var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum = 0;
      var weight = 4;
      for (var i = 0; i < 9; i++) {
        checksum += digits[i] * weight;
        weight -= 1;
        if (weight === 1) {
          weight = 7;
        }
      }
      checksum %= 11;
      if (checksum === 1) {
        return false;
      }
      return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;
    }
    function elCyCheck(tin) {
      var digits = tin.slice(0, 8).split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum = 0;
      for (var i = 1; i < digits.length; i += 2) {
        checksum += digits[i];
      }
      for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {
        if (digits[_i2] < 2) {
          checksum += 1 - digits[_i2];
        } else {
          checksum += 2 * (digits[_i2] - 2) + 5;
          if (digits[_i2] > 4) {
            checksum += 2;
          }
        }
      }
      return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
    }
    function elGrCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum = 0;
      for (var i = 0; i < 8; i++) {
        checksum += digits[i] * Math.pow(2, 8 - i);
      }
      return checksum % 11 % 10 === digits[8];
    }
    function enIeCheck(tin) {
      var checksum = algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
        return parseInt(a, 10);
      }), 8);
      if (tin.length === 9 && tin[8] !== "W") {
        checksum += (tin[8].charCodeAt(0) - 64) * 9;
      }
      checksum %= 23;
      if (checksum === 0) {
        return tin[7].toUpperCase() === "W";
      }
      return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
    }
    var enUsCampusPrefix = {
      andover: ["10", "12"],
      atlanta: ["60", "67"],
      austin: ["50", "53"],
      brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
      cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
      fresno: ["15", "24"],
      internet: ["20", "26", "27", "45", "46", "47"],
      kansas: ["40", "44"],
      memphis: ["94", "95"],
      ogden: ["80", "90"],
      philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
      sba: ["31"]
    };
    function enUsGetPrefixes() {
      var prefixes = [];
      for (var location in enUsCampusPrefix) {
        if (enUsCampusPrefix.hasOwnProperty(location)) {
          prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
        }
      }
      return prefixes;
    }
    function enUsCheck(tin) {
      return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
    }
    function esArCheck(tin) {
      var accum = 0;
      var digits = tin.split("");
      var digit = parseInt(digits.pop(), 10);
      for (var i = 0; i < digits.length; i++) {
        accum += digits[9 - i] * (2 + i % 6);
      }
      var verif = 11 - accum % 11;
      if (verif === 11) {
        verif = 0;
      } else if (verif === 10) {
        verif = 9;
      }
      return digit === verif;
    }
    function esEsCheck(tin) {
      var chars = tin.toUpperCase().split("");
      if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
        var lead_replace = 0;
        switch (chars[0]) {
          case "Y":
            lead_replace = 1;
            break;
          case "Z":
            lead_replace = 2;
            break;
          default:
        }
        chars.splice(0, 1, lead_replace);
      } else {
        while (chars.length < 9) {
          chars.unshift(0);
        }
      }
      var lookup = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
      chars = chars.join("");
      var checksum = parseInt(chars.slice(0, 8), 10) % 23;
      return chars[8] === lookup[checksum];
    }
    function etEeCheck(tin) {
      var full_year = tin.slice(1, 3);
      var century_digit = tin.slice(0, 1);
      switch (century_digit) {
        case "1":
        case "2":
          full_year = "18".concat(full_year);
          break;
        case "3":
        case "4":
          full_year = "19".concat(full_year);
          break;
        default:
          full_year = "20".concat(full_year);
          break;
      }
      var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum = 0;
      var weight = 1;
      for (var i = 0; i < 10; i++) {
        checksum += digits[i] * weight;
        weight += 1;
        if (weight === 10) {
          weight = 1;
        }
      }
      if (checksum % 11 === 10) {
        checksum = 0;
        weight = 3;
        for (var _i3 = 0; _i3 < 10; _i3++) {
          checksum += digits[_i3] * weight;
          weight += 1;
          if (weight === 10) {
            weight = 1;
          }
        }
        if (checksum % 11 === 10) {
          return digits[10] === 0;
        }
      }
      return checksum % 11 === digits[10];
    }
    function fiFiCheck(tin) {
      var full_year = tin.slice(4, 6);
      var century_symbol = tin.slice(6, 7);
      switch (century_symbol) {
        case "+":
          full_year = "18".concat(full_year);
          break;
        case "-":
          full_year = "19".concat(full_year);
          break;
        default:
          full_year = "20".concat(full_year);
          break;
      }
      var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
      if (checksum < 10) {
        return checksum === parseInt(tin.slice(10), 10);
      }
      checksum -= 10;
      var letters_lookup = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
      return letters_lookup[checksum] === tin.slice(10);
    }
    function frBeCheck(tin) {
      if (tin.slice(2, 4) !== "00" || tin.slice(4, 6) !== "00") {
        var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
        if (!(0, _isDate.default)(date, "YY/MM/DD")) {
          return false;
        }
      }
      var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;
      var checkdigits = parseInt(tin.slice(9, 11), 10);
      if (checksum !== checkdigits) {
        checksum = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
        if (checksum !== checkdigits) {
          return false;
        }
      }
      return true;
    }
    function frFrCheck(tin) {
      tin = tin.replace(/\s/g, "");
      var checksum = parseInt(tin.slice(0, 10), 10) % 511;
      var checkdigits = parseInt(tin.slice(10, 13), 10);
      return checksum === checkdigits;
    }
    function frLuCheck(tin) {
      var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      if (!algorithms.luhnCheck(tin.slice(0, 12))) {
        return false;
      }
      return algorithms.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
    }
    function hrHrCheck(tin) {
      return algorithms.iso7064Check(tin);
    }
    function huHuCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum = 8;
      for (var i = 1; i < 9; i++) {
        checksum += digits[i] * (i + 1);
      }
      return checksum % 11 === digits[9];
    }
    function itItNameCheck(name) {
      var vowelflag = false;
      var xflag = false;
      for (var i = 0; i < 3; i++) {
        if (!vowelflag && /[AEIOU]/.test(name[i])) {
          vowelflag = true;
        } else if (!xflag && vowelflag && name[i] === "X") {
          xflag = true;
        } else if (i > 0) {
          if (vowelflag && !xflag) {
            if (!/[AEIOU]/.test(name[i])) {
              return false;
            }
          }
          if (xflag) {
            if (!/X/.test(name[i])) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function itItCheck(tin) {
      var chars = tin.toUpperCase().split("");
      if (!itItNameCheck(chars.slice(0, 3))) {
        return false;
      }
      if (!itItNameCheck(chars.slice(3, 6))) {
        return false;
      }
      var number_locations = [6, 7, 9, 10, 12, 13, 14];
      var number_replace = {
        L: "0",
        M: "1",
        N: "2",
        P: "3",
        Q: "4",
        R: "5",
        S: "6",
        T: "7",
        U: "8",
        V: "9"
      };
      for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
        var i = _number_locations[_i4];
        if (chars[i] in number_replace) {
          chars.splice(i, 1, number_replace[chars[i]]);
        }
      }
      var month_replace = {
        A: "01",
        B: "02",
        C: "03",
        D: "04",
        E: "05",
        H: "06",
        L: "07",
        M: "08",
        P: "09",
        R: "10",
        S: "11",
        T: "12"
      };
      var month = month_replace[chars[8]];
      var day = parseInt(chars[9] + chars[10], 10);
      if (day > 40) {
        day -= 40;
      }
      if (day < 10) {
        day = "0".concat(day);
      }
      var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
      if (!(0, _isDate.default)(date, "YY/MM/DD")) {
        return false;
      }
      var checksum = 0;
      for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
        var char_to_int = parseInt(chars[_i5], 10);
        if (isNaN(char_to_int)) {
          char_to_int = chars[_i5].charCodeAt(0) - 65;
        }
        checksum += char_to_int;
      }
      var odd_convert = {
        // Maps of characters at odd places
        A: 1,
        B: 0,
        C: 5,
        D: 7,
        E: 9,
        F: 13,
        G: 15,
        H: 17,
        I: 19,
        J: 21,
        K: 2,
        L: 4,
        M: 18,
        N: 20,
        O: 11,
        P: 3,
        Q: 6,
        R: 8,
        S: 12,
        T: 14,
        U: 16,
        V: 10,
        W: 22,
        X: 25,
        Y: 24,
        Z: 23,
        0: 1,
        1: 0
      };
      for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
        var _char_to_int = 0;
        if (chars[_i6] in odd_convert) {
          _char_to_int = odd_convert[chars[_i6]];
        } else {
          var multiplier = parseInt(chars[_i6], 10);
          _char_to_int = 2 * multiplier + 1;
          if (multiplier > 4) {
            _char_to_int += 2;
          }
        }
        checksum += _char_to_int;
      }
      if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {
        return false;
      }
      return true;
    }
    function lvLvCheck(tin) {
      tin = tin.replace(/\W/, "");
      var day = tin.slice(0, 2);
      if (day !== "32") {
        var month = tin.slice(2, 4);
        if (month !== "00") {
          var full_year = tin.slice(4, 6);
          switch (tin[6]) {
            case "0":
              full_year = "18".concat(full_year);
              break;
            case "1":
              full_year = "19".concat(full_year);
              break;
            default:
              full_year = "20".concat(full_year);
              break;
          }
          var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
          if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
            return false;
          }
        }
        var checksum = 1101;
        var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
        for (var i = 0; i < tin.length - 1; i++) {
          checksum -= parseInt(tin[i], 10) * multip_lookup[i];
        }
        return parseInt(tin[10], 10) === checksum % 11;
      }
      return true;
    }
    function mtMtCheck(tin) {
      if (tin.length !== 9) {
        var chars = tin.toUpperCase().split("");
        while (chars.length < 8) {
          chars.unshift(0);
        }
        switch (tin[7]) {
          case "A":
          case "P":
            if (parseInt(chars[6], 10) === 0) {
              return false;
            }
            break;
          default: {
            var first_part = parseInt(chars.join("").slice(0, 5), 10);
            if (first_part > 32e3) {
              return false;
            }
            var second_part = parseInt(chars.join("").slice(5, 7), 10);
            if (first_part === second_part) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function nlNlCheck(tin) {
      return algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
        return parseInt(a, 10);
      }), 9) % 11 === parseInt(tin[8], 10);
    }
    function plPlCheck(tin) {
      if (tin.length === 10) {
        var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
        var _checksum = 0;
        for (var i = 0; i < lookup.length; i++) {
          _checksum += parseInt(tin[i], 10) * lookup[i];
        }
        _checksum %= 11;
        if (_checksum === 10) {
          return false;
        }
        return _checksum === parseInt(tin[9], 10);
      }
      var full_year = tin.slice(0, 2);
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 80) {
        full_year = "18".concat(full_year);
        month -= 80;
      } else if (month > 60) {
        full_year = "22".concat(full_year);
        month -= 60;
      } else if (month > 40) {
        full_year = "21".concat(full_year);
        month -= 40;
      } else if (month > 20) {
        full_year = "20".concat(full_year);
        month -= 20;
      } else {
        full_year = "19".concat(full_year);
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var checksum = 0;
      var multiplier = 1;
      for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
        checksum += parseInt(tin[_i7], 10) * multiplier % 10;
        multiplier += 2;
        if (multiplier > 10) {
          multiplier = 1;
        } else if (multiplier === 5) {
          multiplier += 2;
        }
      }
      checksum = 10 - checksum % 10;
      return checksum === parseInt(tin[10], 10);
    }
    function ptBrCheck(tin) {
      if (tin.length === 11) {
        var _sum;
        var remainder;
        _sum = 0;
        if (
          // Reject known invalid CPFs
          tin === "11111111111" || tin === "22222222222" || tin === "33333333333" || tin === "44444444444" || tin === "55555555555" || tin === "66666666666" || tin === "77777777777" || tin === "88888888888" || tin === "99999999999" || tin === "00000000000"
        ) return false;
        for (var i = 1; i <= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
        remainder = _sum * 10 % 11;
        if (remainder === 10) remainder = 0;
        if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;
        _sum = 0;
        for (var _i8 = 1; _i8 <= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
        remainder = _sum * 10 % 11;
        if (remainder === 10) remainder = 0;
        if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;
        return true;
      }
      if (
        // Reject know invalid CNPJs
        tin === "00000000000000" || tin === "11111111111111" || tin === "22222222222222" || tin === "33333333333333" || tin === "44444444444444" || tin === "55555555555555" || tin === "66666666666666" || tin === "77777777777777" || tin === "88888888888888" || tin === "99999999999999"
      ) {
        return false;
      }
      var length = tin.length - 2;
      var identifiers = tin.substring(0, length);
      var verificators = tin.substring(length);
      var sum = 0;
      var pos = length - 7;
      for (var _i9 = length; _i9 >= 1; _i9--) {
        sum += identifiers.charAt(length - _i9) * pos;
        pos -= 1;
        if (pos < 2) {
          pos = 9;
        }
      }
      var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
      if (result !== parseInt(verificators.charAt(0), 10)) {
        return false;
      }
      length += 1;
      identifiers = tin.substring(0, length);
      sum = 0;
      pos = length - 7;
      for (var _i10 = length; _i10 >= 1; _i10--) {
        sum += identifiers.charAt(length - _i10) * pos;
        pos -= 1;
        if (pos < 2) {
          pos = 9;
        }
      }
      result = sum % 11 < 2 ? 0 : 11 - sum % 11;
      if (result !== parseInt(verificators.charAt(1), 10)) {
        return false;
      }
      return true;
    }
    function ptPtCheck(tin) {
      var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
        return parseInt(a, 10);
      }), 9) % 11;
      if (checksum > 9) {
        return parseInt(tin[8], 10) === 0;
      }
      return checksum === parseInt(tin[8], 10);
    }
    function roRoCheck(tin) {
      if (tin.slice(0, 4) !== "9000") {
        var full_year = tin.slice(1, 3);
        switch (tin[0]) {
          case "1":
          case "2":
            full_year = "19".concat(full_year);
            break;
          case "3":
          case "4":
            full_year = "18".concat(full_year);
            break;
          case "5":
          case "6":
            full_year = "20".concat(full_year);
            break;
          default:
        }
        var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
        if (date.length === 8) {
          if (!(0, _isDate.default)(date, "YY/MM/DD")) {
            return false;
          }
        } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        var digits = tin.split("").map(function(a) {
          return parseInt(a, 10);
        });
        var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
        var checksum = 0;
        for (var i = 0; i < multipliers.length; i++) {
          checksum += digits[i] * multipliers[i];
        }
        if (checksum % 11 === 10) {
          return digits[12] === 1;
        }
        return digits[12] === checksum % 11;
      }
      return true;
    }
    function skSkCheck(tin) {
      if (tin.length === 9) {
        tin = tin.replace(/\W/, "");
        if (tin.slice(6) === "000") {
          return false;
        }
        var full_year = parseInt(tin.slice(0, 2), 10);
        if (full_year > 53) {
          return false;
        }
        if (full_year < 10) {
          full_year = "190".concat(full_year);
        } else {
          full_year = "19".concat(full_year);
        }
        var month = parseInt(tin.slice(2, 4), 10);
        if (month > 50) {
          month -= 50;
        }
        if (month < 10) {
          month = "0".concat(month);
        }
        var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
      }
      return true;
    }
    function slSiCheck(tin) {
      var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
        return parseInt(a, 10);
      }), 8) % 11;
      if (checksum === 10) {
        return parseInt(tin[7], 10) === 0;
      }
      return checksum === parseInt(tin[7], 10);
    }
    function svSeCheck(tin) {
      var tin_copy = tin.slice(0);
      if (tin.length > 11) {
        tin_copy = tin_copy.slice(2);
      }
      var full_year = "";
      var month = tin_copy.slice(2, 4);
      var day = parseInt(tin_copy.slice(4, 6), 10);
      if (tin.length > 11) {
        full_year = tin.slice(0, 4);
      } else {
        full_year = tin.slice(0, 2);
        if (tin.length === 11 && day < 60) {
          var current_year = (/* @__PURE__ */ new Date()).getFullYear().toString();
          var current_century = parseInt(current_year.slice(0, 2), 10);
          current_year = parseInt(current_year, 10);
          if (tin[6] === "-") {
            if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
              full_year = "".concat(current_century - 1).concat(full_year);
            } else {
              full_year = "".concat(current_century).concat(full_year);
            }
          } else {
            full_year = "".concat(current_century - 1).concat(full_year);
            if (current_year - parseInt(full_year, 10) < 100) {
              return false;
            }
          }
        }
      }
      if (day > 60) {
        day -= 60;
      }
      if (day < 10) {
        day = "0".concat(day);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(day);
      if (date.length === 8) {
        if (!(0, _isDate.default)(date, "YY/MM/DD")) {
          return false;
        }
      } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      return algorithms.luhnCheck(tin.replace(/\W/, ""));
    }
    function ukUaCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
      var checksum = 0;
      for (var i = 0; i < multipliers.length; i++) {
        checksum += digits[i] * multipliers[i];
      }
      return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;
    }
    var taxIdFormat = {
      "bg-BG": /^\d{10}$/,
      "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
      "de-AT": /^\d{9}$/,
      "de-DE": /^[1-9]\d{10}$/,
      "dk-DK": /^\d{6}-{0,1}\d{4}$/,
      "el-CY": /^[09]\d{7}[A-Z]$/,
      "el-GR": /^([0-4]|[7-9])\d{8}$/,
      "en-CA": /^\d{9}$/,
      "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
      "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
      "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
      "es-AR": /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
      "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
      "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
      "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
      "fr-BE": /^\d{11}$/,
      "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
      // Conforms both to official spec and provided example
      "fr-LU": /^\d{13}$/,
      "hr-HR": /^\d{11}$/,
      "hu-HU": /^8\d{9}$/,
      "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
      "lv-LV": /^\d{6}-{0,1}\d{5}$/,
      // Conforms both to DG TAXUD spec and original research
      "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
      "nl-NL": /^\d{9}$/,
      "pl-PL": /^\d{10,11}$/,
      "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
      "pt-PT": /^\d{9}$/,
      "ro-RO": /^\d{13}$/,
      "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
      "sl-SI": /^[1-9]\d{7}$/,
      "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
      "uk-UA": /^\d{10}$/
    };
    taxIdFormat["lb-LU"] = taxIdFormat["fr-LU"];
    taxIdFormat["lt-LT"] = taxIdFormat["et-EE"];
    taxIdFormat["nl-BE"] = taxIdFormat["fr-BE"];
    taxIdFormat["fr-CA"] = taxIdFormat["en-CA"];
    var taxIdCheck = {
      "bg-BG": bgBgCheck,
      "cs-CZ": csCzCheck,
      "de-AT": deAtCheck,
      "de-DE": deDeCheck,
      "dk-DK": dkDkCheck,
      "el-CY": elCyCheck,
      "el-GR": elGrCheck,
      "en-CA": isCanadianSIN,
      "en-IE": enIeCheck,
      "en-US": enUsCheck,
      "es-AR": esArCheck,
      "es-ES": esEsCheck,
      "et-EE": etEeCheck,
      "fi-FI": fiFiCheck,
      "fr-BE": frBeCheck,
      "fr-FR": frFrCheck,
      "fr-LU": frLuCheck,
      "hr-HR": hrHrCheck,
      "hu-HU": huHuCheck,
      "it-IT": itItCheck,
      "lv-LV": lvLvCheck,
      "mt-MT": mtMtCheck,
      "nl-NL": nlNlCheck,
      "pl-PL": plPlCheck,
      "pt-BR": ptBrCheck,
      "pt-PT": ptPtCheck,
      "ro-RO": roRoCheck,
      "sk-SK": skSkCheck,
      "sl-SI": slSiCheck,
      "sv-SE": svSeCheck,
      "uk-UA": ukUaCheck
    };
    taxIdCheck["lb-LU"] = taxIdCheck["fr-LU"];
    taxIdCheck["lt-LT"] = taxIdCheck["et-EE"];
    taxIdCheck["nl-BE"] = taxIdCheck["fr-BE"];
    taxIdCheck["fr-CA"] = taxIdCheck["en-CA"];
    var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
    var sanitizeRegexes = {
      "de-AT": allsymbols,
      "de-DE": /[\/\\]/g,
      "fr-BE": allsymbols
    };
    sanitizeRegexes["nl-BE"] = sanitizeRegexes["fr-BE"];
    function isTaxID(str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      (0, _assertString.default)(str);
      var strcopy = str.slice(0);
      if (locale in taxIdFormat) {
        if (locale in sanitizeRegexes) {
          strcopy = strcopy.replace(sanitizeRegexes[locale], "");
        }
        if (!taxIdFormat[locale].test(strcopy)) {
          return false;
        }
        if (locale in taxIdCheck) {
          return taxIdCheck[locale](strcopy);
        }
        return true;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isISO6346.js
var require_isISO6346 = __commonJS({
  "asset-input/node_modules/validator/lib/isISO6346.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isFreightContainerID = void 0;
    exports2.isISO6346 = isISO6346;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
    var isDigit = /^[0-9]$/;
    function isISO6346(str) {
      (0, _assertString.default)(str);
      str = str.toUpperCase();
      if (!isISO6346Str.test(str)) return false;
      if (str.length === 11) {
        var sum = 0;
        for (var i = 0; i < str.length - 1; i++) {
          if (!isDigit.test(str[i])) {
            var convertedCode = void 0;
            var letterCode = str.charCodeAt(i) - 55;
            if (letterCode < 11) convertedCode = letterCode;
            else if (letterCode >= 11 && letterCode <= 20) convertedCode = 12 + letterCode % 11;
            else if (letterCode >= 21 && letterCode <= 30) convertedCode = 23 + letterCode % 21;
            else convertedCode = 34 + letterCode % 31;
            sum += convertedCode * Math.pow(2, i);
          } else sum += str[i] * Math.pow(2, i);
        }
        var checkSumDigit = sum % 11;
        return Number(str[str.length - 1]) === checkSumDigit;
      }
      return true;
    }
    var isFreightContainerID = exports2.isFreightContainerID = isISO6346;
  }
});

// asset-input/node_modules/validator/lib/isISO6391.js
var require_isISO6391 = __commonJS({
  "asset-input/node_modules/validator/lib/isISO6391.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isISO6391;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isISO6391Set = /* @__PURE__ */ new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
    function isISO6391(str) {
      (0, _assertString.default)(str);
      return isISO6391Set.has(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isISO4217.js
var require_isISO4217 = __commonJS({
  "asset-input/node_modules/validator/lib/isISO4217.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CurrencyCodes = void 0;
    exports2.default = isISO4217;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO4217CurrencyCodes = /* @__PURE__ */ new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLE", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
    function isISO4217(str) {
      (0, _assertString.default)(str);
      return validISO4217CurrencyCodes.has(str.toUpperCase());
    }
    var CurrencyCodes = exports2.CurrencyCodes = validISO4217CurrencyCodes;
  }
});

// asset-input/node_modules/validator/lib/isBase58.js
var require_isBase58 = __commonJS({
  "asset-input/node_modules/validator/lib/isBase58.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBase58;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
    function isBase58(str) {
      (0, _assertString.default)(str);
      if (base58Reg.test(str)) {
        return true;
      }
      return false;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/rtrim.js
var require_rtrim = __commonJS({
  "asset-input/node_modules/validator/lib/rtrim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rtrim;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rtrim(str, chars) {
      (0, _assertString.default)(str);
      if (chars) {
        var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
        return str.replace(pattern, "");
      }
      var strIndex = str.length - 1;
      while (/\s/.test(str.charAt(strIndex))) {
        strIndex -= 1;
      }
      return str.slice(0, strIndex + 1);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/ltrim.js
var require_ltrim = __commonJS({
  "asset-input/node_modules/validator/lib/ltrim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = ltrim;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ltrim(str, chars) {
      (0, _assertString.default)(str);
      var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
      return str.replace(pattern, "");
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/trim.js
var require_trim = __commonJS({
  "asset-input/node_modules/validator/lib/trim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = trim;
    var _rtrim = _interopRequireDefault(require_rtrim());
    var _ltrim = _interopRequireDefault(require_ltrim());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function trim(str, chars) {
      return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isMailtoURI.js
var require_isMailtoURI = __commonJS({
  "asset-input/node_modules/validator/lib/isMailtoURI.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isMailtoURI;
    var _trim = _interopRequireDefault(require_trim());
    var _isEmail = _interopRequireDefault(require_isEmail());
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function parseMailtoQueryString(queryString) {
      var allowedParams = /* @__PURE__ */ new Set(["subject", "body", "cc", "bcc"]), query = {
        cc: "",
        bcc: ""
      };
      var isParseFailed = false;
      var queryParams = queryString.split("&");
      if (queryParams.length > 4) {
        return false;
      }
      var _iterator = _createForOfIteratorHelper(queryParams), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var q = _step.value;
          var _q$split = q.split("="), _q$split2 = _slicedToArray(_q$split, 2), key = _q$split2[0], value = _q$split2[1];
          if (key && !allowedParams.has(key)) {
            isParseFailed = true;
            break;
          }
          if (value && (key === "cc" || key === "bcc")) {
            query[key] = value;
          }
          if (key) {
            allowedParams.delete(key);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return isParseFailed ? false : query;
    }
    function isMailtoURI(url, options) {
      (0, _assertString.default)(url);
      if (url.indexOf("mailto:") !== 0) {
        return false;
      }
      var _url$replace$split = url.replace("mailto:", "").split("?"), _url$replace$split2 = _slicedToArray(_url$replace$split, 2), to = _url$replace$split2[0], _url$replace$split2$ = _url$replace$split2[1], queryString = _url$replace$split2$ === void 0 ? "" : _url$replace$split2$;
      if (!to && !queryString) {
        return true;
      }
      var query = parseMailtoQueryString(queryString);
      if (!query) {
        return false;
      }
      return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(",").every(function(email) {
        email = (0, _trim.default)(email, " ");
        if (email) {
          return (0, _isEmail.default)(email, options);
        }
        return true;
      });
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/escape.js
var require_escape = __commonJS({
  "asset-input/node_modules/validator/lib/escape.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = escape;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function escape(str) {
      (0, _assertString.default)(str);
      return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/unescape.js
var require_unescape = __commonJS({
  "asset-input/node_modules/validator/lib/unescape.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = unescape;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function unescape(str) {
      (0, _assertString.default)(str);
      return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/blacklist.js
var require_blacklist = __commonJS({
  "asset-input/node_modules/validator/lib/blacklist.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = blacklist;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function blacklist(str, chars) {
      (0, _assertString.default)(str);
      return str.replace(new RegExp("[".concat(chars, "]+"), "g"), "");
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/stripLow.js
var require_stripLow = __commonJS({
  "asset-input/node_modules/validator/lib/stripLow.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = stripLow;
    var _assertString = _interopRequireDefault(require_assertString());
    var _blacklist = _interopRequireDefault(require_blacklist());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stripLow(str, keep_new_lines) {
      (0, _assertString.default)(str);
      var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
      return (0, _blacklist.default)(str, chars);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/whitelist.js
var require_whitelist = __commonJS({
  "asset-input/node_modules/validator/lib/whitelist.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = whitelist;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function whitelist(str, chars) {
      (0, _assertString.default)(str);
      return str.replace(new RegExp("[^".concat(chars, "]+"), "g"), "");
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isWhitelisted.js
var require_isWhitelisted = __commonJS({
  "asset-input/node_modules/validator/lib/isWhitelisted.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isWhitelisted;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isWhitelisted(str, chars) {
      (0, _assertString.default)(str);
      for (var i = str.length - 1; i >= 0; i--) {
        if (chars.indexOf(str[i]) === -1) {
          return false;
        }
      }
      return true;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/normalizeEmail.js
var require_normalizeEmail = __commonJS({
  "asset-input/node_modules/validator/lib/normalizeEmail.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = normalizeEmail;
    var _merge = _interopRequireDefault(require_merge2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_normalize_email_options = {
      // The following options apply to all email addresses
      // Lowercases the local part of the email address.
      // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
      // The domain is always lowercased, as per RFC 1035
      all_lowercase: true,
      // The following conversions are specific to GMail
      // Lowercases the local part of the GMail address (known to be case-insensitive)
      gmail_lowercase: true,
      // Removes dots from the local part of the email address, as that's ignored by GMail
      gmail_remove_dots: true,
      // Removes the subaddress (e.g. "+foo") from the email address
      gmail_remove_subaddress: true,
      // Conversts the googlemail.com domain to gmail.com
      gmail_convert_googlemaildotcom: true,
      // The following conversions are specific to Outlook.com / Windows Live / Hotmail
      // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
      outlookdotcom_lowercase: true,
      // Removes the subaddress (e.g. "+foo") from the email address
      outlookdotcom_remove_subaddress: true,
      // The following conversions are specific to Yahoo
      // Lowercases the local part of the Yahoo address (known to be case-insensitive)
      yahoo_lowercase: true,
      // Removes the subaddress (e.g. "-foo") from the email address
      yahoo_remove_subaddress: true,
      // The following conversions are specific to Yandex
      // Lowercases the local part of the Yandex address (known to be case-insensitive)
      yandex_lowercase: true,
      // The following conversions are specific to iCloud
      // Lowercases the local part of the iCloud address (known to be case-insensitive)
      icloud_lowercase: true,
      // Removes the subaddress (e.g. "+foo") from the email address
      icloud_remove_subaddress: true
    };
    var icloud_domains = ["icloud.com", "me.com"];
    var outlookdotcom_domains = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"];
    var yahoo_domains = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"];
    var yandex_domains = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
    function dotsReplacer(match) {
      if (match.length > 1) {
        return match;
      }
      return "";
    }
    function normalizeEmail(email, options) {
      options = (0, _merge.default)(options, default_normalize_email_options);
      var raw_parts = email.split("@");
      var domain = raw_parts.pop();
      var user = raw_parts.join("@");
      var parts = [user, domain];
      parts[1] = parts[1].toLowerCase();
      if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
        if (options.gmail_remove_subaddress) {
          parts[0] = parts[0].split("+")[0];
        }
        if (options.gmail_remove_dots) {
          parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.gmail_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
        parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
      } else if (icloud_domains.indexOf(parts[1]) >= 0) {
        if (options.icloud_remove_subaddress) {
          parts[0] = parts[0].split("+")[0];
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.icloud_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
      } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
        if (options.outlookdotcom_remove_subaddress) {
          parts[0] = parts[0].split("+")[0];
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.outlookdotcom_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
      } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
        if (options.yahoo_remove_subaddress) {
          var components = parts[0].split("-");
          parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.yahoo_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
      } else if (yandex_domains.indexOf(parts[1]) >= 0) {
        if (options.all_lowercase || options.yandex_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
        parts[1] = "yandex.ru";
      } else if (options.all_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      return parts.join("@");
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isSlug.js
var require_isSlug = __commonJS({
  "asset-input/node_modules/validator/lib/isSlug.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isSlug;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
    function isSlug(str) {
      (0, _assertString.default)(str);
      return charsetRegex.test(str);
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isLicensePlate.js
var require_isLicensePlate = __commonJS({
  "asset-input/node_modules/validator/lib/isLicensePlate.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLicensePlate;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validators = {
      "cs-CZ": function csCZ(str) {
        return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
      },
      "de-DE": function deDE(str) {
        return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|AÖ|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|BÖ|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|FÜ|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|GÖ|GP|GR|GS|GT|GÜ|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|LÖ|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|MÜ|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|NÖ|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|TÜ|ÜB|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|WÜ|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BÜD|BUL|BÜR|BÜS|BÜZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DÜW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FLÖ|FOR|FRG|FRI|FRW|FTL|FÜS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HMÜ|HOG|HOH|HOL|HOM|HOR|HÖS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JÜL|KEH|KEL|KEM|KIB|KLE|KLZ|KÖN|KÖT|KÖZ|KRU|KÜN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LÖB|LOS|LRO|LSZ|LÜN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MÜB|MÜR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|ÖHR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PLÖ|PRÜ|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RÜD|RÜG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SLÜ|SLZ|SMÜ|SOB|SOG|SOK|SÖM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SÜW|SWA|SZB|TBB|TDO|TET|TIR|TÖL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WÜM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
      },
      "de-LI": function deLI(str) {
        return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
      },
      "en-IN": function enIN(str) {
        return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
      },
      "es-AR": function esAR(str) {
        return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
      },
      "fi-FI": function fiFI(str) {
        return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
      },
      "hu-HU": function huHU(str) {
        return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
      },
      "pt-BR": function ptBR(str) {
        return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
      },
      "pt-PT": function ptPT(str) {
        return /^([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})$/.test(str);
      },
      "sq-AL": function sqAL(str) {
        return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
      },
      "sv-SE": function svSE(str) {
        return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-ZÅÄÖ ]{2,7}$)/.test(str.trim());
      },
      "en-PK": function enPK(str) {
        return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(str.trim());
      }
    };
    function isLicensePlate(str, locale) {
      (0, _assertString.default)(str);
      if (locale in validators) {
        return validators[locale](str);
      } else if (locale === "any") {
        for (var key in validators) {
          var validator = validators[key];
          if (validator(str)) {
            return true;
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isStrongPassword.js
var require_isStrongPassword = __commonJS({
  "asset-input/node_modules/validator/lib/isStrongPassword.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isStrongPassword;
    var _merge = _interopRequireDefault(require_merge2());
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var upperCaseRegex = /^[A-Z]$/;
    var lowerCaseRegex = /^[a-z]$/;
    var numberRegex = /^[0-9]$/;
    var symbolRegex = /^[-#!$@£%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/;
    var defaultOptions = {
      minLength: 8,
      minLowercase: 1,
      minUppercase: 1,
      minNumbers: 1,
      minSymbols: 1,
      returnScore: false,
      pointsPerUnique: 1,
      pointsPerRepeat: 0.5,
      pointsForContainingLower: 10,
      pointsForContainingUpper: 10,
      pointsForContainingNumber: 10,
      pointsForContainingSymbol: 10
    };
    function countChars(str) {
      var result = {};
      Array.from(str).forEach(function(char) {
        var curVal = result[char];
        if (curVal) {
          result[char] += 1;
        } else {
          result[char] = 1;
        }
      });
      return result;
    }
    function analyzePassword(password) {
      var charMap = countChars(password);
      var analysis = {
        length: password.length,
        uniqueChars: Object.keys(charMap).length,
        uppercaseCount: 0,
        lowercaseCount: 0,
        numberCount: 0,
        symbolCount: 0
      };
      Object.keys(charMap).forEach(function(char) {
        if (upperCaseRegex.test(char)) {
          analysis.uppercaseCount += charMap[char];
        } else if (lowerCaseRegex.test(char)) {
          analysis.lowercaseCount += charMap[char];
        } else if (numberRegex.test(char)) {
          analysis.numberCount += charMap[char];
        } else if (symbolRegex.test(char)) {
          analysis.symbolCount += charMap[char];
        }
      });
      return analysis;
    }
    function scorePassword(analysis, scoringOptions) {
      var points = 0;
      points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
      points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
      if (analysis.lowercaseCount > 0) {
        points += scoringOptions.pointsForContainingLower;
      }
      if (analysis.uppercaseCount > 0) {
        points += scoringOptions.pointsForContainingUpper;
      }
      if (analysis.numberCount > 0) {
        points += scoringOptions.pointsForContainingNumber;
      }
      if (analysis.symbolCount > 0) {
        points += scoringOptions.pointsForContainingSymbol;
      }
      return points;
    }
    function isStrongPassword(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      (0, _assertString.default)(str);
      var analysis = analyzePassword(str);
      options = (0, _merge.default)(options || {}, defaultOptions);
      if (options.returnScore) {
        return scorePassword(analysis, options);
      }
      return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/validator/lib/isVAT.js
var require_isVAT = __commonJS({
  "asset-input/node_modules/validator/lib/isVAT.js"(exports2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isVAT;
    exports2.vatMatchers = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var algorithms = _interopRequireWildcard(require_algorithms());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AU = function AU2(str) {
      var match = str.match(/^(AU)?(\d{11})$/);
      if (!match) {
        return false;
      }
      var weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
      str = str.replace(/^AU/, "");
      var ABN = (parseInt(str.slice(0, 1), 10) - 1).toString() + str.slice(1);
      var total = 0;
      for (var i = 0; i < 11; i++) {
        total += weights[i] * ABN.charAt(i);
      }
      return total !== 0 && total % 89 === 0;
    };
    var CH = function CH2(str) {
      var hasValidCheckNumber = function hasValidCheckNumber2(digits) {
        var lastDigit = digits.pop();
        var weights = [5, 4, 3, 2, 7, 6, 5, 4];
        var calculatedCheckNumber = (11 - digits.reduce(function(acc, el, idx) {
          return acc + el * weights[idx];
        }, 0) % 11) % 11;
        return lastDigit === calculatedCheckNumber;
      };
      return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function(el) {
        return +el;
      }));
    };
    var PT = function PT2(str) {
      var match = str.match(/^(PT)?(\d{9})$/);
      if (!match) {
        return false;
      }
      var tin = match[2];
      var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
        return parseInt(a, 10);
      }), 9) % 11;
      if (checksum > 9) {
        return parseInt(tin[8], 10) === 0;
      }
      return checksum === parseInt(tin[8], 10);
    };
    var vatMatchers = exports2.vatMatchers = {
      /**
       * European Union VAT identification numbers
       */
      AT: function AT(str) {
        return /^(AT)?U\d{8}$/.test(str);
      },
      BE: function BE(str) {
        return /^(BE)?\d{10}$/.test(str);
      },
      BG: function BG(str) {
        return /^(BG)?\d{9,10}$/.test(str);
      },
      HR: function HR(str) {
        return /^(HR)?\d{11}$/.test(str);
      },
      CY: function CY(str) {
        return /^(CY)?\w{9}$/.test(str);
      },
      CZ: function CZ(str) {
        return /^(CZ)?\d{8,10}$/.test(str);
      },
      DK: function DK(str) {
        return /^(DK)?\d{8}$/.test(str);
      },
      EE: function EE(str) {
        return /^(EE)?\d{9}$/.test(str);
      },
      FI: function FI(str) {
        return /^(FI)?\d{8}$/.test(str);
      },
      FR: function FR(str) {
        return /^(FR)?\w{2}\d{9}$/.test(str);
      },
      DE: function DE(str) {
        return /^(DE)?\d{9}$/.test(str);
      },
      EL: function EL(str) {
        return /^(EL)?\d{9}$/.test(str);
      },
      HU: function HU(str) {
        return /^(HU)?\d{8}$/.test(str);
      },
      IE: function IE(str) {
        return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
      },
      IT: function IT(str) {
        return /^(IT)?\d{11}$/.test(str);
      },
      LV: function LV(str) {
        return /^(LV)?\d{11}$/.test(str);
      },
      LT: function LT(str) {
        return /^(LT)?\d{9,12}$/.test(str);
      },
      LU: function LU(str) {
        return /^(LU)?\d{8}$/.test(str);
      },
      MT: function MT(str) {
        return /^(MT)?\d{8}$/.test(str);
      },
      NL: function NL(str) {
        return /^(NL)?\d{9}B\d{2}$/.test(str);
      },
      PL: function PL(str) {
        return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
      },
      PT,
      RO: function RO(str) {
        return /^(RO)?\d{2,10}$/.test(str);
      },
      SK: function SK(str) {
        return /^(SK)?\d{10}$/.test(str);
      },
      SI: function SI(str) {
        return /^(SI)?\d{8}$/.test(str);
      },
      ES: function ES(str) {
        return /^(ES)?\w\d{7}[A-Z]$/.test(str);
      },
      SE: function SE(str) {
        return /^(SE)?\d{12}$/.test(str);
      },
      /**
       * VAT numbers of non-EU countries
       */
      AL: function AL(str) {
        return /^(AL)?\w{9}[A-Z]$/.test(str);
      },
      MK: function MK(str) {
        return /^(MK)?\d{13}$/.test(str);
      },
      AU,
      BY: function BY(str) {
        return /^(УНП )?\d{9}$/.test(str);
      },
      CA: function CA(str) {
        return /^(CA)?\d{9}$/.test(str);
      },
      IS: function IS(str) {
        return /^(IS)?\d{5,6}$/.test(str);
      },
      IN: function IN(str) {
        return /^(IN)?\d{15}$/.test(str);
      },
      ID: function ID(str) {
        return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
      },
      IL: function IL(str) {
        return /^(IL)?\d{9}$/.test(str);
      },
      KZ: function KZ(str) {
        return /^(KZ)?\d{12}$/.test(str);
      },
      NZ: function NZ(str) {
        return /^(NZ)?\d{9}$/.test(str);
      },
      NG: function NG(str) {
        return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
      },
      NO: function NO(str) {
        return /^(NO)?\d{9}MVA$/.test(str);
      },
      PH: function PH(str) {
        return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
      },
      RU: function RU(str) {
        return /^(RU)?(\d{10}|\d{12})$/.test(str);
      },
      SM: function SM(str) {
        return /^(SM)?\d{5}$/.test(str);
      },
      SA: function SA(str) {
        return /^(SA)?\d{15}$/.test(str);
      },
      RS: function RS(str) {
        return /^(RS)?\d{9}$/.test(str);
      },
      CH,
      TR: function TR(str) {
        return /^(TR)?\d{10}$/.test(str);
      },
      UA: function UA(str) {
        return /^(UA)?\d{12}$/.test(str);
      },
      GB: function GB(str) {
        return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
      },
      UZ: function UZ(str) {
        return /^(UZ)?\d{9}$/.test(str);
      },
      /**
       * VAT numbers of Latin American countries
       */
      AR: function AR(str) {
        return /^(AR)?\d{11}$/.test(str);
      },
      BO: function BO(str) {
        return /^(BO)?\d{7}$/.test(str);
      },
      BR: function BR(str) {
        return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
      },
      CL: function CL(str) {
        return /^(CL)?\d{8}-\d{1}$/.test(str);
      },
      CO: function CO(str) {
        return /^(CO)?\d{10}$/.test(str);
      },
      CR: function CR(str) {
        return /^(CR)?\d{9,12}$/.test(str);
      },
      EC: function EC(str) {
        return /^(EC)?\d{13}$/.test(str);
      },
      SV: function SV(str) {
        return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
      },
      GT: function GT(str) {
        return /^(GT)?\d{7}-\d{1}$/.test(str);
      },
      HN: function HN(str) {
        return /^(HN)?$/.test(str);
      },
      MX: function MX(str) {
        return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
      },
      NI: function NI(str) {
        return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
      },
      PA: function PA(str) {
        return /^(PA)?$/.test(str);
      },
      PY: function PY(str) {
        return /^(PY)?\d{6,8}-\d{1}$/.test(str);
      },
      PE: function PE(str) {
        return /^(PE)?\d{11}$/.test(str);
      },
      DO: function DO(str) {
        return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
      },
      UY: function UY(str) {
        return /^(UY)?\d{12}$/.test(str);
      },
      VE: function VE(str) {
        return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
      }
    };
    function isVAT(str, countryCode) {
      (0, _assertString.default)(str);
      (0, _assertString.default)(countryCode);
      if (countryCode in vatMatchers) {
        return vatMatchers[countryCode](str);
      }
      throw new Error("Invalid country code: '".concat(countryCode, "'"));
    }
  }
});

// asset-input/node_modules/validator/index.js
var require_validator2 = __commonJS({
  "asset-input/node_modules/validator/index.js"(exports2, module2) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _toDate = _interopRequireDefault(require_toDate());
    var _toFloat = _interopRequireDefault(require_toFloat());
    var _toInt = _interopRequireDefault(require_toInt());
    var _toBoolean = _interopRequireDefault(require_toBoolean());
    var _equals = _interopRequireDefault(require_equals());
    var _contains = _interopRequireDefault(require_contains());
    var _matches = _interopRequireDefault(require_matches());
    var _isEmail = _interopRequireDefault(require_isEmail());
    var _isURL = _interopRequireDefault(require_isURL());
    var _isMACAddress = _interopRequireDefault(require_isMACAddress());
    var _isIP = _interopRequireDefault(require_isIP());
    var _isIPRange = _interopRequireDefault(require_isIPRange());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isDate = _interopRequireDefault(require_isDate());
    var _isTime = _interopRequireDefault(require_isTime());
    var _isBoolean = _interopRequireDefault(require_isBoolean());
    var _isLocale = _interopRequireDefault(require_isLocale());
    var _isAbaRouting = _interopRequireDefault(require_isAbaRouting());
    var _isAlpha = _interopRequireWildcard(require_isAlpha());
    var _isAlphanumeric = _interopRequireWildcard(require_isAlphanumeric());
    var _isNumeric = _interopRequireDefault(require_isNumeric());
    var _isPassportNumber = _interopRequireDefault(require_isPassportNumber());
    var _isPort = _interopRequireDefault(require_isPort());
    var _isLowercase = _interopRequireDefault(require_isLowercase());
    var _isUppercase = _interopRequireDefault(require_isUppercase());
    var _isIMEI = _interopRequireDefault(require_isIMEI());
    var _isAscii = _interopRequireDefault(require_isAscii());
    var _isFullWidth = _interopRequireDefault(require_isFullWidth());
    var _isHalfWidth = _interopRequireDefault(require_isHalfWidth());
    var _isVariableWidth = _interopRequireDefault(require_isVariableWidth());
    var _isMultibyte = _interopRequireDefault(require_isMultibyte());
    var _isSemVer = _interopRequireDefault(require_isSemVer());
    var _isSurrogatePair = _interopRequireDefault(require_isSurrogatePair());
    var _isInt = _interopRequireDefault(require_isInt());
    var _isFloat = _interopRequireWildcard(require_isFloat());
    var _isDecimal = _interopRequireDefault(require_isDecimal());
    var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
    var _isOctal = _interopRequireDefault(require_isOctal());
    var _isDivisibleBy = _interopRequireDefault(require_isDivisibleBy());
    var _isHexColor = _interopRequireDefault(require_isHexColor());
    var _isRgbColor = _interopRequireDefault(require_isRgbColor());
    var _isHSL = _interopRequireDefault(require_isHSL());
    var _isISRC = _interopRequireDefault(require_isISRC());
    var _isIBAN = _interopRequireWildcard(require_isIBAN());
    var _isBIC = _interopRequireDefault(require_isBIC());
    var _isMD = _interopRequireDefault(require_isMD5());
    var _isHash = _interopRequireDefault(require_isHash());
    var _isJWT = _interopRequireDefault(require_isJWT());
    var _isJSON = _interopRequireDefault(require_isJSON());
    var _isEmpty = _interopRequireDefault(require_isEmpty());
    var _isLength = _interopRequireDefault(require_isLength());
    var _isByteLength = _interopRequireDefault(require_isByteLength());
    var _isUUID = _interopRequireDefault(require_isUUID());
    var _isMongoId = _interopRequireDefault(require_isMongoId());
    var _isAfter = _interopRequireDefault(require_isAfter());
    var _isBefore = _interopRequireDefault(require_isBefore());
    var _isIn = _interopRequireDefault(require_isIn());
    var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
    var _isCreditCard = _interopRequireDefault(require_isCreditCard());
    var _isIdentityCard = _interopRequireDefault(require_isIdentityCard());
    var _isEAN = _interopRequireDefault(require_isEAN());
    var _isISIN = _interopRequireDefault(require_isISIN());
    var _isISBN = _interopRequireDefault(require_isISBN());
    var _isISSN = _interopRequireDefault(require_isISSN());
    var _isTaxID = _interopRequireDefault(require_isTaxID());
    var _isMobilePhone = _interopRequireWildcard(require_isMobilePhone());
    var _isEthereumAddress = _interopRequireDefault(require_isEthereumAddress());
    var _isCurrency = _interopRequireDefault(require_isCurrency());
    var _isBtcAddress = _interopRequireDefault(require_isBtcAddress());
    var _isISO = require_isISO6346();
    var _isISO2 = _interopRequireDefault(require_isISO6391());
    var _isISO3 = _interopRequireDefault(require_isISO8601());
    var _isRFC = _interopRequireDefault(require_isRFC3339());
    var _isISO31661Alpha = _interopRequireDefault(require_isISO31661Alpha2());
    var _isISO31661Alpha2 = _interopRequireDefault(require_isISO31661Alpha3());
    var _isISO4 = _interopRequireDefault(require_isISO4217());
    var _isBase = _interopRequireDefault(require_isBase32());
    var _isBase2 = _interopRequireDefault(require_isBase58());
    var _isBase3 = _interopRequireDefault(require_isBase64());
    var _isDataURI = _interopRequireDefault(require_isDataURI());
    var _isMagnetURI = _interopRequireDefault(require_isMagnetURI());
    var _isMailtoURI = _interopRequireDefault(require_isMailtoURI());
    var _isMimeType = _interopRequireDefault(require_isMimeType());
    var _isLatLong = _interopRequireDefault(require_isLatLong());
    var _isPostalCode = _interopRequireWildcard(require_isPostalCode());
    var _ltrim = _interopRequireDefault(require_ltrim());
    var _rtrim = _interopRequireDefault(require_rtrim());
    var _trim = _interopRequireDefault(require_trim());
    var _escape = _interopRequireDefault(require_escape());
    var _unescape = _interopRequireDefault(require_unescape());
    var _stripLow = _interopRequireDefault(require_stripLow());
    var _whitelist = _interopRequireDefault(require_whitelist());
    var _blacklist = _interopRequireDefault(require_blacklist());
    var _isWhitelisted = _interopRequireDefault(require_isWhitelisted());
    var _normalizeEmail = _interopRequireDefault(require_normalizeEmail());
    var _isSlug = _interopRequireDefault(require_isSlug());
    var _isLicensePlate = _interopRequireDefault(require_isLicensePlate());
    var _isStrongPassword = _interopRequireDefault(require_isStrongPassword());
    var _isVAT = _interopRequireDefault(require_isVAT());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var version = "13.12.0";
    var validator = {
      version,
      toDate: _toDate.default,
      toFloat: _toFloat.default,
      toInt: _toInt.default,
      toBoolean: _toBoolean.default,
      equals: _equals.default,
      contains: _contains.default,
      matches: _matches.default,
      isEmail: _isEmail.default,
      isURL: _isURL.default,
      isMACAddress: _isMACAddress.default,
      isIP: _isIP.default,
      isIPRange: _isIPRange.default,
      isFQDN: _isFQDN.default,
      isBoolean: _isBoolean.default,
      isIBAN: _isIBAN.default,
      isBIC: _isBIC.default,
      isAbaRouting: _isAbaRouting.default,
      isAlpha: _isAlpha.default,
      isAlphaLocales: _isAlpha.locales,
      isAlphanumeric: _isAlphanumeric.default,
      isAlphanumericLocales: _isAlphanumeric.locales,
      isNumeric: _isNumeric.default,
      isPassportNumber: _isPassportNumber.default,
      isPort: _isPort.default,
      isLowercase: _isLowercase.default,
      isUppercase: _isUppercase.default,
      isAscii: _isAscii.default,
      isFullWidth: _isFullWidth.default,
      isHalfWidth: _isHalfWidth.default,
      isVariableWidth: _isVariableWidth.default,
      isMultibyte: _isMultibyte.default,
      isSemVer: _isSemVer.default,
      isSurrogatePair: _isSurrogatePair.default,
      isInt: _isInt.default,
      isIMEI: _isIMEI.default,
      isFloat: _isFloat.default,
      isFloatLocales: _isFloat.locales,
      isDecimal: _isDecimal.default,
      isHexadecimal: _isHexadecimal.default,
      isOctal: _isOctal.default,
      isDivisibleBy: _isDivisibleBy.default,
      isHexColor: _isHexColor.default,
      isRgbColor: _isRgbColor.default,
      isHSL: _isHSL.default,
      isISRC: _isISRC.default,
      isMD5: _isMD.default,
      isHash: _isHash.default,
      isJWT: _isJWT.default,
      isJSON: _isJSON.default,
      isEmpty: _isEmpty.default,
      isLength: _isLength.default,
      isLocale: _isLocale.default,
      isByteLength: _isByteLength.default,
      isUUID: _isUUID.default,
      isMongoId: _isMongoId.default,
      isAfter: _isAfter.default,
      isBefore: _isBefore.default,
      isIn: _isIn.default,
      isLuhnNumber: _isLuhnNumber.default,
      isCreditCard: _isCreditCard.default,
      isIdentityCard: _isIdentityCard.default,
      isEAN: _isEAN.default,
      isISIN: _isISIN.default,
      isISBN: _isISBN.default,
      isISSN: _isISSN.default,
      isMobilePhone: _isMobilePhone.default,
      isMobilePhoneLocales: _isMobilePhone.locales,
      isPostalCode: _isPostalCode.default,
      isPostalCodeLocales: _isPostalCode.locales,
      isEthereumAddress: _isEthereumAddress.default,
      isCurrency: _isCurrency.default,
      isBtcAddress: _isBtcAddress.default,
      isISO6346: _isISO.isISO6346,
      isFreightContainerID: _isISO.isFreightContainerID,
      isISO6391: _isISO2.default,
      isISO8601: _isISO3.default,
      isRFC3339: _isRFC.default,
      isISO31661Alpha2: _isISO31661Alpha.default,
      isISO31661Alpha3: _isISO31661Alpha2.default,
      isISO4217: _isISO4.default,
      isBase32: _isBase.default,
      isBase58: _isBase2.default,
      isBase64: _isBase3.default,
      isDataURI: _isDataURI.default,
      isMagnetURI: _isMagnetURI.default,
      isMailtoURI: _isMailtoURI.default,
      isMimeType: _isMimeType.default,
      isLatLong: _isLatLong.default,
      ltrim: _ltrim.default,
      rtrim: _rtrim.default,
      trim: _trim.default,
      escape: _escape.default,
      unescape: _unescape.default,
      stripLow: _stripLow.default,
      whitelist: _whitelist.default,
      blacklist: _blacklist.default,
      isWhitelisted: _isWhitelisted.default,
      normalizeEmail: _normalizeEmail.default,
      toString,
      isSlug: _isSlug.default,
      isStrongPassword: _isStrongPassword.default,
      isTaxID: _isTaxID.default,
      isDate: _isDate.default,
      isTime: _isTime.default,
      isLicensePlate: _isLicensePlate.default,
      isVAT: _isVAT.default,
      ibanLocales: _isIBAN.locales
    };
    var _default = exports2.default = validator;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsStrongPassword.js
var require_IsStrongPassword = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsStrongPassword.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsStrongPassword = exports2.isStrongPassword = exports2.IS_STRONG_PASSWORD = void 0;
    var validator = __importStar(require_validator2());
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_STRONG_PASSWORD = "isStrongPassword";
    function isStrongPassword(value, options) {
      return typeof value === "string" && validator.isStrongPassword(value, options);
    }
    exports2.isStrongPassword = isStrongPassword;
    function IsStrongPassword(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_STRONG_PASSWORD,
        constraints: [options],
        validator: {
          validate: (value, args) => isStrongPassword(value, args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property is not strong enough", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsStrongPassword = IsStrongPassword;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsTimeZone.js
var require_IsTimeZone = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsTimeZone.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsTimeZone = exports2.isTimeZone = exports2.IS_TIMEZONE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_TIMEZONE = "isTimeZone";
    function isTimeZone(value) {
      try {
        if (typeof value !== "string") {
          return false;
        }
        Intl.DateTimeFormat(void 0, { timeZone: value });
        return true;
      } catch (exception) {
        return false;
      }
    }
    exports2.isTimeZone = isTimeZone;
    function IsTimeZone(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_TIMEZONE,
        validator: {
          validate: (value, args) => isTimeZone(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid IANA time-zone", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsTimeZone = IsTimeZone;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/IsBase58.js
var require_IsBase58 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/IsBase58.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsBase58 = exports2.isBase58 = exports2.IS_BASE58 = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isBase58_1 = __importDefault(require_isBase58());
    exports2.IS_BASE58 = "isBase58";
    function isBase58(value) {
      return typeof value === "string" && (0, isBase58_1.default)(value);
    }
    exports2.isBase58 = isBase58;
    function IsBase58(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BASE58,
        validator: {
          validate: (value, args) => isBase58(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be base58 encoded", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsBase58 = IsBase58;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/is-tax-id.js
var require_is_tax_id = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/is-tax-id.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsTaxId = exports2.isTaxId = exports2.IS_TAX_ID = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isTaxID_1 = __importDefault(require_isTaxID());
    exports2.IS_TAX_ID = "isTaxId";
    function isTaxId(value, locale) {
      return typeof value === "string" && (0, isTaxID_1.default)(value, locale || "en-US");
    }
    exports2.isTaxId = isTaxId;
    function IsTaxId(locale, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_TAX_ID,
        constraints: [locale],
        validator: {
          validate: (value, args) => isTaxId(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a Tax Identification Number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsTaxId = IsTaxId;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/string/is-iso4217-currency-code.js
var require_is_iso4217_currency_code = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/string/is-iso4217-currency-code.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsISO4217CurrencyCode = exports2.isISO4217CurrencyCode = exports2.IS_ISO4217_CURRENCY_CODE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var isISO4217_1 = __importDefault(require_isISO4217());
    exports2.IS_ISO4217_CURRENCY_CODE = "isISO4217CurrencyCode";
    function isISO4217CurrencyCode(value) {
      return typeof value === "string" && (0, isISO4217_1.default)(value);
    }
    exports2.isISO4217CurrencyCode = isISO4217CurrencyCode;
    function IsISO4217CurrencyCode(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ISO4217_CURRENCY_CODE,
        validator: {
          validate: (value, args) => isISO4217CurrencyCode(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a valid ISO4217 currency code", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsISO4217CurrencyCode = IsISO4217CurrencyCode;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsBoolean.js
var require_IsBoolean = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsBoolean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsBoolean = exports2.isBoolean = exports2.IS_BOOLEAN = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_BOOLEAN = "isBoolean";
    function isBoolean(value) {
      return value instanceof Boolean || typeof value === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function IsBoolean(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_BOOLEAN,
        validator: {
          validate: (value, args) => isBoolean(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a boolean value", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsBoolean = IsBoolean;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsDate.js
var require_IsDate = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsDate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsDate = exports2.isDate = exports2.IS_DATE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_DATE = "isDate";
    function isDate(value) {
      return value instanceof Date && !isNaN(value.getTime());
    }
    exports2.isDate = isDate;
    function IsDate(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_DATE,
        validator: {
          validate: (value, args) => isDate(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a Date instance", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsDate = IsDate;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsNumber.js
var require_IsNumber = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsNumber = exports2.isNumber = exports2.IS_NUMBER = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_NUMBER = "isNumber";
    function isNumber(value, options = {}) {
      if (typeof value !== "number") {
        return false;
      }
      if (value === Infinity || value === -Infinity) {
        return !!options.allowInfinity;
      }
      if (Number.isNaN(value)) {
        return !!options.allowNaN;
      }
      if (options.maxDecimalPlaces !== void 0) {
        let decimalPlaces = 0;
        if (value % 1 !== 0) {
          decimalPlaces = value.toString().split(".")[1].length;
        }
        if (decimalPlaces > options.maxDecimalPlaces) {
          return false;
        }
      }
      return Number.isFinite(value);
    }
    exports2.isNumber = isNumber;
    function IsNumber(options = {}, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_NUMBER,
        constraints: [options],
        validator: {
          validate: (value, args) => isNumber(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a number conforming to the specified constraints", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsNumber = IsNumber;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsEnum.js
var require_IsEnum = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsEnum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsEnum = exports2.isEnum = exports2.IS_ENUM = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_ENUM = "isEnum";
    function isEnum(value, entity) {
      const enumValues = Object.keys(entity).map((k) => entity[k]);
      return enumValues.includes(value);
    }
    exports2.isEnum = isEnum;
    function validEnumValues(entity) {
      return Object.entries(entity).filter(([key, value]) => isNaN(parseInt(key))).map(([key, value]) => value);
    }
    function IsEnum(entity, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ENUM,
        constraints: [entity, validEnumValues(entity)],
        validator: {
          validate: (value, args) => isEnum(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be one of the following values: $constraint2", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsEnum = IsEnum;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsInt.js
var require_IsInt = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsInt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsInt = exports2.isInt = exports2.IS_INT = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_INT = "isInt";
    function isInt(val) {
      return typeof val === "number" && Number.isInteger(val);
    }
    exports2.isInt = isInt;
    function IsInt(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_INT,
        validator: {
          validate: (value, args) => isInt(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an integer number", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsInt = IsInt;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsString.js
var require_IsString = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsString = exports2.isString = exports2.IS_STRING = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_STRING = "isString";
    function isString(value) {
      return value instanceof String || typeof value === "string";
    }
    exports2.isString = isString;
    function IsString(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_STRING,
        validator: {
          validate: (value, args) => isString(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a string", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsString = IsString;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsArray.js
var require_IsArray = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsArray = exports2.isArray = exports2.IS_ARRAY = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_ARRAY = "isArray";
    function isArray(value) {
      return Array.isArray(value);
    }
    exports2.isArray = isArray;
    function IsArray(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_ARRAY,
        validator: {
          validate: (value, args) => isArray(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an array", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsArray = IsArray;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsObject.js
var require_IsObject = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/typechecker/IsObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsObject = exports2.isObject = exports2.IS_OBJECT = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_OBJECT = "isObject";
    function isObject(value) {
      return value != null && (typeof value === "object" || typeof value === "function") && !Array.isArray(value);
    }
    exports2.isObject = isObject;
    function IsObject(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_OBJECT,
        validator: {
          validate: (value, args) => isObject(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be an object", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsObject = IsObject;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/array/ArrayContains.js
var require_ArrayContains = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/array/ArrayContains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayContains = exports2.arrayContains = exports2.ARRAY_CONTAINS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.ARRAY_CONTAINS = "arrayContains";
    function arrayContains(array, values) {
      if (!Array.isArray(array))
        return false;
      return values.every((value) => array.indexOf(value) !== -1);
    }
    exports2.arrayContains = arrayContains;
    function ArrayContains(values, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.ARRAY_CONTAINS,
        constraints: [values],
        validator: {
          validate: (value, args) => arrayContains(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain $constraint1 values", validationOptions)
        }
      }, validationOptions);
    }
    exports2.ArrayContains = ArrayContains;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/array/ArrayNotContains.js
var require_ArrayNotContains = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/array/ArrayNotContains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayNotContains = exports2.arrayNotContains = exports2.ARRAY_NOT_CONTAINS = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.ARRAY_NOT_CONTAINS = "arrayNotContains";
    function arrayNotContains(array, values) {
      if (!Array.isArray(array))
        return false;
      return values.every((value) => array.indexOf(value) === -1);
    }
    exports2.arrayNotContains = arrayNotContains;
    function ArrayNotContains(values, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.ARRAY_NOT_CONTAINS,
        constraints: [values],
        validator: {
          validate: (value, args) => arrayNotContains(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property should not contain $constraint1 values", validationOptions)
        }
      }, validationOptions);
    }
    exports2.ArrayNotContains = ArrayNotContains;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/array/ArrayNotEmpty.js
var require_ArrayNotEmpty = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/array/ArrayNotEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayNotEmpty = exports2.arrayNotEmpty = exports2.ARRAY_NOT_EMPTY = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.ARRAY_NOT_EMPTY = "arrayNotEmpty";
    function arrayNotEmpty(array) {
      return Array.isArray(array) && array.length > 0;
    }
    exports2.arrayNotEmpty = arrayNotEmpty;
    function ArrayNotEmpty(validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.ARRAY_NOT_EMPTY,
        validator: {
          validate: (value, args) => arrayNotEmpty(value),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property should not be empty", validationOptions)
        }
      }, validationOptions);
    }
    exports2.ArrayNotEmpty = ArrayNotEmpty;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/array/ArrayMinSize.js
var require_ArrayMinSize = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/array/ArrayMinSize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayMinSize = exports2.arrayMinSize = exports2.ARRAY_MIN_SIZE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.ARRAY_MIN_SIZE = "arrayMinSize";
    function arrayMinSize(array, min) {
      return Array.isArray(array) && array.length >= min;
    }
    exports2.arrayMinSize = arrayMinSize;
    function ArrayMinSize(min, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.ARRAY_MIN_SIZE,
        constraints: [min],
        validator: {
          validate: (value, args) => arrayMinSize(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain at least $constraint1 elements", validationOptions)
        }
      }, validationOptions);
    }
    exports2.ArrayMinSize = ArrayMinSize;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/array/ArrayMaxSize.js
var require_ArrayMaxSize = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/array/ArrayMaxSize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayMaxSize = exports2.arrayMaxSize = exports2.ARRAY_MAX_SIZE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.ARRAY_MAX_SIZE = "arrayMaxSize";
    function arrayMaxSize(array, max) {
      return Array.isArray(array) && array.length <= max;
    }
    exports2.arrayMaxSize = arrayMaxSize;
    function ArrayMaxSize(max, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.ARRAY_MAX_SIZE,
        constraints: [max],
        validator: {
          validate: (value, args) => arrayMaxSize(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must contain no more than $constraint1 elements", validationOptions)
        }
      }, validationOptions);
    }
    exports2.ArrayMaxSize = ArrayMaxSize;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/array/ArrayUnique.js
var require_ArrayUnique = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/array/ArrayUnique.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayUnique = exports2.arrayUnique = exports2.ARRAY_UNIQUE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.ARRAY_UNIQUE = "arrayUnique";
    function arrayUnique(array, identifier) {
      if (!Array.isArray(array))
        return false;
      if (identifier) {
        array = array.map((o) => o != null ? identifier(o) : o);
      }
      const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);
      return array.length === uniqueItems.length;
    }
    exports2.arrayUnique = arrayUnique;
    function ArrayUnique(identifierOrOptions, validationOptions) {
      const identifier = typeof identifierOrOptions === "function" ? identifierOrOptions : void 0;
      const options = typeof identifierOrOptions !== "function" ? identifierOrOptions : validationOptions;
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.ARRAY_UNIQUE,
        validator: {
          validate: (value, args) => arrayUnique(value, identifier),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "All $property's elements must be unique", options)
        }
      }, options);
    }
    exports2.ArrayUnique = ArrayUnique;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/object/IsNotEmptyObject.js
var require_IsNotEmptyObject = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/object/IsNotEmptyObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsNotEmptyObject = exports2.isNotEmptyObject = exports2.IS_NOT_EMPTY_OBJECT = void 0;
    var ValidateBy_1 = require_ValidateBy();
    var IsObject_1 = require_IsObject();
    exports2.IS_NOT_EMPTY_OBJECT = "isNotEmptyObject";
    function isNotEmptyObject(value, options) {
      if (!(0, IsObject_1.isObject)(value)) {
        return false;
      }
      if ((options === null || options === void 0 ? void 0 : options.nullable) === false) {
        return !Object.values(value).every((propertyValue) => propertyValue === null || propertyValue === void 0);
      }
      for (const key in value) {
        if (value.hasOwnProperty(key)) {
          return true;
        }
      }
      return false;
    }
    exports2.isNotEmptyObject = isNotEmptyObject;
    function IsNotEmptyObject(options, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_NOT_EMPTY_OBJECT,
        constraints: [options],
        validator: {
          validate: (value, args) => isNotEmptyObject(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix) => eachPrefix + "$property must be a non-empty object", validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsNotEmptyObject = IsNotEmptyObject;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/object/IsInstance.js
var require_IsInstance = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/object/IsInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsInstance = exports2.isInstance = exports2.IS_INSTANCE = void 0;
    var ValidateBy_1 = require_ValidateBy();
    exports2.IS_INSTANCE = "isInstance";
    function isInstance(object, targetTypeConstructor) {
      return targetTypeConstructor && typeof targetTypeConstructor === "function" && object instanceof targetTypeConstructor;
    }
    exports2.isInstance = isInstance;
    function IsInstance(targetType, validationOptions) {
      return (0, ValidateBy_1.ValidateBy)({
        name: exports2.IS_INSTANCE,
        constraints: [targetType],
        validator: {
          validate: (value, args) => isInstance(value, args === null || args === void 0 ? void 0 : args.constraints[0]),
          defaultMessage: (0, ValidateBy_1.buildMessage)((eachPrefix, args) => {
            if (args === null || args === void 0 ? void 0 : args.constraints[0]) {
              return eachPrefix + `$property must be an instance of ${args === null || args === void 0 ? void 0 : args.constraints[0].name}`;
            } else {
              return eachPrefix + `${exports2.IS_INSTANCE} decorator expects and object as value, but got falsy value.`;
            }
          }, validationOptions)
        }
      }, validationOptions);
    }
    exports2.IsInstance = IsInstance;
  }
});

// asset-input/node_modules/class-validator/cjs/decorator/decorators.js
var require_decorators2 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/decorator/decorators.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Allow(), exports2);
    __exportStar(require_IsDefined(), exports2);
    __exportStar(require_IsOptional(), exports2);
    __exportStar(require_Validate(), exports2);
    __exportStar(require_ValidateBy(), exports2);
    __exportStar(require_ValidateIf(), exports2);
    __exportStar(require_ValidateNested(), exports2);
    __exportStar(require_ValidatePromise(), exports2);
    __exportStar(require_IsLatLong(), exports2);
    __exportStar(require_IsLatitude(), exports2);
    __exportStar(require_IsLongitude(), exports2);
    __exportStar(require_Equals(), exports2);
    __exportStar(require_NotEquals(), exports2);
    __exportStar(require_IsEmpty(), exports2);
    __exportStar(require_IsNotEmpty(), exports2);
    __exportStar(require_IsIn(), exports2);
    __exportStar(require_IsNotIn(), exports2);
    __exportStar(require_IsDivisibleBy(), exports2);
    __exportStar(require_IsPositive(), exports2);
    __exportStar(require_IsNegative(), exports2);
    __exportStar(require_Max(), exports2);
    __exportStar(require_Min(), exports2);
    __exportStar(require_MinDate(), exports2);
    __exportStar(require_MaxDate(), exports2);
    __exportStar(require_Contains(), exports2);
    __exportStar(require_NotContains(), exports2);
    __exportStar(require_IsAlpha(), exports2);
    __exportStar(require_IsAlphanumeric(), exports2);
    __exportStar(require_IsDecimal(), exports2);
    __exportStar(require_IsAscii(), exports2);
    __exportStar(require_IsBase64(), exports2);
    __exportStar(require_IsByteLength(), exports2);
    __exportStar(require_IsCreditCard(), exports2);
    __exportStar(require_IsCurrency(), exports2);
    __exportStar(require_IsEmail(), exports2);
    __exportStar(require_IsFQDN(), exports2);
    __exportStar(require_IsFullWidth(), exports2);
    __exportStar(require_IsHalfWidth(), exports2);
    __exportStar(require_IsVariableWidth(), exports2);
    __exportStar(require_IsHexColor(), exports2);
    __exportStar(require_IsHexadecimal(), exports2);
    __exportStar(require_IsMacAddress(), exports2);
    __exportStar(require_IsIP(), exports2);
    __exportStar(require_IsPort(), exports2);
    __exportStar(require_IsISBN(), exports2);
    __exportStar(require_IsISIN(), exports2);
    __exportStar(require_IsISO8601(), exports2);
    __exportStar(require_IsJSON(), exports2);
    __exportStar(require_IsJWT(), exports2);
    __exportStar(require_IsLowercase(), exports2);
    __exportStar(require_IsMobilePhone(), exports2);
    __exportStar(require_IsISO31661Alpha2(), exports2);
    __exportStar(require_IsISO31661Alpha3(), exports2);
    __exportStar(require_IsMongoId(), exports2);
    __exportStar(require_IsMultibyte(), exports2);
    __exportStar(require_IsSurrogatePair(), exports2);
    __exportStar(require_IsUrl(), exports2);
    __exportStar(require_IsUUID(), exports2);
    __exportStar(require_IsFirebasePushId(), exports2);
    __exportStar(require_IsUppercase(), exports2);
    __exportStar(require_Length(), exports2);
    __exportStar(require_MaxLength(), exports2);
    __exportStar(require_MinLength(), exports2);
    __exportStar(require_Matches(), exports2);
    __exportStar(require_IsPhoneNumber(), exports2);
    __exportStar(require_IsMilitaryTime(), exports2);
    __exportStar(require_IsHash(), exports2);
    __exportStar(require_IsISSN(), exports2);
    __exportStar(require_IsDateString(), exports2);
    __exportStar(require_IsBooleanString(), exports2);
    __exportStar(require_IsNumberString(), exports2);
    __exportStar(require_IsBase32(), exports2);
    __exportStar(require_IsBIC(), exports2);
    __exportStar(require_IsBtcAddress(), exports2);
    __exportStar(require_IsDataURI(), exports2);
    __exportStar(require_IsEAN(), exports2);
    __exportStar(require_IsEthereumAddress(), exports2);
    __exportStar(require_IsHSL(), exports2);
    __exportStar(require_IsIBAN(), exports2);
    __exportStar(require_IsIdentityCard(), exports2);
    __exportStar(require_IsISRC(), exports2);
    __exportStar(require_IsLocale(), exports2);
    __exportStar(require_IsMagnetURI(), exports2);
    __exportStar(require_IsMimeType(), exports2);
    __exportStar(require_IsOctal(), exports2);
    __exportStar(require_IsPassportNumber(), exports2);
    __exportStar(require_IsPostalCode(), exports2);
    __exportStar(require_IsRFC3339(), exports2);
    __exportStar(require_IsRgbColor(), exports2);
    __exportStar(require_IsSemVer(), exports2);
    __exportStar(require_IsStrongPassword(), exports2);
    __exportStar(require_IsTimeZone(), exports2);
    __exportStar(require_IsBase58(), exports2);
    __exportStar(require_is_tax_id(), exports2);
    __exportStar(require_is_iso4217_currency_code(), exports2);
    __exportStar(require_IsBoolean(), exports2);
    __exportStar(require_IsDate(), exports2);
    __exportStar(require_IsNumber(), exports2);
    __exportStar(require_IsEnum(), exports2);
    __exportStar(require_IsInt(), exports2);
    __exportStar(require_IsString(), exports2);
    __exportStar(require_IsArray(), exports2);
    __exportStar(require_IsObject(), exports2);
    __exportStar(require_ArrayContains(), exports2);
    __exportStar(require_ArrayNotContains(), exports2);
    __exportStar(require_ArrayNotEmpty(), exports2);
    __exportStar(require_ArrayMinSize(), exports2);
    __exportStar(require_ArrayMaxSize(), exports2);
    __exportStar(require_ArrayUnique(), exports2);
    __exportStar(require_IsNotEmptyObject(), exports2);
    __exportStar(require_IsInstance(), exports2);
  }
});

// asset-input/node_modules/class-validator/cjs/validation/ValidatorConstraintInterface.js
var require_ValidatorConstraintInterface = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/ValidatorConstraintInterface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-validator/cjs/validation/ValidatorOptions.js
var require_ValidatorOptions = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/ValidatorOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-validator/cjs/validation/ValidationArguments.js
var require_ValidationArguments = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation/ValidationArguments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-validator/cjs/validation-schema/ValidationSchema.js
var require_ValidationSchema = __commonJS({
  "asset-input/node_modules/class-validator/cjs/validation-schema/ValidationSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// asset-input/node_modules/class-validator/cjs/index.js
var require_cjs2 = __commonJS({
  "asset-input/node_modules/class-validator/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerSchema = exports2.validateSync = exports2.validateOrReject = exports2.validate = void 0;
    var MetadataStorage_1 = require_MetadataStorage2();
    var Validator_1 = require_Validator();
    var container_1 = require_container();
    __exportStar(require_container(), exports2);
    __exportStar(require_decorators2(), exports2);
    __exportStar(require_ValidationOptions(), exports2);
    __exportStar(require_ValidatorConstraintInterface(), exports2);
    __exportStar(require_ValidationError(), exports2);
    __exportStar(require_ValidatorOptions(), exports2);
    __exportStar(require_ValidationArguments(), exports2);
    __exportStar(require_ValidationTypes(), exports2);
    __exportStar(require_Validator(), exports2);
    __exportStar(require_ValidationSchema(), exports2);
    __exportStar(require_register_decorator(), exports2);
    __exportStar(require_MetadataStorage2(), exports2);
    function validate2(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
      if (typeof schemaNameOrObject === "string") {
        return (0, container_1.getFromContainer)(Validator_1.Validator).validate(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
      } else {
        return (0, container_1.getFromContainer)(Validator_1.Validator).validate(schemaNameOrObject, objectOrValidationOptions);
      }
    }
    exports2.validate = validate2;
    function validateOrReject(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
      if (typeof schemaNameOrObject === "string") {
        return (0, container_1.getFromContainer)(Validator_1.Validator).validateOrReject(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
      } else {
        return (0, container_1.getFromContainer)(Validator_1.Validator).validateOrReject(schemaNameOrObject, objectOrValidationOptions);
      }
    }
    exports2.validateOrReject = validateOrReject;
    function validateSync(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions) {
      if (typeof schemaNameOrObject === "string") {
        return (0, container_1.getFromContainer)(Validator_1.Validator).validateSync(schemaNameOrObject, objectOrValidationOptions, maybeValidatorOptions);
      } else {
        return (0, container_1.getFromContainer)(Validator_1.Validator).validateSync(schemaNameOrObject, objectOrValidationOptions);
      }
    }
    exports2.validateSync = validateSync;
    function registerSchema(schema) {
      (0, MetadataStorage_1.getMetadataStorage)().addValidationSchema(schema);
    }
    exports2.registerSchema = registerSchema;
  }
});

// asset-input/src/category-api.ts
var category_api_exports = {};
__export(category_api_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(category_api_exports);

// asset-input/src/utility/db-connection.ts
var import_mongoose = __toESM(require_mongoose());
import_mongoose.default.set("strictQuery", false);
var ConnectDB = async () => {
  const DB_URL = "mongodb+srv://example:example@cluster0.gaajwxc.mongodb.net/nodejs-sls-mc";
  try {
    await import_mongoose.default.connect(DB_URL);
  } catch (err) {
    console.log(err);
  }
};

// asset-input/src/utility/index.ts
ConnectDB().then(() => {
  console.log("DB connected!");
}).catch((err) => console.log(err));

// asset-input/src/models/product-model.ts
var import_mongoose2 = __toESM(require_mongoose());
var productSchema = new import_mongoose2.default.Schema(
  {
    name: String,
    description: String,
    category_id: String,
    image_url: String,
    price: Number,
    availability: Boolean
  },
  {
    toJSON: {
      transform(doc, ret, options) {
        delete ret.__v;
        delete ret.createdAt;
        delete ret.updatedAt;
      }
    },
    timestamps: true
  }
);
var products = import_mongoose2.default.models.products || import_mongoose2.default.model("products", productSchema);

// asset-input/src/models/category-model.ts
var import_mongoose3 = __toESM(require_mongoose());
var categorySchema = new import_mongoose3.default.Schema(
  {
    name: String,
    nameTranslations: { en: { type: String }, de: { type: String } },
    parentId: {
      type: import_mongoose3.default.SchemaTypes.ObjectId,
      ref: "categories"
    },
    subCategories: [
      {
        type: import_mongoose3.default.SchemaTypes.ObjectId,
        ref: "categories"
      }
    ],
    products: [
      {
        type: import_mongoose3.default.SchemaTypes.ObjectId,
        ref: "products"
      }
    ],
    displayOrder: { type: Number, default: 1 },
    imageUrl: String
  },
  {
    toJSON: {
      transform(doc, ret, options) {
        delete ret.__v;
        delete ret.createdAt;
        delete ret.updatedAt;
      }
    },
    timestamps: true
  }
);
var categories = import_mongoose3.default.models.categories || import_mongoose3.default.model("categories", categorySchema);

// asset-input/src/repository/category-repository.ts
var CategoryRepository = class {
  constructor() {
  }
  async createCategory({ name, parentId, imageUrl }) {
    const newCategory = await categories.create({
      name,
      parentId,
      subCategory: [],
      products: [],
      imageUrl
    });
    if (parentId) {
      const parentCategory = await categories.findById(
        parentId
      );
      parentCategory.subCategories = [
        ...parentCategory.subCategories,
        newCategory
      ];
      await parentCategory.save();
    }
    return newCategory;
  }
  //main categories
  async getAllCategories(offset = 0, perPages) {
    return categories.find({ parentId: null }).populate({
      path: "subCategories",
      model: "categories",
      populate: {
        path: "subCategories",
        model: "categories"
      }
    }).skip(offset).limit(perPages ? perPages : 100);
  }
  async getTopCategories() {
    return categories.find(
      // ne is not equal
      // sub categories will have parentId, top categories no
      { parentId: { $ne: null } },
      //give us all subcategories
      { products: { $slice: 10 } }
      // filter only 10 products frm the subcategories
    ).populate({
      path: "products",
      model: "products"
    }).sort({ displayOrder: "descending" }).limit(10);
  }
  async getCategoryById(id, offset = 0, perPage) {
    return categories.findById(id, {
      products: { $slice: [offset, perPage ? perPage : 100] }
    }).populate({
      path: "products",
      model: "products"
    });
  }
  async updateCategory({ id, name, displayOrder, imageUrl }) {
    let category = await categories.findById(id);
    category.name = name;
    category.displayOrder = displayOrder;
    category.imageUrl = imageUrl;
    return category.save();
  }
  async deleteCategory(id) {
    return categories.deleteOne({ _id: id });
  }
  async addItem({ id, products: products2 }) {
    let category = await categories.findById(id);
    category.products = [...category.products, ...products2];
    return category.save();
  }
  async removeItem({ id, products: products2 }) {
    let category = await categories.findById(id);
    const excludeProducts = category.products.filter(
      (item) => !products2.includes(item)
    );
    category.products = excludeProducts;
    return category.save();
  }
};

// asset-input/src/utility/response.ts
var formatResponse = (statusCode, message, data) => {
  if (data) {
    return {
      statusCode,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        message,
        data
      })
    };
  } else {
    return {
      statusCode,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        message
      })
    };
  }
};
var SucessResponse = (data) => {
  return formatResponse(200, "success", data);
};
var ErrorResponse = (code = 1e3, error) => {
  if (Array.isArray(error)) {
    const errorObject = error[0].constraints;
    const errorMesssage = errorObject[Object.keys(errorObject)[0]] || "Error Occured";
    return formatResponse(code, errorMesssage, errorMesssage);
  }
  return formatResponse(code, `${error}`, error);
};

// asset-input/src/service/category-service.ts
var import_class_transformer = __toESM(require_cjs());

// asset-input/src/utility/errors.ts
var import_class_validator = __toESM(require_cjs2());
var AppValidationError = async (input) => {
  const error = await (0, import_class_validator.validate)(input, {
    ValidationError: { target: true }
  });
  if (error.length) {
    return error;
  }
  return false;
};

// asset-input/src/dto/category-input.ts
var import_class_validator2 = __toESM(require_cjs2());
var CategoryInput = class {
};
__decorateClass([
  (0, import_class_validator2.Length)(3, 128)
], CategoryInput.prototype, "name", 2);
var AddItemInput = class {
};
__decorateClass([
  (0, import_class_validator2.Length)(3, 128)
], AddItemInput.prototype, "id", 2);

// asset-input/src/service/category-service.ts
var CategoryService = class {
  constructor(repository) {
    this._repository = repository;
  }
  async ResponseWithError(event) {
    return ErrorResponse(404, new Error("method not allowed!"));
  }
  async createCategory(event) {
    const input = (0, import_class_transformer.plainToClass)(CategoryInput, event.body);
    const error = await AppValidationError(input);
    if (error) return ErrorResponse(404, error);
    const data = await this._repository.createCategory(input);
    return SucessResponse(data);
  }
  async getCategories(event) {
    const type = event.queryStringParameters?.type;
    if (type === "top") {
      const data2 = await this._repository.getTopCategories();
      return SucessResponse(data2);
    }
    const data = await this._repository.getAllCategories();
    return SucessResponse(data);
  }
  async getCategory(event) {
    const categoryId = event.pathParameters?.id;
    if (!categoryId) return ErrorResponse(403, "please provide category id");
    const data = await this._repository.getCategoryById(categoryId);
    return SucessResponse(data);
  }
  async editCategory(event) {
    const categoryId = event.pathParameters?.id;
    if (!categoryId) return ErrorResponse(403, "please provide category id");
    const input = (0, import_class_transformer.plainToClass)(CategoryInput, event.body);
    const error = await AppValidationError(input);
    if (error) return ErrorResponse(404, error);
    input.id = categoryId;
    const data = await this._repository.updateCategory(input);
    return SucessResponse(data);
  }
  async deleteCategory(event) {
    const categoryId = event.pathParameters?.id;
    if (!categoryId) return ErrorResponse(403, "please provide category id");
    const data = await this._repository.deleteCategory(categoryId);
    return SucessResponse(data);
  }
};

// asset-input/node_modules/@middy/util/index.js
var createErrorRegexp = /[^a-zA-Z]/g;
var HttpError = class extends Error {
  constructor(code, message, options = {}) {
    if (message && typeof message !== "string") {
      options = message;
      message = void 0;
    }
    message ??= httpErrorCodes[code];
    super(message, options);
    const name = httpErrorCodes[code].replace(createErrorRegexp, "");
    this.name = name.substr(-5) !== "Error" ? name + "Error" : name;
    this.status = this.statusCode = code;
    this.expose = options.expose ?? code < 500;
  }
};
var createError = (code, message, properties = {}) => {
  return new HttpError(code, message, properties);
};
var httpErrorCodes = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  306: "(Unused)",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};

// asset-input/node_modules/@middy/http-json-body-parser/index.js
var mimePattern = /^application\/(.+\+)?json($|;.+)/;
var defaults = {
  reviver: void 0,
  disableContentTypeError: false
};
var httpJsonBodyParserMiddleware = (opts = {}) => {
  const options = { ...defaults, ...opts };
  const httpJsonBodyParserMiddlewareBefore = async (request) => {
    const { headers, body } = request.event;
    const contentType = headers?.["Content-Type"] ?? headers?.["content-type"];
    if (!mimePattern.test(contentType)) {
      if (options.disableContentTypeError) {
        return;
      }
      throw createError(415, "Unsupported Media Type", {
        cause: { package: "@middy/http-json-body-parser", data: contentType }
      });
    }
    try {
      const data = request.event.isBase64Encoded ? Buffer.from(body, "base64").toString() : body;
      request.event.body = JSON.parse(data, options.reviver);
    } catch (err) {
      throw createError(415, "Invalid or malformed JSON was provided", {
        cause: { package: "@middy/http-json-body-parser", data: err }
      });
    }
  };
  return {
    before: httpJsonBodyParserMiddlewareBefore
  };
};
var http_json_body_parser_default = httpJsonBodyParserMiddleware;

// asset-input/node_modules/@middy/core/index.js
var import_node_stream = require("node:stream");
var import_promises = require("node:stream/promises");
var import_node_timers = require("node:timers");
var defaultLambdaHandler = () => {
};
var defaultPlugin = {
  timeoutEarlyInMillis: 5,
  timeoutEarlyResponse: () => {
    const err = new Error("[AbortError]: The operation was aborted.", {
      cause: { package: "@middy/core" }
    });
    err.name = "TimeoutError";
    throw err;
  },
  streamifyResponse: false
  // Deprecate need for this when AWS provides a flag for when it's looking for it
};
var middy = (lambdaHandler = defaultLambdaHandler, plugin = {}) => {
  if (typeof lambdaHandler !== "function") {
    plugin = lambdaHandler;
    lambdaHandler = defaultLambdaHandler;
  }
  plugin = { ...defaultPlugin, ...plugin };
  plugin.timeoutEarly = plugin.timeoutEarlyInMillis > 0;
  plugin.beforePrefetch?.();
  const beforeMiddlewares = [];
  const afterMiddlewares = [];
  const onErrorMiddlewares = [];
  const middyHandler = (event = {}, context = {}) => {
    plugin.requestStart?.();
    const request = {
      event,
      context,
      response: void 0,
      error: void 0,
      internal: plugin.internal ?? {}
    };
    return runRequest(
      request,
      beforeMiddlewares,
      lambdaHandler,
      afterMiddlewares,
      onErrorMiddlewares,
      plugin
    );
  };
  const middy2 = plugin.streamifyResponse ? awslambda.streamifyResponse(async (event, responseStream, context) => {
    const handlerResponse = await middyHandler(event, context);
    let handlerBody = handlerResponse;
    if (handlerResponse.statusCode) {
      handlerBody = handlerResponse.body ?? "";
      delete handlerResponse.body;
      responseStream = awslambda.HttpResponseStream.from(
        responseStream,
        handlerResponse
      );
    }
    let handlerStream;
    if (handlerBody._readableState) {
      handlerStream = handlerBody;
    } else if (typeof handlerBody === "string") {
      handlerStream = import_node_stream.Readable.from(
        handlerBody.length < stringIteratorSize ? handlerBody : stringIterator(handlerBody)
      );
    }
    if (!handlerStream) {
      throw new Error("handler response not a ReadableStream");
    }
    await (0, import_promises.pipeline)(handlerStream, responseStream);
  }) : middyHandler;
  middy2.use = (middlewares) => {
    if (!Array.isArray(middlewares)) {
      middlewares = [middlewares];
    }
    for (const middleware of middlewares) {
      const { before, after, onError } = middleware;
      if (before || after || onError) {
        if (before) middy2.before(before);
        if (after) middy2.after(after);
        if (onError) middy2.onError(onError);
      } else {
        throw new Error(
          'Middleware must be an object containing at least one key among "before", "after", "onError"'
        );
      }
    }
    return middy2;
  };
  middy2.before = (beforeMiddleware) => {
    beforeMiddlewares.push(beforeMiddleware);
    return middy2;
  };
  middy2.after = (afterMiddleware) => {
    afterMiddlewares.unshift(afterMiddleware);
    return middy2;
  };
  middy2.onError = (onErrorMiddleware) => {
    onErrorMiddlewares.unshift(onErrorMiddleware);
    return middy2;
  };
  middy2.handler = (replaceLambdaHandler) => {
    lambdaHandler = replaceLambdaHandler;
    return middy2;
  };
  return middy2;
};
var stringIteratorSize = 16384;
function* stringIterator(input) {
  let position = 0;
  const length = input.length;
  while (position < length) {
    yield input.substring(position, position + stringIteratorSize);
    position += stringIteratorSize;
  }
}
var handlerAbort = new AbortController();
var runRequest = async (request, beforeMiddlewares, lambdaHandler, afterMiddlewares, onErrorMiddlewares, plugin) => {
  let timeoutID;
  const timeoutEarly = plugin.timeoutEarly && request.context.getRemainingTimeInMillis;
  try {
    await runMiddlewares(request, beforeMiddlewares, plugin);
    if (typeof request.response === "undefined") {
      plugin.beforeHandler?.();
      if (handlerAbort.signal.aborted) {
        handlerAbort = new AbortController();
      }
      const promises = [
        lambdaHandler(request.event, request.context, {
          signal: handlerAbort.signal
        })
      ];
      if (timeoutEarly) {
        let timeoutResolve;
        const timeoutPromise = new Promise((resolve, reject) => {
          timeoutResolve = () => {
            handlerAbort.abort();
            try {
              resolve(plugin.timeoutEarlyResponse());
            } catch (e) {
              reject(e);
            }
          };
        });
        timeoutID = (0, import_node_timers.setTimeout)(
          timeoutResolve,
          request.context.getRemainingTimeInMillis() - plugin.timeoutEarlyInMillis
        );
        promises.push(timeoutPromise);
      }
      request.response = await Promise.race(promises);
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
      plugin.afterHandler?.();
      await runMiddlewares(request, afterMiddlewares, plugin);
    }
  } catch (e) {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
    request.response = void 0;
    request.error = e;
    try {
      await runMiddlewares(request, onErrorMiddlewares, plugin);
    } catch (e2) {
      e2.originalError = request.error;
      request.error = e2;
      throw request.error;
    }
    if (typeof request.response === "undefined") throw request.error;
  } finally {
    await plugin.requestEnd?.(request);
  }
  return request.response;
};
var runMiddlewares = async (request, middlewares, plugin) => {
  for (const nextMiddleware of middlewares) {
    plugin.beforeMiddleware?.(nextMiddleware.name);
    const res = await nextMiddleware(request);
    plugin.afterMiddleware?.(nextMiddleware.name);
    if (typeof res !== "undefined") {
      request.response = res;
      return;
    }
  }
};
var core_default = middy;

// asset-input/src/category-api.ts
var service = new CategoryService(new CategoryRepository());
var handler = core_default((event, context) => {
  const isRoot = event.pathParameters === null;
  switch (event.httpMethod.toLowerCase()) {
    case "post":
      if (isRoot) {
        return service.createCategory(event);
      }
      break;
    case "get":
      return isRoot ? service.getCategories(event) : service.getCategory(event);
    case "put":
      if (!isRoot) {
        return service.editCategory(event);
      }
    case "delete":
      if (!isRoot) {
        return service.deleteCategory(event);
      }
  }
  return service.ResponseWithError(event);
}).use(http_json_body_parser_default());
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! Bundled license information:

mongoose/lib/driver.js:
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/binary.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/connectionstate.js:
  (*!
   * Connection states
   *)

mongoose/lib/helpers/immediate.js:
  (*!
   * Centralize this so we can more easily work around issues with people
   * stubbing out `process.nextTick()` in tests using sinon:
   * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
   * See gh-6074
   *)

mongoose/lib/collection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/error/mongooseError.js:
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/objectid.js:
  (*!
   * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
   * @constructor NodeMongoDbObjectId
   * @see ObjectId
   *)
  (*!
   * ignore
   *)

mongoose/lib/types/objectid.js:
  (*!
   * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299
   *)

mpath/lib/index.js:
  (*!
   * Split a string path into components delimited by '.' or
   * '[\d+]'
   *
   * #### Example:
   *     stringToParts('foo[0].bar.1'); // ['foo', '0', 'bar', '1']
   *)
  (*!
   * Recursively set nested arrays
   *)
  (*!
   * Returns the value passed to it.
   *)

mquery/lib/utils.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mquery/lib/mquery.js:
  (*!
   * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
   *
   *     Thing.where('type').nin(array)
   *)
  (*!
   * @ignore
   *)
  (*!
   * limit, skip, maxScan, batchSize, comment
   *
   * Sets these associated options.
   *
   *     query.comment('feed query');
   *)
  (*!
   * Internal helper for update, updateMany, updateOne
   *)
  (*!
   * Permissions
   *)
  (*!
   * Exports.
   *)

mongoose/lib/promise_provider.js:
  (*!
   * ignore
   *)
  (*!
   * Use native promises by default
   *)

mongoose/lib/statemachine.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/internal.js:
  (*!
   * Dependencies
   *)

mongoose/lib/error/notFound.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/cast.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * exports
   *)

mongoose/lib/helpers/error/combinePathErrors.js:
  (*!
   * ignore
   *)

mongoose/lib/error/validation.js:
  (*!
   * Module requirements
   *)
  (*!
   * Module exports
   *)

mongoose/lib/error/validator.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/version.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/parallelSave.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/overwriteModel.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/missingSchema.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/serverSelection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/error/divergentArray.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/strict.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/error/strictPopulate.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/error/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/schema/operators/exists.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/operators/type.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/schematype/handleImmutable.js:
  (*!
   * ignore
   *)

mongoose/lib/schematype.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/mixed.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/error/objectExpected.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/error/objectParameter.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/error/parallelValidate.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/virtualtype.js:
  (*!
   * ignore
   *)
  (*!
   * exports
   *)

mongoose/lib/helpers/schema/idGetter.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/schema/handleTimestampOption.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/update/applyTimestampsToChildren.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/update/applyTimestampsToUpdate.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/query/applyQueryMiddleware.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/model/applyHooks.js:
  (*!
   * ignore
   *)

mongoose/lib/options.js:
  (*!
   * ignore
   *)

mongoose/lib/types/subdocument.js:
  (*!
   * ignore
   *)

mongoose/lib/types/ArraySubdocument.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from Subdocument
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/helpers/document/cleanModifiedSubpaths.js:
  (*!
   * ignore
   *)

mongoose/lib/types/array/methods/index.js:
  (*!
   * ignore
   *)
  (*!
   * Minimize _just_ empty objects along the path chain specified
   * by `parts`, ignoring all other paths. Useful in cases where
   * you want to minimize after unsetting a path.
   *
   * #### Example:
   *
   *     const obj = { foo: { bar: { baz: {} } }, a: {} };
   *     _minimizePath(obj, 'foo.bar.baz');
   *     obj; // { a: {} }
   *)

mongoose/lib/types/array/index.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/types/buffer.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from Buffer.
   *)
  (*!
   * Compile other Buffer methods marking this buffer as modified.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/types/DocumentArray/index.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/types/map.js:
  (*!
   * ignore
   *)

mongoose/lib/types/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaStringOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/string.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaNumberOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/operators/bitwise.js:
  (*!
   * Module requirements.
   *)
  (*!
   * ignore
   *)

mongoose/lib/schema/number.js:
  (*!
   * Module requirements.
   *)
  (*!
   * ignore
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/boolean.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaArrayOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/cast.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/schema/operators/helpers.js:
  (*!
   * Module requirements.
   *)
  (*!
   * ignore
   *)

mongoose/lib/schema/operators/geospatial.js:
  (*!
   * Module requirements.
   *)
  (*!
   * ignore
   *)

mongoose/lib/schema/array.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/helpers/document/applyDefaults.js:
  (*!
   * ignore
   *)

mongoose/lib/plugins/removeSubdocs.js:
  (*!
   * ignore
   *)

mongoose/lib/plugins/saveSubdocs.js:
  (*!
   * ignore
   *)

mongoose/lib/plugins/sharding.js:
  (*!
   * ignore
   *)

mongoose/lib/plugins/validateBeforeSave.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/document/compile.js:
  (*!
   * exports
   *)

mongoose/lib/helpers/model/discriminator.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/projection/isDefiningProjection.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/projection/isExclusive.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/SubdocumentPath.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/schema/DocumentArrayElement.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaDocumentArrayOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/documentarray.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from ArrayType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaBufferOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/buffer.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaDateOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/date.js:
  (*!
   * Module requirements.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaObjectIdOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/objectid.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/decimal128.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/map.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/uuid.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/schema.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from EventEmitter.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/helpers/common.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/queryhelpers.js:
  (*!
   * Module dependencies
   *)
  (*!
   * ignore
   *)

mongoose/lib/document.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Document exposes the NodeJS event emitter API, so you can use
   * `on`, `once`, etc.
   *)
  (*!
   * Converts to POJO when you use the document for querying
   *)
  (*!
   * Runs queued functions
   *)
  (*!
   * Applies virtuals properties to `json`.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/utils.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/helpers/clone.js:
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/collection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from abstract Collection.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/drivers/node-mongodb-native/decimal128.js:
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/ReadPreference.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/cursor/ChangeStream.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/error/disconnected.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/syncIndexes.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/connection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from EventEmitter
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/drivers/node-mongodb-native/connection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from Connection.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/drivers/node-mongodb-native/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/validoptions.js:
  (*!
   * Valid mongoose options
   *)

mongoose/lib/error/eachAsyncMultiError.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/helpers/cursor/eachAsync.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/cursor/QueryCursor.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/helpers/query/castUpdate.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/query/hasDollarKeys.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/projection/isInclusive.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/query/selectPopulatedFields.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/updateValidators.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/query.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * inherit mquery
   *)
  (*!
   * ignore
   *)
  (*!
   * Export
   *)

mongoose/lib/cursor/AggregationCursor.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/aggregate.js:
  (*!
   * Module dependencies
   *)
  (*!
   * define methods
   *)
  (*!
   * Helpers
   *)
  (*!
   * Exports
   *)

mongoose/lib/error/bulkWriteError.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/helpers/populate/leanPopulateMap.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/populate/getVirtual.js:
  (*!
   * ignore
   *)

sift/lib/index.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

mongoose/lib/helpers/populate/getSchemaTypes.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/populate/getModelsMapForPopulate.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/projection/isPathSelectedInclusive.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/parallelLimit.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/populate/removeDeselectedForeignField.js:
  (*!
   * ignore
   *)

mongoose/lib/model.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Give the constructor the ability to emit events.
   *)
  (*!
   * Populates `docs`
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/error/setOptionError.js:
  (*!
   * Module requirements
   *)
  (*!
   * Module exports
   *)

mongoose/lib/browserDocument.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from the NodeJS document
   *)
  (*!
   * ignore
   *)
  (*!
   * Browser doc exposes the event emitter API
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/document_provider.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/index.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
*/
